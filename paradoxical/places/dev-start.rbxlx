<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX5F7DA7EC4F8D47F9B5519A9128E3DF2D">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AvatarUnificationMode">0</token>
			<token name="CSGAsyncDynamicCollision">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBX0928E62B2FE24F659DBB9AA3549FE4AD</Ref>
			<token name="DecreaseMinimumPartDensityMode">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<token name="EditorLiveScripting">0</token>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="RenderingCacheOptimizations">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">2</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000002</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Terrain" referent="RBX55395069FB9D4710B2ED9CE8FA5D4E9F">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<bool name="ShorelinesUpgraded">false</bool>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005ae</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Folder" referent="RBX1E5214F025A941B4A4F92A10CA09CAB4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">gameMap</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">2df3da2bc8cf85c306509a62000062bc</UniqueId>
			</Properties>
			<Item class="Part" referent="RBXD6472EDE280846209F000ECBE0B7E100">
				<Properties>
					<bool name="Anchored">true</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="CastShadow">true</bool>
					<string name="CollisionGroup">Default</string>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="EnableFluidForces">true</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<string name="MaterialVariantSerialized"></string>
					<string name="Name">Baseplate</string>
					<CoordinateFrame name="PivotOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<UniqueId name="UniqueId">2df3da2bc8cf85c306509a62000062bd</UniqueId>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>200</X>
						<Y>1</Y>
						<Z>200</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXF81C0FD884314B42913686DB21224491">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Lumina Particles</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5d43e5939f03e2e60658825e000064d0</UniqueId>
			</Properties>
		</Item>
		<Item class="Camera" referent="RBX0928E62B2FE24F659DBB9AA3549FE4AD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>138.100479</X>
					<Y>153.29454</Y>
					<Z>114.106712</Z>
					<R00>0.67465657</R00>
					<R01>-0.608311892</R01>
					<R02>0.418085188</R02>
					<R10>-2.98023224e-08</R10>
					<R11>0.566409945</R11>
					<R12>0.82412374</R12>
					<R20>-0.738131762</R20>
					<R21>-0.556000471</R21>
					<R22>0.382132143</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>137.264297</X>
					<Y>151.646271</Y>
					<Z>113.342438</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000423d</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBX9B2DD4A89C47400E9E6E0809D0E5F73D">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000310</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBX1D9D4850A96A4EB0BDA0EA247989C4CE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000301</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXB1C094E1423E45B7810224A6051322E0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000302</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBXE60C5DB5DDA1485BADE49260FA9BAB6A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000303</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX156B34208E5249D1A33968D38D759BE9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000318</UniqueId>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX82B5AE495A4C45C495D690B4063E4F54">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TimerService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000032d</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXDF5AD98CB970407BB3D3A84424B728FF">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">60</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">60</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000031b</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX893E40E0B6894DD0BF8F7591B4E22CBA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000030d</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX005C212D39604A96ACFDA36730928FFA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000030f</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX8B55803783FA492182D5606A4B85640B">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000321</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBX47ADFBC9AA5E4945AA62317923A1A8CA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000322</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBXBA434D320A4149E2A6732C11C6A87DDC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005b0</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBX2520D74881F9473CB702D54FCD7B3763">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005b1</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBXAA01D3D2BFF24C22AF421D2E1229647B">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005b2</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX9E5536156372498A83C4BD5D2BCD6B5A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000313</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXB97109D16A724C14960B7F3675C577F5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000314</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXBE3827B403424EF09A6E4BD09ABE72F2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000032c</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="RBXDB74EA1D062247F880A8C2DE581A67BF">
		<Properties>
			<bool name="AllowCustomAnimations">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_Serialized">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">0</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000032e</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="RBX882F7576CE104003ABA90D61A8B8F95C">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000597</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX2137AB815138461EA42BB71E67A42E67">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerModule</string>
					<string name="ScriptGuid">{9A9A2A3A-DDE7-4BF2-852E-3C1173B1AE6A}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	PlayerModule - This module requires and instantiates the camera and control modules,
	and provides getters for developers to access methods on these singletons without
	having to modify Roblox-supplied scripts.

	2018 PlayerScripts Update - AllYourBlox
--]]

local PlayerModule = {}
PlayerModule.__index = PlayerModule

function PlayerModule.new()
	local self = setmetatable({},PlayerModule)
	self.cameras = require(script:WaitForChild("CameraModule"))
	self.controls = require(script:WaitForChild("ControlModule"))
	return self
end

function PlayerModule:GetCameras()
	return self.cameras
end

function PlayerModule:GetControls()
	return self.controls
end

function PlayerModule:GetClickToMoveController()
	return self.controls:GetClickToMoveController()
end

return PlayerModule.new()
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070a4</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX58C5A1EFD38841D6921226ECF1378EE3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ControlModule</string>
						<string name="ScriptGuid">{0B3A673A-47C6-44E2-B45A-F9507C214298}</string>
						<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	ControlModule - This ModuleScript implements a singleton class to manage the
	selection, activation, and deactivation of the current character movement controller.
	This script binds to RenderStepped at Input priority and calls the Update() methods
	on the active controller instances.

	The character controller ModuleScripts implement classes which are instantiated and
	activated as-needed, they are no longer all instantiated up front as they were in
	the previous generation of PlayerScripts.

	2018 PlayerScripts Update - AllYourBlox
--]]
local ControlModule = {}
ControlModule.__index = ControlModule

--[[ Roblox Services ]]--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local VRService = game:GetService("VRService")

-- Roblox User Input Control Modules - each returns a new() constructor function used to create controllers as needed
local Keyboard = require(script:WaitForChild("Keyboard"))
local Gamepad = require(script:WaitForChild("Gamepad"))
local DynamicThumbstick = require(script:WaitForChild("DynamicThumbstick"))

local FFlagUserHideControlsWhenMenuOpen do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserHideControlsWhenMenuOpen")
	end)
	FFlagUserHideControlsWhenMenuOpen = success and result
end

local FFlagUserDynamicThumbstickSafeAreaUpdate do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickSafeAreaUpdate")
	end)
	FFlagUserDynamicThumbstickSafeAreaUpdate = success and result
end

local TouchThumbstick = require(script:WaitForChild("TouchThumbstick"))

-- These controllers handle only walk/run movement, jumping is handled by the
-- TouchJump controller if any of these are active
local ClickToMove = require(script:WaitForChild("ClickToMoveController"))
local TouchJump = require(script:WaitForChild("TouchJump"))

local VehicleController = require(script:WaitForChild("VehicleController"))

local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Medium.Value

-- Mapping from movement mode and lastInputType enum values to control modules to avoid huge if elseif switching
local movementEnumToModuleMap = {
	[Enum.TouchMovementMode.DPad] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.DPad] = DynamicThumbstick,
	[Enum.TouchMovementMode.Thumbpad] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.Thumbpad] = DynamicThumbstick,
	[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,

	-- Current default
	[Enum.TouchMovementMode.Default] = DynamicThumbstick,

	[Enum.ComputerMovementMode.Default] = Keyboard,
	[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.Scriptable] = nil,
	[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove,
}

-- Keyboard controller is really keyboard and mouse controller
local computerInputTypeToModuleMap = {
	[Enum.UserInputType.Keyboard] = Keyboard,
	[Enum.UserInputType.MouseButton1] = Keyboard,
	[Enum.UserInputType.MouseButton2] = Keyboard,
	[Enum.UserInputType.MouseButton3] = Keyboard,
	[Enum.UserInputType.MouseWheel] = Keyboard,
	[Enum.UserInputType.MouseMovement] = Keyboard,
	[Enum.UserInputType.Gamepad1] = Gamepad,
	[Enum.UserInputType.Gamepad2] = Gamepad,
	[Enum.UserInputType.Gamepad3] = Gamepad,
	[Enum.UserInputType.Gamepad4] = Gamepad,
}

local lastInputType

function ControlModule.new()
	local self = setmetatable({},ControlModule)

	-- The Modules above are used to construct controller instances as-needed, and this
	-- table is a map from Module to the instance created from it
	self.controllers = {}

	self.activeControlModule = nil	-- Used to prevent unnecessarily expensive checks on each input event
	self.activeController = nil
	self.touchJumpController = nil
	self.moveFunction = Players.LocalPlayer.Move
	self.humanoid = nil
	self.lastInputType = Enum.UserInputType.None
	self.controlsEnabled = true

	-- For Roblox self.vehicleController
	self.humanoidSeatedConn = nil
	self.vehicleController = nil

	self.touchControlFrame = nil

	if FFlagUserHideControlsWhenMenuOpen then
		GuiService.MenuOpened:Connect(function()
			if self.touchControlFrame and self.touchControlFrame.Visible then
				self.touchControlFrame.Visible = false
			end
		end)

		GuiService.MenuClosed:Connect(function()
			if self.touchControlFrame then
				self.touchControlFrame.Visible = true
			end
		end)
	end

	self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)

	Players.LocalPlayer.CharacterAdded:Connect(function(char) self:OnCharacterAdded(char) end)
	Players.LocalPlayer.CharacterRemoving:Connect(function(char) self:OnCharacterRemoving(char) end)
	if Players.LocalPlayer.Character then
		self:OnCharacterAdded(Players.LocalPlayer.Character)
	end

	RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt)
		self:OnRenderStepped(dt)
	end)

	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self:OnLastInputTypeChanged(newLastInputType)
	end)


	UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
		self:OnTouchMovementModeChange()
	end)
	Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
		self:OnTouchMovementModeChange()
	end)

	UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function()
		self:OnComputerMovementModeChange()
	end)
	Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
		self:OnComputerMovementModeChange()
	end)

	--[[ Touch Device UI ]]--
	self.playerGui = nil
	self.touchGui = nil
	self.playerGuiAddedConn = nil

		GuiService:GetPropertyChangedSignal("TouchControlsEnabled"):Connect(function()
			self:UpdateTouchGuiVisibility()
			self:UpdateActiveControlModuleEnabled()
		end)

	if UserInputService.TouchEnabled then
		self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if self.playerGui then
			self:CreateTouchGuiContainer()
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		else
			self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
				if child:IsA("PlayerGui") then
					self.playerGui = child
					self:CreateTouchGuiContainer()
					self.playerGuiAddedConn:Disconnect()
					self.playerGuiAddedConn = nil
					self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
				end
			end)
		end
	else
		self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
	end

	return self
end

-- Convenience function so that calling code does not have to first get the activeController
-- and then call GetMoveVector on it. When there is no active controller, this function returns the
-- zero vector
function ControlModule:GetMoveVector(): Vector3
	if self.activeController then
		return self.activeController:GetMoveVector()
	end
	return Vector3.new(0,0,0)
end

function ControlModule:GetActiveController()
	return self.activeController
end

-- Checks for conditions for enabling/disabling the active controller and updates whether the active controller is enabled/disabled
function ControlModule:UpdateActiveControlModuleEnabled()
	-- helpers for disable/enable
	local disable = function()
		self.activeController:Enable(false)

		if self.moveFunction then
			self.moveFunction(Players.LocalPlayer, Vector3.new(0,0,0), true)
		end
	end

	local enable = function()
		if self.activeControlModule == ClickToMove then
			-- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
			-- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only jump.
			self.activeController:Enable(
				true,
				Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice,
				self.touchJumpController
			)
		elseif self.touchControlFrame then
			self.activeController:Enable(true, self.touchControlFrame)
		else
			self.activeController:Enable(true)
		end
	end

	-- there is no active controller
	if not self.activeController then
		return
	end

	-- developer called ControlModule:Disable(), don't turn back on
	if not self.controlsEnabled then
		disable()
		return
	end

	-- GuiService.TouchControlsEnabled == false and the active controller is a touch controller,
	-- disable controls
	if not GuiService.TouchControlsEnabled and UserInputService.TouchEnabled and
			(self.activeControlModule == ClickToMove or self.activeControlModule == TouchThumbstick or
			self.activeControlModule == DynamicThumbstick) then
		disable()
		return
	end

	-- no settings prevent enabling controls
	enable()
end

function ControlModule:Enable(enable: boolean?)
	if enable == nil then
		enable = true
	end
	self.controlsEnabled = enable

	if not self.activeController then
		return
	end

	self:UpdateActiveControlModuleEnabled()
end

-- For those who prefer distinct functions
function ControlModule:Disable()
	self.controlsEnabled = false

	self:UpdateActiveControlModuleEnabled()
end


-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
function ControlModule:SelectComputerMovementModule(): ({}?, boolean)
	if not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled) then
		return nil, false
	end

	local computerModule
	local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode

	if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
		computerModule = computerInputTypeToModuleMap[lastInputType]
		if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
			-- User has ClickToMove set in Settings, prefer ClickToMove controller for keyboard and mouse lastInputTypes
			computerModule = ClickToMove
		end
	else
		-- Developer has selected a mode that must be used.
		computerModule = movementEnumToModuleMap[DevMovementMode]

		-- computerModule is expected to be nil here only when developer has selected Scriptable
		if (not computerModule) and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
			warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
		end
	end

	if computerModule then
		return computerModule, true
	elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
		-- Special case where nil is returned and we actually want to set self.activeController to nil for Scriptable
		return nil, true
	else
		-- This case is for when computerModule is nil because of an error and no suitable control module could
		-- be found.
		return nil, false
	end
end

-- Choose current Touch control module based on settings (user, dev)
-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
function ControlModule:SelectTouchModule(): ({}?, boolean)
	if not UserInputService.TouchEnabled then
		return nil, false
	end
	local touchModule
	local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
	if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
		touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
	elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
		return nil, true
	else
		touchModule = movementEnumToModuleMap[DevMovementMode]
	end
	return touchModule, true
end

local function calculateRawMoveVector(humanoid: Humanoid, cameraRelativeMoveVector: Vector3): Vector3
	local camera = Workspace.CurrentCamera
	if not camera then
		return cameraRelativeMoveVector
	end

	if humanoid:GetState() == Enum.HumanoidStateType.Swimming then
		return camera.CFrame:VectorToWorldSpace(cameraRelativeMoveVector)
	end

	local cameraCFrame = camera.CFrame

	if VRService.VREnabled and humanoid.RootPart then
		-- movement relative to VR frustum
		local cameraDelta = humanoid.RootPart.CFrame.Position - cameraCFrame.Position
		if cameraDelta.Magnitude < 3 then -- "nearly" first person
			local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
			cameraCFrame = cameraCFrame * vrFrame
		end
	end

	local c, s
	local _, _, _, R00, R01, R02, _, _, R12, _, _, R22 = cameraCFrame:GetComponents()
	if R12 < 1 and R12 > -1 then
		-- X and Z components from back vector.
		c = R22
		s = R02
	else
		-- In this case the camera is looking straight up or straight down.
		-- Use X components from right and up vectors.
		c = R00
		s = -R01*math.sign(R12)
	end
	local norm = math.sqrt(c*c + s*s)
	return Vector3.new(
		(c*cameraRelativeMoveVector.X + s*cameraRelativeMoveVector.Z)/norm,
		0,
		(c*cameraRelativeMoveVector.Z - s*cameraRelativeMoveVector.X)/norm
	)
end

function ControlModule:OnRenderStepped(dt)
	if self.activeController and self.activeController.enabled and self.humanoid then
		-- Give the controller a chance to adjust its state
		self.activeController:OnRenderStepped(dt)

		-- Now retrieve info from the controller
		local moveVector = self.activeController:GetMoveVector()
		local cameraRelative = self.activeController:IsMoveVectorCameraRelative()

		local clickToMoveController = self:GetClickToMoveController()
		if self.activeController ~= clickToMoveController then
			if moveVector.magnitude > 0 then
				-- Clean up any developer started MoveTo path
				clickToMoveController:CleanupPath()
			else
				-- Get move vector for developer started MoveTo
				clickToMoveController:OnRenderStepped(dt)
				moveVector = clickToMoveController:GetMoveVector()
				cameraRelative = clickToMoveController:IsMoveVectorCameraRelative()
			end
		end

		-- Are we driving a vehicle ?
		local vehicleConsumedInput = false
		if self.vehicleController then
			moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, cameraRelative, self.activeControlModule==Gamepad)
		end

		-- If not, move the player
		-- Verification of vehicleConsumedInput is commented out to preserve legacy behavior,
		-- in case some game relies on Humanoid.MoveDirection still being set while in a VehicleSeat
		--if not vehicleConsumedInput then
			if cameraRelative then
				moveVector = calculateRawMoveVector(self.humanoid, moveVector)
			end
			self.moveFunction(Players.LocalPlayer, moveVector, false)
		--end

		-- And make them jump if needed
		self.humanoid.Jump = self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
	end
end

function ControlModule:OnHumanoidSeated(active: boolean, currentSeatPart: BasePart)
	if active then
		if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
			if not self.vehicleController then
				self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
			end
			self.vehicleController:Enable(true, currentSeatPart)
		end
	else
		if self.vehicleController then
			self.vehicleController:Enable(false, currentSeatPart)
		end
	end
end

function ControlModule:OnCharacterAdded(char)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end

	self:UpdateTouchGuiVisibility()

	if self.humanoidSeatedConn then
		self.humanoidSeatedConn:Disconnect()
		self.humanoidSeatedConn = nil
	end
	self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart)
		self:OnHumanoidSeated(active, currentSeatPart)
	end)
end

function ControlModule:OnCharacterRemoving(char)
	self.humanoid = nil

	self:UpdateTouchGuiVisibility()
end

function ControlModule:UpdateTouchGuiVisibility()
	if self.touchGui then
		local doShow = self.humanoid and GuiService.TouchControlsEnabled
		self.touchGui.Enabled = not not doShow -- convert to bool
	end
end

-- Helper function to lazily instantiate a controller if it does not yet exist,
-- disable the active controller if it is different from the on being switched to,
-- and then enable the requested controller. The argument to this function must be
-- a reference to one of the control modules, i.e. Keyboard, Gamepad, etc.

-- This function should handle all controller enabling and disabling without relying on
-- ControlModule:Enable() and Disable()
function ControlModule:SwitchToController(controlModule)
	-- controlModule is invalid, just disable current controller
	if not controlModule then
		if self.activeController then
			self.activeController:Enable(false)
		end
		self.activeController = nil
		self.activeControlModule = nil
		return
	end

	-- first time switching to this control module, should instantiate it
	if not self.controllers[controlModule] then
		self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
	end

	-- switch to the new controlModule
	if self.activeController ~= self.controllers[controlModule] then
		if self.activeController then
			self.activeController:Enable(false)
		end
		self.activeController = self.controllers[controlModule]
		self.activeControlModule = controlModule -- Only used to check if controller switch is necessary

		if self.touchControlFrame and (self.activeControlModule == ClickToMove
					or self.activeControlModule == TouchThumbstick
					or self.activeControlModule == DynamicThumbstick) then
			if not self.controllers[TouchJump] then
				self.controllers[TouchJump] = TouchJump.new()
			end
			self.touchJumpController = self.controllers[TouchJump]
			self.touchJumpController:Enable(true, self.touchControlFrame)
		else
			if self.touchJumpController then
				self.touchJumpController:Enable(false)
			end
		end

		self:UpdateActiveControlModuleEnabled()
	end
end

function ControlModule:OnLastInputTypeChanged(newLastInputType)
	if lastInputType == newLastInputType then
		warn("LastInputType Change listener called with current type.")
	end
	lastInputType = newLastInputType

	if lastInputType == Enum.UserInputType.Touch then
		-- TODO: Check if touch module already active
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
		local computerModule = self:SelectComputerMovementModule()
		if computerModule then
			self:SwitchToController(computerModule)
		end
	end

	self:UpdateTouchGuiVisibility()
end

-- Called when any relevant values of GameSettings or LocalPlayer change, forcing re-evalulation of
-- current control scheme
function ControlModule:OnComputerMovementModeChange()
	local controlModule, success =  self:SelectComputerMovementModule()
	if success then
		self:SwitchToController(controlModule)
	end
end

function ControlModule:OnTouchMovementModeChange()
	local touchModule, success = self:SelectTouchModule()
	if success then
		while not self.touchControlFrame do
			wait()
		end
		self:SwitchToController(touchModule)
	end
end

function ControlModule:CreateTouchGuiContainer()
	if self.touchGui then self.touchGui:Destroy() end

	-- Container for all touch device guis
	self.touchGui = Instance.new("ScreenGui")
	self.touchGui.Name = "TouchGui"
	self.touchGui.ResetOnSpawn = false
	self.touchGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	self:UpdateTouchGuiVisibility()

	if FFlagUserDynamicThumbstickSafeAreaUpdate then
		self.touchGui.ClipToDeviceSafeArea = false;
	end

	self.touchControlFrame = Instance.new("Frame")
	self.touchControlFrame.Name = "TouchControlFrame"
	self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
	self.touchControlFrame.BackgroundTransparency = 1
	self.touchControlFrame.Parent = self.touchGui

	self.touchGui.Parent = self.playerGui
end

function ControlModule:GetClickToMoveController()
	if not self.controllers[ClickToMove] then
		self.controllers[ClickToMove] = ClickToMove.new(CONTROL_ACTION_PRIORITY)
	end
	return self.controllers[ClickToMove]
end

return ControlModule.new()
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070a5</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX4D7329988F6248F2BCE737AA2EFA03C1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VRNavigation</string>
							<string name="ScriptGuid">{1A780715-9BAD-4555-B4C3-B0B76461BAE6}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--!nolint GlobalUsedAsLocal

--[[
		VRNavigation
--]]

local VRService = game:GetService("VRService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local ContextActionService = game:GetService("ContextActionService")
local StarterGui = game:GetService("StarterGui")

--local MasterControl = require(script.Parent)
local PathDisplay = nil
local LocalPlayer = Players.LocalPlayer

--[[ Constants ]]--
local RECALCULATE_PATH_THRESHOLD = 4
local NO_PATH_THRESHOLD = 12
local MAX_PATHING_DISTANCE = 200
local POINT_REACHED_THRESHOLD = 1
local OFFTRACK_TIME_THRESHOLD = 2
local THUMBSTICK_DEADZONE = 0.22

local ZERO_VECTOR3 = Vector3.new(0,0,0)
local XZ_VECTOR3 = Vector3.new(1,0,1)

--[[ Utility Functions ]]--
local function IsFinite(num: number)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

local movementUpdateEvent = Instance.new("BindableEvent")
movementUpdateEvent.Name = "MovementUpdate"
movementUpdateEvent.Parent = script

coroutine.wrap(function()
	local PathDisplayModule = script.Parent:WaitForChild("PathDisplay")
	if PathDisplayModule then
		PathDisplay = require(PathDisplayModule)
	end
end)()


--[[ The Class ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local VRNavigation = setmetatable({}, BaseCharacterController)
VRNavigation.__index = VRNavigation

function VRNavigation.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new() :: any, VRNavigation)

	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY

	self.navigationRequestedConn = nil
	self.heartbeatConn = nil

	self.currentDestination = nil
	self.currentPath = nil
	self.currentPoints = nil
	self.currentPointIdx = 0

	self.expectedTimeToNextPoint = 0
	self.timeReachedLastPoint = tick()
	self.moving = false

	self.isJumpBound = false
	self.moveLatch = false

	self.userCFrameEnabledConn = nil

	return self
end

function VRNavigation:SetLaserPointerMode(mode)
	pcall(function()
		StarterGui:SetCore("VRLaserPointerMode", mode)
	end)
end

function VRNavigation:GetLocalHumanoid()
	local character = LocalPlayer.Character
	if not character then
		return
	end

	for _, child in pairs(character:GetChildren()) do
		if child:IsA("Humanoid") then
			return child
		end
	end
	return nil
end

function VRNavigation:HasBothHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) and VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end

function VRNavigation:HasAnyHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) or VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end

function VRNavigation:IsMobileVR()
	return UserInputService.TouchEnabled
end

function VRNavigation:HasGamepad()
	return UserInputService.GamepadEnabled
end

function VRNavigation:ShouldUseNavigationLaser()
	--Places where we use the navigation laser:
	-- mobile VR with any number of hands tracked
	-- desktop VR with only one hand tracked
	-- desktop VR with no hands and no gamepad (i.e. with Oculus remote?)
	--using an Xbox controller with a desktop VR headset means no laser since the user has a thumbstick.
	--in the future, we should query thumbstick presence with a features API
	if self:IsMobileVR() then
		return true
	else
		if self:HasBothHandControllers() then
			return false
		end
		if not self:HasAnyHandControllers() then
			return not self:HasGamepad()
		end
		return true
	end
end



function VRNavigation:StartFollowingPath(newPath)
	currentPath = newPath
	currentPoints = currentPath:GetPointCoordinates()
	currentPointIdx = 1
	moving = true

	timeReachedLastPoint = tick()

	local humanoid = self:GetLocalHumanoid()
	if humanoid and humanoid.Torso and #currentPoints >= 1 then
		local dist = (currentPoints[1] - humanoid.Torso.Position).magnitude
		expectedTimeToNextPoint = dist / humanoid.WalkSpeed
	end

	movementUpdateEvent:Fire("targetPoint", self.currentDestination)
end

function VRNavigation:GoToPoint(point)
	currentPath = true
	currentPoints = { point }
	currentPointIdx = 1
	moving = true

	local humanoid = self:GetLocalHumanoid()
	local distance = (humanoid.Torso.Position - point).magnitude
	local estimatedTimeRemaining = distance / humanoid.WalkSpeed

	timeReachedLastPoint = tick()
	expectedTimeToNextPoint = estimatedTimeRemaining

	movementUpdateEvent:Fire("targetPoint", point)
end

function VRNavigation:StopFollowingPath()
	currentPath = nil
	currentPoints = nil
	currentPointIdx = 0
	moving = false
	self.moveVector = ZERO_VECTOR3
end

function VRNavigation:TryComputePath(startPos: Vector3, destination: Vector3)
	local numAttempts = 0
	local newPath = nil

	while not newPath and numAttempts < 5 do
		newPath = PathfindingService:ComputeSmoothPathAsync(startPos, destination, MAX_PATHING_DISTANCE)
		numAttempts = numAttempts + 1

		if newPath.Status == Enum.PathStatus.ClosestNoPath or newPath.Status == Enum.PathStatus.ClosestOutOfRange then
			newPath = nil
			break
		end

		if newPath and newPath.Status == Enum.PathStatus.FailStartNotEmpty then
			startPos = startPos + (destination - startPos).Unit
			newPath = nil
		end

		if newPath and newPath.Status == Enum.PathStatus.FailFinishNotEmpty then
			destination = destination + Vector3.new(0, 1, 0)
			newPath = nil
		end
	end

	return newPath
end

function VRNavigation:OnNavigationRequest(destinationCFrame: CFrame, inputUserCFrame: CFrame)
	local destinationPosition = destinationCFrame.Position
	local lastDestination = self.currentDestination

	if not IsFiniteVector3(destinationPosition) then
		return
	end

	self.currentDestination = destinationPosition

	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end

	local currentPosition = humanoid.Torso.Position
	local distanceToDestination = (self.currentDestination - currentPosition).magnitude

	if distanceToDestination < NO_PATH_THRESHOLD then
		self:GoToPoint(self.currentDestination)
		return
	end

	if not lastDestination or (self.currentDestination - lastDestination).magnitude > RECALCULATE_PATH_THRESHOLD then
		local newPath = self:TryComputePath(currentPosition, self.currentDestination)
		if newPath then
			self:StartFollowingPath(newPath)
			if PathDisplay then
				PathDisplay.setCurrentPoints(self.currentPoints)
				PathDisplay.renderPath()
			end
		else
			self:StopFollowingPath()
			if PathDisplay then
				PathDisplay.clearRenderedPath()
			end
		end
	else
		if moving then
			self.currentPoints[#currentPoints] = self.currentDestination
		else
			self:GoToPoint(self.currentDestination)
		end
	end
end

function VRNavigation:OnJumpAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		self.isJumping = true
	end
	return Enum.ContextActionResult.Sink
end
function VRNavigation:BindJumpAction(active)
	if active then
		if not self.isJumpBound then
			self.isJumpBound = true
			ContextActionService:BindActionAtPriority("VRJumpAction", (function() return self:OnJumpAction() end), false,
				self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		end
	else
		if self.isJumpBound then
			self.isJumpBound = false
			ContextActionService:UnbindAction("VRJumpAction")
		end
	end
end

function VRNavigation:ControlCharacterGamepad(actionName, inputState, inputObject)
	if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end

	if inputState == Enum.UserInputState.Cancel then
		self.moveVector =  ZERO_VECTOR3
		return
	end

	if inputState ~= Enum.UserInputState.End then
		self:StopFollowingPath()
		if PathDisplay then
			PathDisplay.clearRenderedPath()
		end

		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(true)
			self:SetLaserPointerMode("Hidden")
		end

		if inputObject.Position.magnitude > THUMBSTICK_DEADZONE then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
			if self.moveVector.magnitude > 0 then
				self.moveVector = self.moveVector.unit * math.min(1, inputObject.Position.magnitude)
			end

			self.moveLatch = true
		end
	else
		self.moveVector =  ZERO_VECTOR3

		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(false)
			self:SetLaserPointerMode("Navigation")
		end

		if self.moveLatch then
			self.moveLatch = false
			movementUpdateEvent:Fire("offtrack")
		end
	end
	return Enum.ContextActionResult.Sink
end

function VRNavigation:OnHeartbeat(dt)
	local newMoveVector = self.moveVector
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end

	if self.moving and self.currentPoints then
		local currentPosition = humanoid.Torso.Position
		local goalPosition = currentPoints[1]
		local vectorToGoal = (goalPosition - currentPosition) * XZ_VECTOR3
		local moveDist = vectorToGoal.magnitude
		local moveDir = vectorToGoal / moveDist

		if moveDist < POINT_REACHED_THRESHOLD then
			local estimatedTimeRemaining = 0
			local prevPoint = currentPoints[1]
			for i, point in pairs(currentPoints) do
				if i ~= 1 then
					local dist = (point - prevPoint).magnitude
					prevPoint = point
					estimatedTimeRemaining = estimatedTimeRemaining + (dist / humanoid.WalkSpeed)
				end
			end

			table.remove(currentPoints, 1)
			currentPointIdx = currentPointIdx + 1

			if #currentPoints == 0 then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				return
			else
				if PathDisplay then
					PathDisplay.setCurrentPoints(currentPoints)
					PathDisplay.renderPath()
				end

				local newGoal = currentPoints[1]
				local distanceToGoal = (newGoal - currentPosition).magnitude
				expectedTimeToNextPoint = distanceToGoal / humanoid.WalkSpeed
				timeReachedLastPoint = tick()
			end
		else
			local ignoreTable = {
				(game.Players.LocalPlayer :: Player).Character,
				workspace.CurrentCamera
			}
			local obstructRay = Ray.new(currentPosition - Vector3.new(0, 1, 0), moveDir * 3)
			local obstructPart, obstructPoint, obstructNormal = workspace:FindPartOnRayWithIgnoreList(obstructRay, ignoreTable)

			if obstructPart then
				local heightOffset = Vector3.new(0, 100, 0)
				local jumpCheckRay = Ray.new(obstructPoint + moveDir * 0.5 + heightOffset, -heightOffset)
				local jumpCheckPart, jumpCheckPoint, jumpCheckNormal = workspace:FindPartOnRayWithIgnoreList(jumpCheckRay, ignoreTable)

				local heightDifference = jumpCheckPoint.Y - currentPosition.Y
				if heightDifference < 6 and heightDifference > -2 then
					humanoid.Jump = true
				end
			end

			local timeSinceLastPoint = tick() - timeReachedLastPoint
			if timeSinceLastPoint > expectedTimeToNextPoint + OFFTRACK_TIME_THRESHOLD then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end

				movementUpdateEvent:Fire("offtrack")
			end

			newMoveVector = self.moveVector:Lerp(moveDir, dt * 10)
		end
	end

	if IsFiniteVector3(newMoveVector) then
		self.moveVector = newMoveVector
	end
end


function VRNavigation:OnUserCFrameEnabled()
	if self:ShouldUseNavigationLaser() then
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Navigation")
	else
		self:BindJumpAction(true)
		self:SetLaserPointerMode("Hidden")
	end
end

function VRNavigation:Enable(enable)

	self.moveVector = ZERO_VECTOR3
	self.isJumping = false

	if enable then
		self.navigationRequestedConn = VRService.NavigationRequested:Connect(function(destinationCFrame, inputUserCFrame) self:OnNavigationRequest(destinationCFrame, inputUserCFrame) end)
		self.heartbeatConn = RunService.Heartbeat:Connect(function(dt) self:OnHeartbeat(dt) end)

		ContextActionService:BindAction("MoveThumbstick", (function(actionName, inputState, inputObject) return self:ControlCharacterGamepad(actionName, inputState, inputObject) end),
			false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
		ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)

		self.userCFrameEnabledConn = VRService.UserCFrameEnabled:Connect(function() self:OnUserCFrameEnabled() end)
		self:OnUserCFrameEnabled()

		VRService:SetTouchpadMode(Enum.VRTouchpad.Left, Enum.VRTouchpadMode.VirtualThumbstick)
		VRService:SetTouchpadMode(Enum.VRTouchpad.Right, Enum.VRTouchpadMode.ABXY)

		self.enabled = true
	else
		-- Disable
		self:StopFollowingPath()

		ContextActionService:UnbindAction("MoveThumbstick")
		ContextActionService:UnbindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)

		self:BindJumpAction(false)
		self:SetLaserPointerMode("Disabled")

		if self.navigationRequestedConn then
			self.navigationRequestedConn:Disconnect()
			self.navigationRequestedConn = nil
		end
		if self.heartbeatConn then
			self.heartbeatConn:Disconnect()
			self.heartbeatConn = nil
		end
		if self.userCFrameEnabledConn then
			self.userCFrameEnabledConn:Disconnect()
			self.userCFrameEnabledConn = nil
		end
		self.enabled = false
	end
end

return VRNavigation
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070a6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7979374903C1496A8D9D065E0AC7116E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TouchJump</string>
							<string name="ScriptGuid">{0AF28FA3-29C1-4F21-A1EA-ABBD1D181FAB}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	// FileName: TouchJump
	// Version 1.0
	// Written by: jmargh
	// Description: Implements jump controls for touch devices. Use with Thumbstick and Thumbpad
--]]

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")

--[[ Constants ]]--
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchJump = setmetatable({}, BaseCharacterController)
TouchJump.__index = TouchJump

function TouchJump.new()
	local self = setmetatable(BaseCharacterController.new() :: any, TouchJump)

	self.parentUIFrame = nil
	self.jumpButton = nil
	self.characterAddedConn = nil
	self.humanoidStateEnabledChangedConn = nil
	self.humanoidJumpPowerConn = nil
	self.humanoidParentConn = nil
	self.externallyEnabled = false
	self.jumpPower = 0
	self.jumpStateEnabled = true
	self.isJumping = false
	self.humanoid = nil -- saved reference because property change connections are made using it

	return self
end

function TouchJump:EnableButton(enable)
	if enable then
		if not self.jumpButton then
			self:Create()
		end
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid and self.externallyEnabled then
			if self.externallyEnabled then
				if humanoid.JumpPower > 0 then
					self.jumpButton.Visible = true
				end
			end
		end
	else
		self.jumpButton.Visible = false
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
end

function TouchJump:UpdateEnabled()
	if self.jumpPower > 0 and self.jumpStateEnabled then
		self:EnableButton(true)
	else
		self:EnableButton(false)
	end
end

function TouchJump:HumanoidChanged(prop)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if prop == "JumpPower" then
			self.jumpPower =  humanoid.JumpPower
			self:UpdateEnabled()
		elseif prop == "Parent" then
			if not humanoid.Parent then
				self.humanoidChangeConn:Disconnect()
			end
		end
	end
end

function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
	if state == Enum.HumanoidStateType.Jumping then
		self.jumpStateEnabled = isEnabled
		self:UpdateEnabled()
	end
end

function TouchJump:CharacterAdded(char)
	if self.humanoidChangeConn then
		self.humanoidChangeConn:Disconnect()
		self.humanoidChangeConn = nil
	end

	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end

	self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		self.jumpPower =  self.humanoid.JumpPower
		self:UpdateEnabled()
	end)

	self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
		if not self.humanoid.Parent then
			self.humanoidJumpPowerConn:Disconnect()
			self.humanoidJumpPowerConn = nil
			self.humanoidParentConn:Disconnect()
			self.humanoidParentConn = nil
		end
	end)

	self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
		self:HumanoidStateEnabledChanged(state, enabled)
	end)

	self.jumpPower = self.humanoid.JumpPower
	self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
	self:UpdateEnabled()
end

function TouchJump:SetupCharacterAddedFunction()
	self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:CharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:CharacterAdded(Players.LocalPlayer.Character)
	end
end

function TouchJump:Enable(enable, parentFrame)
	if parentFrame then
		self.parentUIFrame = parentFrame
	end
	self.externallyEnabled = enable
	self:EnableButton(enable)
end

function TouchJump:Create()
	if not self.parentUIFrame then
		return
	end

	if self.jumpButton then
		self.jumpButton:Destroy()
		self.jumpButton = nil
	end

	local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local jumpButtonSize = isSmallScreen and 70 or 120

	self.jumpButton = Instance.new("ImageButton")
	self.jumpButton.Name = "JumpButton"
	self.jumpButton.Visible = false
	self.jumpButton.BackgroundTransparency = 1
	self.jumpButton.Image = TOUCH_CONTROL_SHEET
	self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	self.jumpButton.ImageRectSize = Vector2.new(144, 144)
	self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)

    self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize - 20) or
        UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize * 1.75)

	local touchObject: InputObject? = nil
	self.jumpButton.InputBegan:connect(function(inputObject)
		--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
		--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
		if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
			or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end

		touchObject = inputObject
		self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
		self.isJumping = true
	end)

	local OnInputEnded = function()
		touchObject = nil
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end

	self.jumpButton.InputEnded:connect(function(inputObject: InputObject)
		if inputObject == touchObject then
			OnInputEnded()
		end
	end)

	GuiService.MenuOpened:connect(function()
		if touchObject then
			OnInputEnded()
		end
	end)

	if not self.characterAddedConn then
		self:SetupCharacterAddedFunction()
	end

	self.jumpButton.Parent = self.parentUIFrame
end

return TouchJump
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070a7</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB4276F4B52634B5B8E731DDAE9F2B18F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VehicleController</string>
							<string name="ScriptGuid">{ACA2A171-FA98-44EB-9D1A-1E95923B6568}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	// FileName: VehicleControl
	// Version 1.0
	// Written by: jmargh
	// Description: Implements in-game vehicle controls for all input devices

	// NOTE: This works for basic vehicles (single vehicle seat). If you use custom VehicleSeat code,
	// multiple VehicleSeats or your own implementation of a VehicleSeat this will not work.
--]]
local ContextActionService = game:GetService("ContextActionService")

--[[ Constants ]]--
-- Set this to true if you want to instead use the triggers for the throttle
local useTriggersForThrottle = true
-- Also set this to true if you want the thumbstick to not affect throttle, only triggers when a gamepad is conected
local onlyTriggersForThrottle = false
local ZERO_VECTOR3 = Vector3.new(0,0,0)

local AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE = 35


-- Note that VehicleController does not derive from BaseCharacterController, it is a special case
local VehicleController = {}
VehicleController.__index = VehicleController

function VehicleController.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable({}, VehicleController)

	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY

	self.enabled = false
	self.vehicleSeat = nil
	self.throttle = 0
	self.steer = 0

	self.acceleration = 0
	self.decceleration = 0
	self.turningRight = 0
	self.turningLeft = 0

	self.vehicleMoveVector = ZERO_VECTOR3

	self.autoPilot = {}
	self.autoPilot.MaxSpeed = 0
	self.autoPilot.MaxSteeringAngle = 0

	return self
end

function VehicleController:BindContextActions()
	if useTriggersForThrottle then
		ContextActionService:BindActionAtPriority("throttleAccel", (function(actionName, inputState, inputObject)
			self:OnThrottleAccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("throttleDeccel", (function(actionName, inputState, inputObject)
			self:OnThrottleDeccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
	end
	ContextActionService:BindActionAtPriority("arrowSteerRight", (function(actionName, inputState, inputObject)
		self:OnSteerRight(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
	ContextActionService:BindActionAtPriority("arrowSteerLeft", (function(actionName, inputState, inputObject)
		self:OnSteerLeft(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
end

function VehicleController:Enable(enable: boolean, vehicleSeat: VehicleSeat)
	if enable == self.enabled and vehicleSeat == self.vehicleSeat then
		return
	end

	self.enabled = enable
	self.vehicleMoveVector = ZERO_VECTOR3

	if enable then
		if vehicleSeat then
			self.vehicleSeat = vehicleSeat

			self:SetupAutoPilot()
			self:BindContextActions()
		end
	else
		if useTriggersForThrottle then
			ContextActionService:UnbindAction("throttleAccel")
			ContextActionService:UnbindAction("throttleDeccel")
		end
		ContextActionService:UnbindAction("arrowSteerRight")
		ContextActionService:UnbindAction("arrowSteerLeft")
		self.vehicleSeat = nil
	end
end

function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
		self.acceleration = 0
	else
		self.acceleration = -1
	end
	self.throttle = self.acceleration + self.decceleration
end

function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
		self.decceleration = 0
	else
		self.decceleration = 1
	end
	self.throttle = self.acceleration + self.decceleration
end

function VehicleController:OnSteerRight(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
		self.turningRight = 0
	else
		self.turningRight = 1
	end
	self.steer = self.turningRight + self.turningLeft
end

function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
	if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
		self.turningLeft = 0
	else
		self.turningLeft = -1
	end
	self.steer = self.turningRight + self.turningLeft
end

-- Call this from a function bound to Renderstep with Input Priority
function VehicleController:Update(moveVector: Vector3, cameraRelative: boolean, usingGamepad: boolean)
	if self.vehicleSeat then
		if cameraRelative then
			-- This is the default steering mode
			moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
			if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then
				self.vehicleSeat.ThrottleFloat = -self.throttle
			else
				self.vehicleSeat.ThrottleFloat = -moveVector.Z
			end
			self.vehicleSeat.SteerFloat = moveVector.X

			return moveVector, true
		else
			-- This is the path following mode
			local localMoveVector = self.vehicleSeat.Occupant.RootPart.CFrame:VectorToObjectSpace(moveVector)

			self.vehicleSeat.ThrottleFloat = self:ComputeThrottle(localMoveVector)
			self.vehicleSeat.SteerFloat = self:ComputeSteer(localMoveVector)

			return ZERO_VECTOR3, true
		end
	end
	return moveVector, false
end

function VehicleController:ComputeThrottle(localMoveVector)
	if localMoveVector ~= ZERO_VECTOR3 then
		local throttle = -localMoveVector.Z
		return throttle
	else
		return 0.0
	end
end

function VehicleController:ComputeSteer(localMoveVector)
	if localMoveVector ~= ZERO_VECTOR3 then
		local steerAngle = -math.atan2(-localMoveVector.x, -localMoveVector.z) * (180 / math.pi)
		return steerAngle / self.autoPilot.MaxSteeringAngle
	else
		return 0.0
	end
end

function VehicleController:SetupAutoPilot()
	-- Setup default
	self.autoPilot.MaxSpeed = self.vehicleSeat.MaxSpeed
	self.autoPilot.MaxSteeringAngle = AUTO_PILOT_DEFAULT_MAX_STEERING_ANGLE

	-- VehicleSeat should have a MaxSteeringAngle as well.
	-- Or we could look for a child "AutoPilotConfigModule" to find these values
	-- Or allow developer to set them through the API as like the CLickToMove customization API
end

return VehicleController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070a8</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX4C2C52763971481799D31DF17B2939E0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickToMoveController</string>
							<string name="ScriptGuid">{D9C0FCA2-7F88-4891-BDEE-01DB65C9A17A}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	-- Original By Kip Turner, Copyright Roblox 2014
	-- Updated by Garnold to utilize the new PathfindingService API, 2017
	-- 2018 PlayerScripts Update - AllYourBlox
--]]

--[[ Flags ]]
local FFlagUserExcludeNonCollidableForPathfindingSuccess, FFlagUserExcludeNonCollidableForPathfindingResult =
    pcall(function() return UserSettings():IsUserFeatureEnabled("UserExcludeNonCollidableForPathfinding") end)
local FFlagUserExcludeNonCollidableForPathfinding = FFlagUserExcludeNonCollidableForPathfindingSuccess and FFlagUserExcludeNonCollidableForPathfindingResult

local FFlagUserClickToMoveSupportAgentCanClimbSuccess, FFlagUserClickToMoveSupportAgentCanClimbResult =
    pcall(function() return UserSettings():IsUserFeatureEnabled("UserClickToMoveSupportAgentCanClimb2") end)
local FFlagUserClickToMoveSupportAgentCanClimb = FFlagUserClickToMoveSupportAgentCanClimbSuccess and FFlagUserClickToMoveSupportAgentCanClimbResult

--[[ Roblox Services ]]--
local UserInputService = game:GetService("UserInputService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local DebrisService = game:GetService('Debris')
local StarterGui = game:GetService("StarterGui")
local Workspace = game:GetService("Workspace")
local CollectionService = game:GetService("CollectionService")
local GuiService = game:GetService("GuiService")

--[[ Configuration ]]
local ShowPath = true
local PlayFailureAnimation = true
local UseDirectPath = false
local UseDirectPathForVehicle = true
local AgentSizeIncreaseFactor = 1.0
local UnreachableWaypointTimeout = 8

--[[ Constants ]]--
local movementKeys = {
	[Enum.KeyCode.W] = true;
	[Enum.KeyCode.A] = true;
	[Enum.KeyCode.S] = true;
	[Enum.KeyCode.D] = true;
	[Enum.KeyCode.Up] = true;
	[Enum.KeyCode.Down] = true;
}

local Player = Players.LocalPlayer

local ClickToMoveDisplay = require(script.Parent:WaitForChild("ClickToMoveDisplay"))

local ZERO_VECTOR3 = Vector3.new(0,0,0)
local ALMOST_ZERO = 0.000001


--------------------------UTIL LIBRARY-------------------------------
local Utility = {}
do
	local function FindCharacterAncestor(part)
		if part then
			local humanoid = part:FindFirstChildOfClass("Humanoid")
			if humanoid then
				return part, humanoid
			else
				return FindCharacterAncestor(part.Parent)
			end
		end
	end
	Utility.FindCharacterAncestor = FindCharacterAncestor

	local function Raycast(ray, ignoreNonCollidable: boolean, ignoreList: {Model})
		ignoreList = ignoreList or {}
		local hitPart, hitPos, hitNorm, hitMat = Workspace:FindPartOnRayWithIgnoreList(ray, ignoreList)
		if hitPart then
			if ignoreNonCollidable and hitPart.CanCollide == false then
				-- We always include character parts so a user can click on another character
				-- to walk to them.
				local _, humanoid = FindCharacterAncestor(hitPart)
				if humanoid == nil then
					table.insert(ignoreList, hitPart)
					return Raycast(ray, ignoreNonCollidable, ignoreList)
				end
			end
			return hitPart, hitPos, hitNorm, hitMat
		end
		return nil, nil
	end
	Utility.Raycast = Raycast
end

local humanoidCache = {}
local function findPlayerHumanoid(player: Player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil -- Bust Old Cache
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
end

--------------------------CHARACTER CONTROL-------------------------------
local CurrentIgnoreList: {Model}
local CurrentIgnoreTag = nil

local TaggedInstanceAddedConnection: RBXScriptConnection? = nil
local TaggedInstanceRemovedConnection: RBXScriptConnection? = nil

local function GetCharacter(): Model
	return Player and Player.Character
end

local function UpdateIgnoreTag(newIgnoreTag)
	if newIgnoreTag == CurrentIgnoreTag then
		return
	end
	if TaggedInstanceAddedConnection then
		TaggedInstanceAddedConnection:Disconnect()
		TaggedInstanceAddedConnection = nil
	end
	if TaggedInstanceRemovedConnection then
		TaggedInstanceRemovedConnection:Disconnect()
		TaggedInstanceRemovedConnection = nil
	end
	CurrentIgnoreTag = newIgnoreTag
	CurrentIgnoreList = {GetCharacter()}
	if CurrentIgnoreTag ~= nil then
		local ignoreParts = CollectionService:GetTagged(CurrentIgnoreTag)
		for _, ignorePart in ipairs(ignoreParts) do
			table.insert(CurrentIgnoreList, ignorePart)
		end
		TaggedInstanceAddedConnection = CollectionService:GetInstanceAddedSignal(
			CurrentIgnoreTag):Connect(function(ignorePart)
			table.insert(CurrentIgnoreList, ignorePart)
		end)
		TaggedInstanceRemovedConnection = CollectionService:GetInstanceRemovedSignal(
			CurrentIgnoreTag):Connect(function(ignorePart)
			for i = 1, #CurrentIgnoreList do
				if CurrentIgnoreList[i] == ignorePart then
					CurrentIgnoreList[i] = CurrentIgnoreList[#CurrentIgnoreList]
					table.remove(CurrentIgnoreList)
					break
				end
			end
		end)
	end
end

local function getIgnoreList(): {Model}
	if CurrentIgnoreList then
		return CurrentIgnoreList
	end
	CurrentIgnoreList = {}
	assert(CurrentIgnoreList, "")
	table.insert(CurrentIgnoreList, GetCharacter())
	return CurrentIgnoreList
end

local function minV(a: Vector3, b: Vector3)
	return Vector3.new(math.min(a.X, b.X), math.min(a.Y, b.Y), math.min(a.Z, b.Z))
end
local function maxV(a, b)
	return Vector3.new(math.max(a.X, b.X), math.max(a.Y, b.Y), math.max(a.Z, b.Z))
end
local function getCollidableExtentsSize(character: Model?)
	if character == nil or character.PrimaryPart == nil then return end
	assert(character, "")
	assert(character.PrimaryPart, "")
	local toLocalCFrame = character.PrimaryPart.CFrame:Inverse()
	local min = Vector3.new(math.huge, math.huge, math.huge)
	local max = Vector3.new(-math.huge, -math.huge, -math.huge)
	for _,descendant in pairs(character:GetDescendants()) do
		if descendant:IsA('BasePart') and descendant.CanCollide then
			local localCFrame = toLocalCFrame * descendant.CFrame
			local size = Vector3.new(descendant.Size.X / 2, descendant.Size.Y / 2, descendant.Size.Z / 2)
			local vertices = {
				Vector3.new( size.X,  size.Y,  size.Z),
				Vector3.new( size.X,  size.Y, -size.Z),
				Vector3.new( size.X, -size.Y,  size.Z),
				Vector3.new( size.X, -size.Y, -size.Z),
				Vector3.new(-size.X,  size.Y,  size.Z),
				Vector3.new(-size.X,  size.Y, -size.Z),
				Vector3.new(-size.X, -size.Y,  size.Z),
				Vector3.new(-size.X, -size.Y, -size.Z)
			}
			for _,vertex in ipairs(vertices) do
				local v = localCFrame * vertex
				min = minV(min, v)
				max = maxV(max, v)
			end
		end
	end
	local r = max - min
	if r.X < 0 or r.Y < 0 or r.Z < 0 then return nil end
	return r
end

-----------------------------------PATHER--------------------------------------

local function Pather(endPoint, surfaceNormal, overrideUseDirectPath: boolean?)
	local this = {}

	local directPathForHumanoid
	local directPathForVehicle
	if overrideUseDirectPath ~= nil then
		directPathForHumanoid = overrideUseDirectPath
		directPathForVehicle = overrideUseDirectPath
	else
		directPathForHumanoid = UseDirectPath
		directPathForVehicle = UseDirectPathForVehicle
	end

	this.Cancelled = false
	this.Started = false

	this.Finished = Instance.new("BindableEvent")
	this.PathFailed = Instance.new("BindableEvent")

	this.PathComputing = false
	this.PathComputed = false

	this.OriginalTargetPoint = endPoint
	this.TargetPoint = endPoint
	this.TargetSurfaceNormal = surfaceNormal

	this.DiedConn = nil
	this.SeatedConn = nil
	this.BlockedConn = nil
	this.TeleportedConn = nil

	this.CurrentPoint = 0

	this.HumanoidOffsetFromPath = ZERO_VECTOR3

	this.CurrentWaypointPosition = nil
	this.CurrentWaypointPlaneNormal = ZERO_VECTOR3
	this.CurrentWaypointPlaneDistance = 0
	this.CurrentWaypointNeedsJump = false;

	this.CurrentHumanoidPosition = ZERO_VECTOR3
	this.CurrentHumanoidVelocity = 0 :: Vector3 | number

	this.NextActionMoveDirection = ZERO_VECTOR3
	this.NextActionJump = false

	this.Timeout = 0

	this.Humanoid = findPlayerHumanoid(Player)
	this.OriginPoint = nil
	this.AgentCanFollowPath = false
	this.DirectPath = false
	this.DirectPathRiseFirst = false

	this.stopTraverseFunc = nil :: (() -> ())?
	this.setPointFunc = nil :: ((number) -> ())?
	this.pointList = nil :: {PathWaypoint}?

	local rootPart: BasePart = this.Humanoid and this.Humanoid.RootPart
	if rootPart then
		-- Setup origin
		this.OriginPoint = rootPart.CFrame.Position

		-- Setup agent
		local agentRadius = 2
		local agentHeight = 5
		local agentCanJump = true

		local seat = this.Humanoid.SeatPart
		if seat and seat:IsA("VehicleSeat") then
			-- Humanoid is seated on a vehicle
			local vehicle = seat:FindFirstAncestorOfClass("Model")
			if vehicle then
				-- Make sure the PrimaryPart is set to the vehicle seat while we compute the extends.
				local tempPrimaryPart = vehicle.PrimaryPart
				vehicle.PrimaryPart = seat

				-- For now, only direct path
				if directPathForVehicle then
					local extents: Vector3 = vehicle:GetExtentsSize()
					agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
					agentHeight = AgentSizeIncreaseFactor * extents.Y
					agentCanJump = false
					this.AgentCanFollowPath = true
					this.DirectPath = directPathForVehicle
				end

				-- Reset PrimaryPart
				vehicle.PrimaryPart = tempPrimaryPart
			end
		else
			local extents: Vector3?
			if FFlagUserExcludeNonCollidableForPathfinding then
				local character: Model? = GetCharacter()
				if character ~= nil then
					extents = getCollidableExtentsSize(character)
				end
			end
			if extents == nil then
				extents = GetCharacter():GetExtentsSize()
			end
			assert(extents, "")
			agentRadius = AgentSizeIncreaseFactor * 0.5 * math.sqrt(extents.X * extents.X + extents.Z * extents.Z)
			agentHeight = AgentSizeIncreaseFactor * extents.Y
			agentCanJump = (this.Humanoid.JumpPower > 0)
			this.AgentCanFollowPath = true
			this.DirectPath = directPathForHumanoid :: boolean
			this.DirectPathRiseFirst = this.Humanoid.Sit
		end

		-- Build path object
		if FFlagUserClickToMoveSupportAgentCanClimb then
			this.pathResult = PathfindingService:CreatePath({AgentRadius = agentRadius, AgentHeight = agentHeight, AgentCanJump = agentCanJump, AgentCanClimb = true})
		else
			this.pathResult = PathfindingService:CreatePath({AgentRadius = agentRadius, AgentHeight = agentHeight, AgentCanJump = agentCanJump})
		end
	end

	function this:Cleanup()
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end

		if this.BlockedConn then
			this.BlockedConn:Disconnect()
			this.BlockedConn = nil
		end

		if this.DiedConn then
			this.DiedConn:Disconnect()
			this.DiedConn = nil
		end

		if this.SeatedConn then
			this.SeatedConn:Disconnect()
			this.SeatedConn = nil
		end

		if this.TeleportedConn then
			this.TeleportedConn:Disconnect()
			this.TeleportedConn = nil
		end

		this.Started = false
	end

	function this:Cancel()
		this.Cancelled = true
		this:Cleanup()
	end

	function this:IsActive()
		return this.AgentCanFollowPath and this.Started and not this.Cancelled
	end

	function this:OnPathInterrupted()
		-- Stop moving
		this.Cancelled = true
		this:OnPointReached(false)
	end

	function this:ComputePath()
		if this.OriginPoint then
			if this.PathComputed or this.PathComputing then return end
			this.PathComputing = true
			if this.AgentCanFollowPath then
				if this.DirectPath then
					this.pointList = {
						PathWaypoint.new(this.OriginPoint, Enum.PathWaypointAction.Walk),
						PathWaypoint.new(this.TargetPoint, this.DirectPathRiseFirst and Enum.PathWaypointAction.Jump or Enum.PathWaypointAction.Walk)
					}
					this.PathComputed = true
				else
					this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
					this.pointList = this.pathResult:GetWaypoints()
					this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx) this:OnPathBlocked(blockedIdx) end)
					this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success
				end
			end
			this.PathComputing = false
		end
	end

	function this:IsValidPath()
		this:ComputePath()
		return this.PathComputed and this.AgentCanFollowPath
	end

	this.Recomputing = false
	function this:OnPathBlocked(blockedWaypointIdx)
		local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
		if not pathBlocked or this.Recomputing then
			return
		end

		this.Recomputing = true

		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end

		this.OriginPoint = this.Humanoid.RootPart.CFrame.p

		this.pathResult:ComputeAsync(this.OriginPoint, this.TargetPoint)
		this.pointList = this.pathResult:GetWaypoints()
		if #this.pointList > 0 then
			this.HumanoidOffsetFromPath = this.pointList[1].Position - this.OriginPoint
		end
		this.PathComputed = this.pathResult.Status == Enum.PathStatus.Success

		if ShowPath then
			this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList)
		end
		if this.PathComputed then
			this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
			this:OnPointReached(true) -- Move to first point
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end

		this.Recomputing = false
	end

	function this:OnRenderStepped(dt: number)
		if this.Started and not this.Cancelled then
			-- Check for Timeout (if a waypoint is not reached within the delay, we fail)
			this.Timeout = this.Timeout + dt
			if this.Timeout > UnreachableWaypointTimeout then
				this:OnPointReached(false)
				return
			end

			-- Get Humanoid position and velocity
			this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
			this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity

			-- Check if it has reached some waypoints
			while this.Started and this:IsCurrentWaypointReached() do
				this:OnPointReached(true)
			end

			-- If still started, update actions
			if this.Started then
				-- Move action
				this.NextActionMoveDirection = this.CurrentWaypointPosition - this.CurrentHumanoidPosition
				if this.NextActionMoveDirection.Magnitude > ALMOST_ZERO then
					this.NextActionMoveDirection = this.NextActionMoveDirection.Unit
				else
					this.NextActionMoveDirection = ZERO_VECTOR3
				end
				-- Jump action
				if this.CurrentWaypointNeedsJump then
					this.NextActionJump = true
					this.CurrentWaypointNeedsJump = false	-- Request jump only once
				else
					this.NextActionJump = false
				end
			end
		end
	end

	function this:IsCurrentWaypointReached()
		local reached = false

		-- Check we do have a plane, if not, we consider the waypoint reached
		if this.CurrentWaypointPlaneNormal ~= ZERO_VECTOR3 then
			-- Compute distance of Humanoid from destination plane
			local dist = this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidPosition) - this.CurrentWaypointPlaneDistance
			-- Compute the component of the Humanoid velocity that is towards the plane
			local velocity = -this.CurrentWaypointPlaneNormal:Dot(this.CurrentHumanoidVelocity)
			-- Compute the threshold from the destination plane based on Humanoid velocity
			local threshold = math.max(1.0, 0.0625 * velocity)
			-- If we are less then threshold in front of the plane (between 0 and threshold) or if we are behing the plane (less then 0), we consider we reached it
			reached = dist < threshold
		else
			reached = true
		end

		if reached then
			this.CurrentWaypointPosition = nil
			this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
			this.CurrentWaypointPlaneDistance = 0
		end

		return reached
	end

	function this:OnPointReached(reached)

		if reached and not this.Cancelled then
			-- First, destroyed the current displayed waypoint
			if this.setPointFunc then
				this.setPointFunc(this.CurrentPoint)
			end

			local nextWaypointIdx = this.CurrentPoint + 1

			if nextWaypointIdx > #this.pointList then
				-- End of path reached
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
				this.Finished:Fire()
				this:Cleanup()
			else
				local currentWaypoint = this.pointList[this.CurrentPoint]
				local nextWaypoint = this.pointList[nextWaypointIdx]

				-- If airborne, only allow to keep moving
				-- if nextWaypoint.Action ~= Jump, or path mantains a direction
				-- Otherwise, wait until the humanoid gets to the ground
				local currentState = this.Humanoid:GetState()
				local isInAir = currentState == Enum.HumanoidStateType.FallingDown
					or currentState == Enum.HumanoidStateType.Freefall
					or currentState == Enum.HumanoidStateType.Jumping

				if isInAir then
					local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
					if not shouldWaitForGround and this.CurrentPoint > 1 then
						local prevWaypoint = this.pointList[this.CurrentPoint - 1]

						local prevDir = currentWaypoint.Position - prevWaypoint.Position
						local currDir = nextWaypoint.Position - currentWaypoint.Position

						local prevDirXZ = Vector2.new(prevDir.x, prevDir.z).Unit
						local currDirXZ = Vector2.new(currDir.x, currDir.z).Unit

						local THRESHOLD_COS = 0.996 -- ~cos(5 degrees)
						shouldWaitForGround = prevDirXZ:Dot(currDirXZ) < THRESHOLD_COS
					end

					if shouldWaitForGround then
						this.Humanoid.FreeFalling:Wait()

						-- Give time to the humanoid's state to change
						-- Otherwise, the jump flag in Humanoid
						-- will be reset by the state change
						wait(0.1)
					end
				end

				-- Move to the next point
				this:MoveToNextWayPoint(currentWaypoint, nextWaypoint, nextWaypointIdx)
			end
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
	end

	function this:MoveToNextWayPoint(currentWaypoint: PathWaypoint, nextWaypoint: PathWaypoint, nextWaypointIdx: number)
		-- Build next destination plane
		-- (plane normal is perpendicular to the y plane and is from next waypoint towards current one (provided the two waypoints are not at the same location))
		-- (plane location is at next waypoint)
		this.CurrentWaypointPlaneNormal = currentWaypoint.Position - nextWaypoint.Position
		
		-- plane normal isn't perpendicular to the y plane when climbing up
		if not FFlagUserClickToMoveSupportAgentCanClimb or (nextWaypoint.Label ~= "Climb") then
			this.CurrentWaypointPlaneNormal = Vector3.new(this.CurrentWaypointPlaneNormal.X, 0, this.CurrentWaypointPlaneNormal.Z)
		end
		if this.CurrentWaypointPlaneNormal.Magnitude > ALMOST_ZERO then
			this.CurrentWaypointPlaneNormal	= this.CurrentWaypointPlaneNormal.Unit
			this.CurrentWaypointPlaneDistance = this.CurrentWaypointPlaneNormal:Dot(nextWaypoint.Position)
		else
			-- Next waypoint is the same as current waypoint so no plane
			this.CurrentWaypointPlaneNormal	= ZERO_VECTOR3
			this.CurrentWaypointPlaneDistance = 0
		end

		-- Should we jump
		this.CurrentWaypointNeedsJump = nextWaypoint.Action == Enum.PathWaypointAction.Jump;

		-- Remember next waypoint position
		this.CurrentWaypointPosition = nextWaypoint.Position

		-- Move to next point
		this.CurrentPoint = nextWaypointIdx

		-- Finally reset Timeout
		this.Timeout = 0
	end

	function this:Start(overrideShowPath)
		if not this.AgentCanFollowPath then
			this.PathFailed:Fire()
			return
		end

		if this.Started then return end
		this.Started = true

		ClickToMoveDisplay.CancelFailureAnimation()

		if ShowPath then
			if overrideShowPath == nil or overrideShowPath then
				this.stopTraverseFunc, this.setPointFunc = ClickToMoveDisplay.CreatePathDisplay(this.pointList, this.OriginalTargetPoint)
			end
		end

		if #this.pointList > 0 then
			-- Determine the humanoid offset from the path's first point
			-- Offset of the first waypoint from the path's origin point
			this.HumanoidOffsetFromPath = Vector3.new(0, this.pointList[1].Position.Y - this.OriginPoint.Y, 0)

			-- As well as its current position and velocity
			this.CurrentHumanoidPosition = this.Humanoid.RootPart.Position + this.HumanoidOffsetFromPath
			this.CurrentHumanoidVelocity = this.Humanoid.RootPart.Velocity

			-- Connect to events
			this.SeatedConn = this.Humanoid.Seated:Connect(function(isSeated, seat) this:OnPathInterrupted() end)
			this.DiedConn = this.Humanoid.Died:Connect(function() this:OnPathInterrupted() end)
			this.TeleportedConn = this.Humanoid.RootPart:GetPropertyChangedSignal("CFrame"):Connect(function() this:OnPathInterrupted() end)

			-- Actually start
			this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
			this:OnPointReached(true) -- Move to first point
		else
			this.PathFailed:Fire()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
			end
		end
	end

	--We always raycast to the ground in the case that the user clicked a wall.
	local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal*1.5
	local ray = Ray.new(offsetPoint, Vector3.new(0,-1,0)*50)
	local newHitPart, newHitPos = Workspace:FindPartOnRayWithIgnoreList(ray, getIgnoreList())
	if newHitPart then
		this.TargetPoint = newHitPos
	end
	this:ComputePath()

	return this
end

-------------------------------------------------------------------------

local function CheckAlive()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end

local function GetEquippedTool(character: Model?)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA('Tool') then
				return child
			end
		end
	end
end

local ExistingPather = nil
local ExistingIndicator = nil
local PathCompleteListener = nil
local PathFailedListener = nil

local function CleanupPath()
	if ExistingPather then
		ExistingPather:Cancel()
		ExistingPather = nil
	end
	if PathCompleteListener then
		PathCompleteListener:Disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:Disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		ExistingIndicator:Destroy()
	end
end

local function HandleMoveTo(thisPather, hitPt, hitChar, character, overrideShowPath)
	if ExistingPather then
		CleanupPath()
	end
	ExistingPather = thisPather
	thisPather:Start(overrideShowPath)

	PathCompleteListener = thisPather.Finished.Event:Connect(function()
		CleanupPath()
		if hitChar then
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
			end
		end
	end)
	PathFailedListener = thisPather.PathFailed.Event:Connect(function()
		CleanupPath()
		if overrideShowPath == nil or overrideShowPath then
			local shouldPlayFailureAnim = PlayFailureAnimation and not (ExistingPather and ExistingPather:IsActive())
			if shouldPlayFailureAnim then
				ClickToMoveDisplay.PlayFailureAnimation()
			end
			ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
		end
	end)
end

local function ShowPathFailedFeedback(hitPt)
	if ExistingPather and ExistingPather:IsActive() then
		ExistingPather:Cancel()
	end
	if PlayFailureAnimation then
		ClickToMoveDisplay.PlayFailureAnimation()
	end
	ClickToMoveDisplay.DisplayFailureWaypoint(hitPt)
end

function OnTap(tapPositions: {Vector3}, goToPoint: Vector3?, wasTouchTap: boolean?)
	-- Good to remember if this is the latest tap event
	local camera = Workspace.CurrentCamera
	local character = Player.Character

	if not CheckAlive() then return end

	-- This is a path tap position
	if #tapPositions == 1 or goToPoint then
		if camera then
			local unitRay = camera:ScreenPointToRay(tapPositions[1].X, tapPositions[1].Y)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction*1000)

			local myHumanoid = findPlayerHumanoid(Player)
			local hitPart, hitPt, hitNormal = Utility.Raycast(ray, true, getIgnoreList())

			local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
			if wasTouchTap and hitHumanoid and StarterGui:GetCore("AvatarContextMenuEnabled") then
				local clickedPlayer = Players:GetPlayerFromCharacter(hitHumanoid.Parent)
				if clickedPlayer then
					CleanupPath()
					return
				end
			end
			if goToPoint then
				hitPt = goToPoint
				hitChar = nil
			end
			if hitPt and character then
				-- Clean up current path
				CleanupPath()
				local thisPather = Pather(hitPt, hitNormal)
				if thisPather:IsValidPath() then
					HandleMoveTo(thisPather, hitPt, hitChar, character)
				else
					-- Clean up
					thisPather:Cleanup()
					-- Feedback here for when we don't have a good path
					ShowPathFailedFeedback(hitPt)
				end
			end
		end
	elseif #tapPositions >= 2 then
		if camera then
			-- Do shoot
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
			end
		end
	end
end

local function DisconnectEvent(event)
	if event then
		event:Disconnect()
	end
end

--[[ The ClickToMove Controller Class ]]--
local KeyboardController = require(script.Parent:WaitForChild("Keyboard"))
local ClickToMove = setmetatable({}, KeyboardController)
ClickToMove.__index = ClickToMove

function ClickToMove.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)

	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	-- PC simulation
	self.mouse1Down = tick()
	self.mouse1DownPos = Vector2.new()
	self.mouse2DownTime = tick()
	self.mouse2DownPos = Vector2.new()
	self.mouse2UpTime = tick()

	self.keyboardMoveVector = ZERO_VECTOR3

	self.tapConn = nil
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.humanoidDiedConn = nil
	self.characterChildAddedConn = nil
	self.onCharacterAddedConn = nil
	self.characterChildRemovedConn = nil
	self.renderSteppedConn = nil
	self.menuOpenedConnection = nil

	self.running = false

	self.wasdEnabled = false

	return self
end

function ClickToMove:DisconnectEvents()
	DisconnectEvent(self.tapConn)
	DisconnectEvent(self.inputBeganConn)
	DisconnectEvent(self.inputChangedConn)
	DisconnectEvent(self.inputEndedConn)
	DisconnectEvent(self.humanoidDiedConn)
	DisconnectEvent(self.characterChildAddedConn)
	DisconnectEvent(self.onCharacterAddedConn)
	DisconnectEvent(self.renderSteppedConn)
	DisconnectEvent(self.characterChildRemovedConn)
	DisconnectEvent(self.menuOpenedConnection)
end

function ClickToMove:OnTouchBegan(input, processed)
	if self.fingerTouches[input] == nil and not processed then
		self.numUnsunkTouches = self.numUnsunkTouches + 1
	end
	self.fingerTouches[input] = processed
end

function ClickToMove:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end

function ClickToMove:OnTouchEnded(input, processed)
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
end


function ClickToMove:OnCharacterAdded(character)
	self:DisconnectEvents()

	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)
		end

		-- Cancel path when you use the keyboard controls if wasd is enabled.
		if self.wasdEnabled and processed == false and input.UserInputType == Enum.UserInputType.Keyboard
			and movementKeys[input.KeyCode] then
			CleanupPath()
			ClickToMoveDisplay.CancelFailureAnimation()
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.mouse1DownTime = tick()
			self.mouse1DownPos = input.Position
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2DownTime = tick()
			self.mouse2DownPos = input.Position
		end
	end)

	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		end
	end)

	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		end

		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2UpTime = tick()
			local currPos: Vector3 = input.Position
			-- We allow click to move during path following or if there is no keyboard movement
			local allowed = ExistingPather or self.keyboardMoveVector.Magnitude <= 0
			if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and allowed then
				local positions = {currPos}
				OnTap(positions)
			end
		end
	end)

	self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
		if not processed then
			OnTap(touchPositions, nil, true)
		end
	end)

	self.menuOpenedConnection = GuiService.MenuOpened:Connect(function()
		CleanupPath()
	end)

	local function OnCharacterChildAdded(child)
		if UserInputService.TouchEnabled then
			if child:IsA('Tool') then
				child.ManualActivationOnly = true
			end
		end
		if child:IsA('Humanoid') then
			DisconnectEvent(self.humanoidDiedConn)
			self.humanoidDiedConn = child.Died:Connect(function()
				if ExistingIndicator then
					DebrisService:AddItem(ExistingIndicator.Model, 1)
				end
			end)
		end
	end

	self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
		OnCharacterChildAdded(child)
	end)
	self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
		if UserInputService.TouchEnabled then
			if child:IsA('Tool') then
				child.ManualActivationOnly = false
			end
		end
	end)
	for _, child in pairs(character:GetChildren()) do
		OnCharacterChildAdded(child)
	end
end

function ClickToMove:Start()
	self:Enable(true)
end

function ClickToMove:Stop()
	self:Enable(false)
end

function ClickToMove:CleanupPath()
	CleanupPath()
end

function ClickToMove:Enable(enable: boolean, enableWASD: boolean, touchJumpController)
	if enable then
		if not self.running then
			if Player.Character then -- retro-listen
				self:OnCharacterAdded(Player.Character)
			end
			self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
			self.running = true
		end
		self.touchJumpController = touchJumpController
		if self.touchJumpController then
			self.touchJumpController:Enable(self.jumpEnabled)
		end
	else
		if self.running then
			self:DisconnectEvents()
			CleanupPath()
			-- Restore tool activation on shutdown
			if UserInputService.TouchEnabled then
				local character = Player.Character
				if character then
					for _, child in pairs(character:GetChildren()) do
						if child:IsA('Tool') then
							child.ManualActivationOnly = false
						end
					end
				end
			end
			self.running = false
		end
		if self.touchJumpController and not self.jumpEnabled then
			self.touchJumpController:Enable(true)
		end
		self.touchJumpController = nil
	end

	-- Extension for initializing Keyboard input as this class now derives from Keyboard
	if UserInputService.KeyboardEnabled and enable ~= self.enabled then

		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0

		self.moveVector = ZERO_VECTOR3

		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end
	end

	self.wasdEnabled = enable and enableWASD or false
	self.enabled = enable
end

function ClickToMove:OnRenderStepped(dt)
	-- Reset jump
	self.isJumping = false

	-- Handle Pather
	if ExistingPather then
		-- Let the Pather update
		ExistingPather:OnRenderStepped(dt)

		-- If we still have a Pather, set the resulting actions
		if ExistingPather then
			-- Setup move (NOT relative to camera)
			self.moveVector = ExistingPather.NextActionMoveDirection
			self.moveVectorIsCameraRelative = false

			-- Setup jump (but do NOT prevent the base Keayboard class from requesting jumps as well)
			if ExistingPather.NextActionJump then
				self.isJumping = true
			end
		else
			self.moveVector = self.keyboardMoveVector
			self.moveVectorIsCameraRelative = true
		end
	else
		self.moveVector = self.keyboardMoveVector
		self.moveVectorIsCameraRelative = true
	end

	-- Handle Keyboard's jump
	if self.jumpRequested then
		self.isJumping = true
	end
end

-- Overrides Keyboard:UpdateMovement(inputState) to conditionally consider self.wasdEnabled and let OnRenderStepped handle the movement
function ClickToMove:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.keyboardMoveVector = ZERO_VECTOR3
	elseif self.wasdEnabled then
		self.keyboardMoveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end

-- Overrides Keyboard:UpdateJump() because jump is handled in OnRenderStepped
function ClickToMove:UpdateJump()
	-- Nothing to do (handled in OnRenderStepped)
end

--Public developer facing functions
function ClickToMove:SetShowPath(value)
	ShowPath = value
end

function ClickToMove:GetShowPath()
	return ShowPath
end

function ClickToMove:SetWaypointTexture(texture)
	ClickToMoveDisplay.SetWaypointTexture(texture)
end

function ClickToMove:GetWaypointTexture()
	return ClickToMoveDisplay.GetWaypointTexture()
end

function ClickToMove:SetWaypointRadius(radius)
	ClickToMoveDisplay.SetWaypointRadius(radius)
end

function ClickToMove:GetWaypointRadius()
	return ClickToMoveDisplay.GetWaypointRadius()
end

function ClickToMove:SetEndWaypointTexture(texture)
	ClickToMoveDisplay.SetEndWaypointTexture(texture)
end

function ClickToMove:GetEndWaypointTexture()
	return ClickToMoveDisplay.GetEndWaypointTexture()
end

function ClickToMove:SetWaypointsAlwaysOnTop(alwaysOnTop)
	ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
end

function ClickToMove:GetWaypointsAlwaysOnTop()
	return ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
end

function ClickToMove:SetFailureAnimationEnabled(enabled)
	PlayFailureAnimation = enabled
end

function ClickToMove:GetFailureAnimationEnabled()
	return PlayFailureAnimation
end

function ClickToMove:SetIgnoredPartsTag(tag)
	UpdateIgnoreTag(tag)
end

function ClickToMove:GetIgnoredPartsTag()
	return CurrentIgnoreTag
end

function ClickToMove:SetUseDirectPath(directPath)
	UseDirectPath = directPath
end

function ClickToMove:GetUseDirectPath()
	return UseDirectPath
end

function ClickToMove:SetAgentSizeIncreaseFactor(increaseFactorPercent: number)
	AgentSizeIncreaseFactor = 1.0 + (increaseFactorPercent / 100.0)
end

function ClickToMove:GetAgentSizeIncreaseFactor()
	return (AgentSizeIncreaseFactor - 1.0) * 100.0
end

function ClickToMove:SetUnreachableWaypointTimeout(timeoutInSec)
	UnreachableWaypointTimeout = timeoutInSec
end

function ClickToMove:GetUnreachableWaypointTimeout()
	return UnreachableWaypointTimeout
end

function ClickToMove:SetUserJumpEnabled(jumpEnabled)
	self.jumpEnabled = jumpEnabled
	if self.touchJumpController then
		self.touchJumpController:Enable(jumpEnabled)
	end
end

function ClickToMove:GetUserJumpEnabled()
	return self.jumpEnabled
end

function ClickToMove:MoveTo(position, showPath, useDirectPath)
	local character = Player.Character
	if character == nil then
		return false
	end
	local thisPather = Pather(position, Vector3.new(0, 1, 0), useDirectPath)
	if thisPather and thisPather:IsValidPath() then
		HandleMoveTo(thisPather, position, nil, character, showPath)
		return true
	end
	return false
end

return ClickToMove
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070a9</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX36A1CE0F8DB44C4EA0BB50131DFF9DC6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TouchThumbstick</string>
							<string name="ScriptGuid">{79750E37-55DB-49F0-A69B-E4B97198B1A8}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[

	TouchThumbstick

--]]
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

local UserGameSettings = UserSettings():GetService("UserGameSettings")
local FFlagUserClampClassicThumbstick do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserClampClassicThumbstick")
	end)
	FFlagUserClampClassicThumbstick = success and result
end

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbstick = setmetatable({}, BaseCharacterController)
TouchThumbstick.__index = TouchThumbstick
function TouchThumbstick.new()
	local self = setmetatable(BaseCharacterController.new() :: any, TouchThumbstick)

	self.isFollowStick = false

	self.thumbstickFrame = nil
	self.moveTouchObject = nil
	self.onTouchMovedConn = nil
	self.onTouchEndedConn = nil
	self.screenPos = nil
	self.stickImage = nil
	self.thumbstickSize = nil -- Float

	return self
end
function TouchThumbstick:Enable(enable: boolean?, uiParentFrame)
	if enable == nil then return false end			-- If nil, return false (invalid argument)
	enable = enable and true or false				-- Force anything non-nil to boolean before comparison
	if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state

	self.moveVector = ZERO_VECTOR3
	self.isJumping = false

	if enable then
		-- Enable
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		self.thumbstickFrame.Visible = true
	else
		-- Disable
		self.thumbstickFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
function TouchThumbstick:OnInputEnded()
	self.thumbstickFrame.Position = self.screenPos
	self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset/2 - self.thumbstickSize/4, 0, self.thumbstickFrame.Size.Y.Offset/2 - self.thumbstickSize/4)

	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	self.thumbstickFrame.Position = self.screenPos
	self.moveTouchObject = nil
end
function TouchThumbstick:Create(parentFrame)

	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onTouchMovedConn then
			self.onTouchMovedConn:Disconnect()
			self.onTouchMovedConn = nil
		end
		if self.onTouchEndedConn then
			self.onTouchEndedConn:Disconnect()
			self.onTouchEndedConn = nil
		end
	end

	local minAxis = math.min(parentFrame.AbsoluteSize.X, parentFrame.AbsoluteSize.Y)
	local isSmallScreen = minAxis <= 500
	self.thumbstickSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, (self.thumbstickSize/2) - 10, 1, -self.thumbstickSize - 20) or
		UDim2.new(0, self.thumbstickSize/2, 1, -self.thumbstickSize * 1.75)

	self.thumbstickFrame = Instance.new("Frame")
	self.thumbstickFrame.Name = "ThumbstickFrame"
	self.thumbstickFrame.Active = true
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	self.thumbstickFrame.Position = self.screenPos
	self.thumbstickFrame.BackgroundTransparency = 1

	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new()
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	outerImage.Position = UDim2.new(0, 0, 0, 0)
	outerImage.Parent = self.thumbstickFrame

	self.stickImage = Instance.new("ImageLabel")
	self.stickImage.Name = "StickImage"
	self.stickImage.Image = TOUCH_CONTROL_SHEET
	self.stickImage.ImageRectOffset = Vector2.new(220, 0)
	self.stickImage.ImageRectSize = Vector2.new(111, 111)
	self.stickImage.BackgroundTransparency = 1
	self.stickImage.Size = UDim2.new(0, self.thumbstickSize/2, 0, self.thumbstickSize/2)
	self.stickImage.Position = UDim2.new(0, self.thumbstickSize/2 - self.thumbstickSize/4, 0, self.thumbstickSize/2 - self.thumbstickSize/4)
	self.stickImage.ZIndex = 2
	self.stickImage.Parent = self.thumbstickFrame

	local centerPosition = nil
	local deadZone = 0.05

	local function DoMove(direction: Vector2)

		local currentMoveVector = direction / (self.thumbstickSize/2)

		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < deadZone then
			currentMoveVector = Vector3.new()
		else
			if FFlagUserClampClassicThumbstick then
				currentMoveVector = currentMoveVector.unit * math.min(1, (inputAxisMagnitude - deadZone) / (1 - deadZone))
			else
				currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			end
			-- NOTE: Making currentMoveVector a unit vector will cause the player to instantly go max speed
			-- must check for zero length vector is using unit
			currentMoveVector = Vector3.new(currentMoveVector.X, 0, currentMoveVector.Y)
		end

		self.moveVector = currentMoveVector
	end

	local function MoveStick(pos: Vector3)
		local relativePosition = Vector2.new(pos.X - centerPosition.X, pos.Y - centerPosition.Y)
		local length = relativePosition.magnitude
		local maxLength = self.thumbstickFrame.AbsoluteSize.X/2
		if self.isFollowStick and length > maxLength then
			local offset = relativePosition.unit * maxLength
			self.thumbstickFrame.Position = UDim2.new(
				0, pos.X - self.thumbstickFrame.AbsoluteSize.X/2 - offset.X,
				0, pos.Y - self.thumbstickFrame.AbsoluteSize.Y/2 - offset.Y)
		else
			length = math.min(length, maxLength)
			relativePosition = relativePosition.unit * length
		end
		self.stickImage.Position = UDim2.new(0, relativePosition.X + self.stickImage.AbsoluteSize.X/2, 0, relativePosition.Y + self.stickImage.AbsoluteSize.Y/2)
	end

	-- input connections
	self.thumbstickFrame.InputBegan:Connect(function(inputObject: InputObject)
		--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
		--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
		if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
			or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end

		self.moveTouchObject = inputObject
		self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.X - self.thumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.Y - self.thumbstickFrame.Size.Y.Offset/2)
		centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.X + self.thumbstickFrame.AbsoluteSize.X/2,
			self.thumbstickFrame.AbsolutePosition.Y + self.thumbstickFrame.AbsoluteSize.Y/2)
		local direction = Vector2.new(inputObject.Position.X - centerPosition.X, inputObject.Position.Y - centerPosition.Y)
	end)

	self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject: InputObject, isProcessed: boolean)
		if inputObject == self.moveTouchObject then
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.X + self.thumbstickFrame.AbsoluteSize.X/2,
				self.thumbstickFrame.AbsolutePosition.Y + self.thumbstickFrame.AbsoluteSize.Y/2)
			local direction = Vector2.new(inputObject.Position.X - centerPosition.X, inputObject.Position.Y - centerPosition.Y)
			DoMove(direction)
			MoveStick(inputObject.Position)
		end
	end)

	self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)

	GuiService.MenuOpened:Connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)

	self.thumbstickFrame.Parent = parentFrame
end
return TouchThumbstick
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070aa</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA9122725A7E540D794F1DB913BC7851C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PathDisplay</string>
							<string name="ScriptGuid">{FB641652-D0DD-4C08-B43C-63723E003733}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict


local PathDisplay = {}
PathDisplay.spacing = 8
PathDisplay.image = "rbxasset://textures/Cursors/Gamepad/Pointer.png"
PathDisplay.imageSize = Vector2.new(2, 2)

local currentPoints = {}
local renderedPoints = {}

local pointModel = Instance.new("Model")
pointModel.Name = "PathDisplayPoints"

local adorneePart = Instance.new("Part")
adorneePart.Anchored = true
adorneePart.CanCollide = false
adorneePart.Transparency = 1
adorneePart.Name = "PathDisplayAdornee"
adorneePart.CFrame = CFrame.new(0, 0, 0)
adorneePart.Parent = pointModel

local pointPool = {}
local poolTop = 30
for i = 1, poolTop do
	local point = Instance.new("ImageHandleAdornment")
	point.Archivable = false
	point.Adornee = adorneePart
	point.Image = PathDisplay.image
	point.Size = PathDisplay.imageSize
	pointPool[i] = point
end

local function retrieveFromPool(): ImageHandleAdornment?
	local point = pointPool[1]
	if not point then
		return nil
	end

	pointPool[1], pointPool[poolTop] = pointPool[poolTop], nil
	poolTop = poolTop - 1
	return point
end

local function returnToPool(point: ImageHandleAdornment)
	poolTop = poolTop + 1
	pointPool[poolTop] = point
end

local function renderPoint(point: Vector3, isLast): ImageHandleAdornment?
	if poolTop == 0 then
		return nil
	end

	local rayDown = Ray.new(point + Vector3.new(0, 2, 0), Vector3.new(0, -8, 0))
	local hitPart, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(rayDown, { (game.Players.LocalPlayer :: Player).Character :: Model, workspace.CurrentCamera :: Camera })
	if not hitPart then
		return nil
	end

	local pointCFrame = CFrame.new(hitPoint, hitPoint + hitNormal)

	local point = retrieveFromPool()
	point.CFrame = pointCFrame
	point.Parent = pointModel
	return point
end

function PathDisplay.setCurrentPoints(points)
	if typeof(points) == 'table' then
		currentPoints = points
	else
		currentPoints = {}
	end
end

function PathDisplay.clearRenderedPath()
	for _, oldPoint in ipairs(renderedPoints) do
		oldPoint.Parent = nil
		returnToPool(oldPoint)
	end
	renderedPoints = {}
	pointModel.Parent = nil
end

function PathDisplay.renderPath()
	PathDisplay.clearRenderedPath()
	if not currentPoints or #currentPoints == 0 then
		return
	end

	local currentIdx = #currentPoints
	local lastPos = currentPoints[currentIdx]
	local distanceBudget = 0

	renderedPoints[1] = renderPoint(lastPos, true)
	if not renderedPoints[1] then
		return
	end

	while true do
		local currentPoint = currentPoints[currentIdx]
		local nextPoint = currentPoints[currentIdx - 1]

		if currentIdx < 2 then
			break
		else

			local toNextPoint = nextPoint - currentPoint
			local distToNextPoint = toNextPoint.magnitude

			if distanceBudget > distToNextPoint then
				distanceBudget = distanceBudget - distToNextPoint
				currentIdx = currentIdx - 1
			else
				local dirToNextPoint = toNextPoint.unit
				local pointPos = currentPoint + (dirToNextPoint * distanceBudget)
				local point = renderPoint(pointPos, false)

				if point then
					renderedPoints[#renderedPoints + 1] = point
				end

				distanceBudget = distanceBudget + PathDisplay.spacing
			end
		end
	end

	pointModel.Parent = workspace.CurrentCamera
end

return PathDisplay
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070ab</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5FB99643E5CC424D91F441C80AD5A55A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Gamepad</string>
							<string name="ScriptGuid">{FCD01305-328E-4C90-B2F2-D03301B0FFD7}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	Gamepad Character Control - This module handles controlling your avatar using a game console-style controller

	2018 PlayerScripts Update - AllYourBlox
--]]

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local NONE = Enum.UserInputType.None
local thumbstickDeadzone = 0.2

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Gamepad = setmetatable({}, BaseCharacterController)
Gamepad.__index = Gamepad

function Gamepad.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new() :: any, Gamepad)

	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY

	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0

	self.activeGamepad = NONE	-- Enum.UserInputType.Gamepad1, 2, 3...
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	return self
end

function Gamepad:Enable(enable: boolean): boolean
	if not UserInputService.GamepadEnabled then
		return false
	end

	if enable == self.enabled then
		-- Module is already in the state being requested. True is returned here since the module will be in the state
		-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
		-- no action was necessary. False indicates failure to be in requested/expected state.
		return true
	end

	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false

	if enable then
		self.activeGamepad = self:GetHighestPriorityGamepad()
		if self.activeGamepad ~= NONE then
			self:BindContextActions()
			self:ConnectGamepadConnectionListeners()
		else
			-- No connected gamepads, failure to enable
			return false
		end
	else
		self:UnbindContextActions()
		self:DisconnectGamepadConnectionListeners()
		self.activeGamepad = NONE
	end

	self.enabled = enable
	return true
end

-- This function selects the lowest number gamepad from the currently-connected gamepad
-- and sets it as the active gamepad
function Gamepad:GetHighestPriorityGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	local bestGamepad = NONE -- Note that this value is higher than all valid gamepad values
	for _, gamepad in pairs(connectedGamepads) do
		if gamepad.Value < bestGamepad.Value then
			bestGamepad = gamepad
		end
	end
	return bestGamepad
end

function Gamepad:BindContextActions()

	if self.activeGamepad == NONE then
		-- There must be an active gamepad to set up bindings
		return false
	end

	local handleJumpAction = function(actionName, inputState, inputObject)
		self.isJumping = (inputState == Enum.UserInputState.Begin)
		return Enum.ContextActionResult.Sink
	end

	local handleThumbstickInput = function(actionName, inputState, inputObject)

		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
			return Enum.ContextActionResult.Sink
		end

		if self.activeGamepad ~= inputObject.UserInputType then
			return Enum.ContextActionResult.Pass
		end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end

		if inputObject.Position.magnitude > thumbstickDeadzone then
			self.moveVector  =  Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
		else
			self.moveVector = ZERO_VECTOR3
		end
		return Enum.ContextActionResult.Sink
	end

	ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
		self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
	ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false,
		self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)

	return true
end

function Gamepad:UnbindContextActions()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	ContextActionService:UnbindAction("moveThumbstick")
	ContextActionService:UnbindAction("jumpAction")
end

function Gamepad:OnNewGamepadConnected()
	-- A new gamepad has been connected.
	local bestGamepad: Enum.UserInputType = self:GetHighestPriorityGamepad()

	if bestGamepad == self.activeGamepad then
		-- A new gamepad was connected, but our active gamepad is not changing
		return
	end

	if bestGamepad == NONE then
		-- There should be an active gamepad when GamepadConnected fires, so this should not
		-- normally be hit. If there is no active gamepad, unbind actions but leave
		-- the module enabled and continue to listen for a new gamepad connection.
		warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
		self:UnbindContextActions()
		return
	end

	if self.activeGamepad ~= NONE then
		-- Switching from one active gamepad to another
		self:UnbindContextActions()
	end

	self.activeGamepad = bestGamepad
	self:BindContextActions()
end

function Gamepad:OnCurrentGamepadDisconnected()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end

	local bestGamepad = self:GetHighestPriorityGamepad()

	if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
		warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
		self:UnbindContextActions()
		self.activeGamepad = NONE
		return
	end

	if bestGamepad == NONE then
		-- No active gamepad, unbinding actions but leaving gamepad connection listener active
		self:UnbindContextActions()
		self.activeGamepad = NONE
	else
		-- Set new gamepad as active and bind to tool activation
		self.activeGamepad = bestGamepad
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
end

function Gamepad:ConnectGamepadConnectionListeners()
	self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		self:OnNewGamepadConnected()
	end)

	self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if self.activeGamepad == gamepadEnum then
			self:OnCurrentGamepadDisconnected()
		end
	end)

end

function Gamepad:DisconnectGamepadConnectionListeners()
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end

	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
end

return Gamepad
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070ac</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX657A2695C536421FA0164763F85B5008">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">DynamicThumbstick</string>
							<string name="ScriptGuid">{B556F005-0D92-45E5-AF5E-3D244FA1FC3B}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"

local DYNAMIC_THUMBSTICK_ACTION_NAME = "DynamicThumbstickAction"
local DYNAMIC_THUMBSTICK_ACTION_PRIORITY = Enum.ContextActionPriority.High.Value

local MIDDLE_TRANSPARENCIES = {
	1 - 0.89,
	1 - 0.70,
	1 - 0.60,
	1 - 0.50,
	1 - 0.40,
	1 - 0.30,
	1 - 0.25
}
local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES

local FADE_IN_OUT_BACKGROUND = true
local FADE_IN_OUT_MAX_ALPHA = 0.35

local SAFE_AREA_INSET_MAX = 100

local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local FFlagUserDynamicThumbstickMoveOverButtons do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickMoveOverButtons2")
	end)
	FFlagUserDynamicThumbstickMoveOverButtons = success and result
end

local FFlagUserDynamicThumbstickSafeAreaUpdate do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserDynamicThumbstickSafeAreaUpdate")
	end)
	FFlagUserDynamicThumbstickSafeAreaUpdate = success and result
end

local LocalPlayer = Players.LocalPlayer
if not LocalPlayer then
	Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
	LocalPlayer = Players.LocalPlayer
end

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local DynamicThumbstick = setmetatable({}, BaseCharacterController)
DynamicThumbstick.__index = DynamicThumbstick

function DynamicThumbstick.new()
	local self = setmetatable(BaseCharacterController.new() :: any, DynamicThumbstick)

	self.moveTouchObject = nil
	self.moveTouchLockedIn = false
	self.moveTouchFirstChanged = false
	self.moveTouchStartPosition = nil

	self.startImage = nil
	self.endImage = nil
	self.middleImages = {}

	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}

	self.isFirstTouch = true

	self.thumbstickFrame = nil

	self.onRenderSteppedConn = nil

	self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
	self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
	self.hasFadedBackgroundInPortrait = false
	self.hasFadedBackgroundInLandscape = false

	self.tweenInAlphaStart = nil
	self.tweenOutAlphaStart = nil

	return self
end

-- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
-- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
function DynamicThumbstick:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end

function DynamicThumbstick:Enable(enable: boolean?, uiParentFrame): boolean?
	if enable == nil then return false end			-- If nil, return false (invalid argument)
	enable = enable and true or false				-- Force anything non-nil to boolean before comparison
	if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state

	if enable then
		-- Enable
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end

		self:BindContextActions()
	else
		if FFlagUserDynamicThumbstickMoveOverButtons then
			self:UnbindContextActions()
		else
			ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)
		end

		-- Disable
		self:OnInputEnded() -- Cleanup
	end

	self.enabled = enable
	self.thumbstickFrame.Visible = enable
	return nil
end

-- Was called OnMoveTouchEnded in previous version
function DynamicThumbstick:OnInputEnded()
	self.moveTouchObject = nil
	self.moveVector = ZERO_VECTOR3
	self:FadeThumbstick(false)
end

function DynamicThumbstick:FadeThumbstick(visible: boolean?)
	if not visible and self.moveTouchObject then
		return
	end
	if self.isFirstTouch then return end

	if self.startImageFadeTween then
		self.startImageFadeTween:Cancel()
	end
	if self.endImageFadeTween then
		self.endImageFadeTween:Cancel()
	end
	for i = 1, #self.middleImages do
		if self.middleImageFadeTweens[i] then
			self.middleImageFadeTweens[i]:Cancel()
		end
	end

	if visible then
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0 })
		self.startImageFadeTween:Play()

		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0.2 })
		self.endImageFadeTween:Play()

		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = MIDDLE_TRANSPARENCIES[i] })
			self.middleImageFadeTweens[i]:Play()
		end
	else
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
		self.startImageFadeTween:Play()

		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
		self.endImageFadeTween:Play()

		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
			self.middleImageFadeTweens[i]:Play()
		end
	end
end

function DynamicThumbstick:FadeThumbstickFrame(fadeDuration: number, fadeRatio: number)
	self.fadeInAndOutHalfDuration = fadeDuration * 0.5
	self.fadeInAndOutBalance = fadeRatio
	self.tweenInAlphaStart = tick()
end

function DynamicThumbstick:InputInFrame(inputObject: InputObject)
	local frameCornerTopLeft: Vector2 = self.thumbstickFrame.AbsolutePosition
	local frameCornerBottomRight = frameCornerTopLeft + self.thumbstickFrame.AbsoluteSize
	local inputPosition = inputObject.Position
	if inputPosition.X >= frameCornerTopLeft.X and inputPosition.Y >= frameCornerTopLeft.Y then
		if inputPosition.X <= frameCornerBottomRight.X and inputPosition.Y <= frameCornerBottomRight.Y then
			return true
		end
	end
	return false
end

function DynamicThumbstick:DoFadeInBackground()
	local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
	local hasFadedBackgroundInOrientation = false

	-- only fade in/out the background once per orientation
	if playerGui then
		if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
			playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
				hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
				self.hasFadedBackgroundInLandscape = true
		elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
				hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
				self.hasFadedBackgroundInPortrait = true
		end
	end

	if not hasFadedBackgroundInOrientation then
		self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
		self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
		self.tweenInAlphaStart = tick()
	end
end

function DynamicThumbstick:DoMove(direction: Vector3)
	local currentMoveVector: Vector3 = direction

	-- Scaled Radial Dead Zone
	local inputAxisMagnitude: number = currentMoveVector.Magnitude
	if inputAxisMagnitude < self.radiusOfDeadZone then
		currentMoveVector = ZERO_VECTOR3
	else
		currentMoveVector = currentMoveVector.Unit*(
			1 - math.max(0, (self.radiusOfMaxSpeed - currentMoveVector.Magnitude)/self.radiusOfMaxSpeed)
		)
		currentMoveVector = Vector3.new(currentMoveVector.X, 0, currentMoveVector.Y)
	end

	self.moveVector = currentMoveVector
end


function DynamicThumbstick:LayoutMiddleImages(startPos: Vector3, endPos: Vector3)
	local startDist = (self.thumbstickSize / 2) + self.middleSize
	local vector = endPos - startPos
	local distAvailable = vector.Magnitude - (self.thumbstickRingSize / 2) - self.middleSize
	local direction = vector.Unit

	local distNeeded = self.middleSpacing * NUM_MIDDLE_IMAGES
	local spacing = self.middleSpacing

	if distNeeded < distAvailable then
		spacing = distAvailable / NUM_MIDDLE_IMAGES
	end

	for i = 1, NUM_MIDDLE_IMAGES do
		local image = self.middleImages[i]
		local distWithout = startDist + (spacing * (i - 2))
		local currentDist = startDist + (spacing * (i - 1))

		if distWithout < distAvailable then
			local pos = endPos - direction * currentDist
			local exposedFraction = math.clamp(1 - ((currentDist - distAvailable) / spacing), 0, 1)

			image.Visible = true
			image.Position = UDim2.new(0, pos.X, 0, pos.Y)
			image.Size = UDim2.new(0, self.middleSize * exposedFraction, 0, self.middleSize * exposedFraction)
		else
			image.Visible = false
		end
	end
end

function DynamicThumbstick:MoveStick(pos)
	local vector2StartPosition = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y)
	local startPos = vector2StartPosition - self.thumbstickFrame.AbsolutePosition
	local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
	self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
	self:LayoutMiddleImages(startPos, endPos)
end

function DynamicThumbstick:BindContextActions()
	local function inputBegan(inputObject)
		if self.moveTouchObject then
			return Enum.ContextActionResult.Pass
		end

		if not self:InputInFrame(inputObject) then
			return Enum.ContextActionResult.Pass
		end

		if self.isFirstTouch then
			self.isFirstTouch = false
			local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out,0,false,0)
			TweenService:Create(self.startImage, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)}):Play()
			TweenService:Create(
				self.endImage,
				tweenInfo,
				{Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize), ImageColor3 = Color3.new(0,0,0)}
			):Play()
		end

		self.moveTouchLockedIn = false
		self.moveTouchObject = inputObject
		self.moveTouchStartPosition = inputObject.Position
		self.moveTouchFirstChanged = true

		if FADE_IN_OUT_BACKGROUND then
			self:DoFadeInBackground()
		end

		return Enum.ContextActionResult.Pass
	end

	local function inputChanged(inputObject: InputObject)
		if inputObject == self.moveTouchObject then
			if self.moveTouchFirstChanged then
				self.moveTouchFirstChanged = false

				local startPosVec2 = Vector2.new(
					inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X,
					inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y
				)
				self.startImage.Visible = true
				self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
				self.endImage.Visible = true
				self.endImage.Position = self.startImage.Position

				self:FadeThumbstick(true)
				self:MoveStick(inputObject.Position)
			end

			self.moveTouchLockedIn = true

			local direction = Vector2.new(
				inputObject.Position.X - self.moveTouchStartPosition.X,
				inputObject.Position.Y - self.moveTouchStartPosition.Y
			)
			if math.abs(direction.X) > 0 or math.abs(direction.Y) > 0 then
				self:DoMove(direction)
				self:MoveStick(inputObject.Position)
			end
			return Enum.ContextActionResult.Sink
		end
		return Enum.ContextActionResult.Pass
	end

	local function inputEnded(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
			if self.moveTouchLockedIn then
				return Enum.ContextActionResult.Sink
			end
		end
		return Enum.ContextActionResult.Pass
	end

	local function handleInput(actionName, inputState, inputObject)
		if inputState == Enum.UserInputState.Begin then
			return inputBegan(inputObject)
		elseif inputState == Enum.UserInputState.Change then
			if FFlagUserDynamicThumbstickMoveOverButtons then
				if inputObject == self.moveTouchObject then
					return Enum.ContextActionResult.Sink
				else
					return Enum.ContextActionResult.Pass
				end
			else
				return inputChanged(inputObject)
			end
		elseif inputState == Enum.UserInputState.End then
			return inputEnded(inputObject)
		elseif inputState == Enum.UserInputState.Cancel then
			self:OnInputEnded()
		end
	end

	ContextActionService:BindActionAtPriority(
		DYNAMIC_THUMBSTICK_ACTION_NAME,
		handleInput,
		false,
		DYNAMIC_THUMBSTICK_ACTION_PRIORITY,
		Enum.UserInputType.Touch)

	if FFlagUserDynamicThumbstickMoveOverButtons then
		self.TouchMovedCon = UserInputService.TouchMoved:Connect(function(inputObject: InputObject, _gameProcessedEvent: boolean)
			inputChanged(inputObject)
		end)
	end
end

function DynamicThumbstick:UnbindContextActions()
	ContextActionService:UnbindAction(DYNAMIC_THUMBSTICK_ACTION_NAME)

	if self.TouchMovedCon then
		self.TouchMovedCon:Disconnect()
	end
end

function DynamicThumbstick:Create(parentFrame: GuiBase2d)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onRenderSteppedConn then
			self.onRenderSteppedConn:Disconnect()
			self.onRenderSteppedConn = nil
		end
	end

	self.thumbstickSize = 45
	self.thumbstickRingSize = 20
	self.middleSize = 10
	self.middleSpacing = self.middleSize + 4
	self.radiusOfDeadZone = 2
	self.radiusOfMaxSpeed = 20

	local screenSize = parentFrame.AbsoluteSize
	local isBigScreen = math.min(screenSize.X, screenSize.Y) > 500
	if isBigScreen then
		self.thumbstickSize = self.thumbstickSize * 2
		self.thumbstickRingSize = self.thumbstickRingSize * 2
		self.middleSize = self.middleSize * 2
		self.middleSpacing = self.middleSpacing * 2
		self.radiusOfDeadZone = self.radiusOfDeadZone * 2
		self.radiusOfMaxSpeed = self.radiusOfMaxSpeed * 2
	end

	local safeInset: number = if FFlagUserDynamicThumbstickSafeAreaUpdate then SAFE_AREA_INSET_MAX else 0
	local function layoutThumbstickFrame(portraitMode: boolean)
		if portraitMode then
			self.thumbstickFrame.Size = UDim2.new(1, safeInset, 0.4, safeInset)
			self.thumbstickFrame.Position = UDim2.new(0, -safeInset, 0.6, 0)
		else
			self.thumbstickFrame.Size = UDim2.new(0.4, safeInset, 2/3, safeInset)
			self.thumbstickFrame.Position = UDim2.new(0, -safeInset, 1/3, 0)
		end
	end

	self.thumbstickFrame = Instance.new("Frame")
	self.thumbstickFrame.BorderSizePixel = 0
	self.thumbstickFrame.Name = "DynamicThumbstickFrame"
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.BackgroundTransparency = 1.0
	self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	self.thumbstickFrame.Active = false
	layoutThumbstickFrame(false)

	self.startImage = Instance.new("ImageLabel")
	self.startImage.Name = "ThumbstickStart"
	self.startImage.Visible = true
	self.startImage.BackgroundTransparency = 1
	self.startImage.Image = TOUCH_CONTROLS_SHEET
	self.startImage.ImageRectOffset = Vector2.new(1,1)
	self.startImage.ImageRectSize = Vector2.new(144, 144)
	self.startImage.ImageColor3 = Color3.new(0, 0, 0)
	self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.startImage.Position = UDim2.new(0, self.thumbstickRingSize * 3.3 + safeInset, 1, -self.thumbstickRingSize * 2.8 - safeInset)
	self.startImage.Size = UDim2.new(0, self.thumbstickRingSize  * 3.7, 0, self.thumbstickRingSize  * 3.7)
	self.startImage.ZIndex = 10
	self.startImage.Parent = self.thumbstickFrame

	self.endImage = Instance.new("ImageLabel")
	self.endImage.Name = "ThumbstickEnd"
	self.endImage.Visible = true
	self.endImage.BackgroundTransparency = 1
	self.endImage.Image = TOUCH_CONTROLS_SHEET
	self.endImage.ImageRectOffset = Vector2.new(1,1)
	self.endImage.ImageRectSize =  Vector2.new(144, 144)
	self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.endImage.Position = self.startImage.Position
	self.endImage.Size = UDim2.new(0, self.thumbstickSize * 0.8, 0, self.thumbstickSize * 0.8)
	self.endImage.ZIndex = 10
	self.endImage.Parent = self.thumbstickFrame

	for i = 1, NUM_MIDDLE_IMAGES do
		self.middleImages[i] = Instance.new("ImageLabel")
		self.middleImages[i].Name = "ThumbstickMiddle"
		self.middleImages[i].Visible = false
		self.middleImages[i].BackgroundTransparency = 1
		self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
		self.middleImages[i].ImageRectOffset = Vector2.new(1,1)
		self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
		self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
		self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
		self.middleImages[i].ZIndex = 9
		self.middleImages[i].Parent = self.thumbstickFrame
	end

	local CameraChangedConn: RBXScriptConnection? = nil
	local function onCurrentCameraChanged()
		if CameraChangedConn then
			CameraChangedConn:Disconnect()
			CameraChangedConn = nil
		end
		local newCamera = workspace.CurrentCamera
		if newCamera then
			local function onViewportSizeChanged()
				local size = newCamera.ViewportSize
				local portraitMode = size.X < size.Y
				layoutThumbstickFrame(portraitMode)
			end
			CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
			onViewportSizeChanged()
		end
	end
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
	if workspace.CurrentCamera then
		onCurrentCameraChanged()
	end

	self.moveTouchStartPosition = nil

	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}

	self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
		if self.tweenInAlphaStart ~= nil then
			local delta = tick() - self.tweenInAlphaStart
			local fadeInTime = (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeInTime, 1)
			if delta > fadeInTime then
				self.tweenOutAlphaStart = tick()
				self.tweenInAlphaStart = nil
			end
		elseif self.tweenOutAlphaStart ~= nil then
			local delta = tick() - self.tweenOutAlphaStart
			local fadeOutTime = (self.fadeInAndOutHalfDuration * 2) - (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeOutTime, 1)
			if delta > fadeOutTime  then
				self.tweenOutAlphaStart = nil
			end
		end
	end)

	self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject: InputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)

	GuiService.MenuOpened:connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)

	local playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
	while not playerGui do
		LocalPlayer.ChildAdded:wait()
		playerGui = LocalPlayer:FindFirstChildOfClass("PlayerGui")
	end

	local playerGuiChangedConn = nil
	local originalScreenOrientationWasLandscape =	playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
													playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight

	local function longShowBackground()
		self.fadeInAndOutHalfDuration = 2.5
		self.fadeInAndOutBalance = 0.05
		self.tweenInAlphaStart = tick()
	end

	playerGuiChangedConn = playerGui:GetPropertyChangedSignal("CurrentScreenOrientation"):Connect(function()
		if (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait) or
			(not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then

			playerGuiChangedConn:disconnect()
			longShowBackground()

			if originalScreenOrientationWasLandscape then
				self.hasFadedBackgroundInPortrait = true
			else
				self.hasFadedBackgroundInLandscape = true
			end
		end
	end)

	self.thumbstickFrame.Parent = parentFrame

	if game:IsLoaded() then
		longShowBackground()
	else
		coroutine.wrap(function()
			game.Loaded:Wait()
			longShowBackground()
		end)()
	end
end

return DynamicThumbstick
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070ad</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX06B7B6C781374A53ACE5C5E8E7FFF681">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseCharacterController</string>
							<string name="ScriptGuid">{C1A92D7A-1F18-48F3-A11F-7ECB7447D676}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	BaseCharacterController - Abstract base class for character controllers, not intended to be
	directly instantiated.

	2018 PlayerScripts Update - AllYourBlox
--]]

local ZERO_VECTOR3: Vector3 = Vector3.new(0,0,0)

--[[ The Module ]]--
local BaseCharacterController = {}
BaseCharacterController.__index = BaseCharacterController

function BaseCharacterController.new()
	local self = setmetatable({}, BaseCharacterController)
	self.enabled = false
	self.moveVector = ZERO_VECTOR3
	self.moveVectorIsCameraRelative = true
	self.isJumping = false
	return self
end

function BaseCharacterController:OnRenderStepped(dt: number)
	-- By default, nothing to do
end

function BaseCharacterController:GetMoveVector(): Vector3
	return self.moveVector
end

function BaseCharacterController:IsMoveVectorCameraRelative(): boolean
	return self.moveVectorIsCameraRelative
end

function BaseCharacterController:GetIsJumping(): boolean
	return self.isJumping
end

-- Override in derived classes to set self.enabled and return boolean indicating
-- whether Enable/Disable was successful. Return true if controller is already in the requested state.
function BaseCharacterController:Enable(enable: boolean): boolean
	error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
	return false
end

return BaseCharacterController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070ae</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFE77817934B1490D94512EF117419FFD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Keyboard</string>
							<string name="ScriptGuid">{708BAB35-E0E6-4901-B3F6-87614952DCDC}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	Keyboard Character Control - This module handles controlling your avatar from a keyboard

	2018 PlayerScripts Update - AllYourBlox
--]]

--[[ Roblox Services ]]--
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Keyboard = setmetatable({}, BaseCharacterController)
Keyboard.__index = Keyboard

function Keyboard.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new() :: any, Keyboard)

	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY

	self.textFocusReleasedConn = nil
	self.textFocusGainedConn = nil
	self.windowFocusReleasedConn = nil

	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0

	self.jumpEnabled = true

	return self
end

function Keyboard:Enable(enable: boolean)
	if not UserInputService.KeyboardEnabled then
		return false
	end

	if enable == self.enabled then
		-- Module is already in the state being requested. True is returned here since the module will be in the state
		-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
		-- no action was necessary. False indicates failure to be in requested/expected state.
		return true
	end

	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.jumpRequested = false
	self:UpdateJump()

	if enable then
		self:BindContextActions()
		self:ConnectFocusEventListeners()
	else
		self:UnbindContextActions()
		self:DisconnectFocusEventListeners()
	end

	self.enabled = enable
	return true
end

function Keyboard:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	else
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end

function Keyboard:UpdateJump()
	self.isJumping = self.jumpRequested
end

function Keyboard:BindContextActions()

	-- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
	-- which fixes them from getting stuck on.
	-- We return ContextActionResult.Pass here for legacy reasons.
	-- Many games rely on gameProcessedEvent being false on UserInputService.InputBegan for these control actions.
	local handleMoveForward = function(actionName, inputState, inputObject)
		self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
		self:UpdateMovement(inputState)
		return Enum.ContextActionResult.Pass
	end

	local handleMoveBackward = function(actionName, inputState, inputObject)
		self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
		self:UpdateMovement(inputState)
		return Enum.ContextActionResult.Pass
	end

	local handleMoveLeft = function(actionName, inputState, inputObject)
		self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
		self:UpdateMovement(inputState)
		return Enum.ContextActionResult.Pass
	end

	local handleMoveRight = function(actionName, inputState, inputObject)
		self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
		self:UpdateMovement(inputState)
		return Enum.ContextActionResult.Pass
	end

	local handleJumpAction = function(actionName, inputState, inputObject)
		self.jumpRequested = self.jumpEnabled and (inputState == Enum.UserInputState.Begin)
		self:UpdateJump()
		return Enum.ContextActionResult.Pass
	end

	-- TODO: Revert to KeyCode bindings so that in the future the abstraction layer from actual keys to
	-- movement direction is done in Lua
	ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false,
		self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
	ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false,
		self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
	ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false,
		self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
	ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false,
		self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
	ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
		self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
end

function Keyboard:UnbindContextActions()
	ContextActionService:UnbindAction("moveForwardAction")
	ContextActionService:UnbindAction("moveBackwardAction")
	ContextActionService:UnbindAction("moveLeftAction")
	ContextActionService:UnbindAction("moveRightAction")
	ContextActionService:UnbindAction("jumpAction")
end

function Keyboard:ConnectFocusEventListeners()
	local function onFocusReleased()
		self.moveVector = ZERO_VECTOR3
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.jumpRequested = false
		self:UpdateJump()
	end

	local function onTextFocusGained(textboxFocused)
		self.jumpRequested = false
		self:UpdateJump()
	end

	self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
	self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
	self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
end

function Keyboard:DisconnectFocusEventListeners()
	if self.textFocusReleasedConn then
		self.textFocusReleasedConn:Disconnect()
		self.textFocusReleasedConn = nil
	end
	if self.textFocusGainedConn then
		self.textFocusGainedConn:Disconnect()
		self.textFocusGainedConn = nil
	end
	if self.windowFocusReleasedConn then
		self.windowFocusReleasedConn:Disconnect()
		self.windowFocusReleasedConn = nil
	end
end

return Keyboard
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070af</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX290754B68D7A4A6593F220FFFE4CEDD9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickToMoveDisplay</string>
							<string name="ScriptGuid">{238267D0-D76A-4C25-ADC7-DCEE195CC420}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
local ClickToMoveDisplay = {}

local FAILURE_ANIMATION_ID = "rbxassetid://2874840706"

local TrailDotIcon = "rbxasset://textures/ui/traildot.png"
local EndWaypointIcon = "rbxasset://textures/ui/waypoint.png"

local WaypointsAlwaysOnTop = false

local WAYPOINT_INCLUDE_FACTOR = 2
local LAST_DOT_DISTANCE = 3

local WAYPOINT_BILLBOARD_SIZE = UDim2.new(0, 1.68 * 25, 0, 2 * 25)

local ENDWAYPOINT_SIZE_OFFSET_MIN = Vector2.new(0, 0.5)
local ENDWAYPOINT_SIZE_OFFSET_MAX = Vector2.new(0, 1)

local FAIL_WAYPOINT_SIZE_OFFSET_CENTER = Vector2.new(0, 0.5)
local FAIL_WAYPOINT_SIZE_OFFSET_LEFT = Vector2.new(0.1, 0.5)
local FAIL_WAYPOINT_SIZE_OFFSET_RIGHT = Vector2.new(-0.1, 0.5)

local FAILURE_TWEEN_LENGTH = 0.125
local FAILURE_TWEEN_COUNT = 4

local TWEEN_WAYPOINT_THRESHOLD = 5

local TRAIL_DOT_PARENT_NAME = "ClickToMoveDisplay"

local TrailDotSize = Vector2.new(1.5, 1.5)

local TRAIL_DOT_MIN_SCALE = 1
local TRAIL_DOT_MIN_DISTANCE = 10
local TRAIL_DOT_MAX_SCALE = 2.5
local TRAIL_DOT_MAX_DISTANCE = 100

local PlayersService = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = PlayersService.LocalPlayer

local function CreateWaypointTemplates()
	local TrailDotTemplate = Instance.new("Part")
	TrailDotTemplate.Size = Vector3.new(1, 1, 1)
	TrailDotTemplate.Anchored = true
	TrailDotTemplate.CanCollide = false
	TrailDotTemplate.Name = "TrailDot"
	TrailDotTemplate.Transparency = 1
	local TrailDotImage = Instance.new("ImageHandleAdornment")
	TrailDotImage.Name = "TrailDotImage"
	TrailDotImage.Size = TrailDotSize
	TrailDotImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	TrailDotImage.AlwaysOnTop = WaypointsAlwaysOnTop
	TrailDotImage.Image = TrailDotIcon
	TrailDotImage.Adornee = TrailDotTemplate
	TrailDotImage.Parent = TrailDotTemplate

	local EndWaypointTemplate = Instance.new("Part")
	EndWaypointTemplate.Size = Vector3.new(2, 2, 2)
	EndWaypointTemplate.Anchored = true
	EndWaypointTemplate.CanCollide = false
	EndWaypointTemplate.Name = "EndWaypoint"
	EndWaypointTemplate.Transparency = 1
	local EndWaypointImage = Instance.new("ImageHandleAdornment")
	EndWaypointImage.Name = "TrailDotImage"
	EndWaypointImage.Size = TrailDotSize
	EndWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	EndWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
	EndWaypointImage.Image = TrailDotIcon
	EndWaypointImage.Adornee = EndWaypointTemplate
	EndWaypointImage.Parent = EndWaypointTemplate
	local EndWaypointBillboard = Instance.new("BillboardGui")
	EndWaypointBillboard.Name = "EndWaypointBillboard"
	EndWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
	EndWaypointBillboard.LightInfluence = 0
	EndWaypointBillboard.SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MIN
	EndWaypointBillboard.AlwaysOnTop = true
	EndWaypointBillboard.Adornee = EndWaypointTemplate
	EndWaypointBillboard.Parent = EndWaypointTemplate
	local EndWaypointImageLabel = Instance.new("ImageLabel")
	EndWaypointImageLabel.Image = EndWaypointIcon
	EndWaypointImageLabel.BackgroundTransparency = 1
	EndWaypointImageLabel.Size = UDim2.new(1, 0, 1, 0)
	EndWaypointImageLabel.Parent = EndWaypointBillboard


	local FailureWaypointTemplate = Instance.new("Part")
	FailureWaypointTemplate.Size = Vector3.new(2, 2, 2)
	FailureWaypointTemplate.Anchored = true
	FailureWaypointTemplate.CanCollide = false
	FailureWaypointTemplate.Name = "FailureWaypoint"
	FailureWaypointTemplate.Transparency = 1
	local FailureWaypointImage = Instance.new("ImageHandleAdornment")
	FailureWaypointImage.Name = "TrailDotImage"
	FailureWaypointImage.Size = TrailDotSize
	FailureWaypointImage.SizeRelativeOffset = Vector3.new(0, 0, -0.1)
	FailureWaypointImage.AlwaysOnTop = WaypointsAlwaysOnTop
	FailureWaypointImage.Image = TrailDotIcon
	FailureWaypointImage.Adornee = FailureWaypointTemplate
	FailureWaypointImage.Parent = FailureWaypointTemplate
	local FailureWaypointBillboard = Instance.new("BillboardGui")
	FailureWaypointBillboard.Name = "FailureWaypointBillboard"
	FailureWaypointBillboard.Size = WAYPOINT_BILLBOARD_SIZE
	FailureWaypointBillboard.LightInfluence = 0
	FailureWaypointBillboard.SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER
	FailureWaypointBillboard.AlwaysOnTop = true
	FailureWaypointBillboard.Adornee = FailureWaypointTemplate
	FailureWaypointBillboard.Parent = FailureWaypointTemplate
	local FailureWaypointFrame = Instance.new("Frame")
	FailureWaypointFrame.BackgroundTransparency = 1
	FailureWaypointFrame.Size = UDim2.new(0, 0, 0, 0)
	FailureWaypointFrame.Position = UDim2.new(0.5, 0, 1, 0)
	FailureWaypointFrame.Parent = FailureWaypointBillboard
	local FailureWaypointImageLabel = Instance.new("ImageLabel")
	FailureWaypointImageLabel.Image = EndWaypointIcon
	FailureWaypointImageLabel.BackgroundTransparency = 1
	FailureWaypointImageLabel.Position = UDim2.new(
		0, -WAYPOINT_BILLBOARD_SIZE.X.Offset/2, 0, -WAYPOINT_BILLBOARD_SIZE.Y.Offset
	)
	FailureWaypointImageLabel.Size = WAYPOINT_BILLBOARD_SIZE
	FailureWaypointImageLabel.Parent = FailureWaypointFrame

	return TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate
end

local TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()

local function getTrailDotParent()
	local camera = Workspace.CurrentCamera
	local trailParent = camera:FindFirstChild(TRAIL_DOT_PARENT_NAME)
	if not trailParent then
		trailParent = Instance.new("Model")
		trailParent.Name = TRAIL_DOT_PARENT_NAME
		trailParent.Parent = camera
	end
	return trailParent
end

local function placePathWaypoint(waypointModel, position: Vector3)
	local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
	local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
		ray,
		{ Workspace.CurrentCamera, LocalPlayer.Character }
	)
	if hitPart then
		waypointModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
		waypointModel.Parent = getTrailDotParent()
	end
end

local TrailDot = {}
TrailDot.__index = TrailDot

function TrailDot:Destroy()
	self.DisplayModel:Destroy()
end

function TrailDot:NewDisplayModel(position)
	local newDisplayModel: Part = TrailDotTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	return newDisplayModel
end

function TrailDot.new(position, closestWaypoint)
	local self = setmetatable({}, TrailDot)

	self.DisplayModel = self:NewDisplayModel(position)
	self.ClosestWayPoint = closestWaypoint

	return self
end

local EndWaypoint = {}
EndWaypoint.__index = EndWaypoint

function EndWaypoint:Destroy()
	self.Destroyed = true
	self.Tween:Cancel()
	self.DisplayModel:Destroy()
end

function EndWaypoint:NewDisplayModel(position)
	local newDisplayModel: Part = EndWaypointTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	return newDisplayModel
end

function EndWaypoint:CreateTween()
	local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, -1, true)
	local tween = TweenService:Create(
		self.DisplayModel.EndWaypointBillboard,
		tweenInfo,
		{ SizeOffset = ENDWAYPOINT_SIZE_OFFSET_MAX }
	)
	tween:Play()
	return tween
end

function EndWaypoint:TweenInFrom(originalPosition: Vector3)
	local currentPositon: Vector3 = self.DisplayModel.Position
	local studsOffset = originalPosition - currentPositon
	self.DisplayModel.EndWaypointBillboard.StudsOffset = Vector3.new(0, studsOffset.Y, 0)
	local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tween = TweenService:Create(
		self.DisplayModel.EndWaypointBillboard,
		tweenInfo,
		{ StudsOffset = Vector3.new(0, 0, 0) }
	)
	tween:Play()
	return tween
end

function EndWaypoint.new(position: Vector3, closestWaypoint: number?, originalPosition: Vector3?)
	local self = setmetatable({}, EndWaypoint)

	self.DisplayModel = self:NewDisplayModel(position)
	self.Destroyed = false
	if originalPosition and (originalPosition - position).Magnitude > TWEEN_WAYPOINT_THRESHOLD then
		self.Tween = self:TweenInFrom(originalPosition)
		coroutine.wrap(function()
			self.Tween.Completed:Wait()
			if not self.Destroyed then
				self.Tween = self:CreateTween()
			end
		end)()
	else
		self.Tween = self:CreateTween()
	end
	self.ClosestWayPoint = closestWaypoint

	return self
end

local FailureWaypoint = {}
FailureWaypoint.__index = FailureWaypoint

function FailureWaypoint:Hide()
	self.DisplayModel.Parent = nil
end

function FailureWaypoint:Destroy()
	self.DisplayModel:Destroy()
end

function FailureWaypoint:NewDisplayModel(position)
	local newDisplayModel: Part = FailureWaypointTemplate:Clone()
	placePathWaypoint(newDisplayModel, position)
	local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
	local hitPart, hitPoint, hitNormal = Workspace:FindPartOnRayWithIgnoreList(
		ray, { Workspace.CurrentCamera, LocalPlayer.Character }
	)
	if hitPart then
		newDisplayModel.CFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
		newDisplayModel.Parent = getTrailDotParent()
	end
	return newDisplayModel
end

function FailureWaypoint:RunFailureTween()
	wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore starting tweening
	-- Tween out from center
	local tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tweenLeft = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
		{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_LEFT })
	tweenLeft:Play()

	local tweenLeftRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
		{ Rotation = 10 })
	tweenLeftRoation:Play()

	tweenLeft.Completed:wait()

	-- Tween back and forth
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
		FAILURE_TWEEN_COUNT - 1, true)
	local tweenSideToSide = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
		{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_RIGHT})
	tweenSideToSide:Play()

	-- Tween flash dark and roate left and right
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH, Enum.EasingStyle.Sine, Enum.EasingDirection.Out,
		FAILURE_TWEEN_COUNT - 1, true)
	local tweenFlash = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame.ImageLabel, tweenInfo,
		{ ImageColor3 = Color3.new(0.75, 0.75, 0.75)})
	tweenFlash:Play()

	local tweenRotate = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
		{ Rotation = -10 })
	tweenRotate:Play()

	tweenSideToSide.Completed:wait()

	-- Tween back to center
	tweenInfo = TweenInfo.new(FAILURE_TWEEN_LENGTH/2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
	local tweenCenter = TweenService:Create(self.DisplayModel.FailureWaypointBillboard, tweenInfo,
		{ SizeOffset = FAIL_WAYPOINT_SIZE_OFFSET_CENTER })
	tweenCenter:Play()

	local tweenRoation = TweenService:Create(self.DisplayModel.FailureWaypointBillboard.Frame, tweenInfo,
		{ Rotation = 0 })
	tweenRoation:Play()

	tweenCenter.Completed:wait()

	wait(FAILURE_TWEEN_LENGTH) -- Delay one tween length betfore removing
end

function FailureWaypoint.new(position)
	local self = setmetatable({}, FailureWaypoint)

	self.DisplayModel = self:NewDisplayModel(position)

	return self
end

local failureAnimation = Instance.new("Animation")
failureAnimation.AnimationId = FAILURE_ANIMATION_ID

local lastHumanoid = nil
local lastFailureAnimationTrack: AnimationTrack? = nil

local function getFailureAnimationTrack(myHumanoid)
	if myHumanoid == lastHumanoid then
		return lastFailureAnimationTrack
	end
	lastFailureAnimationTrack = myHumanoid:LoadAnimation(failureAnimation)
	assert(lastFailureAnimationTrack, "")
	lastFailureAnimationTrack.Priority = Enum.AnimationPriority.Action
	lastFailureAnimationTrack.Looped = false
	return lastFailureAnimationTrack
end

local function findPlayerHumanoid()
	local character = LocalPlayer.Character
	if character then
		return character:FindFirstChildOfClass("Humanoid")
	end
end

local function createTrailDots(wayPoints: {PathWaypoint}, originalEndWaypoint: Vector3)
	local newTrailDots = {}
	local count = 1
	for i = 1, #wayPoints - 1 do
		local closeToEnd = (wayPoints[i].Position - wayPoints[#wayPoints].Position).Magnitude < LAST_DOT_DISTANCE
		local includeWaypoint = i % WAYPOINT_INCLUDE_FACTOR == 0 and not closeToEnd
		if includeWaypoint then
			local trailDot = TrailDot.new(wayPoints[i].Position, i)
			newTrailDots[count] = trailDot
			count = count + 1
		end
	end

	local newEndWaypoint = EndWaypoint.new(wayPoints[#wayPoints].Position, #wayPoints, originalEndWaypoint)
	table.insert(newTrailDots, newEndWaypoint)

	local reversedTrailDots = {}
	count = 1
	for i = #newTrailDots, 1, -1 do
		reversedTrailDots[count] = newTrailDots[i]
		count = count + 1
	end
	return reversedTrailDots
end

local function getTrailDotScale(distanceToCamera: number, defaultSize: Vector2)
	local rangeLength = TRAIL_DOT_MAX_DISTANCE - TRAIL_DOT_MIN_DISTANCE
	local inRangePoint = math.clamp(distanceToCamera - TRAIL_DOT_MIN_DISTANCE, 0, rangeLength)/rangeLength
	local scale = TRAIL_DOT_MIN_SCALE + (TRAIL_DOT_MAX_SCALE - TRAIL_DOT_MIN_SCALE)*inRangePoint
	return defaultSize * scale
end

local createPathCount = 0
-- originalEndWaypoint is optional, causes the waypoint to tween from that position.
function ClickToMoveDisplay.CreatePathDisplay(wayPoints, originalEndWaypoint)
	createPathCount = createPathCount + 1
	local trailDots = createTrailDots(wayPoints, originalEndWaypoint)

	local function removePathBeforePoint(wayPointNumber)
		-- kill all trailDots before and at wayPointNumber
		for i = #trailDots, 1, -1 do
			local trailDot = trailDots[i]
			if trailDot.ClosestWayPoint <= wayPointNumber then
				trailDot:Destroy()
				trailDots[i] = nil
			else
				break
			end
		end
	end

	local reiszeTrailDotsUpdateName = "ClickToMoveResizeTrail" ..createPathCount
	local function resizeTrailDots()
		if #trailDots == 0 then
			RunService:UnbindFromRenderStep(reiszeTrailDotsUpdateName)
			return
		end
		local cameraPos = Workspace.CurrentCamera.CFrame.p
		for i = 1, #trailDots do
			local trailDotImage: ImageHandleAdornment = trailDots[i].DisplayModel:FindFirstChild("TrailDotImage")
			if trailDotImage then
				local distanceToCamera = (trailDots[i].DisplayModel.Position - cameraPos).Magnitude
				trailDotImage.Size = getTrailDotScale(distanceToCamera, TrailDotSize)
			end
		end
	end
	RunService:BindToRenderStep(reiszeTrailDotsUpdateName, Enum.RenderPriority.Camera.Value - 1, resizeTrailDots)

	local function removePath()
		removePathBeforePoint(#wayPoints)
	end

	return removePath, removePathBeforePoint
end

local lastFailureWaypoint = nil
function ClickToMoveDisplay.DisplayFailureWaypoint(position)
	if lastFailureWaypoint then
		lastFailureWaypoint:Hide()
	end
	local failureWaypoint = FailureWaypoint.new(position)
	lastFailureWaypoint = failureWaypoint
	coroutine.wrap(function()
		failureWaypoint:RunFailureTween()
		failureWaypoint:Destroy()
		failureWaypoint = nil
	end)()
end

function ClickToMoveDisplay.CreateEndWaypoint(position)
	return EndWaypoint.new(position)
end

function ClickToMoveDisplay.PlayFailureAnimation()
	local myHumanoid = findPlayerHumanoid()
	if myHumanoid then
		local animationTrack = getFailureAnimationTrack(myHumanoid)
		animationTrack:Play()
	end
end

function ClickToMoveDisplay.CancelFailureAnimation()
	if lastFailureAnimationTrack ~= nil and lastFailureAnimationTrack.IsPlaying then
		lastFailureAnimationTrack:Stop()
	end
end

function ClickToMoveDisplay.SetWaypointTexture(texture)
	TrailDotIcon = texture
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end

function ClickToMoveDisplay.GetWaypointTexture()
	return TrailDotIcon
end

function ClickToMoveDisplay.SetWaypointRadius(radius)
	TrailDotSize = Vector2.new(radius, radius)
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end

function ClickToMoveDisplay.GetWaypointRadius()
	return TrailDotSize.X
end

function ClickToMoveDisplay.SetEndWaypointTexture(texture)
	EndWaypointIcon = texture
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end

function ClickToMoveDisplay.GetEndWaypointTexture()
	return EndWaypointIcon
end

function ClickToMoveDisplay.SetWaypointsAlwaysOnTop(alwaysOnTop)
	WaypointsAlwaysOnTop = alwaysOnTop
	TrailDotTemplate, EndWaypointTemplate, FailureWaypointTemplate = CreateWaypointTemplates()
end

function ClickToMoveDisplay.GetWaypointsAlwaysOnTop()
	return WaypointsAlwaysOnTop
end

return ClickToMoveDisplay
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b0</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXCD43FB380B1C4835B337F954661C5368">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CameraModule</string>
						<string name="ScriptGuid">{77C27DD6-EAE1-4B2B-B61E-FB63CED2887E}</string>
						<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	CameraModule - This ModuleScript implements a singleton class to manage the
	selection, activation, and deactivation of the current camera controller,
	character occlusion controller, and transparency controller. This script binds to
	RenderStepped at Camera priority and calls the Update() methods on the active
	controller instances.

	The camera controller ModuleScripts implement classes which are instantiated and
	activated as-needed, they are no longer all instantiated up front as they were in
	the previous generation of PlayerScripts.

	2018 PlayerScripts Update - AllYourBlox
--]]

local CameraModule = {}
CameraModule.__index = CameraModule

-- NOTICE: Player property names do not all match their StarterPlayer equivalents,
-- with the differences noted in the comments on the right
local PLAYER_CAMERA_PROPERTIES =
{
	"CameraMinZoomDistance",
	"CameraMaxZoomDistance",
	"CameraMode",
	"DevCameraOcclusionMode",
	"DevComputerCameraMode",			-- Corresponds to StarterPlayer.DevComputerCameraMovementMode
	"DevTouchCameraMode",				-- Corresponds to StarterPlayer.DevTouchCameraMovementMode

	-- Character movement mode
	"DevComputerMovementMode",
	"DevTouchMovementMode",
	"DevEnableMouseLock",				-- Corresponds to StarterPlayer.EnableMouseLockOption
}

local USER_GAME_SETTINGS_PROPERTIES =
{
	"ComputerCameraMovementMode",
	"ComputerMovementMode",
	"ControlMode",
	"GamepadCameraSensitivity",
	"MouseSensitivity",
	"RotationType",
	"TouchCameraMovementMode",
	"TouchMovementMode",
}

--[[ Roblox Services ]]--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

-- Static camera utils
local CameraUtils = require(script:WaitForChild("CameraUtils"))
local CameraInput = require(script:WaitForChild("CameraInput"))

-- Load Roblox Camera Controller Modules
local ClassicCamera = require(script:WaitForChild("ClassicCamera"))
local OrbitalCamera = require(script:WaitForChild("OrbitalCamera"))
local LegacyCamera = require(script:WaitForChild("LegacyCamera"))
local VehicleCamera = require(script:WaitForChild("VehicleCamera"))
-- New VR System Modules
local VRCamera = require(script:WaitForChild("VRCamera"))
local VRVehicleCamera = require(script:WaitForChild("VRVehicleCamera"))

-- Load Roblox Occlusion Modules
local Invisicam = require(script:WaitForChild("Invisicam"))
local Poppercam = require(script:WaitForChild("Poppercam"))

-- Load the near-field character transparency controller and the mouse lock "shift lock" controller
local TransparencyController = require(script:WaitForChild("TransparencyController"))
local MouseLockController = require(script:WaitForChild("MouseLockController"))

-- Table of camera controllers that have been instantiated. They are instantiated as they are used.
local instantiatedCameraControllers = {}
local instantiatedOcclusionModules = {}

-- Management of which options appear on the Roblox User Settings screen
do
	local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")

	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)

	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.CameraToggle)
end


function CameraModule.new()
	local self = setmetatable({},CameraModule)

	-- Current active controller instances
	self.activeCameraController = nil
	self.activeOcclusionModule = nil
	self.activeTransparencyController = nil
	self.activeMouseLockController = nil

	self.currentComputerCameraMovementMode = nil

	-- Connections to events
	self.cameraSubjectChangedConn = nil
	self.cameraTypeChangedConn = nil

	-- Adds CharacterAdded and CharacterRemoving event handlers for all current players
	for _,player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end

	-- Adds CharacterAdded and CharacterRemoving event handlers for all players who join in the future
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)

	self.activeTransparencyController = TransparencyController.new()
	self.activeTransparencyController:Enable(true)

	if not UserInputService.TouchEnabled then
		self.activeMouseLockController = MouseLockController.new()
		local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
		if toggleEvent then
			toggleEvent:Connect(function()
				self:OnMouseLockToggled()
			end)
		end
	end

	self:ActivateCameraController(self:GetCameraControlChoice())
	self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	self:OnCurrentCameraChanged() -- Does initializations and makes first camera controller
	RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt) self:Update(dt) end)

	-- Connect listeners to camera-related properties
	for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
		Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnLocalPlayerCameraPropertyChanged(propertyName)
		end)
	end

	for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
		UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnUserGameSettingsPropertyChanged(propertyName)
		end)
	end
	game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)

	return self
end

function CameraModule:GetCameraMovementModeFromSettings()
	local cameraMode = Players.LocalPlayer.CameraMode

	-- Lock First Person trumps all other settings and forces ClassicCamera
	if cameraMode == Enum.CameraMode.LockFirstPerson then
		return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
	end

	local devMode, userMode
	if UserInputService.TouchEnabled then
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
	else
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
	end

	if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
		-- Developer is allowing user choice, so user setting is respected
		return userMode
	end

	return devMode
end

function CameraModule:ActivateOcclusionModule(occlusionMode: Enum.DevCameraOcclusionMode)
	local newModuleCreator
	if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
		newModuleCreator = Poppercam
	elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		newModuleCreator = Invisicam
	else
		warn("CameraScript ActivateOcclusionModule called with unsupported mode")
		return
	end

	self.occlusionMode = occlusionMode

	-- First check to see if there is actually a change. If the module being requested is already
	-- the currently-active solution then just make sure it's enabled and exit early
	if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
		if not self.activeOcclusionModule:GetEnabled() then
			self.activeOcclusionModule:Enable(true)
		end
		return
	end

	-- Save a reference to the current active module (may be nil) so that we can disable it if
	-- we are successful in activating its replacement
	local prevOcclusionModule = self.activeOcclusionModule

	-- If there is no active module, see if the one we need has already been instantiated
	self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]

	-- If the module was not already instantiated and selected above, instantiate it
	if not self.activeOcclusionModule then
		self.activeOcclusionModule = newModuleCreator.new()
		if self.activeOcclusionModule then
			instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
		end
	end

	-- If we were successful in either selecting or instantiating the module,
	-- enable it if it's not already the currently-active enabled module
	if self.activeOcclusionModule then
		local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
		-- Sanity check that the module we selected or instantiated actually supports the desired occlusionMode
		if newModuleOcclusionMode ~= occlusionMode then
			warn("CameraScript ActivateOcclusionModule mismatch: ",self.activeOcclusionModule:GetOcclusionMode(),"~=",occlusionMode)
		end

		-- Deactivate current module if there is one
		if prevOcclusionModule then
			-- Sanity check that current module is not being replaced by itself (that should have been handled above)
			if prevOcclusionModule ~= self.activeOcclusionModule then
				prevOcclusionModule:Enable(false)
			else
				warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
			end
		end

		-- Occlusion modules need to be initialized with information about characters and cameraSubject
		-- Invisicam needs the LocalPlayer's character
		-- Poppercam needs all player characters and the camera subject
		if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			-- Optimization to only send Invisicam what we know it needs
			if Players.LocalPlayer.Character then
				self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer )
			end
		else
			-- When Poppercam is enabled, we send it all existing player characters for its raycast ignore list
			for _, player in pairs(Players:GetPlayers()) do
				if player and player.Character then
					self.activeOcclusionModule:CharacterAdded(player.Character, player)
				end
			end
			self.activeOcclusionModule:OnCameraSubjectChanged((game.Workspace.CurrentCamera :: Camera).CameraSubject)
		end

		-- Activate new choice
		self.activeOcclusionModule:Enable(true)
	end
end

function CameraModule:ShouldUseVehicleCamera()
	local camera = workspace.CurrentCamera
	if not camera then
		return false
	end

	local cameraType = camera.CameraType
	local cameraSubject = camera.CameraSubject

	local isEligibleType = cameraType == Enum.CameraType.Custom or cameraType == Enum.CameraType.Follow
	local isEligibleSubject = cameraSubject and cameraSubject:IsA("VehicleSeat") or false
	local isEligibleOcclusionMode = self.occlusionMode ~= Enum.DevCameraOcclusionMode.Invisicam

	return isEligibleSubject and isEligibleType and isEligibleOcclusionMode
end

-- When supplied, legacyCameraType is used and cameraMovementMode is ignored (should be nil anyways)
-- Next, if userCameraCreator is passed in, that is used as the cameraCreator
function CameraModule:ActivateCameraController(cameraMovementMode, legacyCameraType: Enum.CameraType?)
	local newCameraCreator = nil

	if legacyCameraType~=nil then
		--[[
			This function has been passed a CameraType enum value. Some of these map to the use of
			the LegacyCamera module, the value "Custom" will be translated to a movementMode enum
			value based on Dev and User settings, and "Scriptable" will disable the camera controller.
		--]]

		if legacyCameraType == Enum.CameraType.Scriptable then
			if self.activeCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = nil
			end
			return

		elseif legacyCameraType == Enum.CameraType.Custom then
			cameraMovementMode = self:GetCameraMovementModeFromSettings()

		elseif legacyCameraType == Enum.CameraType.Track then
			-- Note: The TrackCamera module was basically an older, less fully-featured
			-- version of ClassicCamera, no longer actively maintained, but it is re-implemented in
			-- case a game was dependent on its lack of ClassicCamera's extra functionality.
			cameraMovementMode = Enum.ComputerCameraMovementMode.Classic

		elseif legacyCameraType == Enum.CameraType.Follow then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Follow

		elseif legacyCameraType == Enum.CameraType.Orbital then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital

		elseif legacyCameraType == Enum.CameraType.Attach or
			   legacyCameraType == Enum.CameraType.Watch or
			   legacyCameraType == Enum.CameraType.Fixed then
			newCameraCreator = LegacyCamera
		else
			warn("CameraScript encountered an unhandled Camera.CameraType value: ",legacyCameraType)
		end
	end

	if not newCameraCreator then
		if VRService.VREnabled then
			newCameraCreator = VRCamera
		elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or
			cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or
			cameraMovementMode == Enum.ComputerCameraMovementMode.Default or
			cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle then
			newCameraCreator = ClassicCamera
		elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
			newCameraCreator = OrbitalCamera
		else
			warn("ActivateCameraController did not select a module.")
			return
		end
	end

	local isVehicleCamera = self:ShouldUseVehicleCamera()
	if isVehicleCamera then
		if VRService.VREnabled then
			newCameraCreator = VRVehicleCamera
		else
			newCameraCreator = VehicleCamera
		end
	end

	-- Create the camera control module we need if it does not already exist in instantiatedCameraControllers
	local newCameraController
	if not instantiatedCameraControllers[newCameraCreator] then
		newCameraController = newCameraCreator.new()
		instantiatedCameraControllers[newCameraCreator] = newCameraController
	else
		newCameraController = instantiatedCameraControllers[newCameraCreator]
		if newCameraController.Reset then
			newCameraController:Reset()
		end
	end

	if self.activeCameraController then
		-- deactivate the old controller and activate the new one
		if self.activeCameraController ~= newCameraController then
			self.activeCameraController:Enable(false)
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)
		elseif not self.activeCameraController:GetEnabled() then
			self.activeCameraController:Enable(true)
		end
	elseif newCameraController ~= nil then
		-- only activate the new controller
		self.activeCameraController = newCameraController
		self.activeCameraController:Enable(true)
	end

	if self.activeCameraController then
		if cameraMovementMode~=nil then
			self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
		elseif legacyCameraType~=nil then
			-- Note that this is only called when legacyCameraType is not a type that
			-- was convertible to a ComputerCameraMovementMode value, i.e. really only applies to LegacyCamera
			self.activeCameraController:SetCameraType(legacyCameraType)
		end
	end
end

-- Note: The active transparency controller could be made to listen for this event itself.
function CameraModule:OnCameraSubjectChanged()
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if self.activeTransparencyController then
		self.activeTransparencyController:SetSubject(cameraSubject)
	end

	if self.activeOcclusionModule then
		self.activeOcclusionModule:OnCameraSubjectChanged(cameraSubject)
	end

	self:ActivateCameraController(nil, camera.CameraType)
end

function CameraModule:OnCameraTypeChanged(newCameraType: Enum.CameraType)
	if newCameraType == Enum.CameraType.Scriptable then
		if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			CameraUtils.restoreMouseBehavior()
		end
	end

	-- Forward the change to ActivateCameraController to handle
	self:ActivateCameraController(nil, newCameraType)
end

-- Note: Called whenever workspace.CurrentCamera changes, but also on initialization of this script
function CameraModule:OnCurrentCameraChanged()
	local currentCamera = game.Workspace.CurrentCamera
	if not currentCamera then return end

	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
	end

	if self.cameraTypeChangedConn then
		self.cameraTypeChangedConn:Disconnect()
	end

	self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	end)

	self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end)

	self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	self:OnCameraTypeChanged(currentCamera.CameraType)
end

function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName: string)
	if propertyName == "CameraMode" then
		-- CameraMode is only used to turn on/off forcing the player into first person view. The
		-- Note: The case "Classic" is used for all other views and does not correspond only to the ClassicCamera module
		if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
			-- Locked in first person, use ClassicCamera which supports this
			if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
			end

			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
			-- Not locked in first person view
			local cameraMovementMode = self:GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		else
			warn("Unhandled value for property player.CameraMode: ",Players.LocalPlayer.CameraMode)
		end

	elseif propertyName == "DevComputerCameraMode" or
		   propertyName == "DevTouchCameraMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))

	elseif propertyName == "DevCameraOcclusionMode" then
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)

	elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
		if self.activeCameraController then
			self.activeCameraController:UpdateForDistancePropertyChange()
		end
	elseif propertyName == "DevTouchMovementMode" then
	elseif propertyName == "DevComputerMovementMode" then
	elseif propertyName == "DevEnableMouseLock" then
		-- This is the enabling/disabling of "Shift Lock" mode, not LockFirstPerson (which is a CameraMode)
		-- Note: Enabling and disabling of MouseLock mode is normally only a publish-time choice made via
		-- the corresponding EnableMouseLockOption checkbox of StarterPlayer, and this script does not have
		-- support for changing the availability of MouseLock at runtime (this would require listening to
		-- Player.DevEnableMouseLock changes)
	end
end

function CameraModule:OnUserGameSettingsPropertyChanged(propertyName: string)
	if propertyName == "ComputerCameraMovementMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	end
end

--[[
	Main RenderStep Update. The camera controller and occlusion module both have opportunities
	to set and modify (respectively) the CFrame and Focus before it is set once on CurrentCamera.
	The camera and occlusion modules should only return CFrames, not set the CFrame property of
	CurrentCamera directly.
--]]
function CameraModule:Update(dt)	
	if self.activeCameraController then
		self.activeCameraController:UpdateMouseBehavior()

		local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)

		if self.activeOcclusionModule then
			newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
		end

		-- Here is where the new CFrame and Focus are set for this render frame
		local currentCamera = game.Workspace.CurrentCamera :: Camera
		currentCamera.CFrame = newCameraCFrame
		currentCamera.Focus = newCameraFocus

		-- Update to character local transparency as needed based on camera-to-subject distance
		if self.activeTransparencyController then
			self.activeTransparencyController:Update(dt)
		end

		if CameraInput.getInputEnabled() then
			CameraInput.resetInputForFrameEnd()
		end
	end
end

-- Formerly getCurrentCameraMode, this function resolves developer and user camera control settings to
-- decide which camera control module should be instantiated. The old method of converting redundant enum types
function CameraModule:GetCameraControlChoice()
	local player = Players.LocalPlayer

	if player then
		if UserInputService:GetLastInputType() == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
			-- Touch
			if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
				return CameraUtils.ConvertCameraModeEnumToStandard( UserGameSettings.TouchCameraMovementMode )
			else
				return CameraUtils.ConvertCameraModeEnumToStandard( player.DevTouchCameraMode )
			end
		else
			-- Computer
			if player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
				local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
				return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
			else
				return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
			end
		end
	end
end

function CameraModule:OnCharacterAdded(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterAdded(char, player)
	end
end

function CameraModule:OnCharacterRemoving(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterRemoving(char, player)
	end
end

function CameraModule:OnPlayerAdded(player)
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char, player)
	end)
	player.CharacterRemoving:Connect(function(char)
		self:OnCharacterRemoving(char, player)
	end)
end

function CameraModule:OnMouseLockToggled()
	if self.activeMouseLockController then
		local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
		local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
		if self.activeCameraController then
			self.activeCameraController:SetIsMouseLocked(mouseLocked)
			self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
		end
	end
end

local cameraModuleObject = CameraModule.new()

return {}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b1</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX2B22FAE35BB8479E994CDC6A735452DF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TransparencyController</string>
							<string name="ScriptGuid">{4FAB49C0-B98A-47B0-985D-40E30F843498}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	TransparencyController - Manages transparency of player character at close camera-to-subject distances
	2018 Camera Update - AllYourBlox
--]]
local MAX_TWEEN_RATE = 2.8 -- per second

local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ The Module ]]--
local TransparencyController = {}
TransparencyController.__index = TransparencyController

function TransparencyController.new()
	local self = setmetatable({}, TransparencyController)

	self.transparencyDirty = false
	self.enabled = false
	self.lastTransparency = nil

	self.descendantAddedConn, self.descendantRemovingConn = nil, nil
	self.toolDescendantAddedConns = {}
	self.toolDescendantRemovingConns = {}
	self.cachedParts = {}

	return self
end


function TransparencyController:HasToolAncestor(object: Instance)
	if object.Parent == nil then return false end
	assert(object.Parent, "")
	return object.Parent:IsA('Tool') or self:HasToolAncestor(object.Parent)
end

function TransparencyController:IsValidPartToModify(part: BasePart)
	if part:IsA('BasePart') or part:IsA('Decal') then
		return not self:HasToolAncestor(part)
	end
	return false
end

function TransparencyController:CachePartsRecursive(object)
	if object then
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		end
		for _, child in pairs(object:GetChildren()) do
			self:CachePartsRecursive(child)
		end
	end
end

function TransparencyController:TeardownTransparency()
	for child, _ in pairs(self.cachedParts) do
		child.LocalTransparencyModifier = 0
	end
	self.cachedParts = {}
	self.transparencyDirty = true
	self.lastTransparency = nil

	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
		self.descendantAddedConn = nil
	end
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
		self.descendantRemovingConn = nil
	end
	for object, conn in pairs(self.toolDescendantAddedConns) do
		conn:Disconnect()
		self.toolDescendantAddedConns[object] = nil
	end
	for object, conn in pairs(self.toolDescendantRemovingConns) do
		conn:Disconnect()
		self.toolDescendantRemovingConns[object] = nil
	end
end

function TransparencyController:SetupTransparency(character)
	self:TeardownTransparency()

	if self.descendantAddedConn then self.descendantAddedConn:disconnect() end
	self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
		-- This is a part we want to invisify
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		-- There is now a tool under the character
		elseif object:IsA('Tool') then
			if self.toolDescendantAddedConns[object] then self.toolDescendantAddedConns[object]:Disconnect() end
			self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
				self.cachedParts[toolChild] = nil
				if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
					-- Reset the transparency
					toolChild.LocalTransparencyModifier = 0
				end
			end)
			if self.toolDescendantRemovingConns[object] then self.toolDescendantRemovingConns[object]:disconnect() end
			self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
				wait() -- wait for new parent
				if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
					if self:IsValidPartToModify(formerToolChild) then
						self.cachedParts[formerToolChild] = true
						self.transparencyDirty = true
					end
				end
			end)
		end
	end)
	if self.descendantRemovingConn then self.descendantRemovingConn:disconnect() end
	self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
		if self.cachedParts[object] then
			self.cachedParts[object] = nil
			-- Reset the transparency
			object.LocalTransparencyModifier = 0
		end
	end)
	self:CachePartsRecursive(character)
end


function TransparencyController:Enable(enable: boolean)
	if self.enabled ~= enable then
		self.enabled = enable
	end
end

function TransparencyController:SetSubject(subject)
	local character = nil
	if subject and subject:IsA("Humanoid") then
		character = subject.Parent
	end
	if subject and subject:IsA("VehicleSeat") and subject.Occupant then
		character = subject.Occupant.Parent
	end
	if character then
		self:SetupTransparency(character)
	else
		self:TeardownTransparency()
	end
end

function TransparencyController:Update(dt)
	local currentCamera = workspace.CurrentCamera

	if currentCamera and self.enabled then
		-- calculate goal transparency based on distance
		local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
		local transparency = (distance<2) and (1.0-(distance-0.5)/1.5) or 0 -- (7 - distance) / 5
		if transparency < 0.5 then -- too far, don't control transparency
			transparency = 0
		end

		-- tween transparency if the goal is not fully transparent and the subject was not fully transparent last frame
		if self.lastTransparency and transparency < 1 and self.lastTransparency < 0.95 then
			local deltaTransparency = transparency - self.lastTransparency
			local maxDelta = MAX_TWEEN_RATE * dt
			deltaTransparency = math.clamp(deltaTransparency, -maxDelta, maxDelta)
			transparency = self.lastTransparency + deltaTransparency
		else
			self.transparencyDirty = true
		end

		transparency = math.clamp(Util.Round(transparency, 2), 0, 1)

		-- update transparencies 
		if self.transparencyDirty or self.lastTransparency ~= transparency then
			for child, _ in pairs(self.cachedParts) do
				child.LocalTransparencyModifier = transparency
			end
			self.transparencyDirty = false
			self.lastTransparency = transparency
		end
	end
end

return TransparencyController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b2</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX86D0B7554A7247CCB682B5B7EF75300D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VehicleCamera</string>
							<string name="ScriptGuid">{64E2E50A-D961-41CC-AED9-3A88A05650AA}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
local EPSILON = 1e-3
local PITCH_LIMIT = math.rad(80)
local YAW_DEFAULT = math.rad(0)
local ZOOM_MINIMUM = 0.5
local ZOOM_SENSITIVITY_CURVATURE = 0.5

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
local CameraUtils = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local VehicleCameraCore = require(script:WaitForChild("VehicleCameraCore"))
local VehicleCameraConfig = require(script:WaitForChild("VehicleCameraConfig"))

local localPlayer = Players.LocalPlayer

local map = CameraUtils.map
local Spring = CameraUtils.Spring
local mapClamp = CameraUtils.mapClamp
local sanitizeAngle = CameraUtils.sanitizeAngle

-- pitch-axis rotational velocity of a part with a given CFrame and total RotVelocity
local function pitchVelocity(rotVel, cf)
	return math.abs(cf.XVector:Dot(rotVel))
end

-- yaw-axis rotational velocity of a part with a given CFrame and total RotVelocity
local function yawVelocity(rotVel, cf)
	return math.abs(cf.YVector:Dot(rotVel))
end

-- track physics solver time delta separately from the render loop to correctly synchronize time delta
local worldDt = 1/60
RunService.Stepped:Connect(function(_, _worldDt)
	worldDt = _worldDt
end)

local VehicleCamera = setmetatable({}, BaseCamera)
VehicleCamera.__index = VehicleCamera

function VehicleCamera.new()
	local self = setmetatable(BaseCamera.new(), VehicleCamera)
	self:Reset()
	return self
end

function VehicleCamera:Reset()
	self.vehicleCameraCore = VehicleCameraCore.new(self:GetSubjectCFrame())
	self.pitchSpring = Spring.new(0, -math.rad(VehicleCameraConfig.pitchBaseAngle))
	self.yawSpring = Spring.new(0, YAW_DEFAULT)
	self.lastPanTick = 0
	
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	
	assert(camera)
	assert(cameraSubject)
	assert(cameraSubject:IsA("VehicleSeat"))
	
	local assemblyParts = cameraSubject:GetConnectedParts(true) -- passing true to recursively get all assembly parts
	local assemblyPosition, assemblyRadius = CameraUtils.getLooseBoundingSphere(assemblyParts)
	
	assemblyRadius = math.max(assemblyRadius, EPSILON)
	
	self.assemblyRadius = assemblyRadius
	self.assemblyOffset = cameraSubject.CFrame:Inverse()*assemblyPosition -- seat-space offset of the assembly bounding sphere center
	
	self:_StepInitialZoom()
end

function VehicleCamera:_StepInitialZoom()
	self:SetCameraToSubjectDistance(math.max(
		ZoomController.GetZoomRadius(),
		self.assemblyRadius*VehicleCameraConfig.initialZoomRadiusMul
	))
end

function VehicleCamera:_StepRotation(dt, vdotz): CFrame
	local yawSpring = self.yawSpring
	local pitchSpring = self.pitchSpring
	
	local rotationInput = CameraInput.getRotation(true)
	local dYaw = -rotationInput.X
	local dPitch = -rotationInput.Y
	
	yawSpring.pos = sanitizeAngle(yawSpring.pos + dYaw)
	pitchSpring.pos = sanitizeAngle(math.clamp(pitchSpring.pos + dPitch, -PITCH_LIMIT, PITCH_LIMIT))

	if CameraInput.getRotationActivated() then
		self.lastPanTick = os.clock()
	end

	local pitchBaseAngle = -math.rad(VehicleCameraConfig.pitchBaseAngle)
	local pitchDeadzoneAngle = math.rad(VehicleCameraConfig.pitchDeadzoneAngle)

	if os.clock() - self.lastPanTick > VehicleCameraConfig.autocorrectDelay then
		-- adjust autocorrect response based on forward velocity
		local autocorrectResponse = mapClamp(
			vdotz,
			VehicleCameraConfig.autocorrectMinCarSpeed,
			VehicleCameraConfig.autocorrectMaxCarSpeed,
			0,
			VehicleCameraConfig.autocorrectResponse
		)

		yawSpring.freq = autocorrectResponse
		pitchSpring.freq = autocorrectResponse
		
		-- zero out response under a threshold
		if yawSpring.freq < EPSILON then
			yawSpring.vel = 0
		end

		if pitchSpring.freq < EPSILON then
			pitchSpring.vel = 0
		end

		if math.abs(sanitizeAngle(pitchBaseAngle - pitchSpring.pos)) <= pitchDeadzoneAngle then
			-- do nothing within the deadzone
			pitchSpring.goal = pitchSpring.pos
		else
			pitchSpring.goal = pitchBaseAngle
		end
	else
		yawSpring.freq = 0
		yawSpring.vel = 0

		pitchSpring.freq = 0
		pitchSpring.vel = 0

		pitchSpring.goal = pitchBaseAngle
	end

	return CFrame.fromEulerAnglesYXZ(
		pitchSpring:step(dt),
		yawSpring:step(dt),
		0
	)
end

function VehicleCamera:_GetThirdPersonLocalOffset()
	return self.assemblyOffset + Vector3.new(0, self.assemblyRadius*VehicleCameraConfig.verticalCenterOffset, 0)
end

function VehicleCamera:_GetFirstPersonLocalOffset(subjectCFrame: CFrame)
	local character = localPlayer.Character
	
	if character and character.Parent then
		local head = character:FindFirstChild("Head")
		
		if head and head:IsA("BasePart") then
			return subjectCFrame:Inverse()*head.Position
		end
	end
	
	return self:_GetThirdPersonLocalOffset()
end

function VehicleCamera:Update()
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	local vehicleCameraCore = self.vehicleCameraCore
	
	assert(camera)
	assert(cameraSubject)
	assert(cameraSubject:IsA("VehicleSeat"))
	
	-- consume the physics solver time delta to account for mismatched physics/render cycles
	local dt = worldDt
	worldDt = 0
	
	-- get subject info
	local subjectCFrame: CFrame = self:GetSubjectCFrame()
	local subjectVel: Vector3 = self:GetSubjectVelocity()
	local subjectRotVel = self:GetSubjectRotVelocity()
	
	-- measure the local-to-world-space forward velocity of the vehicle
	local vDotZ = math.abs(subjectVel:Dot(subjectCFrame.ZVector))
	local yawVel = yawVelocity(subjectRotVel, subjectCFrame)
	local pitchVel = pitchVelocity(subjectRotVel, subjectCFrame)
	
	-- step camera components forward
	local zoom = self:StepZoom()
	local objectRotation = self:_StepRotation(dt, vDotZ)
	
	-- mix third and first person offsets in local space
	local firstPerson = mapClamp(zoom, ZOOM_MINIMUM, self.assemblyRadius, 1, 0)
	
	local tpOffset = self:_GetThirdPersonLocalOffset()
	local fpOffset = self:_GetFirstPersonLocalOffset(subjectCFrame)
	local localOffset = tpOffset:Lerp(fpOffset, firstPerson)
	
	-- step core forward
	vehicleCameraCore:setTransform(subjectCFrame)
	local processedRotation = vehicleCameraCore:step(dt, pitchVel, yawVel, firstPerson)
	
	-- calculate final focus & cframe
	local focus = CFrame.new(subjectCFrame*localOffset)*processedRotation*objectRotation
	local cf = focus*CFrame.new(0, 0, zoom)

	return cf, focus
end

function VehicleCamera:ApplyVRTransform()
	-- no-op override; VR transform is not applied in vehicles
end

function VehicleCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end

function VehicleCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end

return VehicleCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b3</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX9208CDC28BF24EF6ABA66967FD9BB2AB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VehicleCameraCore</string>
								<string name="ScriptGuid">{22D65B2A-F52A-494F-8BA6-4F8CDA11DF47}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
local CameraUtils = require(script.Parent.Parent.CameraUtils)
local VehicleCameraConfig = require(script.Parent.VehicleCameraConfig)

local map = CameraUtils.map
local mapClamp = CameraUtils.mapClamp
local sanitizeAngle = CameraUtils.sanitizeAngle

-- extract sanitized yaw from a CFrame rotation
local function getYaw(cf)
	local _, yaw = cf:toEulerAnglesYXZ()
	return sanitizeAngle(yaw)
end

-- extract sanitized pitch from a CFrame rotation
local function getPitch(cf)
	local pitch = cf:toEulerAnglesYXZ()
	return sanitizeAngle(pitch)
end

-- step a damped angular spring axis
local function stepSpringAxis(dt, f, g, p, v)
	local offset = sanitizeAngle(p - g)
	local decay = math.exp(-f*dt)

	local p1 = sanitizeAngle((offset*(1 + f*dt) + v*dt)*decay + g)
	local v1 = (v*(1 - f*dt) - offset*(f*f*dt))*decay

	return p1, v1
end

-- value damper with separate response frequencies for rising and falling values
local VariableEdgeSpring = {} do
	VariableEdgeSpring.__index = VariableEdgeSpring

	function VariableEdgeSpring.new(fRising, fFalling, position)
		return setmetatable({
			fRising = fRising,
			fFalling = fFalling,
			g = position,
			p = position,
			v = position*0,
		}, VariableEdgeSpring)
	end

	function VariableEdgeSpring:step(dt)
		local fRising = self.fRising
		local fFalling = self.fFalling
		local g = self.g
		local p0 = self.p
		local v0 = self.v

		local f = 2*math.pi*(v0 > 0 and fRising or fFalling)

		local offset = p0 - g
		local decay = math.exp(-f*dt)

		local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
		local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay

		self.p = p1
		self.v = v1

		return p1
	end
end

-- damps a 3D rotation in Tait-Bryan YXZ space, filtering out Z
local YawPitchSpring = {} do
	YawPitchSpring.__index = YawPitchSpring

	function YawPitchSpring.new(cf)
		assert(typeof(cf) == "CFrame")
		
		return setmetatable({
			yawG = getYaw(cf), -- yaw goal
			yawP = getYaw(cf), -- yaw position
			yawV = 0, -- yaw velocity

			pitchG = getPitch(cf), -- pitch goal
			pitchP = getPitch(cf), -- pitch position
			pitchV = 0, -- pitch velocity

			-- yaw/pitch response springs
			fSpringYaw = VariableEdgeSpring.new(
				VehicleCameraConfig.yawReponseDampingRising,
				VehicleCameraConfig.yawResponseDampingFalling,
				0
			),
			fSpringPitch = VariableEdgeSpring.new(
				VehicleCameraConfig.pitchReponseDampingRising,
				VehicleCameraConfig.pitchResponseDampingFalling,
				0
			),
		}, YawPitchSpring)
	end
	
	-- Extract Tait-Bryan angles from a CFrame rotation
	function YawPitchSpring:setGoal(goalCFrame)
		assert(typeof(goalCFrame) == "CFrame")
		
		self.yawG = getYaw(goalCFrame)
		self.pitchG = getPitch(goalCFrame)
	end

	function YawPitchSpring:getCFrame()
		return CFrame.fromEulerAnglesYXZ(self.pitchP, self.yawP, 0)
	end

	function YawPitchSpring:step(dt, pitchVel, yawVel, firstPerson)
		assert(typeof(dt) == "number")
		assert(typeof(yawVel) == "number")
		assert(typeof(pitchVel) == "number")
		assert(typeof(firstPerson) == "number")
		
		local fSpringYaw = self.fSpringYaw
		local fSpringPitch = self.fSpringPitch
		
		-- calculate the frequency spring
		fSpringYaw.g = mapClamp(
			map(firstPerson, 0, 1, yawVel, 0),
			math.rad(VehicleCameraConfig.cutoffMinAngularVelYaw),
			math.rad(VehicleCameraConfig.cutoffMaxAngularVelYaw),
			1, 0
		)

		fSpringPitch.g = mapClamp(
			map(firstPerson, 0, 1, pitchVel, 0),
			math.rad(VehicleCameraConfig.cutoffMinAngularVelPitch),
			math.rad(VehicleCameraConfig.cutoffMaxAngularVelPitch),
			1, 0
		)
		
		-- calculate final frequencies
		local fYaw = 2*math.pi*VehicleCameraConfig.yawStiffness*fSpringYaw:step(dt)
		local fPitch = 2*math.pi*VehicleCameraConfig.pitchStiffness*fSpringPitch:step(dt)
		
		-- adjust response for first person
		fPitch *= map(firstPerson, 0, 1, 1, VehicleCameraConfig.firstPersonResponseMul)
		fYaw *= map(firstPerson, 0, 1, 1, VehicleCameraConfig.firstPersonResponseMul)
		
		-- step yaw
		self.yawP, self.yawV = stepSpringAxis(
			dt,
			fYaw,
			self.yawG,
			self.yawP,
			self.yawV
		)
		
		-- step pitch
		self.pitchP, self.pitchV = stepSpringAxis(
			dt,
			fPitch,
			self.pitchG,
			self.pitchP,
			self.pitchV
		)

		return self:getCFrame()
	end
end

local VehicleCameraCore = {} do
	VehicleCameraCore.__index = VehicleCameraCore

	function VehicleCameraCore.new(transform)
		return setmetatable({
			vrs = YawPitchSpring.new(transform)
		}, VehicleCameraCore)
	end

	function VehicleCameraCore:step(dt, pitchVel, yawVel, firstPerson)
		return self.vrs:step(dt, pitchVel, yawVel, firstPerson)
	end

	function VehicleCameraCore:setTransform(transform)
		self.vrs:setGoal(transform)
	end
end

return VehicleCameraCore
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXADEB0833D6B847959CFF5669919BD441">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">VehicleCameraConfig</string>
								<string name="ScriptGuid">{14A9FCAD-44B5-443E-B5F0-121BE63A7271}</string>
								<ProtectedString name="Source"><![CDATA[local VEHICLE_CAMERA_CONFIG = {
	-- (hz) Camera response stiffness along the pitch axis
	pitchStiffness = 0.5,

	-- (hz) Camera response stiffness along the yaw axis
	yawStiffness = 2.5,

	-- (s) Delay after use input before the camera can begin autorotating
	autocorrectDelay = 1,

	-- (studs/s) Minimum vehicle speed before the autocorrect begins to activate
	autocorrectMinCarSpeed = 16,

	-- (studs/s) Vehicle speed where autocorrect is fully activated
	autocorrectMaxCarSpeed = 32,

	-- (hz) Autocorrect stiffness/speed
	autocorrectResponse = 0.5,

	-- (deg/s) Minimum angular yaw velocity before the camera rotation cutoff begins
	cutoffMinAngularVelYaw = 60,

	-- (deg/s) Maximum angular yaw velocity where the camera rotation cutoff is fully activated
	cutoffMaxAngularVelYaw = 180,

	-- (deg/s) Minimum angular pitch velocity before the camera rotation cutoff begins
	cutoffMinAngularVelPitch = 15,

	-- (deg/s) Maximum angular pitch velocity where the camera rotation cutoff is fully activated
	cutoffMaxAngularVelPitch = 60,

	-- (deg) Default pitch angle relative to the horizon
	pitchBaseAngle = 18,

	-- (deg) Half-size of the deadzone angle for pitch autocorrect
	pitchDeadzoneAngle = 12,

	-- (unitless) Multiplier for camera response stiffness in first-person mode
	firstPersonResponseMul = 10,

	-- (hz) Responsiveness of yaw cutoff to rising angular velocities
	yawReponseDampingRising = 1,

	-- (hz) Responsiveness of yaw cutoff to falling angular velocities
	yawResponseDampingFalling = 3,

	-- (hz) Responsiveness of pitch cutoff to rising angular velocities
	pitchReponseDampingRising = 1,

	-- (hz) Responsiveness of pitch cutoff to falling angular velocities
	pitchResponseDampingFalling = 3,

	-- (unitless) Initial zoom radius as a fraction of car radius
	initialZoomRadiusMul = 3,

	-- (unitless) Vertical third-person camera offset as a fraction of car radius
	verticalCenterOffset = 0.33,
}

return VEHICLE_CAMERA_CONFIG
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b5</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX579A4C2B3ADB4261845DABFDCCF7FE27">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Poppercam</string>
							<string name="ScriptGuid">{BA6D7552-E119-48E8-B7A9-32958C6FC32E}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	Poppercam - Occlusion module that brings the camera closer to the subject when objects are blocking the view.
--]]

local ZoomController =  require(script.Parent:WaitForChild("ZoomController"))

local TransformExtrapolator = {} do
	TransformExtrapolator.__index = TransformExtrapolator

	local CF_IDENTITY = CFrame.new()

	local function cframeToAxis(cframe: CFrame): Vector3
		local axis: Vector3, angle: number = cframe:ToAxisAngle()
		return axis*angle
	end

	local function axisToCFrame(axis: Vector3): CFrame
		local angle: number = axis.Magnitude
		if angle > 1e-5 then
			return CFrame.fromAxisAngle(axis, angle)
		end
		return CF_IDENTITY
	end

	local function extractRotation(cf: CFrame): CFrame
		local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:GetComponents()
		return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
	end

	function TransformExtrapolator.new()
		return setmetatable({
			lastCFrame = nil,
		}, TransformExtrapolator)
	end

	function TransformExtrapolator:Step(dt: number, currentCFrame: CFrame)
		local lastCFrame = self.lastCFrame or currentCFrame
		self.lastCFrame = currentCFrame

		local currentPos = currentCFrame.Position
		local currentRot = extractRotation(currentCFrame)

		local lastPos = lastCFrame.p
		local lastRot = extractRotation(lastCFrame)

		-- Estimate velocities from the delta between now and the last frame
		-- This estimation can be a little noisy.
		local dp = (currentPos - lastPos)/dt
		local dr = cframeToAxis(currentRot*lastRot:inverse())/dt

		local function extrapolate(t)
			local p = dp*t + currentPos
			local r = axisToCFrame(dr*t)*currentRot
			return r + p
		end

		return {
			extrapolate = extrapolate,
			posVelocity = dp,
			rotVelocity = dr,
		}
	end

	function TransformExtrapolator:Reset()
		self.lastCFrame = nil
	end
end

--[[ The Module ]]--
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam

function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.focusExtrapolator = TransformExtrapolator.new()
	return self
end

function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end

function Poppercam:Enable(enable)
	self.focusExtrapolator:Reset()
end

function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
	local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p)*CFrame.new(
		0, 0, 0,
		-1, 0, 0,
		0, 1, 0,
		0, 0, -1
	)
	local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
	local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
	return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
end

-- Called when character is added
function Poppercam:CharacterAdded(character, player)
end

-- Called when character is about to be removed
function Poppercam:CharacterRemoving(character, player)
end

function Poppercam:OnCameraSubjectChanged(newSubject)
end

return Poppercam
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC5839EF2B6F64217BDBEDFC9A5938271">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseLockController</string>
							<string name="ScriptGuid">{3D4FEF25-B5B2-44E4-8261-95B7FE8B382A}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	MouseLockController - Replacement for ShiftLockController, manages use of mouse-locked mode
	2018 Camera Update - AllYourBlox
--]]

--[[ Constants ]]--
local DEFAULT_MOUSE_LOCK_CURSOR = "http://www.roblox.com/asset/?id=10546018744"

local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Medium.Value

--[[ Services ]]--
local PlayersService = game:GetService("Players")
local ContextActionService = game:GetService("ContextActionService")
local Settings = UserSettings()	-- ignore warning
local GameSettings = Settings.GameSettings

--[[ Imports ]]
local CameraUtils = require(script.Parent:WaitForChild("CameraUtils"))

--[[ The Module ]]--
local MouseLockController = {}
MouseLockController.__index = MouseLockController

function MouseLockController.new()
	local self = setmetatable({}, MouseLockController)

	self.isMouseLocked = false
	self.savedMouseCursor = nil
	self.boundKeys = {Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift} -- defaults

	self.mouseLockToggledEvent = Instance.new("BindableEvent")

	local boundKeysObj = script:FindFirstChild("BoundKeys")
	if (not boundKeysObj) or (not boundKeysObj:IsA("StringValue")) then
		-- If object with correct name was found, but it's not a StringValue, destroy and replace
		if boundKeysObj then
			boundKeysObj:Destroy()
		end

		boundKeysObj = Instance.new("StringValue")
		-- Luau FIXME: should be able to infer from assignment above that boundKeysObj is not nil
		assert(boundKeysObj, "")
		boundKeysObj.Name = "BoundKeys"
		boundKeysObj.Value = "LeftShift,RightShift"
		boundKeysObj.Parent = script
	end

	if boundKeysObj then
		boundKeysObj.Changed:Connect(function(value)
			self:OnBoundKeysObjectChanged(value)
		end)
		self:OnBoundKeysObjectChanged(boundKeysObj.Value) -- Initial setup call
	end

	-- Watch for changes to user's ControlMode and ComputerMovementMode settings and update the feature availability accordingly
	GameSettings.Changed:Connect(function(property)
		if property == "ControlMode" or property == "ComputerMovementMode" then
			self:UpdateMouseLockAvailability()
		end
	end)

	-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)

	-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)

	self:UpdateMouseLockAvailability()

	return self
end

function MouseLockController:GetIsMouseLocked()
	return self.isMouseLocked
end

function MouseLockController:GetBindableToggleEvent()
	return self.mouseLockToggledEvent.Event
end

function MouseLockController:GetMouseLockOffset()
	local offsetValueObj: Vector3Value = script:FindFirstChild("CameraOffset") :: Vector3Value
	if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
		return offsetValueObj.Value
	else
		-- If CameraOffset object was found but not correct type, destroy
		if offsetValueObj then
			offsetValueObj:Destroy()
		end
		offsetValueObj = Instance.new("Vector3Value")
		assert(offsetValueObj, "")
		offsetValueObj.Name = "CameraOffset"
		offsetValueObj.Value = Vector3.new(1.75,0,0) -- Legacy Default Value
		offsetValueObj.Parent = script
	end

	if offsetValueObj and offsetValueObj.Value then
		return offsetValueObj.Value
	end

	return Vector3.new(1.75,0,0)
end

function MouseLockController:UpdateMouseLockAvailability()
	local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
	local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
	local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
	local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
	local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable

	if MouseLockAvailable~=self.enabled then
		self:EnableMouseLock(MouseLockAvailable)
	end
end

function MouseLockController:OnBoundKeysObjectChanged(newValue: string)
	self.boundKeys = {} -- Overriding defaults, note: possibly with nothing at all if boundKeysObj.Value is "" or contains invalid values
	for token in string.gmatch(newValue,"[^%s,]+") do
		for _, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
			if token == keyEnum.Name then
				self.boundKeys[#self.boundKeys+1] = keyEnum :: Enum.KeyCode
				break
			end
		end
	end
	self:UnbindContextActions()
	self:BindContextActions()
end

--[[ Local Functions ]]--
function MouseLockController:OnMouseLockToggled()
	self.isMouseLocked = not self.isMouseLocked

	if self.isMouseLocked then
		local cursorImageValueObj: StringValue? = script:FindFirstChild("CursorImage") :: StringValue?
		if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
			CameraUtils.setMouseIconOverride(cursorImageValueObj.Value)
		else
			if cursorImageValueObj then
				cursorImageValueObj:Destroy()
			end
			cursorImageValueObj = Instance.new("StringValue")
			assert(cursorImageValueObj, "")
			cursorImageValueObj.Name = "CursorImage"
			cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
			cursorImageValueObj.Parent = script
			CameraUtils.setMouseIconOverride(DEFAULT_MOUSE_LOCK_CURSOR)
		end
	else
		CameraUtils.restoreMouseIcon()
	end

	self.mouseLockToggledEvent:Fire()
end

function MouseLockController:DoMouseLockSwitch(name, state, input)
	if state == Enum.UserInputState.Begin then
		self:OnMouseLockToggled()
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end

function MouseLockController:BindContextActions()
	ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input)
		return self:DoMouseLockSwitch(name, state, input)
	end, false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
end

function MouseLockController:UnbindContextActions()
	ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
end

function MouseLockController:IsMouseLocked(): boolean
	return self.enabled and self.isMouseLocked
end

function MouseLockController:EnableMouseLock(enable: boolean)
	if enable ~= self.enabled then

		self.enabled = enable

		if self.enabled then
			-- Enabling the mode
			self:BindContextActions()
		else
			-- Disabling
			-- Restore mouse cursor
			CameraUtils.restoreMouseIcon()

			self:UnbindContextActions()

			-- If the mode is disabled while being used, fire the event to toggle it off
			if self.isMouseLocked then
				self.mouseLockToggledEvent:Fire()
			end

			self.isMouseLocked = false
		end

	end
end

return MouseLockController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b7</UniqueId>
						</Properties>
						<Item class="StringValue" referent="RBX46EE45EE068848E9A1C2BA060F672ACF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">BoundKeys</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b8</UniqueId>
								<string name="Value">LeftControl</string>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX6BE1CE134D2D42E9BBBB1F679A0CC43B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraToggleStateController</string>
							<string name="ScriptGuid">{331C5C13-0F1E-40FA-8437-94F37AED8484}</string>
							<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local GameSettings = UserSettings():GetService("UserGameSettings")

local Input = require(script.Parent:WaitForChild("CameraInput"))
local CameraUI = require(script.Parent:WaitForChild("CameraUI"))
local CameraUtils = require(script.Parent:WaitForChild("CameraUtils"))

local lastTogglePan = false
local lastTogglePanChange = tick()

local CROSS_MOUSE_ICON = "rbxasset://textures/Cursors/CrossMouseIcon.png"

local lockStateDirty = false
local wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = false
local lastFirstPerson = false

CameraUI.setCameraModeToastEnabled(false)

return function(isFirstPerson: boolean)
	local togglePan = Input.getTogglePan()
	local toastTimeout = 3

	if isFirstPerson and togglePan ~= lastTogglePan then
		lockStateDirty = true
	end

	if lastTogglePan ~= togglePan or tick() - lastTogglePanChange > toastTimeout then
		local doShow = togglePan and tick() - lastTogglePanChange < toastTimeout

		CameraUI.setCameraModeToastOpen(doShow)

		if togglePan then
			lockStateDirty = false
		end
		lastTogglePanChange = tick()
		lastTogglePan = togglePan
	end

	if isFirstPerson ~= lastFirstPerson then
		if isFirstPerson then
			wasTogglePanOnTheLastTimeYouWentIntoFirstPerson = Input.getTogglePan()
			Input.setTogglePan(true)
		elseif not lockStateDirty then
			Input.setTogglePan(wasTogglePanOnTheLastTimeYouWentIntoFirstPerson)
		end
	end

	if isFirstPerson then
		if Input.getTogglePan() then
			CameraUtils.setMouseIconOverride(CROSS_MOUSE_ICON)
			CameraUtils.setMouseBehaviorOverride(Enum.MouseBehavior.LockCenter)
			CameraUtils.setRotationTypeOverride(Enum.RotationType.CameraRelative)
		else
			CameraUtils.restoreMouseIcon()
			CameraUtils.restoreMouseBehavior()
			CameraUtils.setRotationTypeOverride(Enum.RotationType.CameraRelative)
		end

	elseif Input.getTogglePan() then
		CameraUtils.setMouseIconOverride(CROSS_MOUSE_ICON)
		CameraUtils.setMouseBehaviorOverride(Enum.MouseBehavior.LockCenter)
		CameraUtils.setRotationTypeOverride(Enum.RotationType.MovementRelative)

	elseif Input.getHoldPan() then
		CameraUtils.restoreMouseIcon()
		CameraUtils.setMouseBehaviorOverride(Enum.MouseBehavior.LockCurrentPosition)
		CameraUtils.setRotationTypeOverride(Enum.RotationType.MovementRelative)

	else
		CameraUtils.restoreMouseIcon()
		CameraUtils.restoreMouseBehavior()
		CameraUtils.restoreRotationType()
	end

	lastFirstPerson = isFirstPerson
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070b9</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEE30D755D999484CA6B516BF9A70D1FF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VRBaseCamera</string>
							<string name="ScriptGuid">{983CBBD1-49BC-4733-AE99-29DC02BCAFA7}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	VRBaseCamera - Base class for VR camera
	2021 Roblox VR
--]]

--[[ Local Constants ]]--
local VR_ANGLE = math.rad(15)
local VR_PANEL_SIZE = 512
local VR_ZOOM = 7
local VR_FADE_SPEED = 10 -- 1/10 second
local VR_SCREEN_EGDE_BLEND_TIME = 0.14
local VR_SEAT_OFFSET = Vector3.new(0,4,0)

local VRService = game:GetService("VRService")

local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))

local Players = game:GetService("Players")
local player = Players.LocalPlayer

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local UserGameSettings = UserSettings():GetService("UserGameSettings")

local FFlagUserVRRotationUpdate do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserVRRotationUpdate")
	end)
	FFlagUserVRRotationUpdate = success and result
end

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local VRBaseCamera = setmetatable({}, BaseCamera)
VRBaseCamera.__index = VRBaseCamera

function VRBaseCamera.new()
	local self = setmetatable(BaseCamera.new(), VRBaseCamera)

	-- distance is different in VR
	self.defaultDistance = VR_ZOOM
	self.defaultSubjectDistance = math.clamp(self.defaultDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
	self.currentSubjectDistance = math.clamp(self.defaultDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)

	-- VR screen effect
	self.VRFadeResetTimer = 0
	self.VREdgeBlurTimer = 0

	-- initialize vr specific variables
	self.gamepadResetConnection = nil
	self.needsReset = true
	
	-- timer for step rotation
	if FFlagUserVRRotationUpdate then
		self:Reset()
	end
	
	return self
end

function VRBaseCamera:Reset()
	self.stepRotateTimeout = 0
end

function VRBaseCamera:GetModuleName()
	return "VRBaseCamera"
end

function VRBaseCamera:GamepadZoomPress()
	local dist = self:GetCameraToSubjectDistance()

	if dist > VR_ZOOM / 2 then
		self:SetCameraToSubjectDistance(0)
		self.currentSubjectDistance = 0
	else
		self:SetCameraToSubjectDistance(VR_ZOOM)
		self.currentSubjectDistance = VR_ZOOM
	end

	self:GamepadReset()
	self:ResetZoom()
end

function VRBaseCamera:GamepadReset()
	if FFlagUserVRRotationUpdate then
		self.stepRotateTimeout = 0
	end
	self.needsReset = true
end

function VRBaseCamera:ResetZoom()
	ZoomController.SetZoomParameters(self.currentSubjectDistance, 0)
	ZoomController.ReleaseSpring()
end

function VRBaseCamera:OnEnable(enable: boolean)
	if enable then
		self.gamepadResetConnection = CameraInput.gamepadReset:Connect(function()
			self:GamepadReset()
		end)
	else
		-- make sure zoom is reset when switching to another camera
		if self.inFirstPerson then
			self:GamepadZoomPress()
		end

		if self.gamepadResetConnection then
			self.gamepadResetConnection:Disconnect()
			self.gamepadResetConnection = nil
		end

		-- reset VR effects
		self.VREdgeBlurTimer = 0
		self:UpdateEdgeBlur(player, 1)
		local VRFade = Lighting:FindFirstChild("VRFade")
		if VRFade then
			VRFade.Brightness = 0
		end
	end
end

function VRBaseCamera:UpdateDefaultSubjectDistance()
	self.defaultSubjectDistance = math.clamp(VR_ZOOM, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
end

-- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
function VRBaseCamera:GetCameraToSubjectDistance(): number
	return self.currentSubjectDistance
end

-- VR only supports 1st person or 3rd person and no overrides
function VRBaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance: number): number
	local lastSubjectDistance = self.currentSubjectDistance

	local newSubjectDistance = math.clamp(desiredSubjectDistance, 0, player.CameraMaxZoomDistance)
	if newSubjectDistance < 1.0 then
		self.currentSubjectDistance = 0.5
		if not self.inFirstPerson then
			self:EnterFirstPerson()
		end
	else
		self.currentSubjectDistance = newSubjectDistance
		if self.inFirstPerson then
			self:LeaveFirstPerson()
		end
	end

	-- Pass target distance and zoom direction to the zoom controller
	ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))

	-- Returned only for convenience to the caller to know the outcome
	return self.currentSubjectDistance
end

-- defines subject and height of VR camera
function VRBaseCamera:GetVRFocus(subjectPosition, timeDelta)
	local lastFocus = self.lastCameraFocus or subjectPosition

	self.cameraTranslationConstraints = Vector3.new(
		self.cameraTranslationConstraints.x,
		math.min(1, self.cameraTranslationConstraints.y + timeDelta),
		self.cameraTranslationConstraints.z)

	local cameraHeightDelta = Vector3.new(0, self:GetCameraHeight(), 0)
	local newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):
			Lerp(subjectPosition + cameraHeightDelta, self.cameraTranslationConstraints.y))

	return newFocus
end

-- (VR) Screen effects --------------
function VRBaseCamera:StartFadeFromBlack()
	if UserGameSettings.VignetteEnabled == false then
		return
	end

	local VRFade = Lighting:FindFirstChild("VRFade")
	if not VRFade then
		VRFade = Instance.new("ColorCorrectionEffect")
		VRFade.Name = "VRFade"
		VRFade.Parent = Lighting
	end
	VRFade.Brightness = -1
	self.VRFadeResetTimer = 0.1
end

function VRBaseCamera:UpdateFadeFromBlack(timeDelta: number)
	local VRFade = Lighting:FindFirstChild("VRFade")
	if self.VRFadeResetTimer > 0  then
		self.VRFadeResetTimer = math.max(self.VRFadeResetTimer - timeDelta, 0)

		local VRFade = Lighting:FindFirstChild("VRFade")
		if VRFade and VRFade.Brightness < 0 then
			VRFade.Brightness = math.min(VRFade.Brightness + timeDelta * VR_FADE_SPEED, 0)
		end
	else
		if VRFade then -- sanity check, VRFade off
			VRFade.Brightness = 0
		end
	end
end

function VRBaseCamera:StartVREdgeBlur(player)
	if UserGameSettings.VignetteEnabled == false then
		return
	end

	local blurPart = nil
	blurPart = (workspace.CurrentCamera :: Camera):FindFirstChild("VRBlurPart")
	if not blurPart then
		local basePartSize = Vector3.new(0.44,0.47,1)
		blurPart = Instance.new("Part")
		blurPart.Name = "VRBlurPart"
		blurPart.Parent = workspace.CurrentCamera
		blurPart.CanTouch = false
		blurPart.CanCollide = false
		blurPart.CanQuery = false
		blurPart.Anchored = true
		blurPart.Size = basePartSize
		blurPart.Transparency = 1
		blurPart.CastShadow = false

		RunService.RenderStepped:Connect(function(step)
			local userHeadCF = VRService:GetUserCFrame(Enum.UserCFrame.Head)

			local vrCF = (workspace.CurrentCamera :: Camera).CFrame * (CFrame.new(userHeadCF.p * (workspace.CurrentCamera :: Camera).HeadScale) * (userHeadCF - userHeadCF.p))
			blurPart.CFrame = (vrCF * CFrame.Angles(0, math.rad(180), 0)) + vrCF.LookVector * (1.05 * (workspace.CurrentCamera :: Camera).HeadScale)
			blurPart.Size = basePartSize * (workspace.CurrentCamera :: Camera).HeadScale
		end)
	end

	local VRScreen = player.PlayerGui:FindFirstChild("VRBlurScreen")
	local VRBlur = nil
	if VRScreen then
		VRBlur = VRScreen:FindFirstChild("VRBlur")
	end

	if not VRBlur then
		if not VRScreen then
			VRScreen = Instance.new("SurfaceGui") or Instance.new("ScreenGui")
		end

		VRScreen.Name = "VRBlurScreen"
		VRScreen.Parent = player.PlayerGui

		VRScreen.Adornee = blurPart

		VRBlur = Instance.new("ImageLabel")
		VRBlur.Name = "VRBlur"
		VRBlur.Parent = VRScreen

		VRBlur.Image = "rbxasset://textures/ui/VR/edgeBlur.png"
		VRBlur.AnchorPoint = Vector2.new(0.5, 0.5)
		VRBlur.Position = UDim2.new(0.5, 0, 0.5, 0)

		-- this computes the ratio between the GUI 3D panel and the VR viewport
		-- adding 15% overshoot for edges on 2 screen headsets
		local ratioX = (workspace.CurrentCamera :: Camera).ViewportSize.X * 2.3 / VR_PANEL_SIZE
		local ratioY = (workspace.CurrentCamera :: Camera).ViewportSize.Y * 2.3 / VR_PANEL_SIZE

		VRBlur.Size = UDim2.fromScale(ratioX, ratioY)
		VRBlur.BackgroundTransparency = 1
		VRBlur.Active = true
		VRBlur.ScaleType = Enum.ScaleType.Stretch
	end

	VRBlur.Visible = true
	VRBlur.ImageTransparency = 0
	self.VREdgeBlurTimer = VR_SCREEN_EGDE_BLEND_TIME
end

function VRBaseCamera:UpdateEdgeBlur(player, timeDelta)
	local VRScreen = player.PlayerGui:FindFirstChild("VRBlurScreen")
	local VRBlur = nil
	if VRScreen then
		VRBlur = VRScreen:FindFirstChild("VRBlur")
	end

	if VRBlur then
		if self.VREdgeBlurTimer > 0 then
			self.VREdgeBlurTimer = self.VREdgeBlurTimer - timeDelta

			local VRScreen = player.PlayerGui:FindFirstChild("VRBlurScreen")
			if VRScreen then
				local VRBlur = VRScreen:FindFirstChild("VRBlur")
				if VRBlur then
					VRBlur.ImageTransparency = 1.0 - math.clamp(self.VREdgeBlurTimer, 0.01,
						VR_SCREEN_EGDE_BLEND_TIME) * (1/VR_SCREEN_EGDE_BLEND_TIME)
				end
			end
		else
			VRBlur.Visible = false
		end
	end
end

function VRBaseCamera:GetCameraHeight()
	if not self.inFirstPerson then
		return math.sin(VR_ANGLE) * self.currentSubjectDistance
	end
	return 0
end

function VRBaseCamera:GetSubjectCFrame(): CFrame
	local result = BaseCamera.GetSubjectCFrame(self)
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if not cameraSubject then
		return result
	end

	-- new VR system overrides
	if cameraSubject:IsA("Humanoid") then
		local humanoid = cameraSubject
		local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead

		if humanoidIsDead and humanoid == self.lastSubject then
			result = self.lastSubjectCFrame
		end
	end

	if result then
		self.lastSubjectCFrame = result
	end

	return result
end

function VRBaseCamera:GetSubjectPosition(): Vector3?
	local result = BaseCamera.GetSubjectPosition(self)

	-- new VR system overrides
	local camera = game.Workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	if cameraSubject then
		if cameraSubject:IsA("Humanoid") then
			local humanoid = cameraSubject
			local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead

			if  humanoidIsDead and humanoid == self.lastSubject then
				result = self.lastSubjectPosition
			end
		elseif cameraSubject:IsA("VehicleSeat") then
			local offset = VR_SEAT_OFFSET
			result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
		end
	else
		return nil
	end

	self.lastSubjectPosition = result

	return result
end

-- gets the desired rotation accounting for smooth rotation. Manages fades and resets resulting 
-- from rotation
function VRBaseCamera:getRotation(dt)
	local rotateInput = CameraInput.getRotation()
	local yawDelta = 0
	
	if UserGameSettings.VRSmoothRotationEnabled then
		yawDelta = rotateInput.X * 40 * dt
	else
		
		if math.abs(rotateInput.X) > 0.03 then
			if self.stepRotateTimeout > 0 then
				self.stepRotateTimeout -= dt
			end
			
			if self.stepRotateTimeout <= 0 then
				yawDelta = 1
				if rotateInput.X < 0 then
					yawDelta = -1
				end
				
				yawDelta *= math.rad(60)
				self:StartFadeFromBlack()
				self.stepRotateTimeout = 0.25
			end
		elseif math.abs(rotateInput.X) < 0.02 then
			self.stepRotateTimeout = 0 -- allow fast rotation when spamming input
		end
	end
	
	return yawDelta

end

-----------------------------

return VRBaseCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070ba</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6EFE879453D24C4A969552E6C612C4D4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VRCamera</string>
							<string name="ScriptGuid">{6E0EC349-04F0-4314-BFAA-0CD64FA71E61}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	VRCamera - Roblox VR camera control module
	2021 Roblox VR
--]]

--[[ Services ]]--
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

-- Local private variables and constants
local CAMERA_BLACKOUT_TIME = 0.1
local FP_ZOOM = 0.5

-- requires
local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
local Util = require(script.Parent:WaitForChild("CameraUtils"))

local FFlagUserVRRotationUpdate do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserVRRotationUpdate")
	end)
	FFlagUserVRRotationUpdate = success and result
end

--[[ The Module ]]--
local VRBaseCamera = require(script.Parent:WaitForChild("VRBaseCamera"))
local VRCamera = setmetatable({}, VRBaseCamera)
VRCamera.__index = VRCamera

function VRCamera.new()
	local self = setmetatable(VRBaseCamera.new(), VRCamera)

	self.lastUpdate = tick()
	self:Reset()

	return self
end

function VRCamera:Reset()
	self.needsReset = true
	self.needsBlackout = true
	self.motionDetTime = 0.0
	self.blackOutTimer = 0
	self.lastCameraResetPosition = nil
	if not FFlagUserVRRotationUpdate then
		self.stepRotateTimeout = 0.0
		self.cameraOffsetRotation = 0
		self.cameraOffsetRotationDiscrete = 0
	else
		VRBaseCamera.Reset(self)
	end
end

function VRCamera:Update(timeDelta)
	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus

	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera.CameraSubject

	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end

	-- update fullscreen effects
	self:UpdateFadeFromBlack(timeDelta)
	self:UpdateEdgeBlur(player, timeDelta)

	local lastSubjPos = self.lastSubjectPosition
	local subjectPosition: Vector3 = self:GetSubjectPosition()
	-- transition from another camera or from spawn
	if self.needsBlackout then 
		self:StartFadeFromBlack()

		local dt = math.clamp(timeDelta, 0.0001, 0.1)
		self.blackOutTimer += dt
		if self.blackOutTimer > CAMERA_BLACKOUT_TIME and game:IsLoaded() then
			self.needsBlackout = false
			self.needsReset = true
		end
	end

	if subjectPosition and player and camera then
		newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)

		if self:IsInFirstPerson() then
			-- update camera CFrame
			newCameraCFrame, newCameraFocus = self:UpdateFirstPersonTransform(
				timeDelta,newCameraCFrame, newCameraFocus, lastSubjPos, subjectPosition)
		else -- 3rd person
			-- update camera CFrame
			newCameraCFrame, newCameraFocus = self:UpdateThirdPersonTransform(
				timeDelta, newCameraCFrame, newCameraFocus, lastSubjPos, subjectPosition)
		end

		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
	end

	self.lastUpdate = tick()
	return newCameraCFrame, newCameraFocus
end

-- returns where the floor should be placed given the camera subject, nil if anything is invalid
function VRCamera:GetAvatarFeetWorldYValue(): number?
	local camera = workspace.CurrentCamera
	local cameraSubject = camera.CameraSubject
	if not cameraSubject then
		return nil
	end

	if cameraSubject:IsA("Humanoid") and cameraSubject.RootPart then
		local rootPart = cameraSubject.RootPart
		return rootPart.Position.Y - rootPart.Size.Y / 2 - cameraSubject.HipHeight
	end

	return nil
end

function VRCamera:UpdateFirstPersonTransform(timeDelta, newCameraCFrame, newCameraFocus, lastSubjPos, subjectPosition)
	-- transition from TP to FP
	if self.needsReset then
		self:StartFadeFromBlack()
		self.needsReset = false
		if not FFlagUserVRRotationUpdate then
			self.stepRotateTimeout = 0.25
			self.VRCameraFocusFrozen = true
			self.cameraOffsetRotation = 0
			self.cameraOffsetRotationDiscrete = 0
		end
	end

	-- blur screen edge during movement
	local player = PlayersService.LocalPlayer
	local subjectDelta = lastSubjPos - subjectPosition
	if subjectDelta.magnitude > 0.01 then
		self:StartVREdgeBlur(player)
	end
	-- straight view, not angled down
	local cameraFocusP = newCameraFocus.p
	local cameraLookVector = self:GetCameraLookVector()
	cameraLookVector = Vector3.new(cameraLookVector.X, 0, cameraLookVector.Z).Unit

	local yawDelta -- inline with FFlagVRRotationUpdate
	if FFlagUserVRRotationUpdate then

		yawDelta = self:getRotation(timeDelta)
	else
		if self.stepRotateTimeout > 0 then
			self.stepRotateTimeout -= timeDelta
		end
	
		-- step rotate in 1st person
		local rotateInput = CameraInput.getRotation()
		yawDelta = 0
		if UserGameSettings.VRSmoothRotationEnabled then
			yawDelta = rotateInput.X
		else
			if self.stepRotateTimeout <= 0.0 and math.abs(rotateInput.X) > 0.03 then
				yawDelta = 0.5
				if rotateInput.X < 0 then
					yawDelta = -0.5
				end
				self.needsReset = true
			end
		end
	end

	local newLookVector = self:CalculateNewLookVectorFromArg(cameraLookVector, Vector2.new(yawDelta, 0))
	newCameraCFrame = CFrame.new(cameraFocusP - (FP_ZOOM * newLookVector), cameraFocusP)

	return newCameraCFrame, newCameraFocus
end

function VRCamera:UpdateThirdPersonTransform(timeDelta, newCameraCFrame, newCameraFocus, lastSubjPos, subjectPosition)
	local zoom = self:GetCameraToSubjectDistance()
	if zoom < 0.5 then
		zoom = 0.5
	end

	if lastSubjPos ~= nil and self.lastCameraFocus ~= nil then
		-- compute delta of subject since last update
		local player = PlayersService.LocalPlayer
		local subjectDelta = lastSubjPos - subjectPosition
		local moveVector = require(player:WaitForChild("PlayerScripts").PlayerModule:WaitForChild("ControlModule")):GetMoveVector()

		-- is the subject still moving?
		local isMoving = subjectDelta.magnitude > 0.01 or moveVector.magnitude > 0.01
		if isMoving then
			self.motionDetTime = 0.1
		end

		self.motionDetTime = self.motionDetTime - timeDelta
		if self.motionDetTime > 0 then
			isMoving = true
		end

		if isMoving and not self.needsReset then
			-- if subject moves keep old camera focus
			newCameraFocus = self.lastCameraFocus

			-- if the focus subject stopped, time to reset the camera
			self.VRCameraFocusFrozen = true
		else
			local subjectMoved = self.lastCameraResetPosition == nil or (subjectPosition - self.lastCameraResetPosition).Magnitude > 1

			-- compute offset for 3rd person camera rotation
			if FFlagUserVRRotationUpdate then
				local yawDelta = self:getRotation(timeDelta)
				if math.abs(yawDelta) > 0 then
					local cameraOffset = newCameraFocus:ToObjectSpace(newCameraCFrame)
					local rotatedFocus = newCameraFocus * CFrame.Angles(0, yawDelta, 0)
					newCameraCFrame = rotatedFocus * cameraOffset
				end

				-- recenter the camera on teleport
				if (self.VRCameraFocusFrozen and subjectMoved) or self.needsReset then
					VRService:RecenterUserHeadCFrame()

					self.VRCameraFocusFrozen = false
					self.needsReset = false
					self.lastCameraResetPosition = subjectPosition

					self:ResetZoom()
					self:StartFadeFromBlack()

					-- get player facing direction
					local humanoid = self:GetHumanoid()
					local forwardVector = humanoid.Torso and humanoid.Torso.CFrame.lookVector or Vector3.new(1,0,0)
					-- adjust camera height
					local vecToCameraAtHeight = Vector3.new(forwardVector.X, 0, forwardVector.Z)
					local newCameraPos = newCameraFocus.Position - vecToCameraAtHeight * zoom
					-- compute new cframe at height level to subject
					local lookAtPos = Vector3.new(newCameraFocus.Position.X, newCameraPos.Y, newCameraFocus.Position.Z)

					newCameraCFrame = CFrame.new(newCameraPos, lookAtPos)
				end

			else
				local rotateInput = CameraInput.getRotation()
				local userCameraPan = rotateInput ~= Vector2.new()
				local panUpdate = false
				if userCameraPan then
					if rotateInput.X ~= 0 then
						local tempRotation = self.cameraOffsetRotation + rotateInput.X;
						if(tempRotation < -math.pi) then
							tempRotation = math.pi - (tempRotation + math.pi) 
						else
							if (tempRotation > math.pi) then
								tempRotation = -math.pi + (tempRotation - math.pi) 
							end
						end
						self.cameraOffsetRotation = math.clamp(tempRotation, -math.pi, math.pi)
						if UserGameSettings.VRSmoothRotationEnabled then
							self.cameraOffsetRotationDiscrete = self.cameraOffsetRotation
	
							-- get player facing direction
							local humanoid = self:GetHumanoid()
							local forwardVector = humanoid.Torso and humanoid.Torso.CFrame.lookVector or Vector3.new(1,0,0)
							-- adjust camera height
							local vecToCameraAtHeight = Vector3.new(forwardVector.X, 0, forwardVector.Z)
							local newCameraPos = newCameraFocus.Position - vecToCameraAtHeight * zoom
							-- compute new cframe at height level to subject
							local lookAtPos = Vector3.new(newCameraFocus.Position.X, newCameraPos.Y, newCameraFocus.Position.Z)
	
							local tempCF = CFrame.new(newCameraPos, lookAtPos)
							tempCF = tempCF * CFrame.fromAxisAngle(Vector3.new(0,1,0), self.cameraOffsetRotationDiscrete)
							newCameraPos = lookAtPos - (tempCF.LookVector * (lookAtPos - newCameraPos).Magnitude)
	
							newCameraCFrame = CFrame.new(newCameraPos, lookAtPos)
						else
							local tempRotDisc = math.floor(self.cameraOffsetRotation * 12 / 12)
							if tempRotDisc ~= self.cameraOffsetRotationDiscrete then
								self.cameraOffsetRotationDiscrete = tempRotDisc
								panUpdate = true
							end
						end
					end
				end

				-- recenter the camera on teleport
				if (self.VRCameraFocusFrozen and subjectMoved) or self.needsReset or panUpdate then
					if not panUpdate then
						self.cameraOffsetRotationDiscrete = 0
						self.cameraOffsetRotation = 0
					end

					VRService:RecenterUserHeadCFrame()

					self.VRCameraFocusFrozen = false
					self.needsReset = false
					self.lastCameraResetPosition = subjectPosition

					self:ResetZoom()
					self:StartFadeFromBlack()

					-- get player facing direction
					local humanoid = self:GetHumanoid()
					local forwardVector = humanoid.Torso and humanoid.Torso.CFrame.lookVector or Vector3.new(1,0,0)
					-- adjust camera height
					local vecToCameraAtHeight = Vector3.new(forwardVector.X, 0, forwardVector.Z)
					local newCameraPos = newCameraFocus.Position - vecToCameraAtHeight * zoom
					-- compute new cframe at height level to subject
					local lookAtPos = Vector3.new(newCameraFocus.Position.X, newCameraPos.Y, newCameraFocus.Position.Z)

					if self.cameraOffsetRotation ~= 0 then
						local tempCF = CFrame.new(newCameraPos, lookAtPos)
						tempCF = tempCF * CFrame.fromAxisAngle(Vector3.new(0,1,0), self.cameraOffsetRotationDiscrete)
						newCameraPos = lookAtPos - (tempCF.LookVector * (lookAtPos - newCameraPos).Magnitude)
					end

					newCameraCFrame = CFrame.new(newCameraPos, lookAtPos)
				end
			end
		end
	end

	return newCameraCFrame, newCameraFocus
end

function VRCamera:EnterFirstPerson()
	self.inFirstPerson = true
	
	self:UpdateMouseBehavior()
end

function VRCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self.needsReset = true
	
	self:UpdateMouseBehavior()
	
	if self.VRBlur then
		self.VRBlur.Visible = false
	end
end

return VRCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070bb</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5CE0511FE35742699845EE117C50B98E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClassicCamera</string>
							<string name="ScriptGuid">{379BC5F9-47C5-4A27-9379-DAA51A5EBA25}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	ClassicCamera - Classic Roblox camera control module
	2018 Camera Update - AllYourBlox

	Note: This module also handles camera control types Follow and Track, the
	latter of which is currently not distinguished from Classic
--]]

-- Local private variables and constants
local ZERO_VECTOR2 = Vector2.new(0,0)

local tweenAcceleration = math.rad(220) -- Radians/Second^2
local tweenSpeed = math.rad(0)          -- Radians/Second
local tweenMaxSpeed = math.rad(250)     -- Radians/Second
local TIME_BEFORE_AUTO_ROTATE = 2       -- Seconds, used when auto-aligning camera with vehicles

local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)
local ZOOM_SENSITIVITY_CURVATURE = 0.5
local FIRST_PERSON_DISTANCE_MIN = 0.5

--[[ Services ]]--
local PlayersService = game:GetService("Players")
local VRService = game:GetService("VRService")

local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local ClassicCamera = setmetatable({}, BaseCamera)
ClassicCamera.__index = ClassicCamera

function ClassicCamera.new()
	local self = setmetatable(BaseCamera.new(), ClassicCamera)

	self.isFollowCamera = false
	self.isCameraToggle = false
	self.lastUpdate = tick()
	self.cameraToggleSpring = Util.Spring.new(5, 0)

	return self
end

function ClassicCamera:GetCameraToggleOffset(dt: number)
	if self.isCameraToggle then
		local zoom = self.currentSubjectDistance

		if CameraInput.getTogglePan() then
			self.cameraToggleSpring.goal = math.clamp(Util.map(zoom, 0.5, self.FIRST_PERSON_DISTANCE_THRESHOLD, 0, 1), 0, 1)
		else
			self.cameraToggleSpring.goal = 0
		end

		local distanceOffset: number = math.clamp(Util.map(zoom, 0.5, 64, 0, 1), 0, 1) + 1
		return Vector3.new(0, self.cameraToggleSpring:step(dt)*distanceOffset, 0)
	end

	return Vector3.new()
end

-- Movement mode standardized to Enum.ComputerCameraMovementMode values
function ClassicCamera:SetCameraMovementMode(cameraMovementMode: Enum.ComputerCameraMovementMode)
	BaseCamera.SetCameraMovementMode(self, cameraMovementMode)

	self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
	self.isCameraToggle = cameraMovementMode == Enum.ComputerCameraMovementMode.CameraToggle
end

function ClassicCamera:Update()
	local now = tick()
	local timeDelta = now - self.lastUpdate

	local camera = workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus

	local overrideCameraLookVector = nil
	if self.resetCameraAngle then
		local rootPart: BasePart = self:GetHumanoidRootPart()
		if rootPart then
			overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
		else
			overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
		end
		self.resetCameraAngle = false
	end

	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")
	local isOnASkateboard = cameraSubject and cameraSubject:IsA("SkateboardPlatform")
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing

	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end

	local rotateInput = CameraInput.getRotation()

	self:StepZoom()

	local cameraHeight = self:GetCameraHeight()

	-- Reset tween speed if user is panning
	if CameraInput.getRotation() ~= Vector2.new() then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end

	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition: Vector3 = self:GetSubjectPosition()

	if subjectPosition and player and camera then
		local zoom = self:GetCameraToSubjectDistance()
		if zoom < 0.5 then
			zoom = 0.5
		end

		if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
			-- We need to use the right vector of the camera after rotation, not before
			local newLookCFrame: CFrame = self:CalculateNewLookCFrameFromArg(overrideCameraLookVector, rotateInput)

			local offset: Vector3 = self:GetMouseLockOffset()
			local cameraRelativeOffset: Vector3 = offset.X * newLookCFrame.RightVector + offset.Y * newLookCFrame.UpVector + offset.Z * newLookCFrame.LookVector

			--offset can be NAN, NAN, NAN if newLookVector has only y component
			if Util.IsFiniteVector3(cameraRelativeOffset) then
				subjectPosition = subjectPosition + cameraRelativeOffset
			end
		else
			local userPanningTheCamera = CameraInput.getRotation() ~= Vector2.new()

			if not userPanningTheCamera and self.lastCameraTransform then

				local isInFirstPerson = self:IsInFirstPerson()

				if (isInVehicle or isOnASkateboard or (self.isFollowCamera and isClimbing)) and self.lastUpdate and humanoid and humanoid.Torso then
					if isInFirstPerson then
						if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
							local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
							if Util.IsFinite(y) then
								rotateInput = rotateInput + Vector2.new(y, 0)
							end
							tweenSpeed = 0
						end
					elseif not userRecentlyPannedCamera then
						local forwardVector = humanoid.Torso.CFrame.lookVector
						tweenSpeed = math.clamp(tweenSpeed + tweenAcceleration * timeDelta, 0, tweenMaxSpeed)

						local percent = math.clamp(tweenSpeed * timeDelta, 0, 1)
						if self:IsInFirstPerson() and not (self.isFollowCamera and self.isClimbing) then
							percent = 1
						end

						local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
						if Util.IsFinite(y) and math.abs(y) > 0.0001 then
							rotateInput = rotateInput + Vector2.new(y * percent, 0)
						end
					end

				elseif self.isFollowCamera and (not (isInFirstPerson or userRecentlyPannedCamera) and not VRService.VREnabled) then
					-- Logic that was unique to the old FollowCamera module
					local lastVec = -(self.lastCameraTransform.p - subjectPosition)

					local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())

					-- This cutoff is to decide if the humanoid's angle of movement,
					-- relative to the camera's look vector, is enough that
					-- we want the camera to be following them. The point is to provide
					-- a sizable dead zone to allow more precise forward movements.
					local thetaCutoff = 0.4

					-- Check for NaNs
					if Util.IsFinite(y) and math.abs(y) > 0.0001 and math.abs(y) > thetaCutoff * timeDelta then
						rotateInput = rotateInput + Vector2.new(y, 0)
					end
				end
			end
		end

		if not self.isFollowCamera then
			local VREnabled = VRService.VREnabled

			if VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			else
				newCameraFocus = CFrame.new(subjectPosition)
			end

			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local vecToSubject = (subjectPosition - camera.CFrame.p)
				local distToSubject = vecToSubject.magnitude

				local flaggedRotateInput = rotateInput

				-- Only move the camera if it exceeded a maximum distance to the subject in VR
				if distToSubject > zoom or flaggedRotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, zoom)
					vecToSubject = self:CalculateNewLookVectorFromArg(nil, rotateInput) * desiredDist
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if flaggedRotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)

					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				local newLookVector = self:CalculateNewLookVectorFromArg(overrideCameraLookVector, rotateInput)
				newCameraCFrame = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
			end
		else -- is FollowCamera
			local newLookVector = self:CalculateNewLookVectorFromArg(overrideCameraLookVector, rotateInput)

			if VRService.VREnabled then
				newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
			else
				newCameraFocus = CFrame.new(subjectPosition)
			end
			newCameraCFrame = CFrame.new(newCameraFocus.p - (zoom * newLookVector), newCameraFocus.p) + Vector3.new(0, cameraHeight, 0)
		end

		local toggleOffset = self:GetCameraToggleOffset(timeDelta)
		newCameraFocus = newCameraFocus + toggleOffset
		newCameraCFrame = newCameraCFrame + toggleOffset

		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA("BasePart") then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end

	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end

function ClassicCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end

function ClassicCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end

return ClassicCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070bc</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0DA1E2A14AD74ABA822090C7DB5CD98C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ZoomController</string>
							<string name="ScriptGuid">{2AD1BE08-A0A0-4F94-A91D-6D92C5C223E4}</string>
							<ProtectedString name="Source"><![CDATA[-- Zoom
-- Controls the distance between the focus and the camera.

local ZOOM_STIFFNESS = 4.5
local ZOOM_DEFAULT = 12.5
local ZOOM_ACCELERATION = 0.0375

local MIN_FOCUS_DIST = 0.5
local DIST_OPAQUE = 1

local Popper = require(script:WaitForChild("Popper"))

local clamp = math.clamp
local exp = math.exp
local min = math.min
local max = math.max
local pi = math.pi

local cameraMinZoomDistance, cameraMaxZoomDistance do
	local Player = game:GetService("Players").LocalPlayer
	assert(Player)

	local function updateBounds()
		cameraMinZoomDistance = Player.CameraMinZoomDistance
		cameraMaxZoomDistance = Player.CameraMaxZoomDistance
	end

	updateBounds()

	Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
	Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
end

local ConstrainedSpring = {} do
	ConstrainedSpring.__index = ConstrainedSpring

	function ConstrainedSpring.new(freq: number, x: number, minValue: number, maxValue: number)
		x = clamp(x, minValue, maxValue)
		return setmetatable({
			freq = freq, -- Undamped frequency (Hz)
			x = x, -- Current position
			v = 0, -- Current velocity
			minValue = minValue, -- Minimum bound
			maxValue = maxValue, -- Maximum bound
			goal = x, -- Goal position
		}, ConstrainedSpring)
	end

	function ConstrainedSpring:Step(dt: number)
		local freq = self.freq :: number * 2 * pi -- Convert from Hz to rad/s
		local x: number = self.x
		local v: number = self.v
		local minValue: number = self.minValue
		local maxValue: number = self.maxValue
		local goal: number = self.goal

		-- Solve the spring ODE for position and velocity after time t, assuming critical damping:
		--   2*f*x'[t] + x''[t] = f^2*(g - x[t])
		-- Knowns are x[0] and x'[0].
		-- Solve for x[t] and x'[t].

		local offset = goal - x
		local step = freq*dt
		local decay = exp(-step)

		local x1 = goal + (v*dt - offset*(step + 1))*decay
		local v1 = ((offset*freq - v)*step + v)*decay

		-- Constrain
		if x1 < minValue then
			x1 = minValue
			v1 = 0
		elseif x1 > maxValue then
			x1 = maxValue
			v1 = 0
		end

		self.x = x1
		self.v = v1

		return x1
	end
end

local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, MIN_FOCUS_DIST, cameraMaxZoomDistance)

local function stepTargetZoom(z: number, dz: number, zoomMin: number, zoomMax: number)
	z = clamp(z + dz*(1 + z*ZOOM_ACCELERATION), zoomMin, zoomMax)
	if z < DIST_OPAQUE then
		z = dz <= 0 and zoomMin or DIST_OPAQUE
	end
	return z
end

local zoomDelta = 0

local Zoom = {} do
	function Zoom.Update(renderDt: number, focus: CFrame, extrapolation)
		local poppedZoom = math.huge

		if zoomSpring.goal > DIST_OPAQUE then
			-- Make a pessimistic estimate of zoom distance for this step without accounting for poppercam
			local maxPossibleZoom = max(
				zoomSpring.x,
				stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance)
			)

			-- Run the Popper algorithm on the feasible zoom range, [MIN_FOCUS_DIST, maxPossibleZoom]
			poppedZoom = Popper(
				focus*CFrame.new(0, 0, MIN_FOCUS_DIST),
				maxPossibleZoom - MIN_FOCUS_DIST,
				extrapolation
			) + MIN_FOCUS_DIST
		end

		zoomSpring.minValue = MIN_FOCUS_DIST
		zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)

		return zoomSpring:Step(renderDt)
	end

	function Zoom.GetZoomRadius()
		return zoomSpring.x
	end

	function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
		zoomSpring.goal = targetZoom
		zoomDelta = newZoomDelta
	end

	function Zoom.ReleaseSpring()
		zoomSpring.x = zoomSpring.goal
		zoomSpring.v = 0
	end
end

return Zoom
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070bd</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX82E41EC6E8DC40D6BE127B6664FFFC9D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Popper</string>
								<string name="ScriptGuid">{D5AFED9C-7ECE-4EED-B7FC-6AFD9DC6B426}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
--------------------------------------------------------------------------------
-- Popper.lua
-- Prevents your camera from clipping through walls.
--------------------------------------------------------------------------------

local Players = game:GetService("Players")

local camera = game.Workspace.CurrentCamera

local min = math.min
local tan = math.tan
local rad = math.rad
local inf = math.huge
local ray = Ray.new

local function getTotalTransparency(part)
	return 1 - (1 - part.Transparency)*(1 - part.LocalTransparencyModifier)
end

local function eraseFromEnd(t, toSize)
	for i = #t, toSize + 1, -1 do
		t[i] = nil
	end
end

local nearPlaneZ, projX, projY do
	local function updateProjection()
		local fov = rad(camera.FieldOfView)
		local view = camera.ViewportSize
		local ar = view.X/view.Y

		projY = 2*tan(fov/2)
		projX = ar*projY
	end

	camera:GetPropertyChangedSignal("FieldOfView"):Connect(updateProjection)
	camera:GetPropertyChangedSignal("ViewportSize"):Connect(updateProjection)

	updateProjection()

	nearPlaneZ = camera.NearPlaneZ
	camera:GetPropertyChangedSignal("NearPlaneZ"):Connect(function()
		nearPlaneZ = camera.NearPlaneZ
	end)
end

local blacklist = {} do
	local charMap = {}

	local function refreshIgnoreList()
		local n = 1
		blacklist = {}
		for _, character in pairs(charMap) do
			blacklist[n] = character
			n = n + 1
		end
	end

	local function playerAdded(player)
		local function characterAdded(character)
			charMap[player] = character
			refreshIgnoreList()
		end
		local function characterRemoving()
			charMap[player] = nil
			refreshIgnoreList()
		end

		player.CharacterAdded:Connect(characterAdded)
		player.CharacterRemoving:Connect(characterRemoving)
		if player.Character then
			characterAdded(player.Character)
		end
	end

	local function playerRemoving(player)
		charMap[player] = nil
		refreshIgnoreList()
	end

	Players.PlayerAdded:Connect(playerAdded)
	Players.PlayerRemoving:Connect(playerRemoving)

	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	refreshIgnoreList()
end

--------------------------------------------------------------------------------------------
-- Popper uses the level geometry find an upper bound on subject-to-camera distance.
--
-- Hard limits are applied immediately and unconditionally. They are generally caused
-- when level geometry intersects with the near plane (with exceptions, see below).
--
-- Soft limits are only applied under certain conditions.
-- They are caused when level geometry occludes the subject without actually intersecting
-- with the near plane at the target distance.
--
-- Soft limits can be promoted to hard limits and hard limits can be demoted to soft limits.
-- We usually don"t want the latter to happen.
--
-- A soft limit will be promoted to a hard limit if an obstruction
-- lies between the current and target camera positions.
--------------------------------------------------------------------------------------------

local subjectRoot
local subjectPart

camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
	local subject = camera.CameraSubject
	if subject:IsA("Humanoid") then
		subjectPart = subject.RootPart
	elseif subject:IsA("BasePart") then
		subjectPart = subject
	else
		subjectPart = nil
	end
end)

local function canOcclude(part)
	-- Occluders must be:
	-- 1. Opaque
	-- 2. Interactable
	-- 3. Not in the same assembly as the subject

	return
		getTotalTransparency(part) < 0.25 and
		part.CanCollide and
		subjectRoot ~= (part:GetRootPart() or part) and
		not part:IsA("TrussPart")
end

-- Offsets for the volume visibility test
local SCAN_SAMPLE_OFFSETS = {
	Vector2.new( 0.4, 0.0),
	Vector2.new(-0.4, 0.0),
	Vector2.new( 0.0,-0.4),
	Vector2.new( 0.0, 0.4),
	Vector2.new( 0.0, 0.2),
}

-- Maximum number of rays that can be cast 
local QUERY_POINT_CAST_LIMIT = 64

--------------------------------------------------------------------------------
-- Piercing raycasts

local function getCollisionPoint(origin, dir)
	local originalSize = #blacklist
	repeat
		local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(
			ray(origin, dir), blacklist, false, true
		)

		if hitPart then
			if hitPart.CanCollide then
				eraseFromEnd(blacklist, originalSize)
				return hitPoint, true
			end
			blacklist[#blacklist + 1] = hitPart
		end
	until not hitPart

	eraseFromEnd(blacklist, originalSize)
	return origin + dir, false
end

--------------------------------------------------------------------------------

local function queryPoint(origin, unitDir, dist, lastPos)
	debug.profilebegin("queryPoint")

	local originalSize = #blacklist

	dist = dist + nearPlaneZ
	local target = origin + unitDir*dist

	local softLimit = inf
	local hardLimit = inf
	local movingOrigin = origin
	
	local numPierced = 0

	repeat
		local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)
		numPierced += 1

		if entryPart then
			-- forces the current iteration into a hard limit to cap the number of raycasts
			local earlyAbort = numPierced >= QUERY_POINT_CAST_LIMIT
			
			if canOcclude(entryPart) or earlyAbort then
				local wl = {entryPart}
				local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)

				local lim = (entryPos - origin).Magnitude

				if exitPart and not earlyAbort then
					local promote = false
					if lastPos then
						promote =
							workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or
							workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
					end

					if promote then
						-- Ostensibly a soft limit, but the camera has passed through it in the last frame, so promote to a hard limit.
						hardLimit = lim
					elseif dist < softLimit then
						-- Trivial soft limit
						softLimit = lim
					end
				else
					-- Trivial hard limit
					hardLimit = lim
				end
			end

			blacklist[#blacklist + 1] = entryPart
			movingOrigin = entryPos - unitDir*1e-3
		end
	until hardLimit < inf or not entryPart

	eraseFromEnd(blacklist, originalSize)

	debug.profileend()
	return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
end

local function queryViewport(focus, dist)
	debug.profilebegin("queryViewport")

	local fP =  focus.p
	local fX =  focus.rightVector
	local fY =  focus.upVector
	local fZ = -focus.lookVector

	local viewport = camera.ViewportSize

	local hardBoxLimit = inf
	local softBoxLimit = inf

	-- Center the viewport on the PoI, sweep points on the edge towards the target, and take the minimum limits
	for viewX = 0, 1 do
		local worldX = fX*((viewX - 0.5)*projX)

		for viewY = 0, 1 do
			local worldY = fY*((viewY - 0.5)*projY)

			local origin = fP + nearPlaneZ*(worldX + worldY)
			local lastPos = camera:ViewportPointToRay(
				viewport.x*viewX,
				viewport.y*viewY
			).Origin

			local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)

			if hardPointLimit < hardBoxLimit then
				hardBoxLimit = hardPointLimit
			end
			if softPointLimit < softBoxLimit then
				softBoxLimit = softPointLimit
			end
		end
	end
	debug.profileend()

	return softBoxLimit, hardBoxLimit
end

local function testPromotion(focus, dist, focusExtrapolation)
	debug.profilebegin("testPromotion")

	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector

	do
		-- Dead reckoning the camera rotation and focus
		debug.profilebegin("extrapolate")

		local SAMPLE_DT = 0.0625
		local SAMPLE_MAX_T = 1.25

		local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity*SAMPLE_MAX_T) - fP).Magnitude
		-- Metric that decides how many samples to take
		local combinedSpeed = focusExtrapolation.posVelocity.magnitude

		for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist/combinedSpeed), SAMPLE_DT do
			local cfDt = focusExtrapolation.extrapolate(dt) -- Extrapolated CFrame at time dt

			if queryPoint(cfDt.p, -cfDt.lookVector, dist) >= dist then
				return false
			end
		end

		debug.profileend()
	end

	do
		-- Test screen-space offsets from the focus for the presence of soft limits
		debug.profilebegin("testOffsets")

		for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
			local scaledOffset = offset
			local pos = getCollisionPoint(fP, fX*scaledOffset.x + fY*scaledOffset.y)
			if queryPoint(pos, (fP + fZ*dist - pos).Unit, dist) == inf then
				return false
			end
		end

		debug.profileend()
	end

	debug.profileend()
	return true
end

local function Popper(focus, targetDist, focusExtrapolation)
	debug.profilebegin("popper")

	subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart

	local dist = targetDist
	local soft, hard = queryViewport(focus, targetDist)
	if hard < dist then
		dist = hard
	end
	if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
		dist = soft
	end

	subjectRoot = nil

	debug.profileend()
	return dist
end

return Popper
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070be</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX5C51341E2AEC49D082A8495CB2CFEB08">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Invisicam</string>
							<string name="ScriptGuid">{14172C9C-9774-481A-8B54-00016535B220}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	Invisicam - Occlusion module that makes objects occluding character view semi-transparent
	2018 Camera Update - AllYourBlox
--]]

--[[ Top Level Roblox Services ]]--
local PlayersService = game:GetService("Players")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local USE_STACKING_TRANSPARENCY = true	-- Multiple items between the subject and camera get transparency values that add up to TARGET_TRANSPARENCY
local TARGET_TRANSPARENCY = 0.75 -- Classic Invisicam's Value, also used by new invisicam for parts hit by head and torso rays
local TARGET_TRANSPARENCY_PERIPHERAL = 0.5 -- Used by new SMART_CIRCLE mode for items not hit by head and torso rays

local MODE = {
	--CUSTOM = 1, 		-- Retired, unused
	LIMBS = 2, 			-- Track limbs
	MOVEMENT = 3, 		-- Track movement
	CORNERS = 4, 		-- Char model corners
	CIRCLE1 = 5, 		-- Circle of casts around character
	CIRCLE2 = 6, 		-- Circle of casts around character, camera relative
	LIMBMOVE = 7, 		-- LIMBS mode + MOVEMENT mode
	SMART_CIRCLE = 8, 	-- More sample points on and around character
	CHAR_OUTLINE = 9,	-- Dynamic outline around the character
}

local LIMB_TRACKING_SET = {
	-- Body parts common to R15 and R6
	['Head'] = true,

	-- Body parts unique to R6
	['Left Arm'] = true,
	['Right Arm'] = true,
	['Left Leg'] = true,
	['Right Leg'] = true,

	-- Body parts unique to R15
	['LeftLowerArm'] = true,
	['RightLowerArm'] = true,
	['LeftUpperLeg'] = true,
	['RightUpperLeg'] = true
}

local CORNER_FACTORS = {
	Vector3.new(1,1,-1),
	Vector3.new(1,-1,-1),
	Vector3.new(-1,-1,-1),
	Vector3.new(-1,1,-1)
}

local CIRCLE_CASTS = 10
local MOVE_CASTS = 3
local SMART_CIRCLE_CASTS = 24
local SMART_CIRCLE_INCREMENT = 2.0 * math.pi / SMART_CIRCLE_CASTS
local CHAR_OUTLINE_CASTS = 24

-- Used to sanitize user-supplied functions
local function AssertTypes(param, ...)
	local allowedTypes = {}
	local typeString = ''
	for _, typeName in pairs({...}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end

-- Helper function for Determinant of 3x3, not in CameraUtils for performance reasons
local function Det3x3(a: number,b: number,c: number,d: number,e: number,f: number,g: number,h: number,i: number): number
	return (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))
end

-- Smart Circle mode needs the intersection of 2 rays that are known to be in the same plane
-- because they are generated from cross products with a common vector. This function is computing
-- that intersection, but it's actually the general solution for the point halfway between where
-- two skew lines come nearest to each other, which is more forgiving.
local function RayIntersection(p0: Vector3, v0: Vector3, p1: Vector3, v1: Vector3): Vector3
	local v2 = v0:Cross(v1)
	local d1 = p1.X - p0.X
	local d2 = p1.Y - p0.Y
	local d3 = p1.Z - p0.Z
	local denom = Det3x3(v0.X,-v1.X,v2.X,v0.Y,-v1.Y,v2.Y,v0.Z,-v1.Z,v2.Z)

	if (denom == 0) then
		return ZERO_VECTOR3 -- No solution (rays are parallel)
	end

	local t0 = Det3x3(d1,-v1.X,v2.X,d2,-v1.Y,v2.Y,d3,-v1.Z,v2.Z) / denom
	local t1 = Det3x3(v0.X,d1,v2.X,v0.Y,d2,v2.Y,v0.Z,d3,v2.Z) / denom
	local s0 = p0 + t0 * v0
	local s1 = p1 + t1 * v1
	local s = s0 + 0.5 * ( s1 - s0 )

	-- 0.25 studs is a threshold for deciding if the rays are
	-- close enough to be considered intersecting, found through testing
	if (s1-s0).Magnitude < 0.25 then
		return s
	else
		return ZERO_VECTOR3
	end
end



--[[ The Module ]]--
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Invisicam = setmetatable({}, BaseOcclusion)
Invisicam.__index = Invisicam

function Invisicam.new()
	local self = setmetatable(BaseOcclusion.new(), Invisicam)

	self.char = nil
	self.humanoidRootPart = nil
	self.torsoPart = nil
	self.headPart = nil

	self.childAddedConn = nil
	self.childRemovedConn = nil

	self.behaviors = {} 	-- Map of modes to behavior fns
	self.behaviors[MODE.LIMBS] = self.LimbBehavior
	self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
	self.behaviors[MODE.CORNERS] = self.CornerBehavior
	self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
	self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
	self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
	self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
	self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior

	self.mode = MODE.SMART_CIRCLE
	self.behaviorFunction = self.SmartCircleBehavior

	self.savedHits = {} 	-- Objects currently being faded in/out
	self.trackedLimbs = {}	-- Used in limb-tracking casting modes

	self.camera = game.Workspace.CurrentCamera

	self.enabled = false
	return self
end

function Invisicam:Enable(enable)
	self.enabled = enable

	if not enable then
		self:Cleanup()
	end
end

function Invisicam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Invisicam
end

--[[ Module functions ]]--
function Invisicam:LimbBehavior(castPoints)
	for limb, _ in pairs(self.trackedLimbs) do
		castPoints[#castPoints + 1] = limb.Position
	end
end

function Invisicam:MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position: Vector3, velocity: Vector3 = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
		local horizontalSpeed: number = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector: Vector3 = (i - 1) * self.humanoidRootPart.CFrame.lookVector :: Vector3 * horizontalSpeed
		castPoints[#castPoints + 1] = position + offsetVector
	end
end

function Invisicam:CornerBehavior(castPoints)
	local cframe: CFrame = self.humanoidRootPart.CFrame
	local centerPoint: Vector3 = cframe.Position
	local rotation = cframe - centerPoint
	local halfSize = self.char:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
	castPoints[#castPoints + 1] = centerPoint
	for i = 1, #CORNER_FACTORS do
		castPoints[#castPoints + 1] = centerPoint + (rotation * (halfSize * CORNER_FACTORS[i]))
	end
end

function Invisicam:CircleBehavior(castPoints)
	local cframe: CFrame
	if self.mode == MODE.CIRCLE1 then
		cframe = self.humanoidRootPart.CFrame
	else
		local camCFrame: CFrame = self.camera.CoordinateFrame
		cframe = camCFrame - camCFrame.Position + self.humanoidRootPart.Position
	end
	castPoints[#castPoints + 1] = cframe.Position
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = (2 * math.pi / CIRCLE_CASTS) * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		castPoints[#castPoints + 1] = cframe * offset
	end
end

function Invisicam:LimbMoveBehavior(castPoints)
	self:LimbBehavior(castPoints)
	self:MoveBehavior(castPoints)
end

function Invisicam:CharacterOutlineBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit

	-- Torso cross of points for interior coverage
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end

	local cframe = CFrame.new(ZERO_VECTOR3,Vector3.new(self.camera.CoordinateFrame.lookVector.X,0,self.camera.CoordinateFrame.lookVector.Z))
	local centerPoint = (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)

	local partsWhitelist = {self.torsoPart}
	if self.headPart then
		partsWhitelist[#partsWhitelist + 1] = self.headPart
	end

	for i = 1, CHAR_OUTLINE_CASTS do
		local angle = (2 * math.pi * i / CHAR_OUTLINE_CASTS)
		local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))

		offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)

		local ray = Ray.new(centerPoint + offset, -3 * offset)
		local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false)

		if hit then
			-- Use hit point as the cast point, but nudge it slightly inside the character so that bumping up against
			-- walls is less likely to cause a transparency glitch
			castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
		end
	end
end

function Invisicam:SmartCircleBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit

	-- SMART_CIRCLE mode includes rays to head and 5 to the torso.
	-- Hands, arms, legs and feet are not included since they
	-- are not canCollide and can therefore go inside of parts
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end

	local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
	local torsoPoint = Vector3.new(0,0.5,0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	local radius = 2.5

	-- This loop first calculates points in a circle of radius 2.5 around the torso of the character, in the
	-- plane orthogonal to the camera's lookVector. Each point is then raycast to, to determine if it is within
	-- the free space surrounding the player (not inside anything). Two iterations are done to adjust points that
	-- are inside parts, to try to move them to valid locations that are still on their camera ray, so that the
	-- circle remains circular from the camera's perspective, but does not cast rays into walls or parts that are
	-- behind, below or beside the character and not really obstructing view of the character. This minimizes
	-- the undesirable situation where the character walks up to an exterior wall and it is made invisible even
	-- though it is behind the character.
	for i = 1, SMART_CIRCLE_CASTS do
		local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
		local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
		local circlePoint = torsoPoint + cameraOrientation * offset

		-- Vector from camera to point on the circle being tested
		local vp = circlePoint - self.camera.CFrame.p

		local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
		local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
		local castPoint = circlePoint

		if hit then
			local hprime = hp + 0.1 * hitNormal.unit -- Slightly offset hit point from the hit surface
			local v0 = hprime - torsoPoint -- Vector from torso to offset hit point

			local perp = (v0:Cross(vp)).unit

			-- Vector from the offset hit point, along the hit surface
			local v1 = (perp:Cross(hitNormal)).unit

			-- Vector from camera to offset hit
			local vprime = (hprime - self.camera.CFrame.p).unit

			-- This dot product checks to see if the vector along the hit surface would hit the correct
			-- side of the invisicam cone, or if it would cross the camera look vector and hit the wrong side
			if ( v0.unit:Dot(-v1) < v0.unit:Dot(vprime)) then
				castPoint = RayIntersection(hprime, v1, circlePoint, vp)

				if castPoint.Magnitude > 0 then
					local ray = Ray.new(hprime, castPoint - hprime)
					local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )

					if hit then
						local hprime2 = hitPoint + 0.1 * hitNormal.unit
						castPoint = hprime2
					end
				else
					castPoint = hprime
				end
			else
				castPoint = hprime
			end

			local ray = Ray.new(torsoPoint, (castPoint - torsoPoint))
			local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )

			if hit then
				local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
				castPoint = castPoint2
			end
		end

		castPoints[#castPoints + 1] = castPoint
	end
end

function Invisicam:CheckTorsoReference()
	if self.char then
		self.torsoPart = self.char:FindFirstChild("Torso")
		if not self.torsoPart then
			self.torsoPart = self.char:FindFirstChild("UpperTorso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
			end
		end

		self.headPart = self.char:FindFirstChild("Head")
	end
end

function Invisicam:CharacterAdded(char: Model, player: Player)
	-- We only want the LocalPlayer's character
	if player~=PlayersService.LocalPlayer then return end

	if self.childAddedConn then
		self.childAddedConn:Disconnect()
		self.childAddedConn = nil
	end
	if self.childRemovedConn then
		self.childRemovedConn:Disconnect()
		self.childRemovedConn = nil
	end

	self.char = char

	self.trackedLimbs = {}
	local function childAdded(child)
		if child:IsA("BasePart") then
			if LIMB_TRACKING_SET[child.Name] then
				self.trackedLimbs[child] = true
			end

			if child.Name == "Torso" or child.Name == "UpperTorso" then
				self.torsoPart = child
			end

			if child.Name == "Head" then
				self.headPart = child
			end
		end
	end

	local function childRemoved(child)
		self.trackedLimbs[child] = nil

		-- If removed/replaced part is 'Torso' or 'UpperTorso' double check that we still have a TorsoPart to use
		self:CheckTorsoReference()
	end

	self.childAddedConn = char.ChildAdded:Connect(childAdded)
	self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
	for _, child in pairs(self.char:GetChildren()) do
		childAdded(child)
	end
end

function Invisicam:SetMode(newMode: number)
	AssertTypes(newMode, 'number')
	for _, modeNum in pairs(MODE) do
		if modeNum == newMode then
			self.mode = newMode
			self.behaviorFunction = self.behaviors[self.mode]
			return
		end
	end
	error("Invalid mode number")
end

function Invisicam:GetObscuredParts()
	return self.savedHits
end

-- Want to turn off Invisicam? Be sure to call this after.
function Invisicam:Cleanup()
	for hit, originalFade in pairs(self.savedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end

function Invisicam:Update(dt: number, desiredCameraCFrame: CFrame, desiredCameraFocus: CFrame): (CFrame, CFrame)
	-- Bail if there is no Character
	if not self.enabled or not self.char then
		return desiredCameraCFrame, desiredCameraFocus
	end

	self.camera = game.Workspace.CurrentCamera

	-- TODO: Move this to a GetHumanoidRootPart helper, probably combine with CheckTorsoReference
	-- Make sure we still have a HumanoidRootPart
	if not self.humanoidRootPart then
		local humanoid = self.char:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.RootPart then
			self.humanoidRootPart = humanoid.RootPart
		else
			-- Not set up with Humanoid? Try and see if there's one in the Character at all:
			self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
			if not self.humanoidRootPart then
				-- Bail out, since we're relying on HumanoidRootPart existing
				return desiredCameraCFrame, desiredCameraFocus
			end
		end

		-- TODO: Replace this with something more sensible
		local ancestryChangedConn
		ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
			if child == self.humanoidRootPart and not parent then
				self.humanoidRootPart = nil
				if ancestryChangedConn and ancestryChangedConn.Connected then
					ancestryChangedConn:Disconnect()
					ancestryChangedConn = nil
				end
			end
		end)
	end

	if not self.torsoPart then
		self:CheckTorsoReference()
		if not self.torsoPart then
			-- Bail out, since we're relying on Torso existing, should never happen since we fall back to using HumanoidRootPart as torso
			return desiredCameraCFrame, desiredCameraFocus
		end
	end

	-- Make a list of world points to raycast to
	local castPoints = {}
	self.behaviorFunction(self, castPoints)

	-- Cast to get a list of objects between the camera and the cast points
	local currentHits = {}
	local ignoreList = {self.char}
	local function add(hit)
		currentHits[hit] = true
		if not self.savedHits[hit] then
			self.savedHits[hit] = hit.LocalTransparencyModifier
		end
	end

	local hitParts
	local hitPartCount = 0

	-- Hash table to treat head-ray-hit parts differently than the rest of the hit parts hit by other rays
	-- head/torso ray hit parts will be more transparent than peripheral parts when USE_STACKING_TRANSPARENCY is enabled
	local headTorsoRayHitParts = {}

	local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
	local perPartTransparencyOtherHits = TARGET_TRANSPARENCY

	if USE_STACKING_TRANSPARENCY then

		-- This first call uses head and torso rays to find out how many parts are stacked up
		-- for the purpose of calculating required per-part transparency
		local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
		local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
		hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)

		-- Count how many things the sample rays passed through, including decals. This should only
		-- count decals facing the camera, but GetPartsObscuringTarget does not return surface normals,
		-- so my compromise for now is to just let any decal increase the part count by 1. Only one
		-- decal per part will be considered.
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
			hitPartCount = hitPartCount + 1 -- count the part itself
			headTorsoRayHitParts[hitPart] = true
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA('Decal') or child:IsA('Texture') then
					hitPartCount = hitPartCount + 1 -- count first decal hit, then break
					break
				end
			end
		end

		if (hitPartCount > 0) then
			perPartTransparencyHeadTorsoHits = math.pow( ((0.5 * TARGET_TRANSPARENCY) + (0.5 * TARGET_TRANSPARENCY / hitPartCount)), 1 / hitPartCount )
			perPartTransparencyOtherHits = math.pow( ((0.5 * TARGET_TRANSPARENCY_PERIPHERAL) + (0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount)), 1 / hitPartCount )
		end
	end

	-- Now get all the parts hit by all the rays
	hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)

	local partTargetTransparency = {}

	-- Include decals and textures
	for i = 1, #hitParts do
		local hitPart = hitParts[i]

		partTargetTransparency[hitPart] =headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits

		-- If the part is not already as transparent or more transparent than what invisicam requires, add it to the list of
		-- parts to be modified by invisicam
		if hitPart.Transparency < partTargetTransparency[hitPart] then
			add(hitPart)
		end

		-- Check all decals and textures on the part
		for _, child in pairs(hitPart:GetChildren()) do
			if child:IsA('Decal') or child:IsA('Texture') then
				if (child.Transparency < partTargetTransparency[hitPart]) then
					partTargetTransparency[child] = partTargetTransparency[hitPart]
					add(child)
				end
			end
		end
	end

	-- Invisibilize objects that are in the way, restore those that aren't anymore
	for hitPart, originalLTM in pairs(self.savedHits) do
		if currentHits[hitPart] then
			-- LocalTransparencyModifier gets whatever value is required to print the part's total transparency to equal perPartTransparency
			hitPart.LocalTransparencyModifier = (hitPart.Transparency < 1) and ((partTargetTransparency[hitPart] - hitPart.Transparency) / (1.0 - hitPart.Transparency)) or 0
		else -- Restore original pre-invisicam value of LTM
			hitPart.LocalTransparencyModifier = originalLTM
			self.savedHits[hitPart] = nil
		end
	end

	-- Invisicam does not change the camera values
	return desiredCameraCFrame, desiredCameraFocus
end

return Invisicam
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070bf</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDC5C22A37820419CB1EE51D2F66DB3F4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseCamera</string>
							<string name="ScriptGuid">{7D38C306-5BF6-4056-B863-D92854AAAA7C}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--!nolint DeprecatedApi
--[[
	BaseCamera - Abstract base class for camera control modules
	2018 Camera Update - AllYourBlox
--]]

--[[ Local Constants ]]--
local UNIT_Z = Vector3.new(0,0,1)
local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane

local DEFAULT_DISTANCE = 12.5	-- Studs
local PORTRAIT_DEFAULT_DISTANCE = 25		-- Studs
local FIRST_PERSON_DISTANCE_THRESHOLD = 1.0 -- Below this value, snap into first person

-- Note: DotProduct check in CoordinateFrame::lookAt() prevents using values within about
-- 8.11 degrees of the +/- Y axis, that's why these limits are currently 80 degrees
local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)

local VR_ANGLE = math.rad(15)
local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
local VR_LOW_INTENSITY_REPEAT = 0.1
local VR_HIGH_INTENSITY_REPEAT = 0.4

local ZERO_VECTOR2 = Vector2.new(0,0)
local ZERO_VECTOR3 = Vector3.new(0,0,0)

local SEAT_OFFSET = Vector3.new(0,5,0)
local VR_SEAT_OFFSET = Vector3.new(0,4,0)
local HEAD_OFFSET = Vector3.new(0,1.5,0)
local R15_HEAD_OFFSET = Vector3.new(0, 1.5, 0)
local R15_HEAD_OFFSET_NO_SCALING = Vector3.new(0, 2, 0)
local HUMANOID_ROOT_PART_SIZE = Vector3.new(2, 2, 1)

local GAMEPAD_ZOOM_STEP = 10
local GAMEPAD_ZOOM_STEP_1 = 0
local GAMEPAD_ZOOM_STEP_2 = 10
local GAMEPAD_ZOOM_STEP_3 = 20

local ZOOM_SENSITIVITY_CURVATURE = 0.5
local FIRST_PERSON_DISTANCE_MIN = 0.5

local CameraUtils = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local CameraToggleStateController = require(script.Parent:WaitForChild("CameraToggleStateController"))
local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
local CameraUI = require(script.Parent:WaitForChild("CameraUI"))

--[[ Roblox Services ]]--
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

local player = Players.LocalPlayer

-- [[ Flags ]]
local FFlagUserCameraGamepadZoomFix
do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserCameraGamepadZoomFix")
	end)
	FFlagUserCameraGamepadZoomFix = success and result
end

--[[ The Module ]]--
local BaseCamera = {}
BaseCamera.__index = BaseCamera

function BaseCamera.new()
	local self = setmetatable({}, BaseCamera)

	-- So that derived classes have access to this
	self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD

	self.cameraType = nil
	self.cameraMovementMode = nil

	self.lastCameraTransform = nil
	self.lastUserPanCamera = tick()

	self.humanoidRootPart = nil
	self.humanoidCache = {}

	-- Subject and position on last update call
	self.lastSubject = nil
	self.lastSubjectPosition = Vector3.new(0, 5, 0)
	self.lastSubjectCFrame = CFrame.new(self.lastSubjectPosition)

	-- These subject distance members refer to the nominal camera-to-subject follow distance that the camera
	-- is trying to maintain, not the actual measured value.
	-- The default is updated when screen orientation or the min/max distances change,
	-- to be sure the default is always in range and appropriate for the orientation.
	self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
	self.currentSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)

	self.inFirstPerson = false
	self.inMouseLockedMode = false
	self.portraitMode = false
	self.isSmallTouchScreen = false

	-- Used by modules which want to reset the camera angle on respawn.
	self.resetCameraAngle = true

	self.enabled = false

	-- Input Event Connections

	self.PlayerGui = nil

	self.cameraChangedConn = nil
	self.viewportSizeChangedConn = nil

	-- VR Support
	self.shouldUseVRRotation = false
	self.VRRotationIntensityAvailable = false
	self.lastVRRotationIntensityCheckTime = 0
	self.lastVRRotationTime = 0
	self.vrRotateKeyCooldown = {}
	self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
	self.humanoidJumpOrigin = nil
	self.trackingHumanoid = nil
	self.cameraFrozen = false
	self.subjectStateChangedConn = nil

	self.gamepadZoomPressConnection = nil

	-- Mouse locked formerly known as shift lock mode
	self.mouseLockOffset = ZERO_VECTOR3

	-- Initialization things used to always execute at game load time, but now these camera modules are instantiated
	-- when needed, so the code here may run well after the start of the game

	if player.Character then
		self:OnCharacterAdded(player.Character)
	end

	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)

	if self.cameraChangedConn then self.cameraChangedConn:Disconnect() end
	self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	self:OnCurrentCameraChanged()

	if self.playerCameraModeChangeConn then self.playerCameraModeChangeConn:Disconnect() end
	self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)

	if self.minDistanceChangeConn then self.minDistanceChangeConn:Disconnect() end
	self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)

	if self.maxDistanceChangeConn then self.maxDistanceChangeConn:Disconnect() end
	self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)

	if self.playerDevTouchMoveModeChangeConn then self.playerDevTouchMoveModeChangeConn:Disconnect() end
	self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
		self:OnDevTouchMovementModeChanged()
	end)
	self:OnDevTouchMovementModeChanged() -- Init

	if self.gameSettingsTouchMoveMoveChangeConn then self.gameSettingsTouchMoveMoveChangeConn:Disconnect() end
	self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
		self:OnGameSettingsTouchMovementModeChanged()
	end)
	self:OnGameSettingsTouchMovementModeChanged() -- Init

	UserGameSettings:SetCameraYInvertVisible()
	UserGameSettings:SetGamepadCameraSensitivityVisible()

	self.hasGameLoaded = game:IsLoaded()
	if not self.hasGameLoaded then
		self.gameLoadedConn = game.Loaded:Connect(function()
			self.hasGameLoaded = true
			self.gameLoadedConn:Disconnect()
			self.gameLoadedConn = nil
		end)
	end

	self:OnPlayerCameraPropertyChange()

	return self
end

function BaseCamera:GetModuleName()
	return "BaseCamera"
end

function BaseCamera:OnCharacterAdded(char)
	self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
	self.humanoidRootPart = nil
	if UserInputService.TouchEnabled then
		self.PlayerGui = player:WaitForChild("PlayerGui")
		for _, child in ipairs(char:GetChildren()) do
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end
		char.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end)
		char.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = false
			end
		end)
	end
end

function BaseCamera:GetHumanoidRootPart(): BasePart
	if not self.humanoidRootPart then
		if player.Character then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidRootPart = humanoid.RootPart
			end
		end
	end
	return self.humanoidRootPart
end

function BaseCamera:GetBodyPartToFollow(humanoid: Humanoid, isDead: boolean) -- BasePart
	-- If the humanoid is dead, prefer the head part if one still exists as a sibling of the humanoid
	if humanoid:GetState() == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character and character:IsA("Model") then
			return character:FindFirstChild("Head") or humanoid.RootPart
		end
	end

	return humanoid.RootPart
end

function BaseCamera:GetSubjectCFrame(): CFrame
	local result = self.lastSubjectCFrame
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if not cameraSubject then
		return result
	end

	if cameraSubject:IsA("Humanoid") then
		local humanoid = cameraSubject
		local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead

		local bodyPartToFollow = humanoid.RootPart

		-- If the humanoid is dead, prefer their head part as a follow target, if it exists
		if humanoidIsDead then
			if humanoid.Parent and humanoid.Parent:IsA("Model") then
				bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
			end
		end

		if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
			local heightOffset
			if humanoid.RigType == Enum.HumanoidRigType.R15 then
				if humanoid.AutomaticScalingEnabled then
					heightOffset = R15_HEAD_OFFSET

					local rootPart = humanoid.RootPart
					if bodyPartToFollow == rootPart then
						local rootPartSizeOffset = (rootPart.Size.Y - HUMANOID_ROOT_PART_SIZE.Y)/2
						heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
					end
				else
					heightOffset = R15_HEAD_OFFSET_NO_SCALING
				end
			else
				heightOffset = HEAD_OFFSET
			end

			if humanoidIsDead then
				heightOffset = ZERO_VECTOR3
			end

			result = bodyPartToFollow.CFrame*CFrame.new(heightOffset + humanoid.CameraOffset)
		end

	elseif cameraSubject:IsA("BasePart") then
		result = cameraSubject.CFrame

	elseif cameraSubject:IsA("Model") then
		-- Model subjects are expected to have a PrimaryPart to determine orientation
		if cameraSubject.PrimaryPart then
			result = cameraSubject:GetPrimaryPartCFrame()
		else
			result = CFrame.new()
		end
	end

	if result then
		self.lastSubjectCFrame = result
	end

	return result
end

function BaseCamera:GetSubjectVelocity(): Vector3
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if not cameraSubject then
		return ZERO_VECTOR3
	end

	if cameraSubject:IsA("BasePart") then
		return cameraSubject.Velocity

	elseif cameraSubject:IsA("Humanoid") then
		local rootPart = cameraSubject.RootPart

		if rootPart then
			return rootPart.Velocity
		end

	elseif cameraSubject:IsA("Model") then
		local primaryPart = cameraSubject.PrimaryPart

		if primaryPart then
			return primaryPart.Velocity
		end
	end

	return ZERO_VECTOR3
end

function BaseCamera:GetSubjectRotVelocity(): Vector3
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if not cameraSubject then
		return ZERO_VECTOR3
	end

	if cameraSubject:IsA("BasePart") then
		return cameraSubject.RotVelocity

	elseif cameraSubject:IsA("Humanoid") then
		local rootPart = cameraSubject.RootPart

		if rootPart then
			return rootPart.RotVelocity
		end

	elseif cameraSubject:IsA("Model") then
		local primaryPart = cameraSubject.PrimaryPart

		if primaryPart then
			return primaryPart.RotVelocity
		end
	end

	return ZERO_VECTOR3
end

function BaseCamera:StepZoom()
	local zoom: number = self.currentSubjectDistance
	local zoomDelta: number = CameraInput.getZoomDelta()

	if math.abs(zoomDelta) > 0 then
		local newZoom

		if zoomDelta > 0 then
			newZoom = zoom + zoomDelta*(1 + zoom*ZOOM_SENSITIVITY_CURVATURE)
			newZoom = math.max(newZoom, self.FIRST_PERSON_DISTANCE_THRESHOLD)
		else
			newZoom = (zoom + zoomDelta)/(1 - zoomDelta*ZOOM_SENSITIVITY_CURVATURE)
			newZoom = math.max(newZoom, FIRST_PERSON_DISTANCE_MIN)
		end

		if newZoom < self.FIRST_PERSON_DISTANCE_THRESHOLD then
			newZoom = FIRST_PERSON_DISTANCE_MIN
		end

		self:SetCameraToSubjectDistance(newZoom)
	end

	return ZoomController.GetZoomRadius()
end

function BaseCamera:GetSubjectPosition(): Vector3?
	local result = self.lastSubjectPosition
	local camera = game.Workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if cameraSubject then
		if cameraSubject:IsA("Humanoid") then
			local humanoid = cameraSubject
			local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead

			local bodyPartToFollow = humanoid.RootPart

			-- If the humanoid is dead, prefer their head part as a follow target, if it exists
			if humanoidIsDead then
				if humanoid.Parent and humanoid.Parent:IsA("Model") then
					bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
				end
			end

			if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
				local heightOffset
				if humanoid.RigType == Enum.HumanoidRigType.R15 then
					if humanoid.AutomaticScalingEnabled then
						heightOffset = R15_HEAD_OFFSET
						if bodyPartToFollow == humanoid.RootPart then
							local rootPartSizeOffset = (humanoid.RootPart.Size.Y/2) - (HUMANOID_ROOT_PART_SIZE.Y/2)
							heightOffset = heightOffset + Vector3.new(0, rootPartSizeOffset, 0)
						end
					else
						heightOffset = R15_HEAD_OFFSET_NO_SCALING
					end
				else
					heightOffset = HEAD_OFFSET
				end

				if humanoidIsDead then
					heightOffset = ZERO_VECTOR3
				end

				result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
			end

		elseif cameraSubject:IsA("VehicleSeat") then
			local offset = SEAT_OFFSET
			result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
		elseif cameraSubject:IsA("SkateboardPlatform") then
			result = cameraSubject.CFrame.p + SEAT_OFFSET
		elseif cameraSubject:IsA("BasePart") then
			result = cameraSubject.CFrame.p
		elseif cameraSubject:IsA("Model") then
			if cameraSubject.PrimaryPart then
				result = cameraSubject:GetPrimaryPartCFrame().p
			else
				result = cameraSubject:GetModelCFrame().p
			end
		end
	else
		-- cameraSubject is nil
		-- Note: Previous RootCamera did not have this else case and let self.lastSubject and self.lastSubjectPosition
		-- both get set to nil in the case of cameraSubject being nil. This function now exits here to preserve the
		-- last set valid values for these, as nil values are not handled cases
		return nil
	end

	self.lastSubject = cameraSubject
	self.lastSubjectPosition = result

	return result
end

function BaseCamera:UpdateDefaultSubjectDistance()
	if self.portraitMode then
		self.defaultSubjectDistance = math.clamp(PORTRAIT_DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
	else
		self.defaultSubjectDistance = math.clamp(DEFAULT_DISTANCE, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
	end
end

function BaseCamera:OnViewportSizeChanged()
	local camera = game.Workspace.CurrentCamera
	local size = camera.ViewportSize
	self.portraitMode = size.X < size.Y
	self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)

	self:UpdateDefaultSubjectDistance()
end

-- Listener for changes to workspace.CurrentCamera
function BaseCamera:OnCurrentCameraChanged()
	if UserInputService.TouchEnabled then
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end

		local newCamera = game.Workspace.CurrentCamera

		if newCamera then
			self:OnViewportSizeChanged()
			self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				self:OnViewportSizeChanged()
			end)
		end
	end

	-- VR support additions
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
		self.cameraSubjectChangedConn = nil
	end

	local camera = game.Workspace.CurrentCamera
	if camera then
		self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnNewCameraSubject()
		end)
		self:OnNewCameraSubject()
	end
end

function BaseCamera:OnDynamicThumbstickEnabled()
	if UserInputService.TouchEnabled then
		self.isDynamicThumbstickEnabled = true
	end
end

function BaseCamera:OnDynamicThumbstickDisabled()
	self.isDynamicThumbstickEnabled = false
end

function BaseCamera:OnGameSettingsTouchMovementModeChanged()
	if player.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
		if (UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.DynamicThumbstick
			or UserGameSettings.TouchMovementMode == Enum.TouchMovementMode.Default) then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnDynamicThumbstickDisabled()
		end
	end
end

function BaseCamera:OnDevTouchMovementModeChanged()
	if player.DevTouchMovementMode == Enum.DevTouchMovementMode.DynamicThumbstick then
		self:OnDynamicThumbstickEnabled()
	else
		self:OnGameSettingsTouchMovementModeChanged()
	end
end

function BaseCamera:OnPlayerCameraPropertyChange()
	-- This call forces re-evaluation of player.CameraMode and clamping to min/max distance which may have changed
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end

function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
	return translationVector * sensitivity
end

function BaseCamera:GamepadZoomPress()
	local dist = self:GetCameraToSubjectDistance()

	if FFlagUserCameraGamepadZoomFix then
		local cameraMinZoomDistance = player.CameraMinZoomDistance
		local cameraMaxZoomDistance = player.CameraMaxZoomDistance

		local ZOOM_STEP_1 = 0

		-- Adjust steps such that the minimum zoom level is not subceeded
		if cameraMinZoomDistance > FIRST_PERSON_DISTANCE_MIN then
			ZOOM_STEP_1 = cameraMinZoomDistance
		end
	
		local ZOOM_STEP_2 = ZOOM_STEP_1 + GAMEPAD_ZOOM_STEP
		local ZOOM_STEP_3 = ZOOM_STEP_2 + GAMEPAD_ZOOM_STEP

		-- Adjust steps such that maximum zoom level is not exceeded
		if cameraMaxZoomDistance < ZOOM_STEP_3 then
			ZOOM_STEP_3 = cameraMaxZoomDistance
			ZOOM_STEP_2 = ZOOM_STEP_1 + (ZOOM_STEP_3 - ZOOM_STEP_1)/2
		end
		
		if dist > (ZOOM_STEP_2 + ZOOM_STEP_3)/2 then
			self:SetCameraToSubjectDistance(ZOOM_STEP_2)
		elseif dist > (ZOOM_STEP_1 + ZOOM_STEP_2)/2 then
			self:SetCameraToSubjectDistance(ZOOM_STEP_1)
		else
			self:SetCameraToSubjectDistance(ZOOM_STEP_3)
		end
	else
		if dist > (GAMEPAD_ZOOM_STEP_2 + GAMEPAD_ZOOM_STEP_3)/2 then
			self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_2)
		elseif dist > (GAMEPAD_ZOOM_STEP_1 + GAMEPAD_ZOOM_STEP_2)/2 then
			self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_1)
		else
			self:SetCameraToSubjectDistance(GAMEPAD_ZOOM_STEP_3)
		end
	end
end

function BaseCamera:Enable(enable: boolean)
	if self.enabled ~= enable then
		self.enabled = enable
		if self.enabled then
			CameraInput.setInputEnabled(true)

			self.gamepadZoomPressConnection = CameraInput.gamepadZoomPress:Connect(function()
				self:GamepadZoomPress()
			end)

			if player.CameraMode == Enum.CameraMode.LockFirstPerson then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			end
		else
			CameraInput.setInputEnabled(false)

			if self.gamepadZoomPressConnection then
				self.gamepadZoomPressConnection:Disconnect()
				self.gamepadZoomPressConnection = nil
			end
			-- Clean up additional event listeners and reset a bunch of properties
			self:Cleanup()
		end

		self:OnEnable(enable)
	end
end

function BaseCamera:OnEnable(enable: boolean)
	-- for derived camera
end

function BaseCamera:GetEnabled(): boolean
	return self.enabled
end

function BaseCamera:Cleanup()
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	if self.viewportSizeChangedConn then
		self.viewportSizeChangedConn:Disconnect()
		self.viewportSizeChangedConn = nil
	end

	self.lastCameraTransform = nil
	self.lastSubjectCFrame = nil

	-- Unlock mouse for example if right mouse button was being held down
	CameraUtils.restoreMouseBehavior()
end

function BaseCamera:UpdateMouseBehavior()
	local blockToggleDueToClickToMove = UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove

	if self.isCameraToggle and blockToggleDueToClickToMove == false then
		CameraUI.setCameraModeToastEnabled(true)
		CameraInput.enableCameraToggleInput()
		CameraToggleStateController(self.inFirstPerson)
	else
		CameraUI.setCameraModeToastEnabled(false)
		CameraInput.disableCameraToggleInput()

		-- first time transition to first person mode or mouse-locked third person
		if self.inFirstPerson or self.inMouseLockedMode then
			CameraUtils.setRotationTypeOverride(Enum.RotationType.CameraRelative)
			CameraUtils.setMouseBehaviorOverride(Enum.MouseBehavior.LockCenter)
		else
			CameraUtils.restoreRotationType()

			local rotationActivated = CameraInput.getRotationActivated()
			if rotationActivated then
				CameraUtils.setMouseBehaviorOverride(Enum.MouseBehavior.LockCurrentPosition)
			else
				CameraUtils.restoreMouseBehavior()
			end
		end
	end
end

function BaseCamera:UpdateForDistancePropertyChange()
	-- Calling this setter with the current value will force checking that it is still
	-- in range after a change to the min/max distance limits
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end

function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance: number): number
	local lastSubjectDistance = self.currentSubjectDistance

	-- By default, camera modules will respect LockFirstPerson and override the currentSubjectDistance with 0
	-- regardless of what Player.CameraMinZoomDistance is set to, so that first person can be made
	-- available by the developer without needing to allow players to mousewheel dolly into first person.
	-- Some modules will override this function to remove or change first-person capability.
	if player.CameraMode == Enum.CameraMode.LockFirstPerson then
		self.currentSubjectDistance = 0.5
		if not self.inFirstPerson then
			self:EnterFirstPerson()
		end
	else
		local newSubjectDistance = math.clamp(desiredSubjectDistance, player.CameraMinZoomDistance, player.CameraMaxZoomDistance)
		if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			self.currentSubjectDistance = newSubjectDistance
			if self.inFirstPerson then
				self:LeaveFirstPerson()
			end
		end
	end

	-- Pass target distance and zoom direction to the zoom controller
	ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))

	-- Returned only for convenience to the caller to know the outcome
	return self.currentSubjectDistance
end

function BaseCamera:SetCameraType( cameraType )
	--Used by derived classes
	self.cameraType = cameraType
end

function BaseCamera:GetCameraType()
	return self.cameraType
end

-- Movement mode standardized to Enum.ComputerCameraMovementMode values
function BaseCamera:SetCameraMovementMode( cameraMovementMode )
	self.cameraMovementMode = cameraMovementMode
end

function BaseCamera:GetCameraMovementMode()
	return self.cameraMovementMode
end

function BaseCamera:SetIsMouseLocked(mouseLocked: boolean)
	self.inMouseLockedMode = mouseLocked
end

function BaseCamera:GetIsMouseLocked(): boolean
	return self.inMouseLockedMode
end

function BaseCamera:SetMouseLockOffset(offsetVector)
	self.mouseLockOffset = offsetVector
end

function BaseCamera:GetMouseLockOffset()
	return self.mouseLockOffset
end

function BaseCamera:InFirstPerson(): boolean
	return self.inFirstPerson
end

function BaseCamera:EnterFirstPerson()
	-- Overridden in ClassicCamera, the only module which supports FirstPerson
end

function BaseCamera:LeaveFirstPerson()
	-- Overridden in ClassicCamera, the only module which supports FirstPerson
end

-- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
function BaseCamera:GetCameraToSubjectDistance(): number
	return self.currentSubjectDistance
end

-- Actual measured distance to the camera Focus point, which may be needed in special circumstances, but should
-- never be used as the starting point for updating the nominal camera-to-subject distance (self.currentSubjectDistance)
-- since that is a desired target value set only by mouse wheel (or equivalent) input, PopperCam, and clamped to min max camera distance
function BaseCamera:GetMeasuredDistanceToFocus(): number?
	local camera = game.Workspace.CurrentCamera
	if camera then
		return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
	end
	return nil
end

function BaseCamera:GetCameraLookVector(): Vector3
	return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.LookVector or UNIT_Z
end

function BaseCamera:CalculateNewLookCFrameFromArg(suppliedLookVector: Vector3?, rotateInput: Vector2): CFrame
	local currLookVector: Vector3 = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.Y)
	local yTheta = math.clamp(rotateInput.Y, -MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle)
	local constrainedRotateInput = Vector2.new(rotateInput.X, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.X, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.Y,0,0)
	return newLookCFrame
end

function BaseCamera:CalculateNewLookVectorFromArg(suppliedLookVector: Vector3?, rotateInput: Vector2): Vector3
	local newLookCFrame = self:CalculateNewLookCFrameFromArg(suppliedLookVector, rotateInput)
	return newLookCFrame.LookVector
end

function BaseCamera:CalculateNewLookVectorVRFromArg(rotateInput: Vector2): Vector3
	local subjectPosition: Vector3 = self:GetSubjectPosition()
	local vecToSubject: Vector3 = (subjectPosition - (game.Workspace.CurrentCamera :: Camera).CFrame.p)
	local currLookVector: Vector3 = (vecToSubject * X1_Y0_Z1).unit
	local vrRotateInput: Vector2 = Vector2.new(rotateInput.X, 0)
	local startCFrame: CFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local yawRotatedVector: Vector3 = (CFrame.Angles(0, -vrRotateInput.X, 0) * startCFrame * CFrame.Angles(-vrRotateInput.Y,0,0)).LookVector
	return (yawRotatedVector * X1_Y0_Z1).unit
end

function BaseCamera:GetHumanoid(): Humanoid?
	local character = player and player.Character
	if character then
		local resultHumanoid = self.humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			self.humanoidCache[player] = nil -- Bust Old Cache
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
	return nil
end

function BaseCamera:GetHumanoidPartToFollow(humanoid: Humanoid, humanoidStateType: Enum.HumanoidStateType) -- BasePart
	if humanoidStateType == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character then
			return character:FindFirstChild("Head") or humanoid.Torso
		else
			return humanoid.Torso
		end
	else
		return humanoid.Torso
	end
end


function BaseCamera:OnNewCameraSubject()
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
end

function BaseCamera:IsInFirstPerson()
	return self.inFirstPerson
end

function BaseCamera:Update(dt)
	error("BaseCamera:Update() This is a virtual function that should never be getting called.", 2)
end

function BaseCamera:GetCameraHeight()
	if VRService.VREnabled and not self.inFirstPerson then
		return math.sin(VR_ANGLE) * self.currentSubjectDistance
	end
	return 0
end

return BaseCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c0</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC67CC09D7E134A1AA0CE199CA760E22C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">OrbitalCamera</string>
							<string name="ScriptGuid">{11C0E08A-DD88-4A7E-B128-8E02E31D54F5}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	OrbitalCamera - Spherical coordinates control camera for top-down games
	2018 Camera Update - AllYourBlox
--]]

-- Local private variables and constants
local UNIT_Z = Vector3.new(0,0,1)
local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local TAU = 2 * math.pi

-- Do not edit these values, they are not the developer-set limits, they are limits
-- to the values the camera system equations can correctly handle
local MIN_ALLOWED_ELEVATION_DEG = -80
local MAX_ALLOWED_ELEVATION_DEG = 80

local externalProperties = {}
externalProperties["InitialDistance"]  = 25
externalProperties["MinDistance"]      = 10
externalProperties["MaxDistance"]      = 100
externalProperties["InitialElevation"] = 35
externalProperties["MinElevation"]     = 35
externalProperties["MaxElevation"]     = 35
externalProperties["ReferenceAzimuth"] = -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
externalProperties["CWAzimuthTravel"]  = 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
externalProperties["CCWAzimuthTravel"] = 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
externalProperties["UseAzimuthLimits"] = false -- Full rotation around Y axis available by default

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local CameraInput = require(script.Parent:WaitForChild("CameraInput"))

--[[ Services ]]--
local PlayersService = game:GetService('Players')
local VRService = game:GetService("VRService")

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local OrbitalCamera = setmetatable({}, BaseCamera)
OrbitalCamera.__index = OrbitalCamera


function OrbitalCamera.new()
	local self = setmetatable(BaseCamera.new(), OrbitalCamera)

	self.lastUpdate = tick()

	-- OrbitalCamera-specific members
	self.changedSignalConnections = {}
	self.refAzimuthRad = nil
	self.curAzimuthRad = nil
	self.minAzimuthAbsoluteRad = nil
	self.maxAzimuthAbsoluteRad = nil
	self.useAzimuthLimits = nil
	self.curElevationRad = nil
	self.minElevationRad = nil
	self.maxElevationRad = nil
	self.curDistance = nil
	self.minDistance = nil
	self.maxDistance = nil

	self.gamepadDollySpeedMultiplier = 1

	self.lastUserPanCamera = tick()

	self.externalProperties = {}
	self.externalProperties["InitialDistance"] 	= 25
	self.externalProperties["MinDistance"] 		= 10
	self.externalProperties["MaxDistance"] 		= 100
	self.externalProperties["InitialElevation"] 	= 35
	self.externalProperties["MinElevation"] 		= 35
	self.externalProperties["MaxElevation"] 		= 35
	self.externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
	self.externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
	self.externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
	self.externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default
	self:LoadNumberValueParameters()

	return self
end

function OrbitalCamera:LoadOrCreateNumberValueParameter(name: string, valueType, updateFunction)
	local valueObj = script:FindFirstChild(name)

	if valueObj and valueObj:isA(valueType) then
		-- Value object exists and is the correct type, use its value
		self.externalProperties[name] = valueObj.Value
	elseif self.externalProperties[name] ~= nil then
		-- Create missing (or replace incorrectly-typed) valueObject with default value
		valueObj = Instance.new(valueType)
		valueObj.Name = name
		valueObj.Parent = script
		valueObj.Value = self.externalProperties[name]
	else
		return
	end

	if updateFunction then
		if self.changedSignalConnections[name] then
			self.changedSignalConnections[name]:Disconnect()
		end
		self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
			self.externalProperties[name] = newValue
			updateFunction(self)
		end)
	end
end

function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
	self.minAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) - math.abs(math.rad(self.externalProperties["CWAzimuthTravel"]))
	self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) + math.abs(math.rad(self.externalProperties["CCWAzimuthTravel"]))
	self.useAzimuthLimits = self.externalProperties["UseAzimuthLimits"]
	if self.useAzimuthLimits then
		self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
		self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
	end
end

function OrbitalCamera:SetAndBoundsCheckElevationValues()
	-- These degree values are the direct user input values. It is deliberate that they are
	-- ranged checked only against the extremes, and not against each other. Any time one
	-- is changed, both of the internal values in radians are recalculated. This allows for
	-- A developer to change the values in any order and for the end results to be that the
	-- internal values adjust to match intent as best as possible.
	local minElevationDeg = math.max(self.externalProperties["MinElevation"], MIN_ALLOWED_ELEVATION_DEG)
	local maxElevationDeg = math.min(self.externalProperties["MaxElevation"], MAX_ALLOWED_ELEVATION_DEG)

	-- Set internal values in radians
	self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
	self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
	self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
	self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
end

function OrbitalCamera:SetAndBoundsCheckDistanceValues()
	self.minDistance = self.externalProperties["MinDistance"]
	self.maxDistance = self.externalProperties["MaxDistance"]
	self.curDistance = math.max(self.curDistance, self.minDistance)
	self.curDistance = math.min(self.curDistance, self.maxDistance)
end

-- This loads from, or lazily creates, NumberValue objects for exposed parameters
function OrbitalCamera:LoadNumberValueParameters()
	-- These initial values do not require change listeners since they are read only once
	self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)

	-- Note: ReferenceAzimuth is also used as an initial value, but needs a change listener because it is used in the calculation of the limits
	self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
	self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)

	-- Internal values set (in radians, from degrees), plus sanitization
	self.curAzimuthRad = math.rad(self.externalProperties["ReferenceAzimuth"])
	self.curElevationRad = math.rad(self.externalProperties["InitialElevation"])
	self.curDistance = self.externalProperties["InitialDistance"]

	self:SetAndBoundsCheckAzimuthValues()
	self:SetAndBoundsCheckElevationValues()
	self:SetAndBoundsCheckDistanceValues()
end

function OrbitalCamera:GetModuleName()
	return "OrbitalCamera"
end

function OrbitalCamera:SetInitialOrientation(humanoid: Humanoid)
	if not humanoid or not humanoid.RootPart then
		warn("OrbitalCamera could not set initial orientation due to missing humanoid")
		return
	end
	assert(humanoid.RootPart, "")
	local newDesiredLook = (humanoid.RootPart.CFrame.LookVector - Vector3.new(0,0.23,0)).Unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
	local vertShift = math.asin(self:GetCameraLookVector().Y) - math.asin(newDesiredLook.Y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
end

--[[ Functions of BaseCamera that are overridden by OrbitalCamera ]]--
function OrbitalCamera:GetCameraToSubjectDistance()
	return self.curDistance
end

function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	local player = PlayersService.LocalPlayer
	if player then
		self.currentSubjectDistance = math.clamp(desiredSubjectDistance, self.minDistance, self.maxDistance)

		-- OrbitalCamera is not allowed to go into the first-person range
		self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
	end
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
	return self.currentSubjectDistance
end

function OrbitalCamera:CalculateNewLookVector(suppliedLookVector: Vector3, xyRotateVector: Vector2): Vector3
	local currLookVector: Vector3 = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle: number = math.asin(currLookVector.Y)
	local yTheta: number = math.clamp(xyRotateVector.Y, currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG))
	local constrainedRotateInput: Vector2 = Vector2.new(xyRotateVector.X, yTheta)
	local startCFrame: CFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookVector: Vector3 = (CFrame.Angles(0, -constrainedRotateInput.X, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.Y,0,0)).LookVector
	return newLookVector
end

-- [[ Update ]]--
function OrbitalCamera:Update(dt: number): (CFrame, CFrame)
	local now = tick()
	local timeDelta = (now - self.lastUpdate)
	local userPanningTheCamera = CameraInput.getRotation() ~= Vector2.new()
	local camera = 	workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
	local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')

	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end

	-- Reset tween speed if user is panning
	if userPanningTheCamera then
		self.lastUserPanCamera = tick()
	end

	local subjectPosition = self:GetSubjectPosition()

	if subjectPosition and player and camera then

		-- Process any dollying being done by gamepad
		-- TODO: Move this
		if self.gamepadDollySpeedMultiplier ~= 1 then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
		end

		local VREnabled = VRService.VREnabled
		newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)

		local flaggedRotateInput = CameraInput.getRotation()

		local cameraFocusP = newCameraFocus.p
		if VREnabled and not self:IsInFirstPerson() then
			local cameraHeight = self:GetCameraHeight()
			local vecToSubject: Vector3 = (subjectPosition - camera.CFrame.p)
			local distToSubject: number = vecToSubject.Magnitude

			-- Only move the camera if it exceeded a maximum distance to the subject in VR
			if distToSubject > self.currentSubjectDistance or flaggedRotateInput.X ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)

				-- Note that CalculateNewLookVector is overridden from BaseCamera
				vecToSubject = self:CalculateNewLookVector(vecToSubject.Unit * X1_Y0_Z1, Vector2.new(flaggedRotateInput.X, 0)) * desiredDist

				local newPos = cameraFocusP - vecToSubject
				local desiredLookDir = camera.CFrame.LookVector
				if flaggedRotateInput.X ~= 0 then
					desiredLookDir = vecToSubject
				end
				local lookAt = Vector3.new(newPos.X + desiredLookDir.X, newPos.Y, newPos.Z + desiredLookDir.Z)
				newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
			end
		else
			-- rotateInput is a Vector2 of mouse movement deltas since last update
			self.curAzimuthRad = self.curAzimuthRad - flaggedRotateInput.X

			if self.useAzimuthLimits then
				self.curAzimuthRad = math.clamp(self.curAzimuthRad, self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad)
			else
				self.curAzimuthRad = (self.curAzimuthRad ~= 0) and (math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU)) or 0
			end

			self.curElevationRad = math.clamp(self.curElevationRad + flaggedRotateInput.Y, self.minElevationRad, self.maxElevationRad)

			local cameraPosVector = self.currentSubjectDistance * ( CFrame.fromEulerAnglesYXZ( -self.curElevationRad, self.curAzimuthRad, 0 ) * UNIT_Z )
			local camPos = subjectPosition + cameraPosVector

			newCameraCFrame = CFrame.new(camPos, subjectPosition)
		end

		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end

	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end

return OrbitalCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c1</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE0E9EB85BAA444808BA254DA188AF055">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraInput</string>
							<string name="ScriptGuid">{EDF9DF37-A168-44A8-9028-2AA36E3E01E8}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
local ContextActionService = game:GetService("ContextActionService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")
local VRService = game:GetService("VRService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer

local CAMERA_INPUT_PRIORITY = Enum.ContextActionPriority.Medium.Value
local MB_TAP_LENGTH = 0.3 -- (s) length of time for a short mouse button tap to be registered

local ROTATION_SPEED_KEYS = math.rad(120) -- (rad/s)
local ROTATION_SPEED_MOUSE = Vector2.new(1, 0.77)*math.rad(0.5) -- (rad/s)
local ROTATION_SPEED_POINTERACTION = Vector2.new(1, 0.77)*math.rad(7) -- (rad/s)
local ROTATION_SPEED_TOUCH = Vector2.new(1, 0.66)*math.rad(1) -- (rad/s)
local ROTATION_SPEED_GAMEPAD = Vector2.new(1, 0.77)*math.rad(4) -- (rad/s)

local ZOOM_SPEED_MOUSE = 1 -- (scaled studs/wheel click)
local ZOOM_SPEED_KEYS = 0.1 -- (studs/s)
local ZOOM_SPEED_TOUCH = 0.04 -- (scaled studs/DIP %)

local MIN_TOUCH_SENSITIVITY_FRACTION = 0.25 -- 25% sensitivity at 90°

local FFlagUserResetTouchStateOnMenuOpen
do
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserResetTouchStateOnMenuOpen")
	end)
	FFlagUserResetTouchStateOnMenuOpen = success and result
end

-- right mouse button up & down events
local rmbDown, rmbUp do
	local rmbDownBindable = Instance.new("BindableEvent")
	local rmbUpBindable = Instance.new("BindableEvent")

	rmbDown = rmbDownBindable.Event
	rmbUp = rmbUpBindable.Event

	UserInputService.InputBegan:Connect(function(input, gpe)
		if not gpe and input.UserInputType == Enum.UserInputType.MouseButton2 then
			rmbDownBindable:Fire()
		end
	end)

	UserInputService.InputEnded:Connect(function(input, gpe)
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			rmbUpBindable:Fire()
		end
	end)
end

local thumbstickCurve do
	local K_CURVATURE = 2 -- amount of upwards curvature (0 is flat)
	local K_DEADZONE = 0.1 -- deadzone

	function thumbstickCurve(x)
		-- remove sign, apply linear deadzone
		local fDeadzone = (math.abs(x) - K_DEADZONE)/(1 - K_DEADZONE)
		
		-- apply exponential curve and scale to fit in [0, 1]
		local fCurve = (math.exp(K_CURVATURE*fDeadzone) - 1)/(math.exp(K_CURVATURE) - 1)
		
		-- reapply sign and clamp
		return math.sign(x)*math.clamp(fCurve, 0, 1)
	end
end

-- Adjust the touch sensitivity so that sensitivity is reduced when swiping up
-- or down, but stays the same when swiping towards the middle of the screen
local function adjustTouchPitchSensitivity(delta: Vector2): Vector2
	local camera = workspace.CurrentCamera

	if not camera then
		return delta
	end
	
	-- get the camera pitch in world space
	local pitch = camera.CFrame:ToEulerAnglesYXZ()
	
	if delta.Y*pitch >= 0 then
		-- do not reduce sensitivity when pitching towards the horizon
		return delta
	end
	
	-- set up a line to fit:
	-- 1 = f(0)
	-- 0 = f(±pi/2)
	local curveY = 1 - (2*math.abs(pitch)/math.pi)^0.75

	-- remap curveY from [0, 1] -> [MIN_TOUCH_SENSITIVITY_FRACTION, 1]
	local sensitivity = curveY*(1 - MIN_TOUCH_SENSITIVITY_FRACTION) + MIN_TOUCH_SENSITIVITY_FRACTION

	return Vector2.new(1, sensitivity)*delta
end

local function isInDynamicThumbstickArea(pos: Vector3): boolean
	local playerGui = player:FindFirstChildOfClass("PlayerGui")
	local touchGui = playerGui and playerGui:FindFirstChild("TouchGui")
	local touchFrame = touchGui and touchGui:FindFirstChild("TouchControlFrame")
	local thumbstickFrame = touchFrame and touchFrame:FindFirstChild("DynamicThumbstickFrame")

	if not thumbstickFrame then
		return false
	end
	
	if not touchGui.Enabled then
		return false
	end

	local posTopLeft = thumbstickFrame.AbsolutePosition
	local posBottomRight = posTopLeft + thumbstickFrame.AbsoluteSize

	return
		pos.X >= posTopLeft.X and
		pos.Y >= posTopLeft.Y and
		pos.X <= posBottomRight.X and
		pos.Y <= posBottomRight.Y
end

local worldDt = 1/60
RunService.Stepped:Connect(function(_, _worldDt)
	worldDt = _worldDt
end)

local CameraInput = {}

do
	local connectionList = {}
	local panInputCount = 0

	local function incPanInputCount()
		panInputCount = math.max(0, panInputCount + 1)
	end

	local function decPanInputCount()
		panInputCount = math.max(0, panInputCount - 1)
	end

	local function resetPanInputCount()
		panInputCount = 0
	end

	local touchPitchSensitivity = 1
	local gamepadState = {
		Thumbstick2 = Vector2.new(),
	}
	local keyboardState = {
		Left = 0,
		Right = 0,
		I = 0,
		O = 0
	}
	local mouseState = {
		Movement = Vector2.new(),
		Wheel = 0, -- PointerAction
		Pan = Vector2.new(), -- PointerAction
		Pinch = 0, -- PointerAction
	}
	local touchState = {
		Move = Vector2.new(),
		Pinch = 0,
	}
	
	local gamepadZoomPressBindable = Instance.new("BindableEvent")
	CameraInput.gamepadZoomPress = gamepadZoomPressBindable.Event

	local gamepadResetBindable = VRService.VREnabled and Instance.new("BindableEvent") or nil
	if VRService.VREnabled then
		CameraInput.gamepadReset = gamepadResetBindable.Event
	end
	
	function CameraInput.getRotationActivated(): boolean
		return panInputCount > 0 or gamepadState.Thumbstick2.Magnitude > 0
	end
	
	function CameraInput.getRotation(disableKeyboardRotation: boolean?): Vector2
		local inversionVector = Vector2.new(1, UserGameSettings:GetCameraYInvertValue())

		-- keyboard input is non-coalesced, so must account for time delta
		local kKeyboard = Vector2.new(keyboardState.Right - keyboardState.Left, 0)*worldDt
		local kGamepad = gamepadState.Thumbstick2
		local kMouse = mouseState.Movement
		local kPointerAction = mouseState.Pan
		local kTouch = adjustTouchPitchSensitivity(touchState.Move)

		if disableKeyboardRotation then
			kKeyboard = Vector2.new()
		end

		local result =
			kKeyboard*ROTATION_SPEED_KEYS +
			kGamepad*ROTATION_SPEED_GAMEPAD +
			kMouse*ROTATION_SPEED_MOUSE +
			kPointerAction*ROTATION_SPEED_POINTERACTION +
			kTouch*ROTATION_SPEED_TOUCH

		return result*inversionVector
	end
	
	function CameraInput.getZoomDelta(): number
		local kKeyboard = keyboardState.O - keyboardState.I
		local kMouse = -mouseState.Wheel + mouseState.Pinch
		local kTouch = -touchState.Pinch
		return kKeyboard*ZOOM_SPEED_KEYS + kMouse*ZOOM_SPEED_MOUSE + kTouch*ZOOM_SPEED_TOUCH
	end

	do
		local function thumbstick(action, state, input)
			local position = input.Position
			gamepadState[input.KeyCode.Name] = Vector2.new(thumbstickCurve(position.X), -thumbstickCurve(position.Y))
			return Enum.ContextActionResult.Pass
		end

		local function mouseMovement(input)
			local delta = input.Delta
			mouseState.Movement = Vector2.new(delta.X, delta.Y)
		end
		
		local function mouseWheel(action, state, input)
			mouseState.Wheel = input.Position.Z
			return Enum.ContextActionResult.Pass
		end
		
		local function keypress(action, state, input)
			keyboardState[input.KeyCode.Name] = state == Enum.UserInputState.Begin and 1 or 0
		end
		
		local function gamepadZoomPress(action, state, input)
			if state == Enum.UserInputState.Begin then
				gamepadZoomPressBindable:Fire()
			end
		end

		local function gamepadReset(action, state, input)
			if state == Enum.UserInputState.Begin then
				gamepadResetBindable:Fire()
			end
		end
		
		local function resetInputDevices()
			for _, device in pairs({
				gamepadState,
				keyboardState,
				mouseState,
				touchState,
			}) do
				for k, v in pairs(device) do
					if type(v) == "boolean" then
						device[k] = false
					else
						device[k] *= 0 -- Mul by zero to preserve vector types
					end
				end
			end
		end

		local touchBegan, touchChanged, touchEnded, resetTouchState do
			-- Use TouchPan & TouchPinch when they work in the Studio emulator

			local touches: {[InputObject]: boolean?} = {} -- {[InputObject] = sunk}
			local dynamicThumbstickInput: InputObject? -- Special-cased 
			local lastPinchDiameter: number?

			function touchBegan(input: InputObject, sunk: boolean)
				assert(input.UserInputType == Enum.UserInputType.Touch)
				assert(input.UserInputState == Enum.UserInputState.Begin)
				
				if dynamicThumbstickInput == nil and isInDynamicThumbstickArea(input.Position) and not sunk then
					-- any finger down starting in the dynamic thumbstick area should always be
					-- ignored for camera purposes. these must be handled specially from all other
					-- inputs, as the DT does not sink inputs by itself
					dynamicThumbstickInput = input
					return
				end
				
				if not sunk then
					incPanInputCount()
				end
				
				-- register the finger
				touches[input] = sunk
			end

			function touchEnded(input: InputObject, sunk: boolean)
				assert(input.UserInputType == Enum.UserInputType.Touch)
				assert(input.UserInputState == Enum.UserInputState.End)
				
				-- reset the DT input
				if input == dynamicThumbstickInput then
					dynamicThumbstickInput = nil
				end
				
				-- reset pinch state if one unsunk finger lifts
				if touches[input] == false then
					lastPinchDiameter = nil
					decPanInputCount()
				end
				
				-- unregister input
				touches[input] = nil
			end

			function touchChanged(input, sunk)
				assert(input.UserInputType == Enum.UserInputType.Touch)
				assert(input.UserInputState == Enum.UserInputState.Change)
				
				-- ignore movement from the DT finger
				if input == dynamicThumbstickInput then
					return
				end
				
				-- fixup unknown touches
				if touches[input] == nil then
					touches[input] = sunk
				end
				
				-- collect unsunk touches
				local unsunkTouches = {}
				for touch, sunk in pairs(touches) do
					if not sunk then
						table.insert(unsunkTouches, touch)
					end
				end
				
				-- 1 finger: pan
				if #unsunkTouches == 1 then
					if touches[input] == false then
						local delta = input.Delta
						touchState.Move += Vector2.new(delta.X, delta.Y) -- total touch pan movement (reset at end of frame)
					end
				end
				
				-- 2 fingers: pinch
				if #unsunkTouches == 2 then
					local pinchDiameter = (unsunkTouches[1].Position - unsunkTouches[2].Position).Magnitude
					
					if lastPinchDiameter then
						touchState.Pinch += pinchDiameter - lastPinchDiameter
					end
					
					lastPinchDiameter = pinchDiameter
				else
					lastPinchDiameter = nil
				end
			end

			function resetTouchState()
				touches = {}
				dynamicThumbstickInput = nil
				lastPinchDiameter = nil
				if FFlagUserResetTouchStateOnMenuOpen then
					resetPanInputCount()
				end
			end
		end

		local function pointerAction(wheel, pan, pinch, gpe)
			if not gpe then
				mouseState.Wheel = wheel
				mouseState.Pan = pan
				mouseState.Pinch = -pinch
			end
		end

		local function inputBegan(input, sunk)
			if input.UserInputType == Enum.UserInputType.Touch then
				touchBegan(input, sunk)

			elseif input.UserInputType == Enum.UserInputType.MouseButton2 and not sunk then
				incPanInputCount()
			end
		end

		local function inputChanged(input, sunk)
			if input.UserInputType == Enum.UserInputType.Touch then
				touchChanged(input, sunk)

			elseif input.UserInputType == Enum.UserInputType.MouseMovement then
				mouseMovement(input)
			end
		end

		local function inputEnded(input, sunk)
			if input.UserInputType == Enum.UserInputType.Touch then
				touchEnded(input, sunk)

			elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
				decPanInputCount()
			end
		end

		local inputEnabled = false

		function CameraInput.setInputEnabled(_inputEnabled)
			if inputEnabled == _inputEnabled then
				return
			end
			inputEnabled = _inputEnabled

			resetInputDevices()
			resetTouchState()

			if inputEnabled then -- enable
				ContextActionService:BindActionAtPriority(
					"RbxCameraThumbstick",
					thumbstick,
					false,
					CAMERA_INPUT_PRIORITY,
					Enum.KeyCode.Thumbstick2
				)

				ContextActionService:BindActionAtPriority(
					"RbxCameraKeypress",
					keypress,
					false,
					CAMERA_INPUT_PRIORITY,
					Enum.KeyCode.Left,
					Enum.KeyCode.Right,
					Enum.KeyCode.I,
					Enum.KeyCode.O
				)

				if VRService.VREnabled then
					ContextActionService:BindAction(
						"RbxCameraGamepadReset",
						gamepadReset,
						false,
						Enum.KeyCode.ButtonL3
					)
				end
				
				ContextActionService:BindAction(
					"RbxCameraGamepadZoom",
					gamepadZoomPress,
					false,
					Enum.KeyCode.ButtonR3
				)
				
				table.insert(connectionList, UserInputService.InputBegan:Connect(inputBegan))
				table.insert(connectionList, UserInputService.InputChanged:Connect(inputChanged))
				table.insert(connectionList, UserInputService.InputEnded:Connect(inputEnded))
				table.insert(connectionList, UserInputService.PointerAction:Connect(pointerAction))
				if FFlagUserResetTouchStateOnMenuOpen then
					local GuiService = game:GetService("GuiService")
					table.insert(connectionList, GuiService.MenuOpened:connect(resetTouchState))
				end

			else -- disable
				ContextActionService:UnbindAction("RbxCameraThumbstick")
				ContextActionService:UnbindAction("RbxCameraMouseMove")
				ContextActionService:UnbindAction("RbxCameraMouseWheel")
				ContextActionService:UnbindAction("RbxCameraKeypress")

				ContextActionService:UnbindAction("RbxCameraGamepadZoom")
				if VRService.VREnabled then
					ContextActionService:UnbindAction("RbxCameraGamepadReset")
				end 

				for _, conn in pairs(connectionList) do
					conn:Disconnect()
				end
				connectionList = {}
			end
		end

		function CameraInput.getInputEnabled()
			return inputEnabled
		end
		
		function CameraInput.resetInputForFrameEnd()
			mouseState.Movement = Vector2.new()
			touchState.Move = Vector2.new()
			touchState.Pinch = 0

			mouseState.Wheel = 0 -- PointerAction
			mouseState.Pan = Vector2.new() -- PointerAction
			mouseState.Pinch = 0 -- PointerAction
		end

		UserInputService.WindowFocused:Connect(resetInputDevices)
		UserInputService.WindowFocusReleased:Connect(resetInputDevices)
	end
end

-- Toggle pan
do
	local holdPan = false
	local togglePan = false
	local lastRmbDown = 0 -- tick() timestamp of the last right mouse button down event
	
	function CameraInput.getHoldPan(): boolean
		return holdPan
	end
	
	function CameraInput.getTogglePan(): boolean
		return togglePan
	end
	
	function CameraInput.getPanning(): boolean
		return togglePan or holdPan
	end
	
	function CameraInput.setTogglePan(value: boolean)
		togglePan = value
	end
	
	local cameraToggleInputEnabled = false
	local rmbDownConnection
	local rmbUpConnection
	
	function CameraInput.enableCameraToggleInput()
		if cameraToggleInputEnabled then
			return
		end
		cameraToggleInputEnabled = true
	
		holdPan = false
		togglePan = false
	
		if rmbDownConnection then
			rmbDownConnection:Disconnect()
		end
	
		if rmbUpConnection then
			rmbUpConnection:Disconnect()
		end
	
		rmbDownConnection = rmbDown:Connect(function()
			holdPan = true
			lastRmbDown = tick()
		end)
	
		rmbUpConnection = rmbUp:Connect(function()
			holdPan = false
			if tick() - lastRmbDown < MB_TAP_LENGTH and (togglePan or UserInputService:GetMouseDelta().Magnitude < 2) then
				togglePan = not togglePan
			end
		end)
	end
	
	function CameraInput.disableCameraToggleInput()
		if not cameraToggleInputEnabled then
			return
		end
		cameraToggleInputEnabled = false
	
		if rmbDownConnection then
			rmbDownConnection:Disconnect()
			rmbDownConnection = nil
		end
		
		if rmbUpConnection then
			rmbUpConnection:Disconnect()
			rmbUpConnection = nil
		end
	end
end

return CameraInput]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c2</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX75179308B53A4F0A84DFD74A130E49B9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VRVehicleCamera</string>
							<string name="ScriptGuid">{34B91EAA-C189-41DA-BD72-D13509328817}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	VRVehicleCamera - Roblox VR vehicle camera control module
	2021 Roblox VR
--]]

local EPSILON = 1e-3
local PITCH_LIMIT = math.rad(80)
local YAW_DEFAULT = math.rad(0)
local ZOOM_MINIMUM = 0.5
local ZOOM_SENSITIVITY_CURVATURE = 0.5
local DEFAULT_CAMERA_DIST = 16
local TP_FOLLOW_DIST = 200
local TP_FOLLOW_ANGLE_DOT = 0.56

local VRBaseCamera = require(script.Parent:WaitForChild("VRBaseCamera"))
local CameraInput = require(script.Parent:WaitForChild("CameraInput"))
local CameraUtils = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))
local VehicleCamera = require(script.Parent:WaitForChild("VehicleCamera"))
local VehicleCameraCore =  require(script.Parent.VehicleCamera:FindFirstChild("VehicleCameraCore")) :: any
local VehicleCameraConfig = require(script.Parent.VehicleCamera:FindFirstChild("VehicleCameraConfig")) :: any
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local VRService = game:GetService("VRService")

local localPlayer = Players.LocalPlayer
local Spring = CameraUtils.Spring
local mapClamp = CameraUtils.mapClamp
local sanitizeAngle = CameraUtils.sanitizeAngle

local ZERO_VECTOR3 = Vector3.new(0,0,0)

-- pitch-axis rotational velocity of a part with a given CFrame and total RotVelocity
local function pitchVelocity(rotVel, cf)
	return math.abs(cf.XVector:Dot(rotVel))
end

-- yaw-axis rotational velocity of a part with a given CFrame and total RotVelocity
local function yawVelocity(rotVel, cf)
	return math.abs(cf.YVector:Dot(rotVel))
end

local worldDt = 1/60
local VRVehicleCamera = setmetatable({}, VRBaseCamera)
VRVehicleCamera.__index = VRVehicleCamera

function VRVehicleCamera.new()
	local self = setmetatable(VRBaseCamera.new(), VRVehicleCamera)
	self:Reset()

	-- track physics solver time delta separately from the render loop to correctly synchronize time delta
	RunService.Stepped:Connect(function(_, _worldDt)
		worldDt = _worldDt
	end)

	return self
end

function VRVehicleCamera:Reset()
	self.vehicleCameraCore = VehicleCameraCore.new(self:GetSubjectCFrame())
	self.pitchSpring = Spring.new(0, -math.rad(VehicleCameraConfig.pitchBaseAngle))
	self.yawSpring = Spring.new(0, YAW_DEFAULT)

	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	assert(camera, "VRVehicleCamera initialization error")
	assert(cameraSubject)
	assert(cameraSubject:IsA("VehicleSeat"))

	local assemblyParts = cameraSubject:GetConnectedParts(true) -- passing true to recursively get all assembly parts
	local assemblyPosition, assemblyRadius = CameraUtils.getLooseBoundingSphere(assemblyParts)

	assemblyRadius = math.max(assemblyRadius, EPSILON)

	self.assemblyRadius = assemblyRadius
	self.assemblyOffset = cameraSubject.CFrame:Inverse()*assemblyPosition -- seat-space offset of the assembly bounding sphere center

	self.lastCameraFocus = nil

	self:_StepInitialZoom()
end

function VRVehicleCamera:_StepInitialZoom()
	self:SetCameraToSubjectDistance(math.max(
		ZoomController.GetZoomRadius(),
		self.assemblyRadius*VehicleCameraConfig.initialZoomRadiusMul
	))
end

function VRVehicleCamera:_GetThirdPersonLocalOffset()
	return self.assemblyOffset + Vector3.new(0, self.assemblyRadius*VehicleCameraConfig.verticalCenterOffset, 0)
end

function VRVehicleCamera:_GetFirstPersonLocalOffset(subjectCFrame: CFrame)
	local character = localPlayer.Character

	if character and character.Parent then
		local head = character:FindFirstChild("Head")

		if head and head:IsA("BasePart") then
			return subjectCFrame:Inverse() * head.Position
		end
	end

	return self:_GetThirdPersonLocalOffset()
end

function VRVehicleCamera:Update()
	local camera = workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject
	local vehicleCameraCore = self.vehicleCameraCore

	assert(camera)
	assert(cameraSubject)
	assert(cameraSubject:IsA("VehicleSeat"))

	-- consume the physics solver time delta to account for mismatched physics/render cycles
	local dt = worldDt
	worldDt = 0

	-- get subject info
	local subjectCFrame: CFrame = self:GetSubjectCFrame()
	local subjectVel: Vector3 = self:GetSubjectVelocity()
	local subjectRotVel = self:GetSubjectRotVelocity()

	-- measure the local-to-world-space forward velocity of the vehicle
	local vDotZ = math.abs(subjectVel:Dot(subjectCFrame.ZVector))
	local yawVel = yawVelocity(subjectRotVel, subjectCFrame)
	local pitchVel = pitchVelocity(subjectRotVel, subjectCFrame)

	-- step camera components forward
	local zoom = self:StepZoom()

	-- mix third and first person offsets in local space
	local firstPerson = mapClamp(zoom, ZOOM_MINIMUM, self.assemblyRadius, 1, 0)

	local tpOffset = self:_GetThirdPersonLocalOffset()
	local fpOffset = self:_GetFirstPersonLocalOffset(subjectCFrame)
	local localOffset = tpOffset:Lerp(fpOffset, firstPerson)

	-- step core forward
	vehicleCameraCore:setTransform(subjectCFrame)
	local processedRotation = vehicleCameraCore:step(dt, pitchVel, yawVel, firstPerson)

	-- end product of this function
	local focus = nil
	local cf = nil

	-- update fade from black
	self:UpdateFadeFromBlack(dt)

	if not self:IsInFirstPerson() then
		-- third person comfort camera
		focus =  CFrame.new(subjectCFrame*localOffset)*processedRotation
		cf = focus*CFrame.new(0, 0, zoom)

		if not self.lastCameraFocus then
			self.lastCameraFocus = focus
			self.needsReset = true
		end

		local curCameraDir = focus.Position - camera.CFrame.Position
		local curCameraDist = curCameraDir.magnitude
		curCameraDir = curCameraDir.Unit
		local cameraDot = curCameraDir:Dot(camera.CFrame.LookVector)
		if cameraDot > TP_FOLLOW_ANGLE_DOT and curCameraDist < TP_FOLLOW_DIST and not self.needsReset then -- vehicle in view
			-- keep old focus
			focus = self.lastCameraFocus

			-- new cf result
			local cameraFocusP = focus.p
			local cameraLookVector = self:GetCameraLookVector()
			cameraLookVector = Vector3.new(cameraLookVector.X, 0, cameraLookVector.Z).Unit
			local newLookVector = self:CalculateNewLookVectorFromArg(cameraLookVector, Vector2.new(0, 0))
			cf = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
		else
			-- new focus / teleport
			self.currentSubjectDistance = DEFAULT_CAMERA_DIST
			self.lastCameraFocus = self:GetVRFocus(subjectCFrame.Position, dt)
			self.needsReset = false
			self:StartFadeFromBlack()
			self:ResetZoom()
		end

		self:UpdateEdgeBlur(localPlayer, dt)
	else
		-- first person in vehicle : lock orientation for stable camera
		local dir = Vector3.new(processedRotation.LookVector.X, 0, processedRotation.LookVector.Z).Unit
		local planarRotation = CFrame.new(processedRotation.Position, dir)

		-- this removes the pitch to reduce motion sickness
		focus =  CFrame.new(subjectCFrame * localOffset) * planarRotation
		cf = focus * CFrame.new(0, 0, zoom)

		self:StartVREdgeBlur(localPlayer)
	end

	return cf, focus
end

function VRVehicleCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end

function VRVehicleCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end

return VRVehicleCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c3</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6E08EAC53874499486F2116BD1416A05">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseOcclusion</string>
							<string name="ScriptGuid">{67E76075-3F6A-4BDB-8DE3-3974A435BD07}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	BaseOcclusion - Abstract base class for character occlusion control modules
	2018 Camera Update - AllYourBlox
--]]

--[[ The Module ]]--
local BaseOcclusion: any = {}
BaseOcclusion.__index = BaseOcclusion
setmetatable(BaseOcclusion, {
	__call = function(_, ...)
		return BaseOcclusion.new(...)
	end
})

function BaseOcclusion.new()
	local self = setmetatable({}, BaseOcclusion)
	return self
end

-- Called when character is added
function BaseOcclusion:CharacterAdded(char: Model, player: Player)
end

-- Called when character is about to be removed
function BaseOcclusion:CharacterRemoving(char: Model, player: Player)
end

function BaseOcclusion:OnCameraSubjectChanged(newSubject)
end

--[[ Derived classes are required to override and implement all of the following functions ]]--
function BaseOcclusion:GetOcclusionMode(): Enum.DevCameraOcclusionMode?
	-- Must be overridden in derived classes to return an Enum.DevCameraOcclusionMode value
	warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
	return nil
end

function BaseOcclusion:Enable(enabled: boolean)
	warn("BaseOcclusion Enable must be overridden by derived classes")
end

function BaseOcclusion:Update(dt: number, desiredCameraCFrame: CFrame, desiredCameraFocus: CFrame)
	warn("BaseOcclusion Update must be overridden by derived classes")
	return desiredCameraCFrame, desiredCameraFocus
end

return BaseOcclusion
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c4</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX420CEED4C69648D39C34A072AE220D4E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">LegacyCamera</string>
							<string name="ScriptGuid">{380117DB-B975-4C82-A545-9C315DCBD63E}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
--[[
	LegacyCamera - Implements legacy controller types: Attach, Fixed, Watch
	2018 Camera Update - AllYourBlox
--]]

local ZERO_VECTOR2 = Vector2.new()
local PITCH_LIMIT = math.rad(80)

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local CameraInput = require(script.Parent:WaitForChild("CameraInput"))

--[[ Services ]]--
local PlayersService = game:GetService('Players')

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local LegacyCamera = setmetatable({}, BaseCamera)
LegacyCamera.__index = LegacyCamera

function LegacyCamera.new()
	local self = setmetatable(BaseCamera.new(), LegacyCamera)

	self.cameraType = Enum.CameraType.Fixed
	self.lastUpdate = tick()
	self.lastDistanceToSubject = nil

	return self
end

function LegacyCamera:GetModuleName()
	return "LegacyCamera"
end

--[[ Functions overridden from BaseCamera ]]--
function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	return BaseCamera.SetCameraToSubjectDistance(self,desiredSubjectDistance)
end

function LegacyCamera:Update(dt: number): (CFrame?, CFrame?)

	-- Cannot update until cameraType has been set
	if not self.cameraType then
		return nil, nil
	end

	local now = tick()
	local timeDelta = (now - self.lastUpdate)
	local camera = 	workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer

	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastDistanceToSubject = nil
	end
	local subjectPosition: Vector3 = self:GetSubjectPosition()

	if self.cameraType == Enum.CameraType.Fixed then
		if subjectPosition and player and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVectorFromArg(nil, CameraInput.getRotation())

			newCameraFocus = camera.Focus -- Fixed camera does not change focus
			newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + (distanceToSubject * newLookVector))
		end

	elseif self.cameraType == Enum.CameraType.Attach then
		local subjectCFrame = self:GetSubjectCFrame()
		local cameraPitch = camera.CFrame:ToEulerAnglesYXZ()
		local _, subjectYaw = subjectCFrame:ToEulerAnglesYXZ()

		cameraPitch = math.clamp(cameraPitch - CameraInput.getRotation().Y, -PITCH_LIMIT, PITCH_LIMIT)

		newCameraFocus = CFrame.new(subjectCFrame.p)*CFrame.fromEulerAnglesYXZ(cameraPitch, subjectYaw, 0)
		newCameraCFrame = newCameraFocus*CFrame.new(0, 0, self:StepZoom())

	elseif self.cameraType == Enum.CameraType.Watch then
		if subjectPosition and player and camera then
			local cameraLook = nil

			if subjectPosition == camera.CFrame.p then
				warn("Camera cannot watch subject in same position as itself")
				return camera.CFrame, camera.Focus
			end

			local humanoid = self:GetHumanoid()
			if humanoid and humanoid.RootPart then
				local diffVector = subjectPosition - camera.CFrame.p
				cameraLook = diffVector.unit

				if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
					-- Don't clobber the zoom if they zoomed the camera
					local newDistanceToSubject = diffVector.magnitude
					self:SetCameraToSubjectDistance(newDistanceToSubject)
				end
			end

			local distanceToSubject: number = self:GetCameraToSubjectDistance()
			local newLookVector: Vector3 = self:CalculateNewLookVectorFromArg(cameraLook, CameraInput.getRotation())

			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)

			self.lastDistanceToSubject = distanceToSubject
		end
	else
		-- Unsupported type, return current values unchanged
		return camera.CFrame, camera.Focus
	end

	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end

return LegacyCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c5</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXA9117757FF694888BC49273A896F3FFA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraUI</string>
							<string name="ScriptGuid">{C286C9F4-D39A-4A42-BB9E-2C2D78D276ED}</string>
							<ProtectedString name="Source"><![CDATA[--!nonstrict
local StarterGui = game:GetService("StarterGui")

local initialized = false

local CameraUI: any = {}

do
	-- Instantaneously disable the toast or enable for opening later on. Used when switching camera modes.
	function CameraUI.setCameraModeToastEnabled(enabled: boolean)
		if not enabled and not initialized then
			return
		end

		if not initialized then
			initialized = true
		end
		
		if not enabled then
			CameraUI.setCameraModeToastOpen(false)
		end
	end

	function CameraUI.setCameraModeToastOpen(open: boolean)
		assert(initialized)

		if open then
			StarterGui:SetCore("SendNotification", {
				Title = "Camera Control Enabled",
				Text = "Right click to toggle",
				Duration = 3,
			})
		end
	end
end

return CameraUI
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c6</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX895C762DA22D41B89178932E61F04FA5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraUtils</string>
							<string name="ScriptGuid">{DEF67D5E-FE2E-4496-8CE1-F3DEDE8CBAD9}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	CameraUtils - Math utility functions shared by multiple camera scripts
	2018 Camera Update - AllYourBlox
--]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

local CameraUtils = {}

local function round(num: number)
	return math.floor(num + 0.5)
end

-- Critically damped spring class for fluid motion effects
local Spring = {} do
	Spring.__index = Spring

	-- Initialize to a given undamped frequency and default position
	function Spring.new(freq, pos)
		return setmetatable({
			freq = freq,
			goal = pos,
			pos = pos,
			vel = 0,
		}, Spring)
	end

	-- Advance the spring simulation by `dt` seconds
	function Spring:step(dt: number)
		local f: number = self.freq::number * 2.0 * math.pi
		local g: Vector3 = self.goal
		local p0: Vector3 = self.pos
		local v0: Vector3 = self.vel

		local offset = p0 - g
		local decay = math.exp(-f*dt)

		local p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
		local v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay

		self.pos = p1
		self.vel = v1

		return p1
	end
end

CameraUtils.Spring = Spring

-- map a value from one range to another
function CameraUtils.map(x: number, inMin: number, inMax: number, outMin: number, outMax: number): number
	return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
end

-- maps a value from one range to another, clamping to the output range. order does not matter
function CameraUtils.mapClamp(x: number, inMin: number, inMax: number, outMin: number, outMax: number): number
	return math.clamp(
		(x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin,
		math.min(outMin, outMax),
		math.max(outMin, outMax)
	)
end

-- Ritter's loose bounding sphere algorithm
function CameraUtils.getLooseBoundingSphere(parts: {BasePart})
	local points = table.create(#parts)
	for idx, part in pairs(parts) do
		points[idx] = part.Position
	end

	-- pick an arbitrary starting point
	local x = points[1]

	-- get y, the point furthest from x
	local y = x
	local yDist = 0

	for _, p in ipairs(points) do
		local pDist = (p - x).Magnitude

		if pDist > yDist then
			y = p
			yDist = pDist
		end
	end

	-- get z, the point furthest from y
	local z = y
	local zDist = 0

	for _, p in ipairs(points) do
		local pDist = (p - y).Magnitude

		if pDist > zDist then
			z = p
			zDist = pDist
		end
	end

	-- use (y, z) as the initial bounding sphere
	local sc = (y + z)*0.5
	local sr = (y - z).Magnitude*0.5

	-- expand sphere to fit any outlying points
	for _, p in ipairs(points) do
		local pDist = (p - sc).Magnitude

		if pDist > sr then
			-- shift to midpoint
			sc = sc + (pDist - sr)*0.5*(p - sc).Unit

			-- expand
			sr = (pDist + sr)*0.5
		end
	end

	return sc, sr
end

-- canonicalize an angle to +-180 degrees
function CameraUtils.sanitizeAngle(a: number): number
	return (a + math.pi)%(2*math.pi) - math.pi
end

-- From TransparencyController
function CameraUtils.Round(num: number, places: number): number
	local decimalPivot = 10^places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end

function CameraUtils.IsFinite(val: number): boolean
	return val == val and val ~= math.huge and val ~= -math.huge
end

function CameraUtils.IsFiniteVector3(vec3: Vector3): boolean
	return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
end

-- Legacy implementation renamed
function CameraUtils.GetAngleBetweenXZVectors(v1: Vector3, v2: Vector3): number
	return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
end

function CameraUtils.RotateVectorByAngleAndRound(camLook: Vector3, rotateAngle: number, roundAmount: number): number
	if camLook.Magnitude > 0 then
		camLook = camLook.Unit
		local currAngle = math.atan2(camLook.Z, camLook.X)
		local newAngle = round((math.atan2(camLook.Z, camLook.X) + rotateAngle) / roundAmount) * roundAmount
		return newAngle - currAngle
	end
	return 0
end

-- K is a tunable parameter that changes the shape of the S-curve
-- the larger K is the more straight/linear the curve gets
local k = 0.35
local lowerK = 0.8
local function SCurveTranform(t: number)
	t = math.clamp(t, -1, 1)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.1
local function toSCurveSpace(t: number)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t: number)
	return t/2 + 0.5
end

function CameraUtils.GamepadLinearToCurve(thumbstickPosition: Vector2)
	local function onAxis(axisValue)
		local sign = 1
		if axisValue < 0 then
			sign = -1
		end
		local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
		point = point * sign
		return math.clamp(point, -1, 1)
	end
	return Vector2.new(onAxis(thumbstickPosition.X), onAxis(thumbstickPosition.Y))
end

-- This function converts 4 different, redundant enumeration types to one standard so the values can be compared
function CameraUtils.ConvertCameraModeEnumToStandard(enumValue:
		Enum.TouchCameraMovementMode |
		Enum.ComputerCameraMovementMode |
		Enum.DevTouchCameraMovementMode |
		Enum.DevComputerCameraMovementMode): Enum.ComputerCameraMovementMode | Enum.DevComputerCameraMovementMode
	if enumValue == Enum.TouchCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Follow
	end

	if enumValue == Enum.ComputerCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Classic
	end

	if enumValue == Enum.TouchCameraMovementMode.Classic or
		enumValue == Enum.DevTouchCameraMovementMode.Classic or
		enumValue == Enum.DevComputerCameraMovementMode.Classic or
		enumValue == Enum.ComputerCameraMovementMode.Classic then
		return Enum.ComputerCameraMovementMode.Classic
	end

	if enumValue == Enum.TouchCameraMovementMode.Follow or
		enumValue == Enum.DevTouchCameraMovementMode.Follow or
		enumValue == Enum.DevComputerCameraMovementMode.Follow or
		enumValue == Enum.ComputerCameraMovementMode.Follow then
		return Enum.ComputerCameraMovementMode.Follow
	end

	if enumValue == Enum.TouchCameraMovementMode.Orbital or
		enumValue == Enum.DevTouchCameraMovementMode.Orbital or
		enumValue == Enum.DevComputerCameraMovementMode.Orbital or
		enumValue == Enum.ComputerCameraMovementMode.Orbital then
		return Enum.ComputerCameraMovementMode.Orbital
	end

	if enumValue == Enum.ComputerCameraMovementMode.CameraToggle or
		enumValue == Enum.DevComputerCameraMovementMode.CameraToggle then
		return Enum.ComputerCameraMovementMode.CameraToggle
	end

	-- Note: Only the Dev versions of the Enums have UserChoice as an option
	if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or
		enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
		return Enum.DevComputerCameraMovementMode.UserChoice
	end

	-- For any unmapped options return Classic camera
	return Enum.ComputerCameraMovementMode.Classic
end

local function getMouse()
	local localPlayer = Players.LocalPlayer
	if not localPlayer then
		Players:GetPropertyChangedSignal("LocalPlayer"):Wait()
		localPlayer = Players.LocalPlayer
	end
	assert(localPlayer)
	return localPlayer:GetMouse()
end

local savedMouseIcon: string = ""
local lastMouseIconOverride: string? = nil
function CameraUtils.setMouseIconOverride(icon: string)
	local mouse = getMouse()
	-- Only save the icon if it was written by another script.
	if mouse.Icon ~= lastMouseIconOverride then
		savedMouseIcon = mouse.Icon
	end

	mouse.Icon = icon
	lastMouseIconOverride = icon
end

function CameraUtils.restoreMouseIcon()
	local mouse = getMouse()
	-- Only restore if it wasn't overwritten by another script.
	if mouse.Icon == lastMouseIconOverride then
		mouse.Icon = savedMouseIcon
	end
	lastMouseIconOverride = nil
end

local savedMouseBehavior: Enum.MouseBehavior = Enum.MouseBehavior.Default
local lastMouseBehaviorOverride: Enum.MouseBehavior? = nil
function CameraUtils.setMouseBehaviorOverride(value: Enum.MouseBehavior)
	if UserInputService.MouseBehavior ~= lastMouseBehaviorOverride then
		savedMouseBehavior = UserInputService.MouseBehavior
	end

	UserInputService.MouseBehavior = value
	lastMouseBehaviorOverride = value
end

function CameraUtils.restoreMouseBehavior()
	if UserInputService.MouseBehavior == lastMouseBehaviorOverride then
		UserInputService.MouseBehavior = savedMouseBehavior
	end
	lastMouseBehaviorOverride = nil
end

local savedRotationType: Enum.RotationType = Enum.RotationType.MovementRelative
local lastRotationTypeOverride: Enum.RotationType? = nil
function CameraUtils.setRotationTypeOverride(value: Enum.RotationType)
	if UserGameSettings.RotationType ~= lastRotationTypeOverride then
		savedRotationType = UserGameSettings.RotationType
	end

	UserGameSettings.RotationType = value
	lastRotationTypeOverride = value
end

function CameraUtils.restoreRotationType()
	if UserGameSettings.RotationType == lastRotationTypeOverride then
		UserGameSettings.RotationType = savedRotationType
	end
	lastRotationTypeOverride = nil
end

return CameraUtils

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">69a2d8b8201fa00706543142000070c7</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX0B0FACC55914449AAA5EB4B061C3C16A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">paradoxical</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">69a2d8b8201fa0070654314200007146</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX19D5A9B5A245473288460B2ADF7FE86D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">components</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa0070654314200007148</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX1267CC5BBE9D44C1BAB9B5EEBB484360">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">layer</string>
							<string name="ScriptGuid">{76514B00-D71B-4B08-9E35-5CDDF44D7B5A}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local IS_PLUGIN = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "constants").IS_PLUGIN
local function Layer(_param)
	local displayOrder = _param.displayOrder
	local children = _param.children
	-- eslint-disable-next-line roblox-ts/lua-truthiness
	local _result
	if IS_PLUGIN then
		local _attributes = {
			BackgroundTransparency = 1,
			Size = UDim2.new(1, 0, 1, 0),
			Position = UDim2.new(0, 0, 0, 0),
			ZIndex = displayOrder,
		}
		local _children = {}
		local _length = #_children
		if children then
			for _k, _v in children do
				if type(_k) == "number" then
					_children[_length + _k] = _v
				else
					_children[_k] = _v
				end
			end
		end
		_result = (Roact.createElement("Frame", _attributes, _children))
	else
		local _attributes = {
			DisplayOrder = displayOrder,
			IgnoreGuiInset = true,
			ResetOnSpawn = false,
			ZIndexBehavior = Enum.ZIndexBehavior.Sibling,
		}
		local _children = {}
		local _length = #_children
		if children then
			for _k, _v in children do
				if type(_k) == "number" then
					_children[_length + _k] = _v
				else
					_children[_k] = _v
				end
			end
		end
		_result = (Roact.createElement("ScreenGui", _attributes, _children))
	end
	return _result
end
return {
	Layer = Layer,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006017</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF8D40925B8F34B08B0057FD85E06C9BB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">counter</string>
							<string name="ScriptGuid">{401A33A4-17FD-4836-AD6C-585B1CFDEB0C}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local Roact = _roact
local useState = _roact.useState
local useRem = TS.import(script, script.Parent.Parent, "hooks", "use-rem").useRem
local fonts = TS.import(script, script.Parent.Parent, "utils", "fonts").fonts
local palette = TS.import(script, script.Parent.Parent, "utils", "palette").palette
local Button = TS.import(script, script.Parent, "button").Button
local COLORS = { palette.purple, palette.blue, palette.green, palette.yellow, palette.red }
local function Counter()
	local rem = useRem()
	local count, setCount = useState(0)
	local colorIndex, setColorIndex = useState(0)
	return Roact.createElement(Button, {
		onClick = function()
			setCount(count + 1)
			setColorIndex((colorIndex + 1) % #COLORS)
		end,
		font = fonts.inter.medium,
		text = "👆 Clicked " .. (tostring(count) .. " times"),
		textSize = rem(2),
		textColor = palette.white,
		backgroundColor = COLORS[colorIndex + 1],
		size = UDim2.new(0, rem(20), 0, rem(8)),
		position = UDim2.new(0.5, 0, 0.5, 0),
		anchorPoint = Vector2.new(0.5, 0.5),
	})
end
return {
	Counter = Counter,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006019</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX0A20ACBE22D24B82981AE6BB48645603">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">button</string>
							<string name="ScriptGuid">{D9521257-408E-4F81-8294-9FCB2968C328}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local Roact = _roact
local useEffect = _roact.useEffect
local useState = _roact.useState
local useMotion = TS.import(script, script.Parent.Parent, "hooks", "use-motion").useMotion
local useRem = TS.import(script, script.Parent.Parent, "hooks", "use-rem").useRem
local brighten = TS.import(script, script.Parent.Parent, "utils", "colors").brighten
local fonts = TS.import(script, script.Parent.Parent, "utils", "fonts").fonts
local palette = TS.import(script, script.Parent.Parent, "utils", "palette").palette
local springs = TS.import(script, script.Parent.Parent, "utils", "springs").springs
local function Button(_param)
	local onClick = _param.onClick
	local font = _param.font
	if font == nil then
		font = fonts.inter.regular
	end
	local text = _param.text
	local textSize = _param.textSize
	local textColor = _param.textColor
	if textColor == nil then
		textColor = palette.white
	end
	local backgroundColor = _param.backgroundColor
	if backgroundColor == nil then
		backgroundColor = palette.blue
	end
	local size = _param.size
	local position = _param.position
	local anchorPoint = _param.anchorPoint
	local children = _param.children
	local rem = useRem()
	local pressed, setPressed = useState(false)
	local hovered, setHovered = useState(false)
	local buttonPosition, buttonPositionMotion = useMotion(0)
	local buttonColor, buttonColorMotion = useMotion(backgroundColor)
	useEffect(function()
		if pressed then
			buttonPositionMotion:spring(rem(0.5), springs.responsive)
			buttonColorMotion:spring(brighten(backgroundColor, -0.1), springs.responsive)
		elseif hovered then
			buttonPositionMotion:spring(rem(-0.5), springs.responsive)
			buttonColorMotion:spring(brighten(backgroundColor, 0.1), springs.responsive)
		else
			buttonPositionMotion:spring(0, springs.responsive)
			buttonColorMotion:spring(backgroundColor, springs.responsive)
		end
	end, { pressed, hovered, backgroundColor, rem })
	useEffect(function()
		if not pressed and hovered then
			buttonPositionMotion:impulse(rem(-0.05))
			buttonPositionMotion:spring(rem(-0.5), springs.bubbly)
		end
	end, { pressed })
	local _attributes = {
		BackgroundTransparency = 1,
		AnchorPoint = anchorPoint,
		Size = size,
		Position = position,
	}
	local _children = {}
	local _length = #_children
	local _attributes_1 = {
		key = "button",
		FontFace = font,
		Text = text,
		TextColor3 = textColor,
		TextSize = textSize,
		AutoButtonColor = false,
		BackgroundColor3 = buttonColor,
		Size = UDim2.new(1, 0, 1, 0),
		Position = buttonPosition:map(function(y)
			return UDim2.new(0, 0, 0, y)
		end),
		[Roact.Event.Activated] = onClick,
		[Roact.Event.MouseEnter] = function()
			return setHovered(true)
		end,
		[Roact.Event.MouseLeave] = function()
			setHovered(false)
			setPressed(false)
		end,
		[Roact.Event.MouseButton1Down] = function()
			return setPressed(true)
		end,
		[Roact.Event.MouseButton1Up] = function()
			return setPressed(false)
		end,
	}
	local _children_1 = {
		Roact.createElement("UICorner", {
			key = "button-corner",
			CornerRadius = UDim.new(0, rem(1)),
		}),
	}
	local _length_1 = #_children_1
	if children then
		for _k, _v in children do
			if type(_k) == "number" then
				_children_1[_length_1 + _k] = _v
			else
				_children_1[_k] = _v
			end
		end
	end
	_children[_length + 1] = Roact.createElement("TextButton", _attributes_1, _children_1)
	return Roact.createElement("Frame", _attributes, _children)
end
return {
	Button = Button,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000601b</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX27417290B5BF49458AC0209B5CE38A74">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">hooks</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa0070654314200007149</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX08C652D160F74EAA8A71779B81099BFF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">use-motion</string>
							<string name="ScriptGuid">{6747C6D0-7BBE-477E-92EA-27054025E3D9}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEventListener = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "pretty-react-hooks").useEventListener
local createMotion = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "ripple").createMotion
local _roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local useBinding = _roact.useBinding
local useMemo = _roact.useMemo
local RunService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").RunService
local function useMotion(initialValue)
	local motion = useMemo(function()
		return createMotion(initialValue)
	end, {})
	local binding, setValue = useBinding(initialValue)
	useEventListener(RunService.Heartbeat, function(delta)
		local value = motion:step(delta)
		if value ~= binding:getValue() then
			setValue(value)
		end
	end)
	return binding, motion
end
return {
	useMotion = useMotion,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000602f</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB6D97829BEE9469C9D6B5EDE047A1F3F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">use-rem</string>
							<string name="ScriptGuid">{562E778E-3B7B-4AEC-B1F4-56FE1EC843B7}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local useCallback = _roact.useCallback
local useEffect = _roact.useEffect
local useState = _roact.useState
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local BASE_REM = 16
local BASE_VIEWPORT = Vector2.new(1920, 1080)
local DOMINANT_AXIS = 0.5
--[[
	*
	 * @see https://discord.com/channels/476080952636997633/476080952636997635/1146857136358432900
	 
]]
local function calculateRem(viewport)
	local width = math.log(viewport.X / BASE_VIEWPORT.X, 2)
	local height = math.log(viewport.Y / BASE_VIEWPORT.Y, 2)
	local centered = width + (height - width) * DOMINANT_AXIS
	return BASE_REM * 2 ^ centered
end
local function useRem()
	local rem, setRem = useState(BASE_REM)
	useEffect(function()
		local camera = Workspace.CurrentCamera
		local connection = camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
			setRem(calculateRem(camera.ViewportSize))
		end)
		setRem(calculateRem(camera.ViewportSize))
		return function()
			connection:Disconnect()
		end
	end, {})
	return useCallback(function(value)
		return value * rem
	end, { rem })
end
return {
	useRem = useRem,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006033</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXD1F74C3DA4614588A3F42C831379D270">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">provider</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa007065431420000714a</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXF54D9343B67C47AAB3891583D33D79F0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">rem-provider</string>
							<string name="ScriptGuid">{12CA5856-9648-4317-AEFB-D01313D9E9C0}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _pretty_react_hooks = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "pretty-react-hooks")
local map = _pretty_react_hooks.map
local useCamera = _pretty_react_hooks.useCamera
local useDebounceState = _pretty_react_hooks.useDebounceState
local useEventListener = _pretty_react_hooks.useEventListener
local _roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local Roact = _roact
local createContext = _roact.createContext
local useEffect = _roact.useEffect
local DEFAULT_REM = 16
local MIN_REM = 8
local BASE_RESOLUTION = Vector2.new(1920, 1020)
local MAX_ASPECT_RATIO = 19 / 9
local RemContext = createContext(DEFAULT_REM)
local function RemProvider(_param)
	local baseRem = _param.baseRem
	if baseRem == nil then
		baseRem = DEFAULT_REM
	end
	local minimumRem = _param.minimumRem
	if minimumRem == nil then
		minimumRem = MIN_REM
	end
	local maximumRem = _param.maximumRem
	if maximumRem == nil then
		maximumRem = math.huge
	end
	local remOverride = _param.remOverride
	local children = _param.children
	local camera = useCamera()
	local rem, setRem = useDebounceState(baseRem, {
		wait = 0.2,
		leading = true,
	})
	local update = function()
		local viewport = camera.ViewportSize
		if remOverride ~= nil then
			return remOverride
		end
		-- wide screens should not scale beyond iPhone aspect ratio
		local resolution = Vector2.new(math.min(viewport.X, viewport.Y * MAX_ASPECT_RATIO), viewport.Y)
		local scale = resolution.Magnitude / BASE_RESOLUTION.Magnitude
		local desktop = resolution.X > resolution.Y or scale >= 1
		-- portrait mode should downscale slower than landscape
		local factor = if desktop then scale else map(scale, 0, 1, 0.25, 1)
		setRem(math.clamp(math.round(baseRem * factor), minimumRem, maximumRem))
	end
	useEventListener(camera:GetPropertyChangedSignal("ViewportSize"), update)
	useEffect(function()
		update()
	end, { baseRem, minimumRem, maximumRem, remOverride })
	local _attributes = {
		value = rem,
	}
	local _children = {}
	local _length = #_children
	if children then
		for _k, _v in children do
			if type(_k) == "number" then
				_children[_length + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement(RemContext.Provider, _attributes, _children)
end
return {
	RemProvider = RemProvider,
	DEFAULT_REM = DEFAULT_REM,
	MIN_REM = MIN_REM,
	RemContext = RemContext,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006029</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD22FCD04491C4AC0A605589D60C7D933">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">root-provider</string>
							<string name="ScriptGuid">{89738C89-026B-4302-AC87-5C3863791E4A}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local ReflexProvider = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react-reflex").ReflexProvider
local Roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local store = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "client").store
local RemProvider = TS.import(script, script.Parent, "rem-provider").RemProvider
local function RootProvider(_param)
	local baseRem = _param.baseRem
	local remOverride = _param.remOverride
	local children = _param.children
	local _attributes = {
		producer = store,
	}
	local _children = {}
	local _length = #_children
	local _attributes_1 = {
		key = "rem-provider",
		baseRem = baseRem,
		remOverride = remOverride,
	}
	local _children_1 = {}
	local _length_1 = #_children_1
	if children then
		for _k, _v in children do
			if type(_k) == "number" then
				_children_1[_length_1 + _k] = _v
			else
				_children_1[_k] = _v
			end
		end
	end
	_children[_length + 1] = Roact.createElement(RemProvider, _attributes_1, _children_1)
	return Roact.createElement(ReflexProvider, _attributes, _children)
end
return {
	RootProvider = RootProvider,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000602d</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX79004AB0C108444BBB4A29E9E5E228FB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">stories</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa007065431420000714b</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX5A42C9995CF948A48D023BC4CB1E25ED">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">app.story</string>
							<string name="ScriptGuid">{7B2BFAD7-A561-4A47-A9C0-08ACF3A8745D}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
TS.import(script, script.Parent.Parent, "app", "dev")
local hoarcekat = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "pretty-react-hooks").hoarcekat
local Roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local App = TS.import(script, script.Parent.Parent, "app", "app").App
return hoarcekat(function()
	return Roact.createElement(App)
end)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006023</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXECDCC224B0DD4F7EA66A5219BB91114F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">utils</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">69a2d8b8201fa007065431420000714c</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXC9204DC466D94024BFA5B6677B10B73E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">springs</string>
							<string name="ScriptGuid">{690037E0-B01D-4EB1-8C68-7CF12465A944}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local config = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "ripple").config
local _object = {}
for _k, _v in config.spring do
	_object[_k] = _v
end
_object.bubbly = {
	tension = 300,
	friction = 20,
	mass = 1.2,
}
_object.responsive = {
	tension = 600,
	friction = 34,
	mass = 0.7,
}
local springs = _object
return {
	springs = springs,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006025</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX46689FCDF7574468B477E7427B327A38">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">fonts</string>
							<string name="ScriptGuid">{4092E3B2-DEF4-40D6-8457-1D35E271C24B}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local fonts = {
	inter = {
		regular = Font.new("rbxassetid://12187365364"),
		medium = Font.new("rbxassetid://12187365364", Enum.FontWeight.Medium),
		bold = Font.new("rbxassetid://12187365364", Enum.FontWeight.Bold),
	},
}
return {
	fonts = fonts,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006027</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX6F03CA6F6FEA4283A77D112D682DE215">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">colors</string>
							<string name="ScriptGuid">{D3826C72-F4C6-45FA-9562-6FF862CB6DA8}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local function lerp(a, b, t)
	return a + (b - a) * t
end
local function brighten(color, percent, vibrancy)
	if vibrancy == nil then
		vibrancy = 0.5
	end
	local h, s, v = color:ToHSV()
	local goal = if math.sign(percent) == 1 then 1 else 0
	local alpha = math.abs(percent)
	return Color3.fromHSV(h, lerp(s, 1 - goal, alpha * vibrancy), lerp(v, goal, alpha))
end
return {
	brighten = brighten,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006031</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX78DAA2C902ED4CAFB04A7F892CB8820A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">palette</string>
							<string name="ScriptGuid">{68F7CA0F-CB75-4368-844C-776A1AC58A28}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local palette = {
	white = Color3.fromRGB(255, 255, 255),
	black = Color3.fromRGB(0, 0, 0),
	blue = Color3.fromRGB(56, 67, 214),
	purple = Color3.fromRGB(122, 57, 202),
	red = Color3.fromRGB(218, 56, 84),
	yellow = Color3.fromRGB(243, 163, 88),
	green = Color3.fromRGB(0, 174, 126),
}
return {
	palette = palette,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006035</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX288D167BA61A44B7B3776A3A536E9ACD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">app</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{4DAAE3EF-F1C8-41A7-A19D-4105CC76033E}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
TS.import(script, script, "dev")
local _react_roblox = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "ReactRoblox")
local createRoot = _react_roblox.createRoot
local createPortal = _react_roblox.createPortal
local _roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local Roact = _roact
local StrictMode = _roact.StrictMode
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local App = TS.import(script, script, "app").App
local root = createRoot(Instance.new("Folder"))
local target = Players.LocalPlayer:WaitForChild("PlayerGui")
root:render(createPortal(Roact.createElement(StrictMode, {}, {
	Roact.createElement(App, {
		key = "app",
	}),
}), target))
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006021</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXC551333E34EE45038E6DD5F93592C126">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">app</string>
							<string name="ScriptGuid">{70CD3054-2F1D-4450-99F1-CE3BF1A43ECF}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "RoactTS")
local function App()
	return Roact.createFragment()
end
return {
	App = App,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000601d</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX7F8DE5B4DCB6465895B000AE1CF14E5B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">dev</string>
							<string name="ScriptGuid">{D1E67497-9E32-4D20-B13C-F56DE07E326E}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local RunService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").RunService
if RunService:IsStudio() then
	_G.__DEV__ = true
end
return nil
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000601f</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBXA99EE4E720C743A3AB00DCE2F1AD2AC5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ecs</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{D2FBBC63-EC83-4EFF-A4FB-E9BC1806FD31}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local start = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs").start
local Host = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hosts").Host
local setEnvironment = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "idAttribute").setEnvironment
TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "client")
local HOST = Host.Client
setEnvironment(HOST)
start(HOST)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000602b</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBXE702190FC5F74F79A4FF39FAA4E82DA8">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005af</UniqueId>
			</Properties>
			<Item class="Script" referent="RBXAC8BA87C8D8348B7AF6515240D16287D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Health</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{C0C7CFC5-A062-4919-B204-4B4AAC249B13}</string>
					<ProtectedString name="Source"></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">69a2d8b8201fa007065431420000718d</UniqueId>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX4200956C947D44F9B8F23E991F5F21F6">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Animate</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{837A3C22-8F1E-4AD7-B21B-95C5460C05F3}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
print("afnkahfbahbfa")]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">69a2d8b8201fa007065431420000718f</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX58F2B72DF08A434D839660089DAB9481">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000032f</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX73DBE1D6A50644EFA15F939286DBC2EA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000330</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX8BA8765E22F84AE792EE1B2478B57F65">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000334</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX1780D4989B94441EB53D2811F23CDE22">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000337</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX16777274EE9A464494B6BE7F46AD1BCE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000325</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX3A0139A036904C3A9B3E6D6462CDA000">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000326</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX27639657E73241DE9656695E836F6C95">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000033e</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBXA1A00A4C2E7546108DA6CF6F4D14F74B">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900006006</UniqueId>
				<string name="Value">{289598B7-7908-4DCF-A338-5FDF55D76FFF}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX813603E569984694A14AD75EE1D3627D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000032b</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXD98D06F9E92F47109C4327E31F910DAA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000032c</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX3FEAA9246D8B4566924064743F1185B2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000032e</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX1216C7EC639E49FD9BE059A8CD99EA5D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000330</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX4167249E33E24A3984146BB480470F22">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000347</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXE689819389B04D7DB1C57FA78ADF0BC9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000335</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX0AC95E2E8EC3437FA811201499C0082B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000336</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBXA82CA7F1E57D46C3AA026EC092D7F707">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000034a</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBX18F6F76765C64869814991DB3E583835">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000338</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="RBXCDA9B6E784D6432C8DDA67136D34E741">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000034f</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBXAC9B369056C34D57ABD3D8B3C2544527">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">paradoxical</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000590</UniqueId>
			</Properties>
			<Item class="Script" referent="RBX22853E11F65343AAB62FA3D40891E233">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<bool name="Disabled">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">server</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{A62D75F5-23AB-43E3-8390-966929DE444C}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local start = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs").start
local Host = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hosts").Host
local setEnvironment = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "idAttribute").setEnvironment
TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "store")
local HOST = Host.Server
setEnvironment(HOST)
start(HOST)
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000591</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX3A37544754F14485948557F96B61EE2D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">systems</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000592</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXF14192E097D740AA908524A1D900BB24">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">removeMissingModels</string>
						<string name="ScriptGuid">{E49F8D78-C668-4ED2-8466-515766BCA1A4}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local Model = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Model
--[[
	*
	 * A system that removes missing {@link Model | Models}.
	 *
	 * If a model is removed from the game, this system will remove the
	 * corresponding model from the world.
	 *
	 * If a model is removed from the world, this system will remove the
	 * corresponding model from the game.
	 
]]
local function removeMissingModels(world)
	for id, model in world:query(Model) do
		if not model.model then
			continue
		end
		for _index, _child, _parent in useEvent(model.model, "AncestryChanged") do
			local _ = { _index, _child, _parent }
			if not model.model:IsDescendantOf(game) then
				world:remove(id, Model)
				break
			end
		end
	end
	for _, record in world:queryChanged(Model) do
		if record.new then
			continue
		end
		local _result = record.old
		if _result ~= nil then
			_result = _result.model
			if _result ~= nil then
				_result:Destroy()
			end
		end
	end
end
return removeMissingModels
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000593</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD5E94E83D15644DCAC99D5F8C789C747">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">replication</string>
						<string name="ScriptGuid">{D77D78DD-9264-4D8A-ACCE-2F721A3A229A}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local matterReplication = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "net").matterReplication
local Components = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components")
local REPLICATED_COMPONENT_NAMES = { "Model" }
local _arg0 = function(set, name)
	local _set = set
	local _arg0_1 = Components[name]
	_set[_arg0_1] = true
	return _set
end
-- ▼ ReadonlyArray.reduce ▼
local _result = {}
local _callback = _arg0
for _i = 1, #REPLICATED_COMPONENT_NAMES do
	_result = _callback(_result, REPLICATED_COMPONENT_NAMES[_i], _i - 1, REPLICATED_COMPONENT_NAMES)
end
-- ▲ ReadonlyArray.reduce ▲
local replicatedComponents = _result
local function replication(world)
	local payload
	for _, player in useEvent(Players, "PlayerAdded") do
		if not payload then
			payload = {}
			for id, entityData in world do
				local entityPayload = {}
				local _payload = payload
				local _arg0_1 = tostring(id)
				_payload[_arg0_1] = entityPayload
				for component, componentData in entityData do
					if replicatedComponents[component] ~= nil then
						-- Here we are certain that the component has the name of one of our
						-- components because it exists in our set of components.
						local _arg0_2 = tostring(component)
						local _arg1 = {
							data = componentData,
						}
						entityPayload[_arg0_2] = _arg1
					end
				end
			end
		end
		print("Sending initial payload to", player)
		matterReplication.replication.sendTo(payload, player)
	end
	local changes = {}
	for component in replicatedComponents do
		-- Here we are certain that the component has the name of one of our
		-- components since it came from our set.
		local name = tostring(component)
		for id, record in world:queryChanged(component) do
			local key = tostring(id)
			if not (changes[key] ~= nil) then
				changes[key] = {}
			end
			if world:contains(id) then
				local _result_1 = changes[key]
				if _result_1 ~= nil then
					local _arg1 = {
						data = record.new,
					}
					_result_1[name] = _arg1
				end
			end
		end
	end
	if not (next(changes) == nil) then
		matterReplication.replication.sendToAll(changes)
	end
end
--[[
	*
	 * A system that replicates all replicated components to the client.
	 *
	 * This system runs after after all other systems to ensure any changes made are
	 * included.
	 
]]
return {
	system = replication,
	priority = math.huge,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000594</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXFD8270AF8B5B4E5A82B0D3B17AAA3230">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">updateTransforms</string>
						<string name="ScriptGuid">{CAFD33AB-7A41-4103-A10E-75FD0D82A558}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Workspace = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Workspace
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components")
local Model = _components.Model
local Transform = _components.Transform
local removeMissingModels = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "systems", "removeMissingModels")
local function updateTransforms(world)
	for id, record in world:queryChanged(Transform) do
		if not world:contains(id) then
			continue
		end
		local model = world:get(id, Model)
		if not model or (not record.new or record.new._doNotReconcile) then
			continue
		end
		local _result = model.model
		if _result ~= nil then
			_result:PivotTo(record.new.cframe)
		end
	end
	for id, record in world:queryChanged(Model) do
		if not world:contains(id) then
			continue
		end
		local transform = world:get(id, Transform)
		if not transform then
			continue
		end
		local _result = record.new
		if _result ~= nil then
			_result = _result.model
			if _result ~= nil then
				_result:PivotTo(transform.cframe)
			end
		end
	end
	for id, model, transform in world:query(Model, Transform) do
		if not model.model then
			continue
		end
		local primaryPart
		if model.model:IsA("Model") then
			if not model.model.PrimaryPart then
				continue
			end
			primaryPart = model.model.PrimaryPart
		elseif model.model:IsA("BasePart") then
			primaryPart = model.model
		else
			continue
		end
		if primaryPart.Anchored then
			continue
		end
		if transform.cframe.Y < Workspace.FallenPartsDestroyHeight then
			world:despawn(id)
			continue
		end
		if transform.cframe ~= primaryPart.CFrame then
			world:insert(id, Transform({
				cframe = primaryPart.CFrame,
				_doNotReconcile = true,
			}))
		end
	end
end
--[[
	*
	 * A system that updates {@link Transform | Transforms}.
	 *
	 * If a Transform is updated, the corresponding {@link Model} is updated to
	 * match the Transform.
	 *
	 * If a Model is updated, the new referenced instance is updated to match the
	 * Transform.
	 *
	 * If an non-anchored model moves, the Transform is updated to match the updated
	 * instance transform.
	 *
	 * This system runs after {@link removeMissingModels} to ensure updates aren't
	 * performed unnecessarily.
	 
]]
return {
	system = updateTransforms,
	after = { removeMissingModels },
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000595</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX4CA609E27A4042EE8C481E66C25018F5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">loadPlayerData</string>
						<string name="ScriptGuid">{D3E15744-919A-41FE-9C50-DF11A331883C}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local Health = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Health
local spawnPlayers = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "systems", "spawnPlayers")
local isInserted = {}
local function loadPlayerData(world, state)
	for _, player in Players:GetPlayers() do
		local _userId = player.UserId
		if table.find(isInserted, _userId) ~= nil then
			continue
		end
		local relfexState = state.reflex
		-- eslint-disable-next-line prettier/prettier
		local data = {
			[Health] = relfexState:getState().players.health,
		}
		local shouldContinue = true
		for _, state in data do
			if state[player.UserId] == nil then
				shouldContinue = false
				break
			end
		end
		if not shouldContinue then
			continue
		end
		if not world:contains(player.UserId) then
			continue
		end
		for component, state in data do
			-- eslint-disable-next-line @typescript-eslint/no-explicit-any
			world:insert(player.UserId, component():patch(state[player.UserId]))
		end
		local _userId_1 = player.UserId
		table.insert(isInserted, _userId_1)
	end
end
return {
	system = loadPlayerData,
	after = { spawnPlayers },
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000066a4</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXC6DC945F3C3D4B90B993A87AE8B9AD9D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">spawnPlayers</string>
						<string name="ScriptGuid">{ACC6CFB6-F63E-45DA-A1B5-94228513EDCF}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useEvent = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").useEvent
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components")
local Model = _components.Model
local Transform = _components.Transform
local function spawnPlayers(world)
	for _, player in Players:GetPlayers() do
		for _id, character in useEvent(player, "CharacterAdded") do
			if world:contains(player.UserId) then
				world:insert(player.UserId, Model({
					model = character,
					humanoid = character:FindFirstChildOfClass("Humanoid"),
				}), Transform())
			else
				world:spawnAt(player.UserId, Model({
					model = character,
					humanoid = character:FindFirstChildOfClass("Humanoid"),
				}), Transform())
			end
		end
	end
end
return spawnPlayers
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006996</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXD7E981B5578444E380B9BDD256839728">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">updateReflexStates</string>
						<string name="ScriptGuid">{935CD78C-C72C-4AE6-91E9-DEF56A92BEC5}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local loadPlayerData = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "systems", "loadPlayerData")
local Health = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Health
local function updateReflexStates(world, state)
	for id, record in world:queryChanged(Health) do
		if record.new == nil then
			continue
		end
		(state.reflex).changeHealth(tostring(id) .. "", record.new)
	end
end
return {
	system = updateReflexStates,
	after = { loadPlayerData },
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006b66</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXDE5C3426CDBE484C80690C71F0982990">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">simulateCommands</string>
						<string name="ScriptGuid">{1C814D79-4462-44BA-B4C3-738478F9F2D1}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local useBytenet = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hooks", "useBytenet")
local commands = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "net").commands
local function simulateCommands(world)
	for _, data, player in useBytenet("10", commands.handleCommands) do
		print(data, player)
	end
end
return simulateCommands
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">4d819ccbdf0742ee065c08b5000061fe</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXB865FB60199342F3B9844FD9ED071B44">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">data</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3a589e3654c30573064751ed00006028</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXFB353315976346E1B6451376A770096E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">validate</string>
						<string name="ScriptGuid">{46EF0AAD-DDA4-4FFD-9775-244E3E3AAB42}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "t", "lib", "ts").t
local validate = t.strictInterface({
	health = t.strictInterface({
		current = t.number,
		max = t.number,
		regenAmount = t.number,
		regenRate = t.number,
		regenCD = t.number,
	}),
})
return {
	validate = validate,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3a589e3654c30573064751ed00006383</UniqueId>
					</Properties>
				</Item>
				<Item class="Script" referent="RBXABF4479B73F043A98CF027D061EFD9A7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<bool name="Disabled">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">lapis</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{10CD85BE-155D-4B48-8BA7-128AD17ACA99}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _lapis = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "lapis", "out")
local createCollection = _lapis.createCollection
local setConfig = _lapis.setConfig
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local store = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "store").store
local selectPlayerData = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "selectors").selectPlayerData
local defaultPlayerData = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players").defaultPlayerData
local validate = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "data", "validate").validate
local DataStoreWrapper = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "data", "dataStore")
-- Required to allow interfaces to be used as the collection type
-- eslint-disable-next-line @typescript-eslint/no-explicit-any
setConfig({
	dataStoreService = DataStoreWrapper,
})
local collection = createCollection("PlayerData", {
	defaultData = defaultPlayerData,
	validate = validate,
})
local loadDefaultData = TS.async(function(player)
	store.loadPlayerHealth(tostring(player.UserId) .. "", defaultPlayerData)
	local _exp = TS.Promise.fromEvent(Players.PlayerRemoving, function(p)
		return p == player
	end)
	local _arg0 = function()
		store.closePlayerHealth(tostring(player.UserId) .. "")
	end
	_exp:andThen(_arg0)
end)
local loadPlayerData = TS.async(function(player)
	if player.UserId < 0 then
		-- Lapis session locking may break in local test servers, which use
		-- negative user IDs, so we just load the default data instead.
		return loadDefaultData(player)
	end
	local _exitType, _returns = TS.try(function()
		local document = TS.await(collection:load(tostring(player.UserId), { player.UserId }))
		if not player:IsDescendantOf(Players) then
			return TS.TRY_RETURN, {}
		end
		local unsubscribe = store:subscribe(selectPlayerData(tostring(player.UserId) .. ""), function(data)
			if data then
				document:write(data)
			end
		end)
		local _exp = TS.Promise.fromEvent(Players.PlayerRemoving, function(p)
			return p == player
		end)
		local _arg0 = function()
			document:close()
			unsubscribe()
			store.closePlayerHealth(tostring(player.UserId) .. "")
		end
		_exp:andThen(_arg0)
		store.loadPlayerHealth(tostring(player.UserId) .. "", document:read())
	end, function(err)
		warn("Failed to load data for " .. (player.Name .. (": " .. tostring(err))))
		player:Kick("Failed to load data. If issues persists report to developers.")
	end)
	if _exitType then
		return unpack(_returns)
	end
end)
Players.PlayerAdded:Connect(function(player)
	loadPlayerData(player)
	store.loadAnimationPlayer(tostring(player.UserId) .. "")
	store.loadAnimationIdPlayer(tostring(player.UserId) .. "")
end)
for _, player in Players:GetPlayers() do
	loadPlayerData(player)
	store.closeAnimationPlayer(tostring(player.UserId) .. "")
	store.closeAnimationIdPlayer(tostring(player.UserId) .. "")
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3a589e3654c30573064751ed00006389</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX239B97F9A10A4EED831F1B9F2BE27468">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">dataStore</string>
						<string name="ScriptGuid">{31DCBEE2-FD70-4081-88BB-F25F5CF2DEE2}</string>
						<ProtectedString name="Source"><![CDATA[local MockDataStoreServiceModule = script.mockDataStore

local shouldUseMock = false
if game.GameId == 0 then -- Local place file
	shouldUseMock = true
elseif game:GetService("RunService"):IsStudio() then -- Published file in Studio
	local status, message = pcall(function()
		-- This will error if current instance has no Studio API access:
		game:GetService("DataStoreService"):GetDataStore("__TEST"):SetAsync("__TEST", "__TEST_" .. os.time())
	end)
	if not status and message:find("403", 1, true) then -- HACK
		-- Can connect to datastores, but no API access
		shouldUseMock = true
	end
end

-- Return the mock or actual service depending on environment:
if shouldUseMock then
	warn("INFO: Using MockDataStoreService instead of DataStoreService")
	return require(MockDataStoreServiceModule).new()
else
	return game:GetService("DataStoreService")
end
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063b6</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXB8304DA011374C889C2230225599953F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">mockDataStore</string>
							<string name="ScriptGuid">{951C2265-02CB-4845-BA54-FD552C5D2F14}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Budget = require(script.budget)
local Constants = require(script.constants)
local GlobalDataStore = require(script.globalDataStore)
local SimulatedErrors = require(script.simulatedErrors)
local SimulatedYield = require(script.simulatedYield)
local validateString = require(script.validateString)

local function assertServer()
	if not RunService:IsServer() then
		error("DataStore can't be accessed from the client")
	end
end

local DataStoreServiceMock = {}
DataStoreServiceMock.__index = DataStoreServiceMock

function DataStoreServiceMock.new()
	return setmetatable({
		dataStores = {},
		errors = SimulatedErrors.new(),
		yield = SimulatedYield.new(),
		budget = Budget.new(),
	}, DataStoreServiceMock)
end

function DataStoreServiceMock.manual()
	return setmetatable({
		dataStores = {},
		errors = SimulatedErrors.new(),
		yield = SimulatedYield.new(),
		budget = Budget.manual(),
	}, DataStoreServiceMock)
end

function DataStoreServiceMock:GetDataStore(name, scope)
	assertServer()

	scope = scope or "global"

	validateString("name", name, Constants.MAX_NAME_LENGTH)
	validateString("scope", scope, Constants.MAX_SCOPE_LENGTH)

	if self.dataStores[name] == nil then
		self.dataStores[name] = {}
	end

	if self.dataStores[name][scope] == nil then
		self.dataStores[name][scope] = GlobalDataStore.new(self.budget, self.errors, self.yield)
	end

	return self.dataStores[name][scope]
end

function DataStoreServiceMock:GetRequestBudgetForRequestType(requestType)
	local budget = self.budget.budgets[requestType]

	if budget == nil then
		error("`requestType` must be an Enum.DataStoreRequestType")
	end

	return budget
end

return DataStoreServiceMock]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063b8</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXC0B4679DEAE540E78B61042295618946">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">budget</string>
								<string name="ScriptGuid">{A52298E8-DB31-4402-8F79-72E7D176354B}</string>
								<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Constants = require(script.Parent.constants)

local function defaultBudget()
	local budgets = {}
	local queues = {}

	for requestType, options in Constants.REQUEST_BUDGETS do
		budgets[requestType] = options.INITIAL_BUDGET
		queues[requestType] = {}
	end

	budgets[Enum.DataStoreRequestType.UpdateAsync] =
		math.min(budgets[Enum.DataStoreRequestType.GetAsync], budgets[Enum.DataStoreRequestType.SetIncrementAsync])

	return {
		accumulatedSeconds = 0,
		budgets = budgets,
		queues = queues,
		maxThrottleQueueSize = Constants.MAX_THROTTLE_QUEUE_SIZE,
	}
end

local Budget = {}
Budget.__index = Budget

function Budget.new()
	local self = setmetatable(defaultBudget(), Budget)

	self.manual = false

	RunService.PostSimulation:Connect(function(deltaSeconds)
		self:tick(deltaSeconds)
	end)

	return self
end

function Budget.manual()
	local self = setmetatable(defaultBudget(), Budget)

	self.manual = true

	return self
end

function Budget:setMaxThrottleQueueSize(size)
	self.maxThrottleQueueSize = size
end

function Budget:hasBudget(requestTypes)
	for _, requestType in requestTypes do
		if self.budgets[requestType] < 1 then
			return false
		end
	end

	return true
end

function Budget:consumeBudget(requestTypes)
	for _, requestType in requestTypes do
		self.budgets[requestType] = math.max(self.budgets[requestType] - 1, 0)
	end

	self.budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
		self.budgets[Enum.DataStoreRequestType.GetAsync],
		self.budgets[Enum.DataStoreRequestType.SetIncrementAsync]
	)
end

function Budget:updateBudgets()
	local playerCount = #Players:GetPlayers()

	for requestType, options in Constants.REQUEST_BUDGETS do
		local rate = options.RATE + playerCount * options.RATE_PER_PLAYER

		self.budgets[requestType] = math.min(
			self.budgets[requestType] + rate * Constants.BUDGET_UPDATE_INTERVAL,
			options.MAX_BUDGET_FACTOR * rate
		)
	end

	self.budgets[Enum.DataStoreRequestType.UpdateAsync] = math.min(
		self.budgets[Enum.DataStoreRequestType.GetAsync],
		self.budgets[Enum.DataStoreRequestType.SetIncrementAsync]
	)
end

function Budget:updateQueues()
	for index, queue in self.queues do
		local newQueue = {}

		for _, request in queue do
			if self:hasBudget(request.requestTypes) then
				self:consumeBudget(request.requestTypes)
				coroutine.resume(request.thread)
			else
				table.insert(newQueue, request)
			end
		end

		self.queues[index] = newQueue
	end
end

function Budget:update()
	self:updateBudgets()
	self:updateQueues()
end

function Budget:tick(deltaSeconds)
	self.accumulatedSeconds += deltaSeconds

	while self.accumulatedSeconds >= Constants.BUDGET_UPDATE_INTERVAL do
		self:update()
		self.accumulatedSeconds -= Constants.BUDGET_UPDATE_INTERVAL
	end
end

function Budget:yieldForBudget(requestTypes)
	local mainRequestType = requestTypes[1]

	if self:hasBudget(requestTypes) then
		self:consumeBudget(requestTypes)
	elseif #self.queues[mainRequestType] >= self.maxThrottleQueueSize then
		error("Request was throttled due to lack of budget but the throttle queue was full")
	else
		warn("Request was throttled due to lack of budget")

		table.insert(self.queues[mainRequestType], {
			thread = coroutine.running(),
			requestTypes = requestTypes,
		})

		coroutine.yield()
	end
end

return Budget
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063ba</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD42028FCB4A54C849A08910587C24663">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">constants</string>
								<string name="ScriptGuid">{D66CEC63-4950-470E-AC56-97A22CB90462}</string>
								<ProtectedString name="Source"><![CDATA[return {
	MAX_NAME_LENGTH = 50,
	MAX_SCOPE_LENGTH = 50,
	MAX_KEY_LENGTH = 50,

	MAX_THROTTLE_QUEUE_SIZE = 30, -- The amount of requests that can be throttled per request type at once before the request will error.

	BUDGET_UPDATE_INTERVAL = 1,

	GET_CACHE_DURATION = 5,

	REQUEST_BUDGETS = {
		[Enum.DataStoreRequestType.GetAsync] = {
			INITIAL_BUDGET = 100,
			RATE = 60,
			RATE_PER_PLAYER = 10,
			MAX_BUDGET_FACTOR = 3,
		},

		[Enum.DataStoreRequestType.SetIncrementAsync] = {
			INITIAL_BUDGET = 100,
			RATE = 60,
			RATE_PER_PLAYER = 10,
			MAX_BUDGET_FACTOR = 3,
		},

		[Enum.DataStoreRequestType.SetIncrementSortedAsync] = {
			INITIAL_BUDGET = 50,
			RATE = 30,
			RATE_PER_PLAYER = 5,
			MAX_BUDGET_FACTOR = 3,
		},

		[Enum.DataStoreRequestType.OnUpdate] = {
			INITIAL_BUDGET = 30,
			RATE = 30,
			RATE_PER_PLAYER = 5,
			MAX_BUDGET_FACTOR = 1,
		},

		[Enum.DataStoreRequestType.GetSortedAsync] = {
			INITIAL_BUDGET = 10,
			RATE = 5,
			RATE_PER_PLAYER = 2,
			MAX_BUDGET_FACTOR = 3,
		},
	},
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063bc</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE04D05606C3A4DCB801F3983D63BF98A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">dataStoreKeyInfo</string>
								<string name="ScriptGuid">{1DAE8B55-DE68-4C37-929A-50A9ED215332}</string>
								<ProtectedString name="Source"><![CDATA[local DataStoreKeyInfo = {}
DataStoreKeyInfo.__index = DataStoreKeyInfo

function DataStoreKeyInfo.new(createdTime, updatedTime, version, userIds, metadata)
	local userIdsType = typeof(userIds)

	if userIdsType ~= "nil" and userIdsType ~= "table" then
		error(`expected userIds to be a table or nil, got {userIdsType}`)
	end

	if userIdsType == "table" then
		local expectedKey = 1
		for key, value in userIds do
			assert(typeof(value) == "number", "userId must be a number")

			if key ~= expectedKey then
				error(`expected userIds to be an array, got invalid key: {key}`)
			end

			expectedKey += 1
		end
	end

	return setmetatable({
		CreatedTime = createdTime * 1000,
		UpdatedTime = updatedTime * 1000,
		Version = version,
		userIds = if userIds ~= nil then table.clone(userIds) else {},
		metadata = if metadata ~= nil then table.clone(metadata) else {},
	}, DataStoreKeyInfo)
end

function DataStoreKeyInfo:GetUserIds()
	return table.clone(self.userIds)
end

function DataStoreKeyInfo:GetMetadata()
	return table.clone(self.metadata)
end

return DataStoreKeyInfo
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063be</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEFA2824A9A8B4A0CB7A0C422F9793205">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">globalDataStore</string>
								<string name="ScriptGuid">{7A18F07E-3273-46FD-999B-5AF216A6C374}</string>
								<ProtectedString name="Source"><![CDATA[local Constants = require(script.Parent.constants)
local DataStoreKeyInfo = require(script.Parent.dataStoreKeyInfo)
local validateString = require(script.Parent.validateString)

local function copyDeep(value)
	if typeof(value) ~= "table" then
		return value
	end

	local copy = {}

	for a, b in value do
		copy[a] = copyDeep(b)
	end

	return copy
end

local GlobalDataStore = {}
GlobalDataStore.__index = GlobalDataStore

function GlobalDataStore.new(budget, errors, yield)
	return setmetatable({
		data = {},
		keyInfos = {},
		getCache = {},
		budget = budget,
		errors = errors,
		yield = yield,
	}, GlobalDataStore)
end

function GlobalDataStore:write(key, data, userIds, metadata)
	local now = DateTime.now().UnixTimestampMillis

	local keyInfo = self.keyInfos[key]

	if keyInfo ~= nil then
		local version = tostring(tonumber(keyInfo.Version) + 1)

		self.keyInfos[key] = DataStoreKeyInfo.new(keyInfo.CreatedTime, now, version, userIds, metadata)
	else
		self.keyInfos[key] = DataStoreKeyInfo.new(now, now, "0", userIds, metadata)
	end

	-- Data is written after key info because DataStoreKeyInfo.new can throw an error.
	self.data[key] = copyDeep(data)
end

function GlobalDataStore:UpdateAsync(key, transform)
	validateString("key", key, Constants.MAX_KEY_LENGTH)

	if typeof(transform) ~= "function" then
		error("`transform` must be a function")
	end

	if self.errors ~= nil then
		self.errors:simulateError("UpdateAsync")
	end

	local usingGetCache = self.getCache[key] ~= nil and os.clock() < self.getCache[key]

	local requestsTypes = if usingGetCache
		then { Enum.DataStoreRequestType.SetIncrementAsync }
		else { Enum.DataStoreRequestType.GetAsync, Enum.DataStoreRequestType.SetIncrementAsync }

	self.budget:yieldForBudget(requestsTypes)

	local oldValue = self.data[key]

	local ok, transformed, userIds, metadata = pcall(transform, copyDeep(oldValue), self.keyInfos[key])

	if not ok then
		task.spawn(error, transformed)
		return nil
	end

	if transformed == nil then
		return nil
	end

	-- TODO: Make sure transformed data is savable.

	self.yield:yield()

	self:write(key, transformed, userIds, metadata)

	self.getCache[key] = os.clock() + Constants.GET_CACHE_DURATION

	return copyDeep(transformed), self.keyInfos[key]
end

return GlobalDataStore
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063c0</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX71A7E20B01F841458077C9D554A594FC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">simulatedErrors</string>
								<string name="ScriptGuid">{C2F1F880-87D5-4FC0-A704-3574102F9B78}</string>
								<ProtectedString name="Source"><![CDATA[local SimulatedErrors = {}
SimulatedErrors.__index = SimulatedErrors

function SimulatedErrors.new()
	return setmetatable({
		errorsToSimulate = 0,
	}, SimulatedErrors)
end

function SimulatedErrors:addSimulatedErrors(amount)
	assert(typeof(amount) == "number", "`amount` must be a number")

	self.errorsToSimulate += amount
end

function SimulatedErrors:simulateError(method)
	if self.errorsToSimulate > 0 then
		self.errorsToSimulate -= 1

		error(string.format("`%s` rejected with error (simulated error)", method))
	end
end

return SimulatedErrors
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063c2</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDB72837A701E4B0BACA2BCBD7C7C075C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">simulatedYield</string>
								<string name="ScriptGuid">{B71C36AA-D644-43E5-8DD9-FB226DC7B460}</string>
								<ProtectedString name="Source"><![CDATA[local SimulatedYield = {}
SimulatedYield.__index = SimulatedYield

function SimulatedYield.new()
	return setmetatable({
		yielding = false,
		threads = {},
	}, SimulatedYield)
end

function SimulatedYield:yield()
	if not self.yielding then
		return
	end

	table.insert(self.threads, coroutine.running())

	coroutine.yield()
end

function SimulatedYield:startYield()
	self.yielding = true
end

function SimulatedYield:stopYield()
	self.yielding = false

	for _, thread in self.threads do
		task.spawn(thread)
	end

	table.clear(self.threads)
end

return SimulatedYield
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063c6</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6BC20D634A9740E4BAB3818CE485F8F7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">validateString</string>
								<string name="ScriptGuid">{17E9A3D6-48B1-4A19-94FE-2803635424B6}</string>
								<ProtectedString name="Source"><![CDATA[local function validateString(name, value, maxLength)
	if #value == 0 then
		error(string.format("`%s` can't be empty string", name))
	elseif #value > maxLength then
		error(string.format("`%s` is too long (exceeds %d characters)", name, maxLength))
	end
end

return validateString
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa3000063c8</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXFF1557BB4DBC4ADE923AB3BF1A1F199B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">store</string>
					<string name="ScriptGuid">{F648D8F7-3C98-434C-A9A9-C8282FFB785B}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local combineProducers = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").combineProducers
local sharedSlices = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices").slices
local serverSlices = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "store", "slices").slices
local broadcasterMiddleware = TS.import(script, game:GetService("ServerScriptService"), "paradoxical", "store", "middleware", "broadcaster").broadcasterMiddleware
local _object = {}
for _k, _v in sharedSlices do
	_object[_k] = _v
end
for _k, _v in serverSlices do
	_object[_k] = _v
end
local store = combineProducers(_object)
store:applyMiddleware(broadcasterMiddleware())
return {
	store = store,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3a589e3654c30573064751ed00006346</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX530F8DDF1CA745238E44158A29B19655">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">middleware</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3a589e3654c30573064751ed00006347</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX6A6148ED65F6411DAE08EE77EA5DAB74">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">broadcaster</string>
							<string name="ScriptGuid">{5D95438C-120D-4F44-BEC5-00222BF40787}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createBroadcaster = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createBroadcaster
local server = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "remotes").server
local slices = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices").slices
local function broadcasterMiddleware()
	local broadcaster = createBroadcaster({
		producers = slices,
		dispatch = TS.async(function(player, actions)
			server:Get("broadcast"):SendToPlayer(player, actions)
		end),
		beforeDispatch = function(player, action)
			if action.arguments[1] ~= tostring(player.UserId) then
				return nil
			end
			return action
		end,
	})
	server:OnEvent("start", function(player)
		return broadcaster:start(player)
	end)
	return broadcaster.middleware
end
return {
	broadcasterMiddleware = broadcasterMiddleware,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006348</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX535A1E31784741A9B2E5D0E33BC32210">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">slices</string>
						<string name="ScriptGuid">{B6EBE984-9989-4DE4-B868-AEC98476205D}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local slices = {}
return {
	slices = slices,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3a589e3654c30573064751ed00006349</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX42C39DBAAB9E4AA9A543404843C8CDF5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000033e</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBXA2991BA0203D47758E391BCF32011F69">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Lumina Saves</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5d43e5939f03e2e60658825e000064d1</UniqueId>
			</Properties>
			<Item class="StringValue" referent="RBX432B1DCEC32F417791EEEA36F96D38C2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">VFXSaveData</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5d43e5939f03e2e60658825e000065ba</UniqueId>
					<string name="Value">{&quot;systems&quot;:[],&quot;version&quot;:89,&quot;floatingNodes&quot;:[]}</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX0611B72B60B74E5DBA37ACDD679064D1">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">VFXSaveData</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3b41d83a0f98b4e1065883b600006190</UniqueId>
					<string name="Value">{&quot;systems&quot;:[],&quot;version&quot;:89,&quot;floatingNodes&quot;:[]}</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX16BF477E0F1D4F72A1DFA0587FA4351F">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">VFXSaveData</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3b41d83a0f98b4e1065883b6000061ba</UniqueId>
					<string name="Value">{&quot;systems&quot;:[],&quot;version&quot;:89,&quot;floatingNodes&quot;:[]}</string>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="RBX0ED9CEBFDD4444738634949BEAE78E66">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000351</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBXD3212E7ABA5D42CB94AFCD664353D634">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">assets</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000036d</UniqueId>
			</Properties>
			<Item class="Folder" referent="RBXCE99EECCACB746D89EE2926D818DD114">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">animations</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">2241e77addca441406501bbe00005fb4</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX9517E6B07127479D8B6F722BFE43D774">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">combat</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">2241e77addca441406501bbe00005fb5</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBX267EBA63C6D74B3BADEC963858430DFB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">attacked</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fb6</UniqueId>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX41424641EF07476AB57E8C6D1887CF36">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">fists</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fb7</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX7D75C7CE53834D71B215B88096D58FAB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">attack</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">2241e77addca441406501bbe00005fb8</UniqueId>
							</Properties>
							<Item class="Animation" referent="RBX187350004EEA4F2B90D07A9FBAE62416">
								<Properties>
									<Content name="AnimationId"><url>rbxassetid://14385406405</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">leftHook</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">2241e77addca441406501bbe00005fb9</UniqueId>
								</Properties>
							</Item>
							<Item class="Animation" referent="RBX169D85D6370B452FAC807E690C545FFE">
								<Properties>
									<Content name="AnimationId"><url>rbxassetid://14385409149</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">leftKick</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">2241e77addca441406501bbe00005fba</UniqueId>
								</Properties>
							</Item>
							<Item class="Animation" referent="RBXE8D374FEE6014F588ECA02ED332924EF">
								<Properties>
									<Content name="AnimationId"><url>rbxassetid://14385403991</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">rightHook</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">2241e77addca441406501bbe00005fbb</UniqueId>
								</Properties>
							</Item>
							<Item class="Animation" referent="RBXF686C76365CA44A59079595C68010F9A">
								<Properties>
									<Content name="AnimationId"><url>rbxassetid://14385412276</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">rightKick</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">2241e77addca441406501bbe00005fbc</UniqueId>
								</Properties>
							</Item>
							<Item class="Animation" referent="RBX9B00A04784544C13859A6E8D21241BE0">
								<Properties>
									<Content name="AnimationId"><url>rbxassetid://14457037956</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">slam</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">2241e77addca441406501bbe00005fbd</UniqueId>
								</Properties>
							</Item>
							<Item class="Animation" referent="RBX6F68A556C8B5475D8DE34508D8FAA56E">
								<Properties>
									<Content name="AnimationId"><url>rbxassetid://14385430314</url></Content>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">uppercut</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">2241e77addca441406501bbe00005fbe</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Animation" referent="RBXED745E1339AA4ECAADA1884971629885">
							<Properties>
								<Content name="AnimationId"><url>rbxassetid://14386934264</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">block</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">2241e77addca441406501bbe00005fbf</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBXF5536F3ADC2644D3B87F41401289AC2C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">idle</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc0</UniqueId>
					</Properties>
					<Item class="Animation" referent="RBX51C94E591CFC490296A0D60E9A4676D5">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://15239153655</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">crouch</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc1</UniqueId>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX054F333ADE75444780958F80483C00E0">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://14385447903</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">idle</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc2</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX38AA76C227E94A8389CDC9BF09A35A82">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">movement</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc3</UniqueId>
					</Properties>
					<Item class="Animation" referent="RBX18C6E5927ACB4788B1B943346B2ADB9A">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://15212429900</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">backflip</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc4</UniqueId>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXEAADDAF5A1DF4050BCF4AD0B0BFE30C7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">dashes</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc5</UniqueId>
						</Properties>
						<Item class="Animation" referent="RBX304524F13E294B65833A1F4534DE833D">
							<Properties>
								<Content name="AnimationId"><url>rbxassetid://15210700331</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">backdash</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc6</UniqueId>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBX50DFB718677E4FD3AC010988B3EFB708">
							<Properties>
								<Content name="AnimationId"><url>rbxassetid://15210660294</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">frontdash</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc7</UniqueId>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBX66E20D087E34475EBEBB66AB7CF01ACC">
							<Properties>
								<Content name="AnimationId"><url>rbxassetid://14617433840</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">leftdash</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc8</UniqueId>
							</Properties>
						</Item>
						<Item class="Animation" referent="RBXDF854FC129D449528DAAC141F365E4EE">
							<Properties>
								<Content name="AnimationId"><url>rbxassetid://14617441818</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">rightdash</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">2241e77addca441406501bbe00005fc9</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Animation" referent="RBX2BF13CD9324D4C119C505B7328622AF3">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://14434337943</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">flip</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fca</UniqueId>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX47F3325A9FC3469CB9A81435C6CA2EB8">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://14385475041</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">jump</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fcb</UniqueId>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX95E16EBAC41D447FB7FC12B57EB32DB0">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://14385470658</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">land</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fcc</UniqueId>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX86A057D9DC0943A0BB8E5A33B7FF96BF">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://14385478299</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">run</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fcd</UniqueId>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX18F8DA0446D4420EA5A98D55BE784310">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://14542193308</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">slide</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fce</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX228F0DC5C6134DC4B56B79BB4AAAF675">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">walk</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">2241e77addca441406501bbe00005fcf</UniqueId>
					</Properties>
					<Item class="Animation" referent="RBXBAD2292197A94C868473E1613F74AC2D">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://15239128607</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">crouch</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fd0</UniqueId>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX9A2DC65A52964E00B994818434328CED">
						<Properties>
							<Content name="AnimationId"><url>http://www.roblox.com/asset/?id=14385484112</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">walk</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">2241e77addca441406501bbe00005fd1</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBXEE88726B68D947D7BD39C012BD4E76E7">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">models</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">2241e77addca441406501bbe00005fd2</UniqueId>
				</Properties>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX69323AF0776F4BD89323FC00F96027C2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">paradoxical</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000036e</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX648823029CE4483A91EA6D0AC05A3A37">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">constants</string>
					<string name="ScriptGuid">{C61AEC70-D838-45D8-BA68-7537147FB6C4}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local RunService = _services.RunService
local IS_PLUGIN = RunService:IsStudio() and not RunService:IsRunning()
local playerId = tostring(Players.LocalPlayer.UserId)
return {
	IS_PLUGIN = IS_PLUGIN,
	playerId = playerId,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000036f</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX35FBC0E784EB4AC5820349E0BF22433D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ecs</string>
					<string name="ScriptGuid">{5C10F188-AFFB-4A42-828B-2B256B8DA8A6}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
-- eslint-disable @typescript-eslint/no-explicit-any 
local _matter = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib")
local Debugger = _matter.Debugger
local Loop = _matter.Loop
local World = _matter.World
local Plasma = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "plasma", "src")
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local ServerScriptService = _services.ServerScriptService
local UserInputService = _services.UserInputService
local Host = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hosts").Host
local tags = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "boundTags").tags
local Model = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Model
local _systems = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "systems")
local startSystems = _systems.start
local stopSystems = _systems.stop
local _tags = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "tags")
local startTags = _tags.start
local stopTags = _tags.stop
local combineProducers = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").combineProducers
local clientStore = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "client").store
local recieveReplication = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "recieveReplication")
local sparkState = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "spark").sparkState
local _result = ServerScriptService:FindFirstChild("paradoxical")
if _result ~= nil then
	_result = _result:FindFirstChild("store")
end
local serverStoreModule = _result
local MAX_DISPLAY_ORDER = 2147483647
local GROUP_ID = 33149057
local DEBUG_RANK = 253
local function authorize(player)
	return RunService:IsStudio() or player:GetRankInGroup(GROUP_ID) >= DEBUG_RANK
end
local connections
--[[
	*
	 * Starts the ECS.
	 *
	 * @param host - The host the ECS is running on
	 * @return The world and global ECS state of the ECS
	 *
	 * @throws "ECS already running."
	 * This is thrown when the ECS has already been started.
	 
]]
local function start(host)
	if connections then
		error("ECS already running.")
	end
	local world = World.new()
	local debug = Debugger.new(Plasma)
	debug.authorize = authorize
	debug.findInstanceFromEntity = function(id)
		if not world:contains(id) then
			return nil
		end
		local model = world:get(id, Model)
		local _result_1 = model
		if _result_1 ~= nil then
			_result_1 = _result_1.model
		end
		return _result_1
	end
	local state = {}
	state.spark = sparkState
	if host == Host.Client then
		state.reflex = clientStore
	elseif host == Host.Server then
		local serverStore = (require(serverStoreModule)).store
		state.reflex = serverStore
	else
		state.reflex = combineProducers({})
	end
	local loop = Loop.new(world, state, debug:getWidgets())
	startSystems(host, loop, debug)
	debug:autoInitialize(loop)
	local runServices = {
		default = RunService.Heartbeat,
		stepped = RunService.Stepped,
	}
	if host == Host.All or host == Host.Server then
		connections = loop:begin(runServices)
		startTags(world, tags)
	end
	if host == Host.All or host == Host.Client then
		local _fn = loop
		local _object = {}
		for _k, _v in runServices do
			_object[_k] = _v
		end
		_object.renderedStepped = RunService.RenderStepped
		connections = _fn:begin(_object)
		recieveReplication(world, state)
		local serverDebugger = ReplicatedStorage:FindFirstChild("MatterDebugger")
		if serverDebugger and serverDebugger:IsA("ScreenGui") then
			serverDebugger.DisplayOrder = MAX_DISPLAY_ORDER
		end
		local clientDebugger = Players.LocalPlayer:FindFirstChild("MatterDebugger")
		if clientDebugger and clientDebugger:IsA("ScreenGui") then
			clientDebugger.DisplayOrder = MAX_DISPLAY_ORDER
		end
		local clientState = state.reflex
		UserInputService.InputBegan:Connect(function(input)
			if input.KeyCode == Enum.KeyCode.F4 and authorize(Players.LocalPlayer) then
				debug:toggle()
				clientState.toggle()
			end
		end)
	end
	return { world, state }
end
--[[
	*
	 * Stops the ECS.
	 
]]
local function stop()
	if not connections then
		return nil
	end
	for _, connection in pairs(connections) do
		connection:Disconnect()
	end
	connections = nil
	stopTags()
	stopSystems()
	local _result_1 = ReplicatedStorage:FindFirstChild("MatterDebuggerRemote")
	if _result_1 ~= nil then
		_result_1:Destroy()
	end
end
return {
	start = start,
	stop = stop,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000370</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBXDBD587B0971C41F2A998FE301DAC7573">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">boundTags</string>
						<string name="ScriptGuid">{1D2F4F11-BC93-47DF-9D9F-B9A0C4E05E07}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Test = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Test
--[[
	*
	 * A map of tags to their bound components.
	 
]]
local tags = {
	Test = Test,
}
return {
	tags = tags,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000371</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX722B0BF719A6465AA1CD517B0BB644FD">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">components</string>
						<string name="ScriptGuid">{FF668060-C854-4B53-8B34-1AD27EA736D1}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local component = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib").component
-- eslint-disable-next-line prettier/prettier
local _defaults = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components", "defaults")
local transform = _defaults.transform
local health = _defaults.health
-- eslint-disable-next-line prettier/prettier
-- eslint-disable-next-line prettier/prettier
--[[
	*
	 * The {@link ModelComponent | Model} component constructor.
	 
]]
local Model = component("Model")
--[[
	*
	 * The {@link TransformComponent | Transform} component constructor.
	 
]]
local Transform = component("Transform", transform)
--[[
	*
	 * The {@link HealthComponent | Health} component constructor.
	 
]]
local Health = component("Health", health)
--[[
	*
	 * This is a test component constructor.
	 *
	 * It shouldn't be used and should be removed at some point.
	 
]]
local Test = component("Test")
return {
	Model = Model,
	Transform = Transform,
	Health = Health,
	Test = Test,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000372</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX9FD82DE5A94B4BAF8FEF541E5D5D4914">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">defaults</string>
							<string name="ScriptGuid">{17C9E2B1-C470-4C3A-A748-EE69D4403CD2}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
--[[
	*
	 * The default value created when no data is provided to a {@link Transform}
	 * component.
	 
]]
local transform = {
	cframe = CFrame.new(0, 5, 0),
}
local health = {
	current = 100,
	max = 100,
	regenAmount = 2,
	regenRate = 1,
	regenCD = 5,
}
return {
	transform = transform,
	health = health,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000373</UniqueId>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXEE723B04558C41C9817E3A4D9B3CC7D7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">systems</string>
						<string name="ScriptGuid">{4606A22B-E06A-4EA0-B0BD-627364A23FCC}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local HotReloader = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "rewire", "out").HotReloader
local ServerScriptService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").ServerScriptService
local Host = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hosts").Host
local ERROR_CONTAINER = "%s container not found"
local shared = script:FindFirstChild("shared")
local client = script:FindFirstChild("client")
local _server = ServerScriptService:FindFirstChild("paradoxical")
if _server ~= nil then
	_server = _server:FindFirstChild("systems")
end
local server = _server
local firstRunSystems = {}
local hotReloader
--[[
	*
	 * Starts the system loader.
	 *
	 * Loads systems for the specified container into the provided loop and
	 * debugger. Systems are hot reloaded as they are changed.
	 *
	 * @param container - The container to load
	 * @param loop - The ECS loop to load systems into
	 * @param debug - The debugger to load systems into
	 *
	 * @throws "[container] container not found"
	 * This is thrown when a container necessary for the provided host doesn't
	 * exist.
	 
]]
local function start(container, loop, debug)
	if not firstRunSystems then
		return nil
	end
	local containers = {}
	if not shared then
		error(string.format(ERROR_CONTAINER, "Shared"))
	end
	table.insert(containers, shared)
	if container == Host.All or container == Host.Client then
		if not client then
			error(string.format(ERROR_CONTAINER, "Client"))
		end
		table.insert(containers, client)
	end
	if container == Host.All or container == Host.Server then
		if not server then
			error(string.format(ERROR_CONTAINER, "Server"))
		end
		table.insert(containers, server)
	end
	local systemsByModule = {}
	local function load(module, context)
		if (string.match(module.Name, "%.spec$")) ~= nil or (string.match(module.Name, "%.dev$")) ~= nil then
			return nil
		end
		local original = context.originalModule
		local previous = systemsByModule[original]
		local ok, required = pcall(require, module)
		if not ok then
			warn("Error when hot-reloading system", module.Name, required)
			return nil
		end
		-- Here we don't know that this is necessarily a system, but we let matter
		-- handle this at runtime.
		local system = required
		if firstRunSystems then
			table.insert(firstRunSystems, system)
		elseif previous then
			loop:replaceSystem(previous, system)
			debug:replaceSystem(previous, system)
		else
			loop:scheduleSystem(system)
		end
		systemsByModule[original] = system
	end
	local function unload(_, context)
		if context.isReloading then
			return nil
		end
		local original = context.originalModule
		local previous = systemsByModule[original]
		if previous then
			loop:evictSystem(previous)
			systemsByModule[original] = nil
		end
	end
	hotReloader = HotReloader.new()
	for _, container in containers do
		hotReloader:scan(container, load, unload)
	end
	loop:scheduleSystems(firstRunSystems)
	firstRunSystems = nil
end
--[[
	*
	 * Stops loading systems.
	 
]]
local function stop()
	if firstRunSystems then
		return nil
	end
	firstRunSystems = {}
	local _result = hotReloader
	if _result ~= nil then
		_result:destroy()
	end
end
return {
	start = start,
	stop = stop,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000375</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBX582EF6B3FE404D75B2CC084F3016EA6A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">shared</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000378</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXD44DD7B38AF94B65BBE1810E6DC9FB62">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">updateIdAttribute</string>
								<string name="ScriptGuid">{44320AB8-02FF-449F-9715-62AB45E3E4AE}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Model = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Model
local getIdAttribute = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "idAttribute").getIdAttribute
--[[
	*
	 * A system that updates the ID of {@link Model | Models}.
	 *
	 * @param world - The {@link World} the system operates on
	 
]]
local function updateIdAttribute(world)
	for id, record in world:queryChanged(Model) do
		local _result = record.new
		if _result ~= nil then
			_result = _result.model
			if _result ~= nil then
				_result:SetAttribute(getIdAttribute(), id)
			end
		end
	end
end
return updateIdAttribute
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000379</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX1B3BD0068D484CA78E0156170C974690">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">client</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00005eb6</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXDC0D4C8452E04E90A154066FED73AE1F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">spawnAnimator</string>
								<string name="ScriptGuid">{E84C8C9D-E0FB-47DF-97AC-C7BBE25C95D2}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Model = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Model
local function spawnAnimator(world, state)
	local relfexState = state.reflex
	for id, model in world:query(Model) do
		local animator = model.animator
		if animator then
			continue
		end
		local _fn = world
		local _fn_1 = model
		local _object = {}
		local _left = "animator"
		local _result = model.humanoid
		if _result ~= nil then
			_result = _result:FindFirstChildOfClass("Animator")
		end
		_object[_left] = _result
		_fn:insert(id, _fn_1:patch(_object))
		relfexState.clearAnimations(tostring(id))
	end
end
return spawnAnimator
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">51178f115085344d0651849a00006367</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX29D647AB73B945CCB6CDE65DFE20DBD6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">loadAnimations</string>
								<string name="ScriptGuid">{57E27FA9-99EA-4720-9A5F-7F588EF52476}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local playerId = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "constants").playerId
local Model = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Model
local useReflex = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hooks", "useReflex")
local _animationId = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "selectors", "players", "animationId")
local selectPlayerIdleId = _animationId.selectPlayerIdleId
local selectPlayerJumpId = _animationId.selectPlayerJumpId
local selectPlayerLandId = _animationId.selectPlayerLandId
local selectPlayerRunId = _animationId.selectPlayerRunId
local selectPlayerWalkId = _animationId.selectPlayerWalkId
local spawnAnimator = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "systems", "client", "spawnAnimator")
local function loadAnimation(name, id, animator, reflexState)
	local animationIds = reflexState:getState().players.animationId[playerId]
	-- eslint-disable-next-line roblox-ts/no-array-pairs
	for _, track in pairs(animator:GetPlayingAnimationTracks()) do
		if animationIds[track.Name] ~= nil then
			track:Stop()
		end
	end
	local animation = Instance.new("Animation")
	animation.AnimationId = "rbxassetid://" .. tostring(id)
	animation.Name = name
	local track = animator:LoadAnimation(animation)
	track.Priority = Enum.AnimationPriority.Core
	reflexState.setAnimation(playerId, name, track)
	animation:Destroy()
	return track
end
local function loadAnimations(world, state)
	if not world:contains(tonumber(playerId)) then
		return nil
	end
	local model = world:get(tonumber(playerId), Model)
	local _result = model
	if _result ~= nil then
		_result = _result.animator
	end
	local animator = _result
	if animator == nil then
		return nil
	end
	local reflexState = state.reflex
	if reflexState:getState().players.animationId[playerId] == nil then
		return nil
	end
	local _result_1 = reflexState:getState().players.animation[playerId]
	if _result_1 ~= nil then
		_result_1 = _result_1.idle
	end
	if _result_1 == nil then
		local idle
		for name, id in pairs(reflexState:getState().players.animationId[playerId]) do
			local track = loadAnimation(name, id, animator, reflexState)
			if name == "idle" then
				idle = track
			end
		end
		reflexState.playAnimation(playerId, idle)
	end
	for _, current, previous in useReflex(playerId, reflexState, selectPlayerIdleId(playerId)) do
		if current == nil or current == previous then
			continue
		end
		local track = loadAnimation("idle", current, animator, reflexState)
		reflexState.playAnimation(playerId, track)
	end
	for _, current, previous in useReflex(playerId, reflexState, selectPlayerWalkId(playerId)) do
		if current == nil or current == previous then
			continue
		end
		loadAnimation("walk", current, animator, reflexState)
	end
	for _, current, previous in useReflex(playerId, reflexState, selectPlayerRunId(playerId)) do
		if current == nil or current == previous then
			continue
		end
		loadAnimation("run", current, animator, reflexState)
	end
	for _, current, previous in useReflex(playerId, reflexState, selectPlayerJumpId(playerId)) do
		if current == nil or current == previous then
			continue
		end
		loadAnimation("jump", current, animator, reflexState)
	end
	for _, current, previous in useReflex(playerId, reflexState, selectPlayerLandId(playerId)) do
		if current == nil or current == previous then
			continue
		end
		loadAnimation("land", current, animator, reflexState)
	end
end
return {
	system = loadAnimations,
	after = { spawnAnimator },
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006312</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX296B0077724B4CBDBB8AA8668259735C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">playAnimations</string>
								<string name="ScriptGuid">{C159C0DA-A03D-43AA-B90B-3F45DF6F28CA}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _matter = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib")
local useDeltaTime = _matter.useDeltaTime
local useEvent = _matter.useEvent
local playerId = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "constants").playerId
local Model = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components").Model
local loadAnimations = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "systems", "client", "loadAnimations")
local function playAnimations(world, state)
	if not world:contains(tonumber(playerId)) then
		return nil
	end
	local relfexState = state.reflex
	local model = world:get(tonumber(playerId), Model)
	local _result = model
	if _result ~= nil then
		_result = _result.humanoid
	end
	local humanoid = _result
	local animationState = relfexState:getState().players.animation[playerId]
	if animationState.idle == nil then
		return nil
	end
	relfexState.changeJumpAnimTime(playerId, animationState.jumpAnimTime - useDeltaTime())
	for _, __, newState in useEvent(humanoid, "StateChanged") do
		repeat
			if newState == (Enum.HumanoidStateType.Jumping) then
				relfexState.playAnimation(playerId, animationState.jump)
				relfexState.changeJumpAnimTime(playerId, 0.35)
				break
			end
			if newState == (Enum.HumanoidStateType.Freefall) then
				relfexState.toggleFreefall(playerId)
				break
			end
		until true
	end
	local _result_1 = relfexState:getState().players.animation[playerId]
	if _result_1 ~= nil then
		_result_1 = _result_1.freefalling
	end
	local _condition = _result_1
	if _condition then
		local _result_2 = relfexState:getState().players.animation[playerId]
		if _result_2 ~= nil then
			_result_2 = _result_2.jumpAnimTime
		end
		_condition = _result_2 == 0
	end
	if _condition then
		relfexState.toggleFreefall(playerId)
		relfexState.playAnimation(playerId, animationState.land)
	end
	local _result_2 = animationState.jump
	if _result_2 ~= nil then
		_result_2 = _result_2.IsPlaying
	end
	local _condition_1 = _result_2
	if not _condition_1 then
		local _result_3 = animationState.land
		if _result_3 ~= nil then
			_result_3 = _result_3.IsPlaying
		end
		_condition_1 = _result_3
	end
	if _condition_1 then
		return nil
	end
	if humanoid.MoveDirection.Magnitude ~= 0 then
		relfexState.playAnimation(playerId, animationState.walk)
	else
		relfexState.playAnimation(playerId, animationState.idle)
	end
end
return {
	system = playAnimations,
	after = { loadAnimations },
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6450003095e0ac8f0656fcad0000631b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX81EC8C983208439F9522C4566543F87D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">updateInput</string>
								<string name="ScriptGuid">{6DE08A5C-44D6-4F8E-8575-4E050319E594}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local function updateInput(_, state)
	local sparkState = state.spark
	sparkState.actions:update(sparkState.inputState, sparkState.inputMap)
	sparkState.inputState:clear()
end
return {
	system = updateInput,
	event = "renderedStepped",
	priority = -math.huge,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">68bbc0086c83e032065abcc5000063b3</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX485BDED0CD0E4C50BCD8C39EE37EBA13">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">useCommands</string>
								<string name="ScriptGuid">{7E0B8B5A-B4D5-4D48-97A1-0DFB404F9122}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local commands = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "net").commands
local function useCommands(world, state)
	local sparkState = state.spark
	local actions = sparkState.actions
	if actions:justPressed("crouch") then
		commands.handleCommands.send(2)
	end
end
return useCommands
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">4d819ccbdf0742ee065c08b5000061fc</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX9CCF2764CB294646A68786D8F668D68D">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">tags</string>
						<string name="ScriptGuid">{8D005339-B8BC-4BF0-924F-044DB1401CD6}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local CollectionService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").CollectionService
local getIdAttribute = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "idAttribute").getIdAttribute
local _components = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components")
local Model = _components.Model
local Transform = _components.Transform
local connections = {}
--[[
	*
	 * Starts spawning bound tags.
	 *
	 * @param world - The world to spawn components in
	 * @param bound - A map of bound tags
	 
]]
local function start(world, bound)
	local function spawnBound(instance, component)
		local primaryPart
		if instance:IsA("Model") then
			if instance.PrimaryPart then
				primaryPart = instance.PrimaryPart
			else
				warn("Attempted to tag a model that has no primary part:", instance)
				return nil
			end
		elseif instance:IsA("BasePart") then
			primaryPart = instance
		else
			warn("Attempted to tag an instance that is not a Model or BasePart:", instance)
			return nil
		end
		local id = world:spawn(component(), Model({
			model = instance,
		}), Transform({
			cframe = primaryPart.CFrame,
		}))
		instance:SetAttribute(getIdAttribute(), id)
	end
	for tag, component in bound do
		for _, instance in CollectionService:GetTagged(tag) do
			spawnBound(instance, component)
		end
		local _arg0 = CollectionService:GetInstanceAddedSignal(tag):Connect(function(instance)
			spawnBound(instance, component)
		end)
		table.insert(connections, _arg0)
		local _arg0_1 = CollectionService:GetInstanceRemovedSignal(tag):Connect(function(instance)
			local id = instance:GetAttribute(getIdAttribute())
			if type(id) == "number" then
				world:despawn(id)
			end
		end)
		table.insert(connections, _arg0_1)
	end
end
--[[
	*
	 * Stops spawning bound tags.
	 
]]
local function stop()
	for _, connection in connections do
		connection:Disconnect()
	end
	table.clear(connections)
end
return {
	start = start,
	stop = stop,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000037a</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX33A5C752B66D408CAE707D00A65A57E8">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">recieveReplication</string>
						<string name="ScriptGuid">{717D6687-B625-4E3E-B1E2-7CB5563725CF}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Components = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components")
local matterReplication = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "net").matterReplication
local DEBUG_SPAWN = "Spawn %ds%d with %s"
local DEBUG_DESPAWN = "Despawn %ds%d"
local DEBUG_MODIFY = "Modify %ds%d adding %s, removing %s"
--[[
	*
	 * Starts the replication receiver.
	 *
	 * @param world - The world to replicate components in
	 * @param state - The global state for the ECS
	 
]]
local function recieveReplication(world, state)
	local function debugPrint(message, args)
		if (state.reflex):getState().debugEnabled.enabled then
			print("ECS Replication>", string.format(message, unpack(args())))
		end
	end
	local serverToClientEntity = {}
	matterReplication.replication.listen(function(entities)
		for serverId, componentMap in entities do
			local clientId = serverToClientEntity[serverId]
			if clientId ~= nil and (next(componentMap)) == nil then
				world:despawn(clientId)
				serverToClientEntity[serverId] = nil
				debugPrint(DEBUG_DESPAWN, function()
					return { clientId, serverId }
				end)
				continue
			end
			local componentsToInsert = {}
			local componentsToRemove = {}
			local insertNames = {}
			local removeNames = {}
			for name, container in componentMap do
				local component = Components[name]
				-- eslint-disable-next-line roblox-ts/lua-truthiness
				if container.data then
					local _arg0 = component(container.data)
					table.insert(componentsToInsert, _arg0)
					table.insert(insertNames, name)
				else
					table.insert(componentsToRemove, component)
					table.insert(removeNames, name)
				end
			end
			if clientId == nil then
				local clientId = world:spawnAt(tonumber(serverId), unpack(componentsToInsert))
				serverToClientEntity[serverId] = clientId
				debugPrint(DEBUG_SPAWN, function()
					return { clientId, serverId, table.concat(insertNames, ",") }
				end)
			else
				if #componentsToInsert > 0 then
					world:replace(clientId, unpack(componentsToInsert))
				end
				if #componentsToRemove > 0 then
					world:remove(clientId, unpack(componentsToRemove))
				end
				debugPrint(DEBUG_MODIFY, function()
					return { clientId, serverId, if #insertNames > 0 then table.concat(insertNames, ", ") else "nothing", if #removeNames > 0 then table.concat(removeNames, ", ") else "nothing" }
				end)
			end
		end
	end)
end
return recieveReplication
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">728dc1e802cb68f50651539a00006548</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX23648440D0B845E580831E6212FFA0AE">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">hosts</string>
					<string name="ScriptGuid">{AF7EA7A0-44D1-480A-A1FB-554B944793EB}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
--[[
	*
	 * Represents a particular host configuration.
	 
]]
local Host
do
	local _inverse = {}
	Host = setmetatable({}, {
		__index = _inverse,
	})
	Host.None = 0
	_inverse[0] = "None"
	Host.Client = 1
	_inverse[1] = "Client"
	Host.Server = 2
	_inverse[2] = "Server"
	Host.All = 3
	_inverse[3] = "All"
end
return {
	Host = Host,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000037b</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCB92C478F93C4BBBB7A0DA403AEA980A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">idAttribute</string>
					<string name="ScriptGuid">{707228C6-1813-47EF-AE18-2EB659AAB3EE}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Host = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "hosts").Host
--[[
	*
	 * A string that represents the default ID attribute when the environment is
	 * not client or server.
	 
]]
local unknownIdAttribute = "unknownEntityId"
--[[
	*
	 * A string that represents the ID attribute when the environment is the server.
	 
]]
local serverIdAttribute = "serverEntityId"
--[[
	*
	 * A string that represents the ID attribute when the environment is the client.
	 
]]
local clientIdAttribute = "clientEntityId"
local idAttribute = unknownIdAttribute
--[[
	*
	 * Gets a string that represents the current ID attribute being used. This value
	 * defaults to {@link unknownIdAttribute}.
	 *
	 * @return the ID attribute
	 
]]
local function getIdAttribute()
	return idAttribute
end
--[[
	*
	 * Sets the `idAttribute` variable based on the provided environment.
	 *
	 * @param environment - The environment to set the ID attribute for
	 
]]
local function setEnvironment(environment)
	repeat
		if environment == (Host.Server) then
			idAttribute = serverIdAttribute
			break
		end
		if environment == (Host.Client) then
			idAttribute = clientIdAttribute
			break
		end
		idAttribute = unknownIdAttribute
	until true
end
return {
	getIdAttribute = getIdAttribute,
	setEnvironment = setEnvironment,
	unknownIdAttribute = unknownIdAttribute,
	serverIdAttribute = serverIdAttribute,
	clientIdAttribute = clientIdAttribute,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000037c</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX7DEE98DD5CCB4309B35817630B15B062">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">state</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">3a589e3654c30573064751ed00005fde</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBXF1FC1D24EE19466A91C668ED395E5D61">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">shared</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3a589e3654c30573064751ed0000634d</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBX925AB462A4DE4F95A1442468592C4F7A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">selectors</string>
							<string name="ScriptGuid">{1E089959-897F-41AB-B28B-51FE1B284CA1}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "selectors", "players") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed0000634e</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXF63E074AAF1D4A1781692E7E55159660">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">players</string>
								<string name="ScriptGuid">{806D023D-8ADC-4F4A-AFF6-8F86779E4440}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createSelector = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createSelector
local selectPlayerHealth = function(playerId)
	return function(state)
		return state.players.health[playerId]
	end
end
local selectPlayerAnimation = function(state)
	return state.players.animation
end
local selectPlayerData = function(playerId)
	return createSelector(selectPlayerHealth(playerId), function(health)
		if not health then
			return nil
		end
		return {
			health = health,
		}
	end)
end
return {
	selectPlayerHealth = selectPlayerHealth,
	selectPlayerAnimation = selectPlayerAnimation,
	selectPlayerData = selectPlayerData,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006317</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXFF531A0379D5471BA09CBBA3875A2D15">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">animationId</string>
									<string name="ScriptGuid">{86FF4C45-8395-4BF2-A8EF-FE89EB29A59F}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local selectPlayerAnimationIds = function(playerId)
	return function(state)
		return state.players.animationId[playerId]
	end
end
local selectPlayerIdleId = function(playerId)
	return function(state)
		local _result = state.players.animationId[playerId]
		if _result ~= nil then
			_result = _result.idle
		end
		return _result
	end
end
local selectPlayerWalkId = function(playerId)
	return function(state)
		local _result = state.players.animationId[playerId]
		if _result ~= nil then
			_result = _result.walk
		end
		return _result
	end
end
local selectPlayerRunId = function(playerId)
	return function(state)
		local _result = state.players.animationId[playerId]
		if _result ~= nil then
			_result = _result.run
		end
		return _result
	end
end
local selectPlayerJumpId = function(playerId)
	return function(state)
		local _result = state.players.animationId[playerId]
		if _result ~= nil then
			_result = _result.jump
		end
		return _result
	end
end
local selectPlayerLandId = function(playerId)
	return function(state)
		local _result = state.players.animationId[playerId]
		if _result ~= nil then
			_result = _result.land
		end
		return _result
	end
end
return {
	selectPlayerAnimationIds = selectPlayerAnimationIds,
	selectPlayerIdleId = selectPlayerIdleId,
	selectPlayerWalkId = selectPlayerWalkId,
	selectPlayerRunId = selectPlayerRunId,
	selectPlayerJumpId = selectPlayerJumpId,
	selectPlayerLandId = selectPlayerLandId,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6450003095e0ac8f0656fcad00006319</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX80657AE575394CBCAE4890B96A74833D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">slices</string>
							<string name="ScriptGuid">{B2871459-CC45-43E2-B17E-509E8BA19B3D}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local playersSlice = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players").playersSlice
local slices = {
	players = playersSlice,
}
return {
	slices = slices,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006350</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX3C117F138BE54F4FAA2F3E0B20C8BE6D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">players</string>
								<string name="ScriptGuid">{25C33D75-5991-4063-A1AB-49A15F411CB2}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local exports = {}
local combineProducers = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").combineProducers
local healthSlice = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "health").healthSlice
local animationSlice = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "animation").animationSlice
local animationIdSlice = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "animationIds").animationIdSlice
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "health") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "animation") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "animationIds") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "types") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices", "players", "utils") or {} do
	exports[_k] = _v
end
local playersSlice = combineProducers({
	health = healthSlice,
	animation = animationSlice,
	animationId = animationIdSlice,
})
exports.playersSlice = playersSlice
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006351</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX9BA06AFEB0C34539B9E8DD187003F29E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">health</string>
									<string name="ScriptGuid">{4C82A72C-45FD-42E7-8680-02EC1BFA4FF3}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createProducer = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createProducer
local initialState = {}
local healthSlice = createProducer(initialState, {
	loadPlayerHealth = function(state, player, data)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = data.health
		return _object
	end,
	closePlayerHealth = function(state, player)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = nil
		return _object
	end,
	changeHealthStat = function(state, player, stat, amount)
		local health = state[player]
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = health
		if _condition then
			local _object_1 = {}
			for _k, _v in health do
				_object_1[_k] = _v
			end
			_object_1[stat] = health[stat] + amount
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
	changeHealth = function(state, player, stat)
		local health = state[player]
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = health
		if _condition then
			local _object_1 = {}
			for _k, _v in stat do
				_object_1[_k] = _v
			end
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
})
return {
	healthSlice = healthSlice,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006352</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2D01A7EBC9094E8F9583C055C66286D7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">types</string>
									<string name="ScriptGuid">{F9280F94-5EE1-46E3-9CA2-822EC826B3DC}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return nil
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006353</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB4CF90C43BBE4924A5A43EBD36B67B2E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">utils</string>
									<string name="ScriptGuid">{70C1C4FB-B8C3-4857-9076-DD0643E0E1FA}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local health = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "ecs", "components", "defaults").health
local defaultPlayerData = {
	health = health,
}
return {
	defaultPlayerData = defaultPlayerData,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006354</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB632214C30AA496EB9D357BF9B0024A8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">animation</string>
									<string name="ScriptGuid">{B93384CB-99A5-4479-9F47-FF522018D42A}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createProducer = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createProducer
local initialState = {}
local animationSlice = createProducer(initialState, {
	loadAnimationPlayer = function(state, player)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = {
			jumpAnimTime = 0,
			freefalling = false,
			playingAnimations = {},
		}
		return _object
	end,
	closeAnimationPlayer = function(state, player)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = nil
		return _object
	end,
	setAnimation = function(state, player, animation, newAnimation)
		local animations = state[player]
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = animations
		if _condition then
			local _object_1 = {}
			for _k, _v in animations do
				_object_1[_k] = _v
			end
			_object_1[animation] = newAnimation
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
	playAnimation = function(state, player, animation)
		local animations = state[player]
		local _result = animations
		if _result ~= nil then
			_result = _result.playingAnimations
		end
		local playingAnimations = _result
		if animation == playingAnimations[1] then
			local _object = {}
			for _k, _v in state do
				_object[_k] = _v
			end
			return _object
		end
		do
			local i = 0
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i += 1
				else
					_shouldIncrement = true
				end
				if not (i < #playingAnimations) then
					break
				end
				playingAnimations[i + 1]:Stop(0.1)
			end
		end
		table.clear(playingAnimations)
		playingAnimations[1] = animation
		animation:Play(0.1)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = animations
		if _condition then
			local _object_1 = {}
			for _k, _v in animations do
				_object_1[_k] = _v
			end
			_object_1.playingAnimations = playingAnimations
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
	clearAnimations = function(state, player)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = {
			jumpAnimTime = 0,
			freefalling = false,
			playingAnimations = {},
		}
		return _object
	end,
	changeJumpAnimTime = function(state, player, amount)
		local animations = state[player]
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = animations
		if _condition then
			local _object_1 = {}
			for _k, _v in animations do
				_object_1[_k] = _v
			end
			_object_1.jumpAnimTime = math.max(0, amount)
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
	toggleFreefall = function(state, player)
		local animations = state[player]
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = animations
		if _condition then
			local _object_1 = {}
			for _k, _v in animations do
				_object_1[_k] = _v
			end
			_object_1.freefalling = not animations.freefalling
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
})
return {
	animationSlice = animationSlice,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">51178f115085344d0651849a00006096</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB309970194C04355A1D4948ACFC6DF40">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">animationIds</string>
									<string name="ScriptGuid">{79A3CBC3-1913-4A77-8325-F1CD4BBD2E19}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createProducer = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createProducer
local defualtAnimationIds = {
	idle = 14385447903,
	walk = 14385484112,
	run = 14385478299,
	jump = 14385475041,
	land = 14385470658,
}
local initialState = {}
local animationIdSlice = createProducer(initialState, {
	loadAnimationIdPlayer = function(state, player)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = defualtAnimationIds
		return _object
	end,
	closeAnimationIdPlayer = function(state, player)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object[player] = nil
		return _object
	end,
	changeAnimationId = function(state, player, key, id)
		local animationId = state[player]
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		local _left = player
		local _condition = animationId
		if _condition then
			local _object_1 = {}
			for _k, _v in animationId do
				_object_1[_k] = _v
			end
			_object_1[key] = id
			_condition = _object_1
		end
		_object[_left] = _condition
		return _object
	end,
})
return {
	defualtAnimationIds = defualtAnimationIds,
	animationIdSlice = animationIdSlice,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">69a2d8b8201fa00706543142000068b5</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX2409102951494F3CB9CE855716C6284F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">client</string>
						<string name="ScriptGuid">{A1CD9AB8-42AE-4E8F-A161-59EBF191B3CA}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local combineProducers = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").combineProducers
local sharedSlices = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "shared", "slices").slices
local clientSlices = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "client", "slices").slices
local receiverMiddleware = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "client", "middleware", "receiver").receiverMiddleware
local RunService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").RunService
local _object = {}
for _k, _v in sharedSlices do
	_object[_k] = _v
end
for _k, _v in clientSlices do
	_object[_k] = _v
end
local store = combineProducers(_object)
if not RunService:IsServer() then
	store:applyMiddleware(receiverMiddleware())
end
return {
	store = store,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">3a589e3654c30573064751ed00006375</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBXE43846661E24453D8423F17A4B930237">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">middleware</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006376</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXFBB82B65C3564E22A0BD54E409DFD4A7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">receiver</string>
								<string name="ScriptGuid">{EA519939-42BD-40E1-A78A-E6947C1957E2}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createBroadcastReceiver = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createBroadcastReceiver
local client = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "remotes").client
local function receiverMiddleware()
	local receiver = createBroadcastReceiver({
		start = TS.async(function()
			return client:Get("start"):SendToServer()
		end),
	})
	client:OnEvent("broadcast", function(actions)
		print(actions)
		receiver:dispatch(actions)
	end)
	return receiver.middleware
end
return {
	receiverMiddleware = receiverMiddleware,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006377</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX0264F6403FF3470A8EE5947F98D95F3D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">slices</string>
							<string name="ScriptGuid">{0EA750C7-BEFC-439A-9603-0DC8664BB357}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local debugEnabled = TS.import(script, game:GetService("ReplicatedStorage"), "paradoxical", "state", "client", "slices", "debugEnabled").debugEnabled
local slices = {
	debugEnabled = debugEnabled,
}
return {
	slices = slices,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006378</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX70BBBA51AA4C41AFB4F0E63E5D1C3131">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">debugEnabled</string>
								<string name="ScriptGuid">{98A6996D-64E9-4C4F-A90C-7BBAE7C501D3}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local createProducer = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "reflex", "src").createProducer
local initialState = {
	enabled = true,
}
local debugEnabled = createProducer(initialState, {
	toggle = function(state)
		local _object = {}
		for _k, _v in state do
			_object[_k] = _v
		end
		_object.enabled = not state.enabled
		return _object
	end,
})
return {
	debugEnabled = debugEnabled,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000637a</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX5BD7BEDAC59B44AC851D260E0540562E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">remotes</string>
						<string name="ScriptGuid">{B5999646-1673-4684-845B-616394BCC3F5}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Net = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "net", "out")
local _binding = Net.CreateDefinitions({
	broadcast = Net.Definitions.ServerToClientEvent(),
	start = Net.Definitions.ClientToServerEvent(),
})
local client = _binding.Client
local server = _binding.Server
return {
	client = client,
	server = server,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070c3</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX3976FF93A5104E528A27BFEEBE786E83">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">net</string>
					<string name="ScriptGuid">{A90D7362-2373-4D58-852D-837E63B780E8}</string>
					<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _bytenet = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "bytenet", "src")
local defineNamespace = _bytenet.defineNamespace
local definePacket = _bytenet.definePacket
local map = _bytenet.map
local optional = _bytenet.optional
local struct = _bytenet.struct
local unknown = _bytenet.unknown
local str = _bytenet.string
local uint8 = _bytenet.uint8
local matterReplication = defineNamespace("matterReplication", function()
	return {
		replication = definePacket({
			value = map(str, map(str, struct({
				data = optional(map(str, unknown)),
			}))),
			reliabilityType = "reliable",
		}),
	}
end)
local commands = defineNamespace("commands", function()
	return {
		handleCommands = definePacket({
			value = uint8,
			reliabilityType = "reliable",
		}),
	}
end)
return {
	matterReplication = matterReplication,
	commands = commands,
}
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">728dc1e802cb68f50651539a0000631f</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX859607AA3EC941C0A04FF02EE93ECD0E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">hooks</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">1d49987330d0c4970652dfb200006759</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX1861D747C05D452B9D324BF9E2D947C7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">useReflex</string>
						<string name="ScriptGuid">{230C5BB8-40B8-4777-916E-FDECC1012D6A}</string>
						<ProtectedString name="Source"><![CDATA[local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Matter = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib")

local function useReflex(id, producer, selector) 
    local storage = Matter.useHookState(id)

    if storage.event == nil then
        storage.queue = {}

        storage.event = producer:subscribe(selector, function(current, previous)
            table.insert(storage.queue, table.pack(current, previous))
        end)
    end

    local index = 0
    return function() 
        index += 1

        local args = storage.queue[1]
        table.remove(storage.queue, 1)

        if args then
            return index, unpack(args, 1, args.n)
        end
    end
end

return useReflex
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">1d49987330d0c4970652dfb20000675a</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX063A93B304E447108ACDF685CD890584">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">useBytenet</string>
						<string name="ScriptGuid">{3EFA4AA5-ED32-432F-8CF3-9B45D30CD968}</string>
						<ProtectedString name="Source"><![CDATA[local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Matter = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "matter", "lib")

local function useBytenet(id, packet) 
    local storage = Matter.useHookState(id)

    if storage.id == nil then
        storage.queue = {}
        storage.id = id
        
        packet.listen(function(data, player)
            table.insert(storage.queue, table.pack(data, player))
        end)
    end

    local index = 0
    return function() 
        index += 1

        local args = storage.queue[1]
        table.remove(storage.queue, 1)

        if args then
            return index, unpack(args, 1, args.n)
        end
    end
end

return useBytenet
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">219064c616f131a4065c6806000060b5</UniqueId>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX690BDE2F65434DBC96ECE31922425D21">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">spark</string>
					<string name="ScriptGuid">{A9A12A0F-2289-47FD-A55A-8240E570A0A1}</string>
					<ProtectedString name="Source"><![CDATA[local Matter = require(game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].matter.lib)
local Spark = require(game:GetService("ReplicatedStorage").rbxts_include.node_modules["@rbxts"].spark.out)
local Actions = Spark.Actions
local InputState = Spark.InputState

local actions = require(script.actions)
local inputMap = require(script.inputMap)

function Actions:justPressed(action: string): boolean
	local signal = self:justPressedSignal(action)
	local iterator = Matter.useEvent(action, signal)

	return iterator() ~= nil
end

function Actions:justReleased(action: string): boolean
	local signal = self:justReleasedSignal(action)
	local iterator = Matter.useEvent(action, signal)

	return iterator() ~= nil
end

return {
	sparkState = {
		inputState = InputState.new(),
		actions = Actions.new(actions.actions),
		inputMap = inputMap,
	}
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">2d18b45c91d023a306599bcf00006234</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX060B9EA580F1429B80B3841FAA77A3FA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">actions</string>
						<string name="ScriptGuid">{51C24E73-ECFA-46B1-A92C-5DC3F7494A1A}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local actions = { "move", "jump", "crouch" }
return {
	actions = actions,
}
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">2d18b45c91d023a306599bcf00006236</UniqueId>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBXE7A9215786D2456E8801F85B6954E2C7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">inputMap</string>
						<string name="ScriptGuid">{71A67453-30B1-4AF1-B550-78EF9EC63D06}</string>
						<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local _spark = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "spark", "out")
local InputMap = _spark.InputMap
local VirtualAxis2d = _spark.VirtualAxis2d
return InputMap.new():insert("move", VirtualAxis2d:wasd(), Enum.KeyCode.Thumbstick1):insert("jump", Enum.KeyCode.Space, Enum.KeyCode.ButtonA):insert("crouch", Enum.KeyCode.C)
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">2d18b45c91d023a306599bcf00006238</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX45653B0921CA45B68267D04A69CBD464">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">rbxts_include</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000037f</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX75D462016F164EB884A383A335118FE2">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Promise</string>
					<string name="ScriptGuid">{CC6B92EE-BCE8-4E1C-A47E-0806B159E4DF}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000380</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX9616EA334629452C949A0F77B05B8B6E">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RuntimeLib</string>
					<string name="ScriptGuid">{ADCB4AC5-6B3D-409D-A284-195D432AE8AB}</string>
					<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000381</UniqueId>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX316013F0DD6749558D9F7A1BA29C38AB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">node_modules</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000382</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBX37599D668C194E40B62CD71139E94C17">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">@rbxts</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000383</UniqueId>
					</Properties>
					<Item class="Folder" referent="RBXEA2A68CABD4542EBAE4580722675F955">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">compiler-types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000384</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX037B97CE837B4F53B2A9F6DE8C80FDF7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000385</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXA6CF8782A00B40D09D853E91B88E8CB2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">flipper</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000386</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXC847D6F3E8D34A23A134974B55591BDC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{6E477C93-AFC8-4108-8E87-EAF218D20089}</string>
								<ProtectedString name="Source"><![CDATA[local Flipper = {
	SingleMotor = require(script.SingleMotor),
	GroupMotor = require(script.GroupMotor),

	Instant = require(script.Instant),
	Linear = require(script.Linear),
	Spring = require(script.Spring),
	
	isMotor = require(script.isMotor),
}

return Flipper]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000387</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5600F1C304FC4CACB008CF1BFDBACB0B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">BaseMotor</string>
									<string name="ScriptGuid">{58808087-2912-4324-A724-3E4588235EF5}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Signal = require(script.Parent.Signal)

local noop = function() end

local BaseMotor = {}
BaseMotor.__index = BaseMotor

function BaseMotor.new()
	return setmetatable({
		_onStep = Signal.new(),
		_onStart = Signal.new(),
		_onComplete = Signal.new(),
	}, BaseMotor)
end

function BaseMotor:onStep(handler)
	return self._onStep:connect(handler)
end

function BaseMotor:onStart(handler)
	return self._onStart:connect(handler)
end

function BaseMotor:onComplete(handler)
	return self._onComplete:connect(handler)
end

function BaseMotor:start()
	if not self._connection then
		self._connection = RunService.RenderStepped:Connect(function(deltaTime)
			self:step(deltaTime)
		end)
	end
end

function BaseMotor:stop()
	if self._connection then
		self._connection:Disconnect()
		self._connection = nil
	end
end

BaseMotor.destroy = BaseMotor.stop

BaseMotor.step = noop
BaseMotor.getValue = noop
BaseMotor.setGoal = noop

function BaseMotor:__tostring()
	return "Motor"
end

return BaseMotor
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000388</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAAF6C6DA43C2455DABFD9709B1BD574C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GroupMotor</string>
									<string name="ScriptGuid">{FD70A98F-9F42-4DF4-867F-62A65837F64F}</string>
									<ProtectedString name="Source"><![CDATA[local BaseMotor = require(script.Parent.BaseMotor)
local SingleMotor = require(script.Parent.SingleMotor)

local isMotor = require(script.Parent.isMotor)

local GroupMotor = setmetatable({}, BaseMotor)
GroupMotor.__index = GroupMotor

local function toMotor(value)
	if isMotor(value) then
		return value
	end

	local valueType = typeof(value)

	if valueType == "number" then
		return SingleMotor.new(value, false)
	elseif valueType == "table" then
		return GroupMotor.new(value, false)
	end

	error(("Unable to convert %q to motor; type %s is unsupported"):format(value, valueType), 2)
end

function GroupMotor.new(initialValues, useImplicitConnections)
	assert(initialValues, "Missing argument #1: initialValues")
	assert(typeof(initialValues) == "table", "initialValues must be a table!")
	assert(not initialValues.step, "initialValues contains disallowed property \"step\". Did you mean to put a table of values here?")

	local self = setmetatable(BaseMotor.new(), GroupMotor)

	if useImplicitConnections ~= nil then
		self._useImplicitConnections = useImplicitConnections
	else
		self._useImplicitConnections = true
	end

	self._complete = true
	self._motors = {}

	for key, value in pairs(initialValues) do
		self._motors[key] = toMotor(value)
	end

	return self
end

function GroupMotor:step(deltaTime)
	if self._complete then
		return true
	end

	local allMotorsComplete = true

	for _, motor in pairs(self._motors) do
		local complete = motor:step(deltaTime)
		if not complete then
			-- If any of the sub-motors are incomplete, the group motor will not be complete either
			allMotorsComplete = false
		end
	end

	self._onStep:fire(self:getValue())

	if allMotorsComplete then
		if self._useImplicitConnections then
			self:stop()
		end

		self._complete = true
		self._onComplete:fire()
	end

	return allMotorsComplete
end

function GroupMotor:setGoal(goals)
	assert(not goals.step, "goals contains disallowed property \"step\". Did you mean to put a table of goals here?")

	self._complete = false
	self._onStart:fire()

	for key, goal in pairs(goals) do
		local motor = assert(self._motors[key], ("Unknown motor for key %s"):format(key))
		motor:setGoal(goal)
	end

	if self._useImplicitConnections then
		self:start()
	end
end

function GroupMotor:getValue()
	local values = {}

	for key, motor in pairs(self._motors) do
		values[key] = motor:getValue()
	end

	return values
end

function GroupMotor:__tostring()
	return "Motor(Group)"
end

return GroupMotor
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000389</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4A0E397FD05741B69FA6AD4A78550687">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Instant</string>
									<string name="ScriptGuid">{1BBDF5B3-65CC-49C0-9846-7E399E9DC615}</string>
									<ProtectedString name="Source"><![CDATA[local Instant = {}
Instant.__index = Instant

function Instant.new(targetValue)
	return setmetatable({
		_targetValue = targetValue,
	}, Instant)
end

function Instant:step()
	return {
		complete = true,
		value = self._targetValue,
	}
end

return Instant]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000038a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDEF4889DE9C14D08B12AFFFB81E95E23">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Linear</string>
									<string name="ScriptGuid">{818331CA-AE55-44CA-A952-6A75EF24D57B}</string>
									<ProtectedString name="Source"><![CDATA[local Linear = {}
Linear.__index = Linear

function Linear.new(targetValue, options)
	assert(targetValue, "Missing argument #1: targetValue")
	
	options = options or {}

	return setmetatable({
		_targetValue = targetValue,
		_velocity = options.velocity or 1,
	}, Linear)
end

function Linear:step(state, dt)
	local position = state.value
	local velocity = self._velocity -- Linear motion ignores the state's velocity
	local goal = self._targetValue

	local dPos = dt * velocity

	local complete = dPos >= math.abs(goal - position)
	position = position + dPos * (goal > position and 1 or -1)
	if complete then
		position = self._targetValue
		velocity = 0
	end
	
	return {
		complete = complete,
		value = position,
		velocity = velocity,
	}
end

return Linear]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000038b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA1C6EE22052741A39DA7E296F1B30832">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Signal</string>
									<string name="ScriptGuid">{A81F78C8-7AAF-4FD8-8264-A2DACEC4E008}</string>
									<ProtectedString name="Source"><![CDATA[local Connection = {}
Connection.__index = Connection

function Connection.new(signal, handler)
	return setmetatable({
		signal = signal,
		connected = true,
		_handler = handler,
	}, Connection)
end

function Connection:disconnect()
	if self.connected then
		self.connected = false

		for index, connection in pairs(self.signal._connections) do
			if connection == self then
				table.remove(self.signal._connections, index)
				return
			end
		end
	end
end

local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		_connections = {},
		_threads = {},
	}, Signal)
end

function Signal:fire(...)
	for _, connection in pairs(self._connections) do
		connection._handler(...)
	end

	for _, thread in pairs(self._threads) do
		coroutine.resume(thread, ...)
	end
	
	self._threads = {}
end

function Signal:connect(handler)
	local connection = Connection.new(self, handler)
	table.insert(self._connections, connection)
	return connection
end

function Signal:wait()
	table.insert(self._threads, coroutine.running())
	return coroutine.yield()
end

return Signal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000038c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX83E3E3CAFB9B468EA6A34355E533C3D6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SingleMotor</string>
									<string name="ScriptGuid">{7C7658FE-3CFC-4D49-B75E-72B2DB7A7953}</string>
									<ProtectedString name="Source"><![CDATA[local BaseMotor = require(script.Parent.BaseMotor)

local SingleMotor = setmetatable({}, BaseMotor)
SingleMotor.__index = SingleMotor

function SingleMotor.new(initialValue, useImplicitConnections)
	assert(initialValue, "Missing argument #1: initialValue")
	assert(typeof(initialValue) == "number", "initialValue must be a number!")

	local self = setmetatable(BaseMotor.new(), SingleMotor)

	if useImplicitConnections ~= nil then
		self._useImplicitConnections = useImplicitConnections
	else
		self._useImplicitConnections = true
	end

	self._goal = nil
	self._state = {
		complete = true,
		value = initialValue,
	}

	return self
end

function SingleMotor:step(deltaTime)
	if self._state.complete then
		return true
	end

	local newState = self._goal:step(self._state, deltaTime)

	self._state = newState
	self._onStep:fire(newState.value)

	if newState.complete then
		if self._useImplicitConnections then
			self:stop()
		end

		self._onComplete:fire()
	end

	return newState.complete
end

function SingleMotor:getValue()
	return self._state.value
end

function SingleMotor:setGoal(goal)
	self._state.complete = false
	self._goal = goal

	self._onStart:fire()

	if self._useImplicitConnections then
		self:start()
	end
end

function SingleMotor:__tostring()
	return "Motor(Single)"
end

return SingleMotor
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000038d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX39D60F99DB2A4800A767326089981E1A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Spring</string>
									<string name="ScriptGuid">{929BC907-ACC7-42AC-A6BB-AC3257F2A4B0}</string>
									<ProtectedString name="Source"><![CDATA[local VELOCITY_THRESHOLD = 0.001
local POSITION_THRESHOLD = 0.001

local EPS = 0.0001

local Spring = {}
Spring.__index = Spring

function Spring.new(targetValue, options)
	assert(targetValue, "Missing argument #1: targetValue")
	options = options or {}

	return setmetatable({
		_targetValue = targetValue,
		_frequency = options.frequency or 4,
		_dampingRatio = options.dampingRatio or 1,
	}, Spring)
end

function Spring:step(state, dt)
	-- Copyright 2018 Parker Stebbins (parker@fractality.io)
	-- github.com/Fraktality/Spring
	-- Distributed under the MIT license

	local d = self._dampingRatio
	local f = self._frequency*2*math.pi
	local g = self._targetValue
	local p0 = state.value
	local v0 = state.velocity or 0

	local offset = p0 - g
	local decay = math.exp(-d*f*dt)

	local p1, v1

	if d == 1 then -- Critically damped
		p1 = (offset*(1 + f*dt) + v0*dt)*decay + g
		v1 = (v0*(1 - f*dt) - offset*(f*f*dt))*decay
	elseif d < 1 then -- Underdamped
		local c = math.sqrt(1 - d*d)

		local i = math.cos(f*c*dt)
		local j = math.sin(f*c*dt)

		-- Damping ratios approaching 1 can cause division by small numbers.
		-- To fix that, group terms around z=j/c and find an approximation for z.
		-- Start with the definition of z:
		--    z = sin(dt*f*c)/c
		-- Substitute a=dt*f:
		--    z = sin(a*c)/c
		-- Take the Maclaurin expansion of z with respect to c:
		--    z = a - (a^3*c^2)/6 + (a^5*c^4)/120 + O(c^6)
		--    z ≈ a - (a^3*c^2)/6 + (a^5*c^4)/120
		-- Rewrite in Horner form:
		--    z ≈ a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6

		local z
		if c > EPS then
			z = j/c
		else
			local a = dt*f
			z = a + ((a*a)*(c*c)*(c*c)/20 - c*c)*(a*a*a)/6
		end

		-- Frequencies approaching 0 present a similar problem.
		-- We want an approximation for y as f approaches 0, where:
		--    y = sin(dt*f*c)/(f*c)
		-- Substitute b=dt*c:
		--    y = sin(b*c)/b
		-- Now reapply the process from z.

		local y
		if f*c > EPS then
			y = j/(f*c)
		else
			local b = f*c
			y = dt + ((dt*dt)*(b*b)*(b*b)/20 - b*b)*(dt*dt*dt)/6
		end

		p1 = (offset*(i + d*z) + v0*y)*decay + g
		v1 = (v0*(i - z*d) - offset*(z*f))*decay

	else -- Overdamped
		local c = math.sqrt(d*d - 1)

		local r1 = -f*(d - c)
		local r2 = -f*(d + c)

		local co2 = (v0 - offset*r1)/(2*f*c)
		local co1 = offset - co2

		local e1 = co1*math.exp(r1*dt)
		local e2 = co2*math.exp(r2*dt)

		p1 = e1 + e2 + g
		v1 = e1*r1 + e2*r2
	end

	local complete = math.abs(v1) < VELOCITY_THRESHOLD and math.abs(p1 - g) < POSITION_THRESHOLD
	
	return {
		complete = complete,
		value = complete and g or p1,
		velocity = v1,
	}
end

return Spring]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000038e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA30A33D20DEC45CE95E5FCBA5A8E8F2B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isMotor</string>
									<string name="ScriptGuid">{C54CDB58-8ABB-4856-8C6E-6A5292745159}</string>
									<ProtectedString name="Source"><![CDATA[local function isMotor(value)
	local motorType = tostring(value):match("^Motor%((.+)%)$")

	if motorType then
		return true, motorType
	else
		return false
	end
end

return isMotor]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000038f</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX5A55D1FD7D0248D99CFC10CA8FC0C028">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">typings</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000390</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXE1E5192BE8844FAC9DFB135E6DE6CED6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">lapis</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000391</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXBC38CEA81A6540A79C9C8452A581B963">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{ADDAFE62-F5DE-48B4-9BC4-7C8B68B64584}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.0.4
local TS = _G[script]
local exports = {}
-- import "./Promise";
for _k, _v in TS.import(script, script, "lapis") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000392</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX0E5EE4CC0A164F9C89D951737F80C176">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Promise</string>
									<string name="ScriptGuid">{195BC76A-C944-440A-A74A-4BB9BD329488}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- The executor thread.
		_thread = nil,

		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	self._thread = coroutine.create(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)

	task.spawn(self._thread)

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	:::caution
	If the Promise is cancelled, the `executor` thread is closed with `coroutine.close` after the cancellation hook is called.

	You must perform any cleanup code in the cancellation hook: any time your executor yields, it **may never resume**.
	:::

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- If we are already cancelled, we return a cancelled Promise
	if self._status == Promise.Status.Cancelled then
		local promise = Promise.new(function() end)
		promise:cancel()

		return promise
	end

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)

			onCancel(function()
				-- These are guaranteed to exist because the cancellation handler is guaranteed to only
				-- be called at most once
				if self._status == Promise.Status.Started then
					table.remove(self._queuedResolve, table.find(self._queuedResolve, successCallback))
					table.remove(self._queuedReject, table.find(self._queuedReject, failureCallback))
				end
			end)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	You can return a Promise from the success or failure handler and it will be chained onto.

	Calling `andThen` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `andThen` is cancelled, `successHandler` and `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Calling `catch` on a cancelled Promise returns a cancelled Promise.

	:::tip
	If the Promise returned by `catch` is cancelled,  `failureHandler` will not run.

	To run code no matter what, use [Promise:finally].
	:::

	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	coroutine.close(self._thread)

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled.
]]
function Promise.prototype:_finally(traceback, finallyHandler)
	self._unhandledRejection = false

	local promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local handlerPromise

		onCancel(function()
			-- The finally Promise is not a proper consumer of self. We don't care about the resolved value.
			-- All we care about is running at the end. Therefore, if self has no other consumers, it's safe to
			-- cancel. We don't need to hold out cancelling just because there's a finally handler.
			self:_consumerCancelled(self)

			if handlerPromise then
				handlerPromise:cancel()
			end
		end)

		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = function(...)
				local callbackReturn = finallyHandler(...)

				if Promise.is(callbackReturn) then
					handlerPromise = callbackReturn

					callbackReturn
						:finally(function(status)
							if status ~= Promise.Status.Rejected then
								resolve(self)
							end
						end)
						:catch(function(...)
							reject(...)
						end)
				else
					resolve(self)
				end
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end)

	return promise
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is
	resolved, rejected, *or* cancelled.

	Returns a new Promise that:
	- resolves with the same values that this Promise resolves with.
	- rejects with the same values that this Promise rejects with.
	- is cancelled if this Promise is cancelled.

	If the value you return from the handler is a Promise:
	- We wait for the Promise to resolve, but we ultimately discard the resolved value.
	- If the returned Promise rejects, the Promise returned from `finally` will reject with the rejected value from the
	*returned* promise.
	- If the `finally` Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too.

	Otherwise, the return value from the `finally` handler is entirely discarded.

	:::note Cancellation
	As of Promise v4, `Promise:finally` does not count as a consumer of the parent Promise for cancellation purposes.
	This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers,
	the Promise is cancelled and the finally callbacks run then and there.

	Cancellation still propagates through the `finally` Promise though: if you cancel the `finally` Promise, it can cancel
	its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the `finally` Promise
	will also be cancelled.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local thread = coroutine.running()

		self
			:finally(function()
				task.spawn(thread)
			end)
			-- The finally promise can propagate rejections, so we attach a catch handler to prevent the unhandled
			-- rejection warning from appearing
			:catch(
				function() end
			)

		coroutine.yield()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end

	task.defer(coroutine.close, self._thread)
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
	@return Promise<T>
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000393</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE9A4F1A093B346D5ADC087E62D45CF7C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lapis</string>
									<string name="ScriptGuid">{694EC9FC-4FC6-4934-84B3-BA6070E7CDA9}</string>
									<ProtectedString name="Source"><![CDATA[local Internal = require(script.Internal)
local PromiseTypes = require(script.PromiseTypes)

local internal = Internal.new(true)

export type DataStoreService = {
	GetDataStore: (name: string) -> GlobalDataStore,
	GetRequestBudgetForRequestType: (requestType: Enum.DataStoreRequestType) -> number,
}

export type PartialLapisConfig = {
	saveAttempts: number?,
	loadAttempts: number?,
	loadRetryDelay: number?,
	showRetryWarnings: boolean?,
	dataStoreService: DataStoreService?,
	[any]: nil,
}

export type CollectionOptions<T> = {
	defaultData: T,
	migrations: { (any) -> any }?,
	validate: (T) -> (boolean, string?),
	[any]: nil,
}

export type Collection<T> = {
	load: (self: Collection<T>, key: string, defaultUserIds: { number }?) -> PromiseTypes.TypedPromise<Document<T>>,
}

export type Document<T> = {
	read: (self: Document<T>) -> T,
	write: (self: Document<T>, T) -> (),
	addUserId: (self: Document<T>, userId: number) -> (),
	removeUserId: (self: Document<T>, userId: number) -> (),
	save: (self: Document<T>) -> PromiseTypes.TypedPromise<()>,
	close: (self: Document<T>) -> PromiseTypes.TypedPromise<()>,
	beforeSave: (self: Document<T>, callback: () -> ()) -> (),
	beforeClose: (self: Document<T>, callback: () -> ()) -> (),
}

--[=[
	@class Lapis
]=]
local Lapis = {}

--[=[
	@interface PartialLapisConfig
	@within Lapis
	.saveAttempts number? -- Max save/close retry attempts
	.loadAttempts number? -- Max load retry attempts
	.loadRetryDelay number? -- Seconds between load attempts
	.showRetryWarnings boolean? -- Show warning on retry
	.dataStoreService (DataStoreService | table)? -- Useful for mocking DataStoreService, especially in a local place
]=]

--[=[
	```lua
	Lapis.setConfig({
		saveAttempts = 10,
		showRetryWarnings = false,
	})
	```

	```lua
	-- The default config values:
	{
		saveAttempts = 5,
		loadAttempts = 20,
		loadRetryDelay = 1,
		showRetryWarnings = true,
		dataStoreService = DataStoreService,
	}
	```

	@param partialConfig PartialLapisConfig
]=]
function Lapis.setConfig(partialConfig: PartialLapisConfig)
	internal.setConfig(partialConfig)
end

--[=[
	@interface CollectionOptions
	@within Lapis
	.validate (any) -> true | (false, string) -- Takes a document's data and returns true on success or false and an error on fail.
	.defaultData any
	.migrations { (any) -> any }? -- Migrations take old data and return new data. Order is first to last.
]=]

--[=[
	Creates a [Collection].

	@param name string
	@param options CollectionOptions
	@return Collection
]=]
function Lapis.createCollection<T>(name: string, options: CollectionOptions<T>): Collection<T>
	return internal.createCollection(name, options)
end

return Lapis
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000394</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXBB085AC675C34EC697233DC47FA7B822">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">AutoSave</string>
										<string name="ScriptGuid">{5E24A0D9-E4C9-4F81-BE4B-F3C6EE672465}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Parent.Promise)

local UPDATE_INTERVAL = 5 * 60

local AutoSave = {}
AutoSave.__index = AutoSave

function AutoSave.new(data)
	return setmetatable({
		documents = {},
		data = data,
		gameClosed = false,
		ongoingLoads = 0,
	}, AutoSave)
end

function AutoSave:addDocument(document)
	table.insert(self.documents, document)
end

function AutoSave:removeDocument(document)
	local index = table.find(self.documents, document)

	table.remove(self.documents, index)
end

function AutoSave:finishLoad(document)
	if self.gameClosed then
		document:close()
	end

	self.ongoingLoads -= 1
end

function AutoSave:onGameClose()
	self.gameClosed = true
	self.data.throttle.gameClosed = true

	while #self.documents > 0 do
		self.documents[#self.documents]:close()
	end

	Promise.allSettled({
		Promise.try(function()
			while self.ongoingLoads > 0 do
				task.wait()
			end
		end):andThen(function()
			return self.data:waitForOngoingSaves()
		end),
		self.data:waitForOngoingSaves(),
	}):await()
end

function AutoSave:start()
	local nextUpdateAt = os.clock() + UPDATE_INTERVAL
	RunService.Heartbeat:Connect(function()
		if os.clock() >= nextUpdateAt then
			for _, document in self.documents do
				document:save():catch(warn)
			end

			nextUpdateAt += UPDATE_INTERVAL
		end
	end)

	game:BindToClose(function()
		self:onGameClose()
	end)
end

return AutoSave
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000395</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3174F2B6D1B54830ADE4C8791A8C3FD1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Collection</string>
										<string name="ScriptGuid">{C84A7A9D-A3AC-4BAC-A8BF-48E9083BE967}</string>
										<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local Document = require(script.Parent.Document)
local freezeDeep = require(script.Parent.freezeDeep)
local Migration = require(script.Parent.Migration)
local Promise = require(script.Parent.Parent.Promise)

local LOCK_EXPIRE = 30 * 60

--[=[
	Collections are analagous to [GlobalDataStore].

	@class Collection
]=]
local Collection = {}
Collection.__index = Collection

function Collection.new(name, options, data, autoSave, config)
	assert(options.validate(options.defaultData))

	freezeDeep(options.defaultData)

	options.migrations = options.migrations or {}

	return setmetatable({
		dataStore = config:get("dataStoreService"):GetDataStore(name),
		options = options,
		data = data,
		autoSave = autoSave,
	}, Collection)
end

--[=[
	Loads the document with `key`, migrates it, and session locks it.

	If specified, the document's `DataStoreKeyInfo:GetUserIds()` will be set to `defaultUserIds` if the document has
	never been loaded.

	@param key string
	@param defaultUserIds {number}?
	@return Promise<Document>
]=]
function Collection:load(key, defaultUserIds)
	if self.autoSave.gameClosed then
		-- If game:BindToClose has been called, this infinitely yields so the document can't load.
		return Promise.new(function() end)
	end

	local lockId = HttpService:GenerateGUID(false)

	self.autoSave.ongoingLoads += 1

	return self
		.data
		:load(self.dataStore, key, function(value, keyInfo)
			if value == nil then
				local data = {
					migrationVersion = #self.options.migrations,
					lockId = lockId,
					data = self.options.defaultData,
				}

				return "succeed", data, defaultUserIds
			end

			if value.migrationVersion > #self.options.migrations then
				return "fail", "Saved migration version ahead of latest version"
			end

			if
				value.lockId ~= nil
				and (DateTime.now().UnixTimestampMillis - keyInfo.UpdatedTime) / 1000 < LOCK_EXPIRE
			then
				return "retry", "Could not acquire lock"
			end

			local migrated = Migration.migrate(self.options.migrations, value.migrationVersion, value.data)

			local ok, message = self.options.validate(migrated)
			if not ok then
				return "fail", `Invalid data: {message}`
			end

			local data = {
				migrationVersion = #self.options.migrations,
				lockId = lockId,
				data = migrated,
			}

			return "succeed", data, keyInfo:GetUserIds(), keyInfo:GetMetadata()
		end)
		:andThen(function(value, keyInfo)
			if value == "cancelled" then
				self.autoSave.ongoingLoads -= 1

				-- Infinitely yield because the load was cancelled by game:BindToClose.
				return Promise.new(function() end)
			end

			local data = value.data

			freezeDeep(data)

			local document = Document.new(self, key, self.options.validate, lockId, data, keyInfo:GetUserIds())

			self.autoSave:finishLoad(document)

			if self.autoSave.gameClosed then
				-- Infinitely yield because the document will automatically be closed.
				return Promise.new(function() end)
			end

			self.autoSave:addDocument(document)

			return document
		end)
		-- finally is used instead of catch so it doesn't handle rejection.
		:finally(function(status)
			if status ~= Promise.Status.Resolved then
				self.autoSave.ongoingLoads -= 1
			end
		end)
end

return Collection
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000396</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX50FDCFB252E245358E10F2A79F155EBE">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Config</string>
										<string name="ScriptGuid">{24301418-D700-46E7-8052-8EE2432DDE68}</string>
										<ProtectedString name="Source"><![CDATA[local DataStoreService = game:GetService("DataStoreService")

local Config = {}
Config.__index = Config

function Config.new()
	return setmetatable({
		config = {
			saveAttempts = 5,
			loadAttempts = 20,
			loadRetryDelay = 1,
			showRetryWarnings = true,
			dataStoreService = DataStoreService,
		},
	}, Config)
end

function Config:get(key)
	return self.config[key]
end

function Config:set(values)
	for key, value in values do
		if self.config[key] == nil then
			error(`Invalid config key "{tostring(key)}"`)
		end

		self.config[key] = value
	end
end

return Config
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000397</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0A064EDCAFFD481ABD8964DFA0563DD2">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Data</string>
										<string name="ScriptGuid">{36C27B9B-336B-4C5D-BBEE-0D4ED0481F88}</string>
										<ProtectedString name="Source"><![CDATA[local Promise = require(script.Parent.Parent.Promise)
local Throttle = require(script.Throttle)

local Data = {}
Data.__index = Data

function Data.new(config)
	local throttle = Throttle.new(config)

	throttle:start()

	return setmetatable({
		config = config,
		throttle = throttle,
		ongoingSaves = {},
	}, Data)
end

function Data:waitForOngoingSave(dataStore, key)
	if self.ongoingSaves[dataStore] == nil or self.ongoingSaves[dataStore][key] == nil then
		return Promise.resolve()
	end

	local ongoingSave = self.ongoingSaves[dataStore][key]

	return Promise.allSettled({
		ongoingSave.promise,
		if ongoingSave.pendingSave ~= nil then ongoingSave.pendingSave.promise else nil,
	})
end

function Data:waitForOngoingSaves()
	local promises = {}

	for _, ongoingSaves in self.ongoingSaves do
		for _, ongoingSave in ongoingSaves do
			if ongoingSave.pendingSave ~= nil then
				table.insert(promises, ongoingSave.pendingSave.promise)
			end

			table.insert(promises, ongoingSave.promise)
		end
	end

	return Promise.allSettled(promises)
end

function Data:load(dataStore, key, transform)
	return self:waitForOngoingSave(dataStore, key):andThen(function()
		local attempts = self.config:get("loadAttempts")
		local retryDelay = self.config:get("loadRetryDelay")

		return self.throttle:updateAsync(dataStore, key, transform, true, attempts, retryDelay)
	end)
end

function Data:save(dataStore, key, transform)
	if self.ongoingSaves[dataStore] == nil then
		self.ongoingSaves[dataStore] = {}
	end

	local ongoingSave = self.ongoingSaves[dataStore][key]

	if ongoingSave == nil then
		local attempts = self.config:get("saveAttempts")
		local promise = self
			.throttle
			:updateAsync(dataStore, key, transform, false, attempts)
			:andThenReturn() -- Save promise should not resolve with a value.
			:finally(function()
				self.ongoingSaves[dataStore][key] = nil

				if next(self.ongoingSaves[dataStore]) == nil then
					self.ongoingSaves[dataStore] = nil
				end
			end)

		if promise:getStatus() == Promise.Status.Started then
			self.ongoingSaves[dataStore][key] = { promise = promise }
		end

		return promise
	elseif ongoingSave.pendingSave == nil then
		local pendingSave = { transform = transform }

		local function save()
			return self:save(dataStore, key, pendingSave.transform)
		end

		-- promise:finally(save) can't be used because if the ongoingSave promise rejects, so will the promise returned from finally.
		pendingSave.promise = ongoingSave.promise:andThen(save, save)

		ongoingSave.pendingSave = pendingSave

		return pendingSave.promise
	else
		ongoingSave.pendingSave.transform = transform

		return ongoingSave.pendingSave.promise
	end
end

return Data
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000398</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBXFC8298E6B12C47499ABD0BC7889B1814">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Throttle</string>
											<string name="ScriptGuid">{9F9828D5-0758-4DD0-A822-589E8CAEFCAF}</string>
											<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Parent.Parent.Promise)

local function updateAsync(throttle, request)
	return Promise.new(function(resolve)
		local resultOutside, transformedOutside, keyInfo
		local ok, err = pcall(function()
			_, keyInfo = request.dataStore:UpdateAsync(request.key, function(...)
				if request.cancelOnGameClose and throttle.gameClosed then
					resultOutside = "cancelled"
					return nil
				end

				local result, transformed, userIds = request.transform(...)

				resultOutside = result
				transformedOutside = transformed

				if result == "succeed" then
					return transformed, userIds
				else
					return nil
				end
			end)
		end)

		if resultOutside == "cancelled" then
			resolve("cancelled")
		elseif not ok then
			resolve("retry", err)
		else
			resolve(resultOutside, transformedOutside, keyInfo)
		end
	end)
end

local Throttle = {}
Throttle.__index = Throttle

function Throttle.new(config)
	return setmetatable({
		config = config,
		queue = {},
		gameClosed = false,
	}, Throttle)
end

function Throttle:getUpdateAsyncBudget()
	return self.config:get("dataStoreService"):GetRequestBudgetForRequestType(Enum.DataStoreRequestType.UpdateAsync)
end

function Throttle:start()
	RunService.PostSimulation:Connect(function()
		for index = #self.queue, 1, -1 do
			local request = self.queue[index]

			if request.attempts == 0 then
				table.remove(self.queue, index)
			elseif request.promise == nil and request.cancelOnGameClose and self.gameClosed then
				request.resolve("cancelled")
				table.remove(self.queue, index)
			end
		end

		for _, request in self.queue do
			if self:getUpdateAsyncBudget() == 0 then
				break
			end

			if request.promise ~= nil then
				continue
			end

			local promise = updateAsync(self, request):andThen(function(result, value, keyInfo)
				if result == "cancelled" then
					request.attempts = 0
					request.resolve("cancelled")
				elseif result == "succeed" then
					request.attempts = 0
					request.resolve(value, keyInfo)
				elseif result == "fail" then
					request.attempts = 0
					request.reject(`DataStoreFailure({value})`)
				elseif result == "retry" then
					request.attempts -= 1

					if request.attempts == 0 then
						request.reject(`DataStoreFailure({value})`)
					else
						if self.config:get("showRetryWarnings") then
							warn(`DataStore operation failed. Retrying...\nError: {value}`)
						end

						task.wait(request.retryDelay)
					end
				else
					error("unreachable")
				end

				request.promise = nil
			end)

			if promise:getStatus() == Promise.Status.Started then
				request.promise = promise
			end
		end
	end)
end

function Throttle:updateAsync(dataStore, key, transform, cancelOnGameClose, retryAttempts, retryDelay)
	return Promise.new(function(resolve, reject)
		table.insert(self.queue, {
			dataStore = dataStore,
			key = key,
			transform = transform,
			attempts = retryAttempts,
			retryDelay = retryDelay,
			cancelOnGameClose = cancelOnGameClose,
			resolve = resolve,
			reject = reject,
		})
	end)
end

return Throttle
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000399</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBX8225B1221F2D40D8B2C411F34408BA8D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Document</string>
										<string name="ScriptGuid">{07DDE0E4-2B5A-46A2-AA23-15DC0761AEF6}</string>
										<ProtectedString name="Source"><![CDATA[local freezeDeep = require(script.Parent.freezeDeep)
local Promise = require(script.Parent.Parent.Promise)

local function runCallback(document, name, callback)
	if callback == nil then
		return Promise.resolve()
	end

	document.callingCallback = name

	return Promise.new(function(resolve, reject)
		local ok, message = pcall(callback)

		document.callingCallback = nil

		if not ok then
			reject(`{name} callback threw error: {message}`)
		else
			resolve()
		end
	end)
end

--[=[
	@class Document
]=]
local Document = {}
Document.__index = Document

function Document.new(collection, key, validate, lockId, data, userIds)
	return setmetatable({
		collection = collection,
		key = key,
		validate = validate,
		lockId = lockId,
		data = data,
		userIds = userIds,
		closed = false,
	}, Document)
end

--[=[
	Returns the document's data.

	@return any
]=]
function Document:read()
	return self.data
end

--[=[
	Writes the document's data.

	:::warning
	Throws an error if the document was closed or if the data is invalid.
	:::

	@param data any
]=]
function Document:write(data)
	assert(not self.closed, "Cannot write to a closed document")
	assert(self.validate(data))

	freezeDeep(data)

	self.data = data
end

--[=[
	Adds a user id to the document's `DataStoreKeyInfo:GetUserIds()`. The change won't apply until the document is saved or closed.

	If the user id is already associated with the document the method won't do anything.

	@param userId number
]=]
function Document:addUserId(userId)
	assert(not self.closed, "Cannot add user id to a closed document")

	if table.find(self.userIds, userId) == nil then
		table.insert(self.userIds, userId)
	end
end

--[=[
	Removes a user id from the document's `DataStoreKeyInfo:GetUserIds()`. The change won't apply until the document is saved or closed.

	If the user id is not associated with the document the method won't do anything.

	@param userId number
]=]
function Document:removeUserId(userId)
	assert(not self.closed, "Cannot remove user id from a closed document")

	local index = table.find(self.userIds, userId)

	if index ~= nil then
		table.remove(self.userIds, index)
	end
end

--[=[
	Saves the document's data. If the save is throttled and you call it multiple times, it will save only once with the latest data.

	:::warning
	Throws an error if the document was closed.
	:::

	:::warning
	If the beforeSave callback errors, the returned promise will reject and the data will not be saved.
	:::

	@return Promise<()>
]=]
function Document:save()
	assert(not self.closed, "Cannot save a closed document")
	assert(self.callingCallback == nil, `Cannot save in {self.callingCallback} callback`)

	return runCallback(self, "beforeSave", self.beforeSaveCallback):andThen(function()
		return self.collection.data:save(self.collection.dataStore, self.key, function(value)
			if value.lockId ~= self.lockId then
				return "fail", "The session lock was stolen"
			end

			value.data = self.data

			return "succeed", value, self.userIds
		end)
	end)
end

--[=[
	Saves the document and removes the session lock. The document is unusable after calling. If a save is currently in
	progress it will close the document instead.

	If called again, it will return the promise from the original call.

	:::warning
	If the beforeSave or beforeClose callbacks error, the returned promise will reject and the data will not be saved.
	:::

	@return Promise<()>
]=]
function Document:close()
	assert(self.callingCallback == nil, `Cannot close in {self.callingCallback} callback`)

	if self.closePromise == nil then
		self.closePromise = runCallback(self, "beforeSave", self.beforeSaveCallback)
			:andThenCall(runCallback, self, "beforeClose", self.beforeCloseCallback)
			:finally(function()
				self.closed = true

				self.collection.autoSave:removeDocument(self)
			end)
			:andThen(function()
				return self.collection.data:save(self.collection.dataStore, self.key, function(value)
					if value.lockId ~= self.lockId then
						return "fail", "The session lock was stolen"
					end

					value.data = self.data
					value.lockId = nil

					return "succeed", value, self.userIds
				end)
			end)
	end

	return self.closePromise
end

--[=[
	Sets a callback that is run inside `document:save` and `document:close` before it saves. The document can be read and written to in the
	callback.

	The callback will run before the beforeClose callback inside of `document:close`.

	:::warning
	Throws an error if it was called previously.
	:::

	@param callback () -> ()
]=]
function Document:beforeSave(callback)
	assert(self.beforeSaveCallback == nil, "Document:beforeSave can only be called once")

	self.beforeSaveCallback = callback
end

--[=[
	Sets a callback that is run inside `document:close` before it saves. The document can be read and written to in the
	callback.

	:::warning
	Throws an error if it was called previously.
	:::

	@param callback () -> ()
]=]
function Document:beforeClose(callback)
	assert(self.beforeCloseCallback == nil, "Document:beforeClose can only be called once")

	self.beforeCloseCallback = callback
end

return Document
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000039a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX937F4582303A4D12B6DDD6E01BADED8E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Document.test</string>
										<string name="ScriptGuid">{FECB44F1-133C-45EE-BCFB-1DE3E6CEFFA0}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Promise = require(ReplicatedStorage.Packages.Promise)

local DEFAULT_OPTIONS = {
	validate = function(data)
		return typeof(data.foo) == "string", "foo must be a string"
	end,
	defaultData = { foo = "bar" },
}

return function(x)
	local assertEqual = x.assertEqual
	local shouldThrow = x.shouldThrow

	x.test("it should not merge close into save when save is running", function(context)
		local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("doc"):expect()

		-- It's not safe to merge saves when UpdateAsync is running.
		-- This will yield the UpdateAsync call until stopYield is called.
		context.dataStoreService.yield:startYield()

		local save = document:save()
		document:write({ foo = "new" })
		local close = document:close()

		context.dataStoreService.yield:stopYield()

		Promise.all({ save, close }):expect()

		local saved = context.read("collection", "doc")

		-- If data.foo == "bar", that means the close was merged with the save when it wasn't safe to.
		assert(saved.data.foo == "new", "")
	end)

	x.test("it should merge pending saves", function(context)
		local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("doc"):expect()

		context.dataStoreService.yield:startYield()

		local ongoingSave = document:save()

		local pendingSave = document:save()
		local pendingClose = document:close() -- This should override the pending save.

		context.dataStoreService.yield:stopYield()

		local values = Promise.all({ ongoingSave, pendingSave }):expect()

		-- This stops the close if it wasn't merged.
		context.dataStoreService.yield:startYield()

		-- Since the following code is resumed by the save promise, we need to wait for the close promise to resolve.
		task.wait()

		pendingClose:now("save and close didn't merge"):expect()

		-- save and close should never resolve with a value.
		-- It's checked in this test to make sure it works with save merging.
		assert(#values == 0, "")

		local saved = context.read("collection", "doc")

		assert(saved.lockId == nil, "")
	end)

	x.test("saves data", function(context)
		local document = context.lapis.createCollection("12345", DEFAULT_OPTIONS):load("doc"):expect()

		document:write({
			foo = "new value",
		})

		document:save():expect()

		local saved = context.read("12345", "doc")

		assert(typeof(saved) == "table", "")
		assert(typeof(saved.lockId) == "string", "")
		assert(saved.data.foo == "new value", "")
	end)

	x.test("writes the data", function(context)
		local document = context.lapis.createCollection("1", DEFAULT_OPTIONS):load("doc"):expect()

		document:write({
			foo = "baz",
		})

		assert(document:read().foo == "baz", "")
	end)

	x.test("write throws if data doesn't validate", function(context)
		local document = context.lapis.createCollection("2", DEFAULT_OPTIONS):load("doc"):expect()

		shouldThrow(function()
			document:write({
				foo = 5,
			})
		end, "foo must be a string")
	end)

	x.test("methods throw when called on a closed document", function(context)
		local document = context.lapis.createCollection("5", DEFAULT_OPTIONS):load("doc"):expect()

		local promise = document:close()

		shouldThrow(function()
			document:write({})
		end, "Cannot write to a closed document")

		shouldThrow(function()
			document:save()
		end, "Cannot save a closed document")

		shouldThrow(function()
			document:addUserId(1234)
		end, "Cannot add user id to a closed document")

		shouldThrow(function()
			document:removeUserId(1234)
		end, "Cannot remove user id from a closed document")

		promise:expect()
	end)

	x.test("close returns first promise when called again", function(context)
		local document = context.lapis.createCollection("col", DEFAULT_OPTIONS):load("doc"):expect()

		local promise = document:close()

		assertEqual(promise, document:close())
	end)

	x.test("loads with default data", function(context)
		local document = context.lapis.createCollection("o", DEFAULT_OPTIONS):load("a"):expect()

		assert(document:read().foo == "bar", "")
	end)

	x.test("loads with existing data", function(context)
		local collection = context.lapis.createCollection("xyz", DEFAULT_OPTIONS)

		context.write("xyz", "xyz", {
			foo = "existing",
		})

		local document = collection:load("xyz"):expect()

		assert(document:read().foo == "existing", "")
	end)

	x.test("freezes document data", function(context)
		local collection = context.lapis.createCollection("collection", {
			validate = function()
				return true
			end,
			defaultData = {},
		})

		context.write("collection", "document", { a = { b = 1 } })

		local document = collection:load("document"):expect()

		shouldThrow(function()
			document:read().a.b = 2
		end)

		document:write({ a = { b = 2 } })

		shouldThrow(function()
			document:read().a.b = 3
		end)
	end)

	x.test("doesn't save data when the lock was stolen", function(context)
		local collection = context.lapis.createCollection("hi", DEFAULT_OPTIONS)

		local document = collection:load("hi"):expect()

		context.write("hi", "hi", {
			foo = "stolen",
		}, "stolenLockId")

		document:write({
			foo = "qux",
		})

		shouldThrow(function()
			document:save():expect()
		end, "The session lock was stolen")

		assert(context.read("hi", "hi").data.foo == "stolen", "")

		shouldThrow(function()
			document:close():expect()
		end, "The session lock was stolen")

		assert(context.read("hi", "hi").data.foo == "stolen", "")
	end)

	x.test("doesn't throw when the budget is exhausted", function(context)
		-- This makes sure the test doesn't pass by retyring after budget is added.
		context.lapis.setConfig({ loadAttempts = 1 })

		local document = context.lapis.createCollection("bye", DEFAULT_OPTIONS):load("bye"):expect()

		context.dataStoreService.budget.budgets[Enum.DataStoreRequestType.GetAsync] = 0
		context.dataStoreService.budget.budgets[Enum.DataStoreRequestType.SetIncrementAsync] = 0
		context.dataStoreService.budget.budgets[Enum.DataStoreRequestType.UpdateAsync] = 0

		local promise = document:save()

		-- This wait is necessary so that the request is run by Throttle.
		task.wait(0.1)

		context.dataStoreService.budget:update()

		promise:expect()
	end)

	x.nested("Document:beforeSave", function()
		x.test("throws when setting twice", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeSave(function() end)

			shouldThrow(function()
				document:beforeSave(function() end)
			end, "Document:beforeSave can only be called once")
		end)

		x.test("throws when calling close in callback", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeSave(function()
				document:close()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeSave callback threw error")
		end)

		x.test("throws when calling save in callback", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeSave(function()
				document:save()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeSave callback threw error")
		end)

		x.test("saves new data in document:save", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeSave(function()
				document:read() -- This checks that read doesn't error in the callback.
				document:write({ foo = "new" })
			end)

			document:save():expect()

			assertEqual(context.read("collection", "document").data.foo, "new")
		end)

		x.test("saves new data in document:close", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeSave(function()
				document:write({ foo = "new" })
			end)

			document:close():expect()

			assertEqual(context.read("collection", "document").data.foo, "new")
		end)
	end)

	x.nested("Document:beforeClose", function()
		x.test("throws when setting twice", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeClose(function() end)

			shouldThrow(function()
				document:beforeClose(function() end)
			end, "Document:beforeClose can only be called once")
		end)

		x.test("throws when calling close in callback", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeClose(function()
				document:close()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeClose callback threw error")
		end)

		x.test("throws when calling save in callback", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeClose(function()
				document:save()
			end)

			shouldThrow(function()
				document:close():expect()
			end, "beforeClose callback threw error")
		end)

		x.test("closes document even if beforeClose errors", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			local promise = collection:load("document")
			local document = promise:expect()

			document:beforeClose(function()
				error("error")
			end)

			shouldThrow(function()
				document:close():expect()
			end)

			local secondPromise = collection:load("document")

			assert(secondPromise ~= promise, "collection:load should return a new promise")

			shouldThrow(function()
				document:write({ foo = "baz" })
			end, "Cannot write to a closed document")

			-- Ignore the could not acquire lock error.
			secondPromise:catch(function() end)
		end)

		x.test("saves new data", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			document:beforeClose(function()
				document:read() -- This checks that read doesn't error in the callback.

				document:write({ foo = "new" })
			end)

			document:close():expect()

			assertEqual(context.read("collection", "document").data.foo, "new")
		end)

		x.test("beforeSave runs before beforeClose", function(context)
			local document = context.lapis.createCollection("collection", DEFAULT_OPTIONS):load("document"):expect()

			local order = ""

			document:beforeSave(function()
				order ..= "s"
			end)

			document:beforeClose(function()
				order ..= "c"
			end)

			document:close():expect()

			assertEqual(order, "sc")
		end)
	end)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000039b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA606EB35E2CC454CA09107FAC633533E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Internal</string>
										<string name="ScriptGuid">{F0EC43C1-F12D-491D-82B3-4B2AB16CDC6A}</string>
										<ProtectedString name="Source"><![CDATA[local AutoSave = require(script.Parent.AutoSave)
local Collection = require(script.Parent.Collection)
local Config = require(script.Parent.Config)
local Data = require(script.Parent.Data)

local Internal = {}

function Internal.new(enableAutoSave)
	local config = Config.new()
	local data = Data.new(config)
	local autoSave = AutoSave.new(data)

	if enableAutoSave then
		autoSave:start()
	end

	local usedCollections = {}

	local internal = {}

	if not enableAutoSave then
		-- This exposes AutoSave to unit tests.
		internal.autoSave = autoSave
	end

	function internal.setConfig(values)
		config:set(values)
	end

	function internal.createCollection(name, options)
		if usedCollections[name] then
			error(`Collection "{name}" already exists`)
		end

		usedCollections[name] = true

		return Collection.new(name, options, data, autoSave, config)
	end

	return internal
end

return Internal
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000039c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7C590CCCD9B94BDA90C395E8B28308F3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Migration</string>
										<string name="ScriptGuid">{1E935FC8-5076-49AE-9467-1CBB44BC4AA4}</string>
										<ProtectedString name="Source"><![CDATA[local freezeDeep = require(script.Parent.freezeDeep)

local Migration = {}

function Migration.migrate(migrations, oldVersion, data)
	if oldVersion < #migrations then
		for version = oldVersion + 1, #migrations do
			local migrated = migrations[version](data)

			freezeDeep(migrated)

			data = migrated
		end
	end

	return data
end

return Migration
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000039d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1A0B96C6BC374F798E3E392A90F203CD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">PromiseTypes</string>
										<string name="ScriptGuid">{DB629A07-DF23-486E-857B-B43FBF3D05CC}</string>
										<ProtectedString name="Source"><![CDATA[export type Status = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type Promise = {
	andThen: (
		self: Promise,
		successHandler: (...any) -> ...any,
		failureHandler: ((...any) -> ...any)?
	) -> Promise,
	andThenCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> any,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, ...any),
	awaitStatus: (self: Promise) -> (Status, ...any),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> ...any,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (...any) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

export type TypedPromise<T...> = {
	andThen: (self: Promise, successHandler: (T...) -> ...any, failureHandler: ((...any) -> ...any)?) -> Promise,
	andThenCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> Promise,
	andThenReturn: (self: Promise, ...any) -> Promise,

	await: (self: Promise) -> (boolean, T...),
	awaitStatus: (self: Promise) -> (Status, T...),

	cancel: (self: Promise) -> (),
	catch: (self: Promise, failureHandler: (...any) -> ...any) -> Promise,
	expect: (self: Promise) -> T...,

	finally: (self: Promise, finallyHandler: (status: Status) -> ...any) -> Promise,
	finallyCall: <T...>(self: Promise, callback: (T...) -> ...any, T...) -> Promise,
	finallyReturn: (self: Promise, ...any) -> Promise,

	getStatus: (self: Promise) -> Status,
	now: (self: Promise, rejectionValue: any?) -> Promise,
	tap: (self: Promise, tapHandler: (T...) -> ...any) -> Promise,
	timeout: (self: Promise, seconds: number, rejectionValue: any?) -> Promise,
}

return nil
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000039e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1FF98C8D627C494EA8E6161F59900034">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">freezeDeep</string>
										<string name="ScriptGuid">{D0ACE75F-A9FB-44DE-B1EE-44D1CE7A65F5}</string>
										<ProtectedString name="Source"><![CDATA[local function freezeDeep(value)
	if typeof(value) ~= "table" then
		return
	end

	if not table.isfrozen(value) then
		table.freeze(value)
	end

	for _, innerValue in value do
		freezeDeep(innerValue)
	end
end

return freezeDeep
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000039f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDEF670346324495DB99E68A84D6B546C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">init.test</string>
										<string name="ScriptGuid">{7868A61F-C403-48DD-8F44-9F729C45E07D}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DataStoreServiceMock = require(ReplicatedStorage.DevPackages.DataStoreServiceMock)
local Internal = require(script.Parent.Internal)
local Promise = require(script.Parent.Parent.Promise)

local DEFAULT_OPTIONS = {
	validate = function(data)
		return typeof(data.apples) == "number", "apples should be a number"
	end,
	defaultData = {
		apples = 20,
	},
}

return function(x)
	local assertEqual = x.assertEqual
	local shouldThrow = x.shouldThrow

	x.beforeEach(function(context)
		local dataStoreService = DataStoreServiceMock.manual()

		context.dataStoreService = dataStoreService

		-- We want requests to overflow the throttle queue so that they result in errors.
		dataStoreService.budget:setMaxThrottleQueueSize(0)

		context.lapis = Internal.new(false)
		context.lapis.setConfig({ dataStoreService = dataStoreService, showRetryWarnings = false })

		context.write = function(name, key, data, lockId)
			local dataStore = dataStoreService.dataStores[name]["global"]

			dataStore:write(key, {
				migrationVersion = 0,
				lockId = lockId,
				data = data,
			})
		end

		context.read = function(name, key)
			return dataStoreService.dataStores[name]["global"].data[key]
		end

		context.expectUnlocked = function(name, key)
			local data = dataStoreService.dataStores[name]["global"].data[key]

			if data.lockId ~= nil then
				error("Document is locked")
			end
		end

		context.expectUserIds = function(name, key, targetUserIds)
			local keyInfo = dataStoreService.dataStores[name]["global"].keyInfos[key]

			local currentUserIds = if keyInfo ~= nil then keyInfo:GetUserIds() else {}

			if #currentUserIds ~= #targetUserIds then
				error("Incorrect user ids length")
			end

			for index, value in targetUserIds do
				if currentUserIds[index] ~= value then
					error("Invalid user id")
				end
			end
		end
	end)

	x.test("throws when setting invalid config key", function(context)
		shouldThrow(function()
			context.lapis.setConfig({
				foo = true,
			})
		end, 'Invalid config key "foo"')
	end)

	x.test("throws when creating a duplicate collection", function(context)
		context.lapis.createCollection("foo", DEFAULT_OPTIONS)

		shouldThrow(function()
			context.lapis.createCollection("foo", DEFAULT_OPTIONS)
		end, 'Collection "foo" already exists')
	end)

	x.test("freezes default data", function(context)
		local defaultData = { a = { b = { c = 5 } } }

		context.lapis.createCollection("baz", {
			validate = function()
				return true
			end,
			defaultData = defaultData,
		})

		shouldThrow(function()
			defaultData.a.b.c = 8
		end)
	end)

	x.test("validates default data", function(context)
		shouldThrow(function()
			context.lapis.createCollection("bar", {
				validate = function()
					return false, "data is invalid"
				end,
			})
		end, "data is invalid")
	end)

	x.test("should not override data if validation fails", function(context)
		local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

		context.write("collection", "doc", { apples = "string" })

		local old = context.read("collection", "doc")

		shouldThrow(function()
			collection:load("doc"):expect()
		end, "apples should be a number")

		assertEqual(old, context.read("collection", "doc"))
	end)

	x.test("should session lock the document", function(context)
		local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)
		local document = collection:load("doc"):expect()

		local otherLapis = Internal.new(false)
		otherLapis.setConfig({ dataStoreService = context.dataStoreService, loadAttempts = 1 })

		local otherCollection = otherLapis.createCollection("collection", DEFAULT_OPTIONS)

		shouldThrow(function()
			otherCollection:load("doc"):expect()
		end, "Could not acquire lock")

		-- It should keep the session lock when saved.
		document:save():expect()

		shouldThrow(function()
			otherCollection:load("doc"):expect()
		end, "Could not acquire lock")

		-- It should remove the session lock when closed.
		document:close():expect()

		otherCollection:load("doc"):expect()
	end)

	x.test("load should retry when document is session locked", function(context)
		local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)
		local document = collection:load("doc"):expect()

		local otherLapis = Internal.new(false)
		otherLapis.setConfig({
			dataStoreService = context.dataStoreService,
			loadAttempts = 4,
			loadRetryDelay = 0.5,
			showRetryWarnings = false,
		})

		local otherCollection = otherLapis.createCollection("collection", DEFAULT_OPTIONS)
		local promise = otherCollection:load("doc")

		-- Wait for the document to attempt to load once.
		task.wait(0.1)

		-- Remove the sesssion lock.
		document:close():expect()

		promise:expect()
	end)

	x.test("second load should fail because of session lock", function(context)
		local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

		context.lapis.setConfig({ loadAttempts = 1 })

		local first = collection:load("document")
		local second = collection:load("document")

		first:expect()

		shouldThrow(function()
			second:expect()
		end, "Could not acquire lock")
	end)

	x.test("load returns a new promise when first load fails", function(context)
		context.lapis.setConfig({ loadAttempts = 1 })
		context.dataStoreService.errors:addSimulatedErrors(1)

		local collection = context.lapis.createCollection("ghi", DEFAULT_OPTIONS)

		local promise1 = collection:load("ghi")

		shouldThrow(function()
			promise1:expect()
		end)

		local promise2 = collection:load("ghi")

		assert(promise1 ~= promise2, "load should return new promise")

		promise2:expect()
	end)

	x.test("migrates the data", function(context)
		local collection = context.lapis.createCollection("migration", {
			validate = function(value)
				return value == "newData", "value does not equal newData"
			end,
			defaultData = "newData",
			migrations = {
				function()
					return "newData"
				end,
			},
		})

		context.write("migration", "migration", "data")

		collection:load("migration"):expect()
	end)

	x.test("throws when migration version is ahead of latest version", function(context)
		local collection = context.lapis.createCollection("collection", {
			validate = function()
				return true
			end,
			defaultData = "a",
		})

		local dataStore = context.dataStoreService.dataStores.collection.global
		dataStore:write("document", {
			migrationVersion = 1,
			data = "b",
		})

		local promise = collection:load("document")

		shouldThrow(function()
			promise:expect()
		end, "Saved migration version ahead of latest version")
	end)

	x.test("closing and immediately opening should return a new document", function(context)
		local collection = context.lapis.createCollection("ccc", DEFAULT_OPTIONS)

		local document = collection:load("doc"):expect()

		local close = document:close()
		local open = collection:load("doc")

		close:expect()

		local newDocument = open:expect()

		assert(newDocument ~= document, "")
	end)

	x.test("closes all document on game:BindToClose", function(context)
		local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

		local one = collection:load("one"):expect()
		local two = collection:load("two"):expect()
		local three = collection:load("three"):expect()

		context.dataStoreService.yield:startYield()

		local thread = task.spawn(function()
			context.lapis.autoSave:onGameClose()
		end)

		assert(coroutine.status(thread) == "suspended", "onGameClose didn't wait for the documents to finish closing")

		-- Verify each document has been closed.
		for _, document in { one, two, three } do
			shouldThrow(function()
				document:save():expect()
			end, "Cannot save a closed document")
		end

		context.dataStoreService.yield:stopYield()

		-- Wait for documents to finish saving.
		task.wait(0.1)

		assert(coroutine.status(thread) == "dead", "")
	end)

	x.nested("user ids", function()
		x.test("it uses defaultUserIds on first load", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			local document = collection:load("document", { 123 }):expect()
			context.expectUserIds("collection", "document", { 123 })
			document:close():expect()
			context.expectUserIds("collection", "document", { 123 })

			-- Since the document has already been created, the defaultUserIds should not override the saved ones.
			document = collection:load("document", { 321 }):expect()
			context.expectUserIds("collection", "document", { 123 })
			document:close():expect()
			context.expectUserIds("collection", "document", { 123 })
		end)

		x.test("adds new user ids", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			local document = collection:load("document", {}):expect()

			document:addUserId(111)
			document:addUserId(111) -- It should not add this user id twice.
			document:addUserId(222)

			context.expectUserIds("collection", "document", {})

			document:save():expect()

			context.expectUserIds("collection", "document", { 111, 222 })

			document:close():expect()

			context.expectUserIds("collection", "document", { 111, 222 })
		end)

		x.test("removes new user ids", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			local document = collection:load("document", { 333, 444, 555 }):expect()

			document:removeUserId(111) -- It should do nothing if the user id doesn't exist.
			document:removeUserId(444)

			context.expectUserIds("collection", "document", { 333, 444, 555 })

			document:save():expect()

			context.expectUserIds("collection", "document", { 333, 555 })

			document:close():expect()

			context.expectUserIds("collection", "document", { 333, 555 })
		end)
	end)

	x.nested("load during BindToClose", function()
		x.test("load infinitely yields after BindToClose", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			task.spawn(function()
				context.lapis.autoSave:onGameClose()
			end)

			shouldThrow(function()
				collection:load("document"):timeout(0.5):expect()
			end, "Timed out")
		end)

		x.test("load just before BindToClose", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			context.dataStoreService.yield:startYield()

			collection:load("document")

			local thread = task.spawn(function()
				task.wait(0.1) -- Wait for load request to call UpdateAsync.
				context.lapis.autoSave:onGameClose()
			end)

			assert(
				coroutine.status(thread) == "suspended",
				"onGameClose didn't wait for the documents to finish loading"
			)

			task.wait(0.2)

			context.dataStoreService.yield:stopYield()

			context.dataStoreService.yield:startYield()
			assert(
				coroutine.status(thread) == "suspended",
				"onGameClose didn't wait for the documents to finish closing"
			)
			context.dataStoreService.yield:stopYield()

			task.wait(0.1) -- Wait for document to finish closing.
			context.expectUnlocked("collection", "document")

			assert(coroutine.status(thread) == "dead", "")
		end)

		x.test("BindToClose should finish if a document fails to load", function(context)
			local collection = context.lapis.createCollection("collection", DEFAULT_OPTIONS)

			context.write("collection", "document", "INVALID DATA")
			collection:load("document"):catch(function() end)

			-- Wait to close game so that the save request doesn't get cancelled.
			task.wait(0.1)

			Promise.try(function()
				context.lapis.autoSave:onGameClose()
			end)
				:timeout(1)
				:expect()
		end)
	end)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000003a0</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX88A7A5BF9DF342AD95C198F74B9A0BA5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">types</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000057e</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX95CBB3D2B9084AA0B58181E62EDE5816">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">include</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000057f</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBX3CB71691355849FAB00ABF72E9369F4D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">generated</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000580</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX26B61714C39B4B48AC32412440EF18BE">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">matter</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000003fd</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXD6B625FCB9AC41A0A3B3231FE6727F9D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">lib</string>
								<string name="ScriptGuid">{C7EEC78B-84EF-4F59-8077-18B0005C93A1}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
	@class Matter

	Matter. It's what everything is made out of.
]=]

--[=[
	@within Matter
	@prop World World
]=]

--[=[
	@within Matter
	@prop Loop Loop
]=]

--[=[
	@within Matter
	@prop Debugger Debugger
]=]

--[=[
	@within Matter
	@prop None None

	A value should be interpreted as nil when merging dictionaries.

	`Matter.None` is used by [`Component:patch`](/api/Component#patch).
]=]

--[=[
	@within Matter
	@function component
	@param name? string -- Optional name for debugging purposes
	@param defaultData? {} -- Default data that will be merged with data passed to the component when created
	@return Component -- Your new type of component

	Creates a new type of component. Call the component as a function to create an instance of that component.

	If `defaultData` is specified, it will be merged with data passed to the component when the component instance is
	created. Note that this is not *fallback* data: if you later remove a field from a component instance that is
	specified in the default data, it won't fall back to the value specified in default data.

	```lua
	-- Component:
	local MyComponent = Matter.component("My component")

	-- component instance:
	local myComponentInstance = MyComponent({
		some = "data"
	})
	```
]=]

local immutable = require(script.immutable)
local World = require(script.World)
local Loop = require(script.Loop)
local newComponent = require(script.component).newComponent
local topoRuntime = require(script.topoRuntime)

export type World = typeof(World.new())
export type Loop = typeof(Loop.new())

return table.freeze({
	World = World,
	Loop = Loop,

	component = newComponent,

	useEvent = require(script.hooks.useEvent),
	useDeltaTime = require(script.hooks.useDeltaTime),
	useThrottle = require(script.hooks.useThrottle),
	log = require(script.hooks.log),
	useHookState = topoRuntime.useHookState,
	useCurrentSystem = topoRuntime.useCurrentSystem,

	merge = immutable.merge,
	None = immutable.None,

	Debugger = require(script.debugger.debugger),
})
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000003fe</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX6C8E7CC00E2F4D20A3BAFFDC6B60E59D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Loop</string>
									<string name="ScriptGuid">{41D3B449-2CF0-4622-AEDF-ECE24B08059F}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local rollingAverage = require(script.Parent.rollingAverage)
local topoRuntime = require(script.Parent.topoRuntime)

local recentErrors = {}
local recentErrorLastTime = 0

local function systemFn(system: System)
	if type(system) == "table" then
		return system.system
	end

	return system
end

local function systemName(system: System)
	local fn = systemFn(system)
	return debug.info(fn, "s") .. "->" .. debug.info(fn, "n")
end

--[=[
	@class Loop

	The Loop class handles scheduling and *looping* (who would have guessed) over all of your game systems.

	:::caution Yielding
	Yielding is not allowed in systems. Doing so will result in the system thread being closed early, but it will not
	affect other systems.
	:::
]=]
local Loop = {}
Loop.__index = Loop

--[=[
	Creates a new loop. `Loop.new` accepts as arguments the values that will be passed to all of your systems.

	So typically, you want to pass the World in here, as well as maybe a table of global game state.

	```lua
	local world = World.new()
	local gameState = {}

	local loop = Loop.new(world, gameState)
	```

	@param ... ...any -- Values that will be passed to all of your systems
	@return Loop
]=]
function Loop.new(...)
	return setmetatable({
		_systems = {},
		_skipSystems = {},
		_orderedSystemsByEvent = {},
		_state = { ... },
		_stateLength = select("#", ...),
		_systemState = {},
		_middlewares = {},
		_systemErrors = {},
		_systemLogs = {},
		profiling = nil,
		trackErrors = false,
	}, Loop)
end

--[=[
	@within Loop
	@type System SystemTable | (...any) -> ()

	Either a plain function or a table defining the system.
]=]

--[=[
	@within Loop
	@interface SystemTable
	.system (...any) -> () -- The system function
	.event? string -- The event the system runs on. A string, a key from the table you pass to `Loop:begin`.
	.priority? number -- Priority influences the position in the frame the system is scheduled to run at.
	.after? {System} -- A list of systems that this system must run after.

	A table defining a system with possible options.

	Systems are scheduled in order of `priority`, meaning lower `priority` runs first.
	The default priority is `0`.
]=]

type System = (...any) -> () | { system: (...any) -> (), event: string?, priority: number?, after: nil | {} }

--[=[
	Schedules a set of systems based on the constraints they define.

	Systems may optionally declare:
	- The name of the event they run on (e.g., RenderStepped, Stepped, Heartbeat)
	- A numerical priority value
	- Other systems that they must run *after*

	If systems do not specify an event, they will run on the `default` event.

	Systems that share an event will run in order of their priority, which means that systems with a lower `priority`
	value run first. The default priority is `0`.

	Systems that have defined what systems they run `after` can only be scheduled after all systems they depend on have
	already been scheduled.

	All else being equal, the order in which systems run is stable, meaning if you don't change your code, your systems
	will always run in the same order across machines.

	:::info
	It is possible for your systems to be in an unresolvable state. In which case, `scheduleSystems` will error.
	This can happen when your systems have circular or unresolvable dependency chains.

	If a system has both a `priority` and defines systems it runs `after`, the system can only be scheduled if all of
	the systems it depends on have a lower or equal priority.

	Systems can never depend on systems that run on other events, because it is not guaranteed or required that events
	will fire every frame or will always fire in the same order.
	:::

	:::caution
	`scheduleSystems` has to perform nontrivial sorting work each time it's called, so you should avoid calling it multiple
	times if possible.
	:::

	@param systems { System } -- Array of systems to schedule.
]=]
function Loop:scheduleSystems(systems: { System })
	for _, system in ipairs(systems) do
		if table.find(self._systems, system) == nil then
			table.insert(self._systems, system)
		end
		self._systemState[system] = {}

		if RunService:IsStudio() then
			-- In Studio, we start logging immediately.
			self._systemLogs[system] = {}
		end
	end

	self:_sortSystems()
end
--[=[
	Schedules a single system. This is an expensive function to call multiple times. Instead, try batch scheduling
	systems with [Loop:scheduleSystems] if possible.

	@param system System
]=]
function Loop:scheduleSystem(system: System)
	return self:scheduleSystems({ system })
end

--[=[
	Removes a previously-scheduled system from the Loop. Evicting a system also cleans up any storage from hooks.
	This is intended to be used for hot reloading. Dynamically loading and unloading systems for gameplay logic
	is not recommended.

	@param system System
]=]
function Loop:evictSystem(system: System)
	local systemIndex = table.find(self._systems, system)

	if systemIndex == nil then
		error("Can't evict system because it doesn't exist")
	end

	table.remove(self._systems, systemIndex)

	self._systemErrors[system] = nil

	topoRuntime.start({
		system = self._systemState[system],
	}, function() end)

	self._systemState[system] = nil
	self._systemLogs[system] = nil

	self:_sortSystems()
end

--[=[
	Replaces an older version of a system with a newer version of the system. Internal system storage (which is used
	by hooks) will be moved to be associated with the new system. This is intended to be used for hot reloading.

	@param old System
	@param new System
]=]
function Loop:replaceSystem(old: System, new: System)
	local systemIndex = table.find(self._systems, old)

	if not systemIndex then
		error("Before system does not exist!")
	end

	table.remove(self._systems, systemIndex)
	table.insert(self._systems, new)

	self._systemState[new] = self._systemState[old] or {}
	self._systemState[old] = nil

	if self._skipSystems[old] then
		self._skipSystems[old] = nil
		self._skipSystems[new] = true
	end

	for _, system in self._systems do
		if type(system) == "table" and system.after then
			local index = table.find(system.after, old)

			if index then
				system.after[index] = new
			end
		end
	end

	self:_sortSystems()
end

local function orderSystemsByDependencies(unscheduledSystems: { System })
	local systemPriorityMap = {}
	local visiting = "v"

	local function systemPriority(system: System)
		local priority = systemPriorityMap[system]

		if not priority then
			priority = 0

			systemPriorityMap[system] = visiting

			if type(system) == "table" then
				if system.after then
					for _, dependency in system.after do
						if systemPriorityMap[dependency] ~= visiting then
							priority = math.max(priority, systemPriority(dependency) + 1)
						else
							local errorStatement = {
								`Cyclic dependency detected: System '{systemName(system)}' is set to execute after System '{systemName(
									dependency
								)}', and vice versa. This creates a loop that prevents the systems from being able to execute in a valid order.`,
								"To resolve this issue, reconsider the dependencies between these systems. One possible solution is to update the 'after' field from one of the systems.",
							}
							error(table.concat(errorStatement, "\n"))
						end
					end
				elseif system.priority then
					priority = system.priority
				end
			end

			systemPriorityMap[system] = priority
		end

		return priority
	end

	local scheduledSystems = table.clone(unscheduledSystems)

	table.sort(scheduledSystems, function(a, b)
		local priorityA = systemPriority(a)
		local priorityB = systemPriority(b)

		if priorityA == priorityB then
			local nameA = systemName(a)
			local nameB = systemName(b)

			if nameA == nameB then
				return table.find(unscheduledSystems, a) < table.find(unscheduledSystems, b)
			end

			return nameA < nameB
		end

		return priorityA < priorityB
	end)

	return scheduledSystems
end

function Loop:_sortSystems()
	local systemsByEvent = {}

	for _, system in pairs(self._systems) do
		local eventName = "default"

		if type(system) == "table" then
			if system.event then
				eventName = system.event
			end
			if system.after then
				if system.priority then
					error(`{systemName(system)} shouldn't have both priority and after defined`)
				end

				if #system.after == 0 then
					error(
						`System "{systemName(system)}" "after" table was provided but is empty; did you accidentally use a nil value or make a typo?`
					)
				end

				for _, dependency in system.after do
					if not table.find(self._systems, dependency) then
						error(
							`Unable to schedule "{systemName(system)}" because the system "{systemName(dependency)}" is not scheduled.\n\nEither schedule "{systemName(
								dependency
							)}" before "{systemName(
								system
							)}" or consider scheduling these systems together with Loop:scheduleSystems`
						)
					end
				end
			end
		end

		if not systemsByEvent[eventName] then
			systemsByEvent[eventName] = {}
		end

		table.insert(systemsByEvent[eventName], system)
	end

	self._orderedSystemsByEvent = {}

	for eventName, systems in pairs(systemsByEvent) do
		self._orderedSystemsByEvent[eventName] = orderSystemsByDependencies(systems)
	end
end

--[=[
	Connects to frame events and starts invoking your systems.

	Pass a table of events you want to be able to run systems on, a map of name to event. Systems can use these names
	to define what event they run on. By default, systems run on an event named `"default"`. Custom events may be used
	if they have a `Connect` function.

	```lua
	loop:begin({
		default = RunService.Heartbeat,
		Heartbeat = RunService.Heartbeat,
		RenderStepped = RunService.RenderStepped,
		Stepped = RunService.Stepped,
	})
	```

	&nbsp;

	Returns a table similar to the one you passed in, but the values are `RBXScriptConnection` values (or whatever is
	returned by `:Connect` if you passed in a synthetic event).

	@param events {[string]: RBXScriptSignal} -- A map from event name to event objects.
	@return {[string]: RBXScriptConnection} -- A map from your event names to connection objects.
]=]
function Loop:begin(events)
	local connections = {}

	for eventName, event in pairs(events) do
		local lastTime = os.clock()
		local generation = false

		local function stepSystems()
			if not self._orderedSystemsByEvent[eventName] then
				-- Skip events that have no systems
				return
			end

			local currentTime = os.clock()
			local deltaTime = currentTime - lastTime
			lastTime = currentTime

			generation = not generation

			local dirtyWorlds: { [any]: true } = {}
			local profiling = self.profiling

			for _, system in ipairs(self._orderedSystemsByEvent[eventName]) do
				topoRuntime.start({
					system = self._systemState[system],
					frame = {
						generation = generation,
						deltaTime = deltaTime,
						dirtyWorlds = dirtyWorlds,
						logs = self._systemLogs[system],
					},
					currentSystem = system,
				}, function()
					if self._skipSystems[system] then
						if profiling then
							profiling[system] = nil
						end
						return
					end

					local fn = systemFn(system)
					debug.profilebegin("system: " .. systemName(system))

					local thread = coroutine.create(fn)

					local startTime = os.clock()
					local success, errorValue = coroutine.resume(thread, unpack(self._state, 1, self._stateLength))

					if profiling ~= nil then
						local duration = os.clock() - startTime

						if profiling[system] == nil then
							profiling[system] = {}
						end

						rollingAverage.addSample(profiling[system], duration)
					end

					if coroutine.status(thread) ~= "dead" then
						coroutine.close(thread)

						task.spawn(
							error,
							(
								"Matter: System %s yielded! Its thread has been closed. "
								.. "Yielding in systems is not allowed."
							):format(systemName(system))
						)
					end

					for world in dirtyWorlds do
						world:optimizeQueries()
					end
					table.clear(dirtyWorlds)

					if not success then
						if os.clock() - recentErrorLastTime > 10 then
							recentErrorLastTime = os.clock()
							recentErrors = {}
						end

						local errorString = systemName(system)
							.. ": "
							.. tostring(errorValue)
							.. "\n"
							.. debug.traceback(thread)

						if not recentErrors[errorString] then
							task.spawn(error, errorString)
							warn("Matter: The above error will be suppressed for the next 10 seconds")
							recentErrors[errorString] = true
						end

						if self.trackErrors then
							if self._systemErrors[system] == nil then
								self._systemErrors[system] = {}
							end

							local errorStorage = self._systemErrors[system]
							local lastError = errorStorage[#errorStorage]

							if lastError and lastError.error == errorString then
								lastError.when = os.time()
							else
								table.insert(errorStorage, {
									error = errorString,
									when = os.time(),
								})

								if #errorStorage > 100 then
									table.remove(errorStorage, 1)
								end
							end
						end
					end

					debug.profileend()
				end)
			end
		end

		for _, middleware in ipairs(self._middlewares) do
			stepSystems = middleware(stepSystems, eventName)

			if type(stepSystems) ~= "function" then
				error(
					("Middleware function %s:%s returned %s instead of a function"):format(
						debug.info(middleware, "s"),
						debug.info(middleware, "l"),
						typeof(stepSystems)
					)
				)
			end
		end

		connections[eventName] = event:Connect(stepSystems)
	end

	return connections
end

--[=[
	Adds a user-defined middleware function that is called during each frame.

	This allows you to run code before and after each frame, to perform initialization and cleanup work.

	```lua
	loop:addMiddleware(function(nextFn)
		return function()
			Plasma.start(plasmaNode, nextFn)
		end
	end)
	```

	You must pass `addMiddleware` a function that itself returns a function that invokes `nextFn` at some point.

	The outer function is invoked only once. The inner function is invoked during each frame event.

	:::info
	Middleware added later "wraps" middleware that was added earlier. The innermost middleware function is the internal
	function that actually calls your systems.
	:::
	@param middleware (nextFn: () -> (), eventName: string) -> () -> ()
]=]
function Loop:addMiddleware(middleware: (nextFn: () -> ()) -> () -> ())
	table.insert(self._middlewares, middleware)
end

return Loop
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000003ff</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA2829F7DDA5D42F8ACA2D3299587136A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Queue</string>
									<string name="ScriptGuid">{483B31D8-AA79-4C87-958C-7D4EE20126BC}</string>
									<ProtectedString name="Source"><![CDATA[local Queue = {}
Queue.__index = Queue

function Queue.new()
	return setmetatable({
		_head = nil,
		_tail = nil,
	}, Queue)
end

function Queue:pushBack(value)
	local entry = {
		value = value,
		next = nil,
	}

	if self._tail ~= nil then
		self._tail.next = entry
	end

	self._tail = entry

	if self._head == nil then
		self._head = entry
	end
end

function Queue:popFront()
	if self._head == nil then
		return nil
	end

	local value = self._head.value
	self._head = self._head.next

	return value
end

return Queue
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000400</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA2CD0F0C6D8946D5B8B34E574F570041">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">World</string>
									<string name="ScriptGuid">{8444D70F-1FD3-495E-A243-05F2BDF951C9}</string>
									<ProtectedString name="Source"><![CDATA[local archetypeModule = require(script.Parent.archetype)
local topoRuntime = require(script.Parent.topoRuntime)
local Component = require(script.Parent.component)

local assertValidComponentInstance = Component.assertValidComponentInstance
local assertValidComponent = Component.assertValidComponent
local archetypeOf = archetypeModule.archetypeOf
local negateArchetypeOf = archetypeModule.negateArchetypeOf
local areArchetypesCompatible = archetypeModule.areArchetypesCompatible

local ERROR_NO_ENTITY = "Entity doesn't exist, use world:contains to check if needed"

--[=[
	@class World

	A World contains entities which have components.
	The World is queryable and can be used to get entities with a specific set of components.
	Entities are simply ever-increasing integers.
]=]
local World = {}
World.__index = World

--[=[
	Creates a new World.
]=]
function World.new()
	local firstStorage = {}

	return setmetatable({
		-- List of maps from archetype string --> entity ID --> entity data
		_storages = { firstStorage },
		-- The most recent storage that has not been dirtied by an iterator
		_pristineStorage = firstStorage,

		-- Map from entity ID -> archetype string
		_entityArchetypes = {},

		-- Cache of the component metatables on each entity. Used for generating archetype.
		-- Map of entity ID -> array
		_entityMetatablesCache = {},

		-- Cache of what query archetypes are compatible with what component archetypes
		_queryCache = {},

		-- Cache of what entity archetypes have ever existed in the game. This is used for knowing
		-- when to update the queryCache.
		_entityArchetypeCache = {},

		-- The next ID that will be assigned with World:spawn
		_nextId = 1,

		-- The total number of active entities in the world
		_size = 0,

		-- Storage for `queryChanged`
		_changedStorage = {},
	}, World)
end

-- Searches all archetype storages for the entity with the given archetype
-- Returns the storage that the entity is in if it exists, otherwise nil
function World:_getStorageWithEntity(archetype, id)
	for _, storage in self._storages do
		local archetypeStorage = storage[archetype]
		if archetypeStorage then
			if archetypeStorage[id] then
				return storage
			end
		end
	end
	return nil
end

function World:_markStorageDirty()
	local newStorage = {}
	table.insert(self._storages, newStorage)
	self._pristineStorage = newStorage

	if topoRuntime.withinTopoContext() then
		local frameState = topoRuntime.useFrameState()

		frameState.dirtyWorlds[self] = true
	end
end

function World:_getEntity(id)
	local archetype = self._entityArchetypes[id]
	local storage = self:_getStorageWithEntity(archetype, id)

	return storage[archetype][id]
end

function World:_next(last)
	local entityId, archetype = next(self._entityArchetypes, last)

	if entityId == nil then
		return nil
	end

	local storage = self:_getStorageWithEntity(archetype, entityId)

	return entityId, storage[archetype][entityId]
end

--[=[
	Iterates over all entities in this World. Iteration returns entity ID followed by a dictionary mapping
	Component to Component Instance.

	**Usage:**

	```lua
	for entityId, entityData in world do
		print(entityId, entityData[Components.Example])
	end
	```

	@return number
	@return {[Component]: ComponentInstance}
]=]
function World:__iter()
	return World._next, self
end

--[=[
	Spawns a new entity in the world with the given components.

	@param ... ComponentInstance -- The component values to spawn the entity with.
	@return number -- The new entity ID.
]=]
function World:spawn(...)
	return self:spawnAt(self._nextId, ...)
end

--[=[
	Spawns a new entity in the world with a specific entity ID and given components.

	The next ID generated from [World:spawn] will be increased as needed to never collide with a manually specified ID.

	@param id number -- The entity ID to spawn with
	@param ... ComponentInstance -- The component values to spawn the entity with.
	@return number -- The same entity ID that was passed in
]=]
function World:spawnAt(id, ...)
	if self:contains(id) then
		error(
			string.format(
				"The world already contains an entity with ID %d. Use World:replace instead if this is intentional.",
				id
			),
			2
		)
	end

	self._size += 1

	if id >= self._nextId then
		self._nextId = id + 1
	end

	local components = {}
	local metatables = {}

	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		if components[metatable] then
			error(("Duplicate component type at index %d"):format(i), 2)
		end

		self:_trackChanged(metatable, id, nil, newComponent)

		components[metatable] = newComponent
		table.insert(metatables, metatable)
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, components)

	return id
end

function World:_newQueryArchetype(queryArchetype)
	if self._queryCache[queryArchetype] == nil then
		self._queryCache[queryArchetype] = {}
	else
		return -- Archetype isn't actually new
	end

	for _, storage in self._storages do
		for entityArchetype in storage do
			if areArchetypesCompatible(queryArchetype, entityArchetype) then
				self._queryCache[queryArchetype][entityArchetype] = true
			end
		end
	end
end

function World:_updateQueryCache(entityArchetype)
	for queryArchetype, compatibleArchetypes in pairs(self._queryCache) do
		if areArchetypesCompatible(queryArchetype, entityArchetype) then
			compatibleArchetypes[entityArchetype] = true
		end
	end
end

function World:_transitionArchetype(id, components)
	debug.profilebegin("transitionArchetype")
	local newArchetype = nil
	local oldArchetype = self._entityArchetypes[id]
	local oldStorage

	if oldArchetype then
		oldStorage = self:_getStorageWithEntity(oldArchetype, id)

		if not components then
			oldStorage[oldArchetype][id] = nil
		end
	end

	if components then
		newArchetype = archetypeOf(unpack(self._entityMetatablesCache[id]))

		if oldArchetype ~= newArchetype then
			if oldStorage then
				oldStorage[oldArchetype][id] = nil
			end

			if self._pristineStorage[newArchetype] == nil then
				self._pristineStorage[newArchetype] = {}
			end

			if self._entityArchetypeCache[newArchetype] == nil then
				debug.profilebegin("update query cache")
				self._entityArchetypeCache[newArchetype] = true
				self:_updateQueryCache(newArchetype)
				debug.profileend()
			end
			self._pristineStorage[newArchetype][id] = components
		else
			oldStorage[newArchetype][id] = components
		end
	end

	self._entityArchetypes[id] = newArchetype

	debug.profileend()
end

--[=[
	Replaces a given entity by ID with an entirely new set of components.
	Equivalent to removing all components from an entity, and then adding these ones.

	@param id number -- The entity ID
	@param ... ComponentInstance -- The component values to spawn the entity with.
]=]
function World:replace(id, ...)
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local components = {}
	local metatables = {}
	local entity = self:_getEntity(id)

	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		if components[metatable] then
			error(("Duplicate component type at index %d"):format(i), 2)
		end

		self:_trackChanged(metatable, id, entity[metatable], newComponent)

		components[metatable] = newComponent
		table.insert(metatables, metatable)
	end

	for metatable, component in pairs(entity) do
		if not components[metatable] then
			self:_trackChanged(metatable, id, component, nil)
		end
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, components)
end

--[=[
	Despawns a given entity by ID, removing it and all its components from the world entirely.

	@param id number -- The entity ID
]=]
function World:despawn(id)
	local entity = self:_getEntity(id)

	for metatable, component in pairs(entity) do
		self:_trackChanged(metatable, id, component, nil)
	end

	self._entityMetatablesCache[id] = nil
	self:_transitionArchetype(id, nil)

	self._size -= 1
end

--[=[
	Removes all entities from the world.

	:::caution
	Removing entities in this way is not reported by `queryChanged`.
	:::
]=]
function World:clear()
	local firstStorage = {}
	self._storages = { firstStorage }
	self._pristineStorage = firstStorage
	self._entityArchetypes = {}
	self._entityMetatablesCache = {}
	self._size = 0
	self._changedStorage = {}
end

--[=[
	Checks if the given entity ID is currently spawned in this world.

	@param id number -- The entity ID
	@return bool -- `true` if the entity exists
]=]
function World:contains(id)
	return self._entityArchetypes[id] ~= nil
end

--[=[
	Gets a specific component (or set of components) from a specific entity in this world.

	@param id number -- The entity ID
	@param ... Component -- The components to fetch
	@return ... -- Returns the component values in the same order they were passed in
]=]
function World:get(id, ...)
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local entity = self:_getEntity(id)

	local length = select("#", ...)

	if length == 1 then
		assertValidComponent((...), 1)
		return entity[...]
	end

	local components = {}
	for i = 1, length do
		local metatable = select(i, ...)
		assertValidComponent(metatable, i)
		components[i] = entity[metatable]
	end

	return unpack(components, 1, length)
end

local function noop() end

local noopQuery = setmetatable({
	next = noop,
	snapshot = noop,
	without = function(self)
		return self
	end,
	view = {
		get = noop,
		contains = noop,
	},
}, {
	__iter = function()
		return noop
	end,
})

--[=[
	@class QueryResult

	A result from the [`World:query`](/api/World#query) function.

	Calling the table or the `next` method allows iteration over the results. Once all results have been returned, the
	QueryResult is exhausted and is no longer useful.

	```lua
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end
	```
]=]

local QueryResult = {}
QueryResult.__index = QueryResult

function QueryResult.new(world, expand, queryArchetype, compatibleArchetypes)
	return setmetatable({
		world = world,
		seenEntities = {},
		currentCompatibleArchetype = next(compatibleArchetypes),
		compatibleArchetypes = compatibleArchetypes,
		storageIndex = 1,
		_expand = expand,
		_queryArchetype = queryArchetype,
	}, QueryResult)
end

local function nextItem(query)
	local world = query.world
	local currentCompatibleArchetype = query.currentCompatibleArchetype
	local seenEntities = query.seenEntities
	local compatibleArchetypes = query.compatibleArchetypes

	local entityId, entityData

	local storages = world._storages
	repeat
		local nextStorage = storages[query.storageIndex]
		local currently = nextStorage[currentCompatibleArchetype]
		if currently then
			entityId, entityData = next(currently, query.lastEntityId)
		end

		while entityId == nil do
			currentCompatibleArchetype = next(compatibleArchetypes, currentCompatibleArchetype)

			if currentCompatibleArchetype == nil then
				query.storageIndex += 1

				nextStorage = storages[query.storageIndex]

				if nextStorage == nil or next(nextStorage) == nil then
					return
				end

				currentCompatibleArchetype = nil

				if world._pristineStorage == nextStorage then
					world:_markStorageDirty()
				end

				continue
			elseif nextStorage[currentCompatibleArchetype] == nil then
				continue
			end

			entityId, entityData = next(nextStorage[currentCompatibleArchetype])
		end

		query.lastEntityId = entityId

	until seenEntities[entityId] == nil

	query.currentCompatibleArchetype = currentCompatibleArchetype

	seenEntities[entityId] = true

	return entityId, entityData
end

function QueryResult:__iter()
	return function()
		return self._expand(nextItem(self))
	end
end

function QueryResult:__call()
	return self._expand(nextItem(self))
end

--[=[
	Returns the next set of values from the query result. Once all results have been returned, the
	QueryResult is exhausted and is no longer useful.

	:::info
	This function is equivalent to calling the QueryResult as a function. When used in a for loop, this is implicitly
	done by the language itself.
	:::

	```lua
	-- Using world:query in this position will make Lua invoke the table as a function. This is conventional.
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end
	```

	If you wanted to iterate over the QueryResult without a for loop, it's recommended that you call `next` directly
	instead of calling the QueryResult as a function.
	```lua
	local id, enemy, charge, model = world:query(Enemy, Charge, Model):next()
	local id, enemy, charge, model = world:query(Enemy, Charge, Model)() -- Possible, but unconventional
	```

	@return id -- Entity ID
	@return ...ComponentInstance -- The requested component values
]=]
function QueryResult:next()
	return self._expand(nextItem(self))
end

local snapshot = {
	__iter = function(self): any
		local i = 0
		return function()
			i += 1

			local data = self[i]

			if data then
				return unpack(data, 1, data.n)
			end
			return
		end
	end,
}

--[=[
	Creates a "snapshot" of this query, draining this QueryResult and returning a list containing all of its results.

	By default, iterating over a QueryResult happens in "real time": it iterates over the actual data in the ECS, so
	changes that occur during the iteration will affect future results.

	By contrast, `QueryResult:snapshot()` creates a list of all of the results of this query at the moment it is called,
	so changes made while iterating over the result of `QueryResult:snapshot` do not affect future results of the
	iteration.

	Of course, this comes with a cost: we must allocate a new list and iterate over everything returned from the
	QueryResult in advance, so using this method is slower than iterating over a QueryResult directly.

	The table returned from this method has a custom `__iter` method, which lets you use it as you would use QueryResult
	directly:

	```lua
		for entityId, health, player in world:query(Health, Player):snapshot() do

		end
	```

	However, the table itself is just a list of sub-tables structured like `{entityId, component1, component2, ...etc}`.

	@return {{entityId: number, component: ComponentInstance, component: ComponentInstance, component: ComponentInstance, ...}}
]=]
function QueryResult:snapshot()
	local list = setmetatable({}, snapshot)

	local function iter()
		return nextItem(self)
	end

	for entityId, entityData in iter do
		if entityId then
			table.insert(list, table.pack(self._expand(entityId, entityData)))
		end
	end

	return list
end

--[=[
	Returns an iterator that will skip any entities that also have the given components.

	:::tip
	This is essentially equivalent to querying normally, using `World:get` to check if a component is present,
	and using Lua's `continue` keyword to skip this iteration (though, using `:without` is faster).

	This means that you should avoid queries that return a very large amount of results only to filter them down
	to a few with `:without`. If you can, always prefer adding components and making your query more specific.
	:::

	@param ... Component -- The component types to filter against.
	@return () -> (id, ...ComponentInstance) -- Iterator of entity ID followed by the requested component values

	```lua
	for id in world:query(Target):without(Model) do
		-- Do something
	end
	```
]=]

function QueryResult:without(...)
	local world = self.world
	local filter = negateArchetypeOf(...)

	local negativeArchetype = `{self._queryArchetype}x{filter}`

	if world._queryCache[negativeArchetype] == nil then
		world:_newQueryArchetype(negativeArchetype)
	end

	local compatibleArchetypes = world._queryCache[negativeArchetype]

	self.compatibleArchetypes = compatibleArchetypes
	self.currentCompatibleArchetype = next(compatibleArchetypes)
	return self
end

--[=[
	@class View

	Provides random access to the results of a query.

	Calling the View is equivalent to iterating a query. 

	```lua
	for id, player, health, poison in world:query(Player, Health, Poison):view() do
		-- Do something
	end
	```
]=]

--[=[
	Creates a View of the query and does all of the iterator tasks at once at an amortized cost.
	This is used for many repeated random access to an entity. If you only need to iterate, just use a query.

	```lua
	local inflicting = world:query(Damage, Hitting, Player):view()
	for _, source in world:query(DamagedBy) do
		local damage = inflicting:get(source.from)
	end

	for _ in world:query(Damage):view() do end -- You can still iterate views if you want!
	```
	
	@return View See [View](/api/View) docs.
]=]

function QueryResult:view()
	local function iter()
		return nextItem(self)
	end

	local fetches = {}
	local list = {} :: any

	local View = {}
	View.__index = View

	function View:__iter()
		local current = list.head
		return function()
			if not current then
				return
			end
			local entity = current.entity
			local fetch = fetches[entity]
			current = current.next

			return entity, unpack(fetch, 1, fetch.n)
		end
	end

	--[=[
		@within View
			Retrieve the query results to corresponding `entity`
		@param entity number - the entity ID
		@return ...ComponentInstance
	]=]
	function View:get(entity)
		if not self:contains(entity) then
			return
		end

		local fetch = fetches[entity]
		local queryLength = fetch.n

		if queryLength == 1 then
			return fetch[1]
		elseif queryLength == 2 then
			return fetch[1], fetch[2]
		elseif queryLength == 3 then
			return fetch[1], fetch[2], fetch[3]
		elseif queryLength == 4 then
			return fetch[1], fetch[2], fetch[3], fetch[4]
		elseif queryLength == 5 then
			return fetch[1], fetch[2], fetch[3], fetch[4], fetch[5]
		end

		return unpack(fetch, 1, fetch.n)
	end

	--[=[
		@within View
		Equivalent to `world:contains()`	
		@param entity number - the entity ID
		@return boolean 
	]=]

	function View:contains(entity)
		return fetches[entity] ~= nil
	end

	for entityId, entityData in iter do
		if entityId then
			-- We start at 2 on Select since we don't need want to pack the entity id.
			local fetch = table.pack(select(2, self._expand(entityId, entityData)))
			local node = { entity = entityId, next = nil }

			fetches[entityId] = fetch

			if not list.head then
				list.head = node
			else
				local current = list.head
				while current.next do
					current = current.next
				end
				current.next = node
			end
		end
	end

	return setmetatable({}, View)
end

--[=[
	Performs a query against the entities in this World. Returns a [QueryResult](/api/QueryResult), which iterates over
	the results of the query.

	Order of iteration is not guaranteed.

	```lua
	for id, enemy, charge, model in world:query(Enemy, Charge, Model) do
		-- Do something
	end

	for id in world:query(Target):without(Model) do
		-- Again, with feeling
	end
	```

	@param ... Component -- The component types to query. Only entities with *all* of these components will be returned.
	@return QueryResult -- See [QueryResult](/api/QueryResult) docs.
]=]

function World:query(...)
	debug.profilebegin("World:query")
	assertValidComponent((...), 1)

	local metatables = { ... }
	local queryLength = select("#", ...)

	local archetype = archetypeOf(...)

	if self._queryCache[archetype] == nil then
		self:_newQueryArchetype(archetype)
	end

	local compatibleArchetypes = self._queryCache[archetype]

	debug.profileend()

	if next(compatibleArchetypes) == nil then
		-- If there are no compatible storages avoid creating our complicated iterator
		return noopQuery
	end

	local queryOutput = table.create(queryLength)

	local function expand(entityId, entityData)
		if not entityId then
			return
		end

		if queryLength == 1 then
			return entityId, entityData[metatables[1]]
		elseif queryLength == 2 then
			return entityId, entityData[metatables[1]], entityData[metatables[2]]
		elseif queryLength == 3 then
			return entityId, entityData[metatables[1]], entityData[metatables[2]], entityData[metatables[3]]
		elseif queryLength == 4 then
			return entityId,
				entityData[metatables[1]],
				entityData[metatables[2]],
				entityData[metatables[3]],
				entityData[metatables[4]]
		elseif queryLength == 5 then
			return entityId,
				entityData[metatables[1]],
				entityData[metatables[2]],
				entityData[metatables[3]],
				entityData[metatables[4]],
				entityData[metatables[5]]
		end

		for i, metatable in ipairs(metatables) do
			queryOutput[i] = entityData[metatable]
		end

		return entityId, unpack(queryOutput, 1, queryLength)
	end

	if self._pristineStorage == self._storages[1] then
		self:_markStorageDirty()
	end

	return QueryResult.new(self, expand, archetype, compatibleArchetypes)
end

local function cleanupQueryChanged(hookState)
	local world = hookState.world
	local componentToTrack = hookState.componentToTrack

	for index, object in world._changedStorage[componentToTrack] do
		if object == hookState.storage then
			table.remove(world._changedStorage[componentToTrack], index)
			break
		end
	end

	if next(world._changedStorage[componentToTrack]) == nil then
		world._changedStorage[componentToTrack] = nil
	end
end

--[=[
	@interface ChangeRecord
	@within World
	.new? ComponentInstance -- The new value of the component. Nil if just removed.
	.old? ComponentInstance -- The former value of the component. Nil if just added.
]=]

--[=[
	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Queries for components that have changed **since the last time your system ran `queryChanged`**.

	Only one changed record is returned per entity, even if the same entity changed multiple times. The order
	in which changed records are returned is not guaranteed to be the order that the changes occurred in.

	It should be noted that `queryChanged` does not have the same iterator invalidation concerns as `World:query`.

	:::tip
	The first time your system runs (i.e., on the first frame), all existing entities in the world that match your query
	are returned as "new" change records.
	:::

	:::info
	Calling this function from your system creates storage internally for your system. Then, changes meeting your
	criteria are pushed into your storage. Calling `queryChanged` again each frame drains this storage.

	If your system isn't called every frame, the storage will continually fill up and does not empty unless you drain
	it.

	If you stop calling `queryChanged` in your system, changes will stop being tracked.
	:::

	### Returns
	`queryChanged` returns an iterator function, so you call it in a for loop just like `World:query`.

	The iterator returns the entity ID, followed by a [`ChangeRecord`](#ChangeRecord).

	The `ChangeRecord` type is a table that contains two fields, `new` and `old`, respectively containing the new
	component instance, and the old component instance. `new` and `old` will never be the same value.

	`new` will be nil if the component was removed (or the entity was despawned), and `old` will be nil if the
	component was just added.

	The `old` field will be the value of the component the last time this system observed it, not
	necessarily the value it changed from most recently.

	The `ChangeRecord` table is potentially shared with multiple systems tracking changes for this component, so it
	cannot be modified.

	```lua
	for id, record in world:queryChanged(Model) do
		if record.new == nil then
			-- Model was removed

			if enemy.type == "this is a made up example" then
				world:remove(id, Enemy)
			end
		end
	end
	```

	@param componentToTrack Component -- The component you want to listen to changes for.
	@return () -> (id, ChangeRecord) -- Iterator of entity ID and change record
]=]
function World:queryChanged(componentToTrack, ...: nil)
	if ... then
		error("World:queryChanged does not take any additional parameters", 2)
	end

	local hookState = topoRuntime.useHookState(componentToTrack, cleanupQueryChanged)

	if hookState.storage then
		return function(): any
			local entityId, record = next(hookState.storage)

			if entityId then
				hookState.storage[entityId] = nil

				return entityId, record
			end
			return
		end
	end

	if not self._changedStorage[componentToTrack] then
		self._changedStorage[componentToTrack] = {}
	end

	local storage = {}
	hookState.storage = storage
	hookState.world = self
	hookState.componentToTrack = componentToTrack

	table.insert(self._changedStorage[componentToTrack], storage)

	local queryResult = self:query(componentToTrack)

	return function(): any
		local entityId, component = queryResult:next()

		if entityId then
			return entityId, table.freeze({ new = component })
		end
		return
	end
end

function World:_trackChanged(metatable, id, old, new)
	if not self._changedStorage[metatable] then
		return
	end

	if old == new then
		return
	end

	local record = table.freeze({
		old = old,
		new = new,
	})

	for _, storage in ipairs(self._changedStorage[metatable]) do
		-- If this entity has changed since the last time this system read it,
		-- we ensure that the "old" value is whatever the system saw it as last, instead of the
		-- "old" value we have here.
		if storage[id] then
			storage[id] = table.freeze({ old = storage[id].old, new = new })
		else
			storage[id] = record
		end
	end
end

--[=[
	Inserts a component (or set of components) into an existing entity.

	If another instance of a given component already exists on this entity, it is replaced.

	```lua
	world:insert(
		entityId,
		ComponentA({
			foo = "bar"
		}),
		ComponentB({
			baz = "qux"
		})
	)
	```

	@param id number -- The entity ID
	@param ... ComponentInstance -- The component values to insert
]=]
function World:insert(id, ...)
	debug.profilebegin("insert")
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local entity = self:_getEntity(id)

	local wasNew = false
	for i = 1, select("#", ...) do
		local newComponent = select(i, ...)

		assertValidComponentInstance(newComponent, i)

		local metatable = getmetatable(newComponent)

		local oldComponent = entity[metatable]

		if not oldComponent then
			wasNew = true

			table.insert(self._entityMetatablesCache[id], metatable)
		end

		self:_trackChanged(metatable, id, oldComponent, newComponent)

		entity[metatable] = newComponent
	end

	if wasNew then -- wasNew
		self:_transitionArchetype(id, entity)
	end

	debug.profileend()
end

--[=[
	Removes a component (or set of components) from an existing entity.

	```lua
	local removedA, removedB = world:remove(entityId, ComponentA, ComponentB)
	```

	@param id number -- The entity ID
	@param ... Component -- The components to remove
	@return ...ComponentInstance -- Returns the component instance values that were removed in the order they were passed.
]=]
function World:remove(id, ...)
	if not self:contains(id) then
		error(ERROR_NO_ENTITY, 2)
	end

	local entity = self:_getEntity(id)

	local length = select("#", ...)
	local removed = {}

	for i = 1, length do
		local metatable = select(i, ...)

		assertValidComponent(metatable, i)

		local oldComponent = entity[metatable]

		removed[i] = oldComponent

		self:_trackChanged(metatable, id, oldComponent, nil)

		entity[metatable] = nil
	end

	-- Rebuild entity metatable cache
	local metatables = {}

	for metatable in pairs(entity) do
		table.insert(metatables, metatable)
	end

	self._entityMetatablesCache[id] = metatables

	self:_transitionArchetype(id, entity)

	return unpack(removed, 1, length)
end

--[=[
	Returns the number of entities currently spawned in the world.
]=]
function World:size()
	return self._size
end

--[=[
	:::tip
	[Loop] automatically calls this function on your World(s), so there is no need to call it yourself if you're using
	a Loop.
	:::

	If you are not using a Loop, you should call this function at a regular interval (i.e., once per frame) to optimize
	the internal storage for queries.

	This is part of a strategy to eliminate iterator invalidation when modifying the World while inside a query from
	[World:query]. While inside a query, any changes to the World are stored in a separate location from the rest of
	the World. Calling this function combines the separate storage back into the main storage, which speeds things up
	again.
]=]
function World:optimizeQueries()
	if #self._storages == 1 then
		return
	end

	local firstStorage = self._storages[1]

	for i = 2, #self._storages do
		local storage = self._storages[i]

		for archetype, entities in storage do
			if firstStorage[archetype] == nil then
				firstStorage[archetype] = entities
			else
				for entityId, entityData in entities do
					if firstStorage[archetype][entityId] then
						error("Entity ID already exists in first storage...")
					end
					firstStorage[archetype][entityId] = entityData
				end
			end
		end
	end

	table.clear(self._storages)

	self._storages[1] = firstStorage
	self._pristineStorage = firstStorage
end

return World
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000401</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEE4FD0BB12614187A44671E1CA3F9C96">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">archetype</string>
									<string name="ScriptGuid">{9B03BBD2-9C30-4D83-9E93-9CAFB1775553}</string>
									<ProtectedString name="Source"><![CDATA[local toSet = require(script.Parent.immutable).toSet

local valueIds = {}
local nextValueId = 0
local compatibilityCache = {}
local archetypeCache = {}

local function getValueId(value)
	local valueId = valueIds[value]
	if valueId == nil then
		valueIds[value] = nextValueId
		valueId = nextValueId
		nextValueId += 1
	end

	return valueId
end

function archetypeOf(...)
	debug.profilebegin("archetypeOf")

	local length = select("#", ...)

	local currentNode = archetypeCache

	for i = 1, length do
		local nextNode = currentNode[select(i, ...)]

		if not nextNode then
			nextNode = {}
			currentNode[select(i, ...)] = nextNode
		end

		currentNode = nextNode
	end

	if currentNode._archetype then
		debug.profileend()
		return currentNode._archetype
	end

	local list = table.create(length)

	for i = 1, length do
		list[i] = getValueId(select(i, ...))
	end

	table.sort(list)

	local archetype = table.concat(list, "_")

	currentNode._archetype = archetype

	debug.profileend()

	return archetype
end

function negateArchetypeOf(...)
	return string.gsub(archetypeOf(...), "_", "x")
end

function areArchetypesCompatible(queryArchetype, targetArchetype)
	local archetypes = string.split(queryArchetype, "x")
	local baseArchetype = table.remove(archetypes, 1)

	local cachedCompatibility = compatibilityCache[queryArchetype .. "-" .. targetArchetype]
	if cachedCompatibility ~= nil then
		return cachedCompatibility
	end
	debug.profilebegin("areArchetypesCompatible")

	local queryIds = string.split(baseArchetype, "_")
	local targetIds = toSet(string.split(targetArchetype, "_"))
	local excludeIds = toSet(archetypes)

	for _, queryId in ipairs(queryIds) do
		if targetIds[queryId] == nil then
			compatibilityCache[queryArchetype .. "-" .. targetArchetype] = false
			debug.profileend()
			return false
		end
	end

	for excludeId in excludeIds do
		if targetIds[excludeId] then
			compatibilityCache[queryArchetype .. "-" .. targetArchetype] = false
			debug.profileend()
			return false
		end
	end

	compatibilityCache[queryArchetype .. "-" .. targetArchetype] = true

	debug.profileend()
	return true
end

return {
	archetypeOf = archetypeOf,
	negateArchetypeOf = negateArchetypeOf,
	areArchetypesCompatible = areArchetypesCompatible,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000402</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3F61DA5BDDEF4257AF3CB8A4DBC58234">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">component</string>
									<string name="ScriptGuid">{1C5F56BE-256E-499B-AB99-4589207C4DA6}</string>
									<ProtectedString name="Source"><![CDATA[local merge = require(script.Parent.immutable).merge

--[=[
	@class Component

	A component is a named piece of data that exists on an entity.
	Components are created and removed in the [World](/api/World).

	In the docs, the terms "Component" and "ComponentInstance" are used:
	- **"Component"** refers to the base class of a specific type of component you've created.
		This is what [`Matter.component`](/api/Matter#component) returns.
	- **"Component Instance"** refers to an actual piece of data that can exist on an entity.
		The metatable of a component instance table is its respective Component table.

	Component instances are *plain-old data*: they do not contain behaviors or methods.

	Since component instances are immutable, one helper function exists on all component instances, `patch`,
	which allows reusing data from an existing component instance to make up for the ergonomic loss of mutations.
]=]

--[=[
	@within Component
	@type ComponentInstance {}

	The `ComponentInstance` type refers to an actual piece of data that can exist on an entity.
	The metatable of the component instance table is set to its particular Component table.

	A component instance can be created by calling the Component table:

	```lua
	-- Component:
	local MyComponent = Matter.component("My component")

	-- component instance:
	local myComponentInstance = MyComponent({
		some = "data"
	})

	print(getmetatable(myComponentInstance) == MyComponent) --> true
	```
]=]

-- This is a special value we set inside the component's metatable that will allow us to detect when
-- a Component is accidentally inserted as a Component Instance.
-- It should not be accessible through indexing into a component instance directly.
local DIAGNOSTIC_COMPONENT_MARKER = {}

local function newComponent(name, defaultData)
	name = name or debug.info(2, "s") .. "@" .. debug.info(2, "l")

	assert(
		defaultData == nil or type(defaultData) == "table",
		"if component default data is specified, it must be a table"
	)

	local component = {}
	component.__index = component

	function component.new(data)
		data = data or {}

		if defaultData then
			data = merge(defaultData, data)
		end

		return table.freeze(setmetatable(data, component))
	end

	--[=[
	@within Component

	```lua
	for id, target in world:query(Target) do
		if shouldChangeTarget(target) then
			world:insert(id, target:patch({ -- modify the existing component
				currentTarget = getNewTarget()
			}))
		end
	end
	```

	A utility function used to immutably modify an existing component instance. Key/value pairs from the passed table
	will override those of the existing component instance.

	As all components are immutable and frozen, it is not possible to modify the existing component directly.

	You can use the `Matter.None` constant to remove a value from the component instance:

	```lua
	target:patch({
		currentTarget = Matter.None -- sets currentTarget to nil
	})
	```

	@param partialNewData {} -- The table to be merged with the existing component data.
	@return ComponentInstance -- A copy of the component instance with values from `partialNewData` overriding existing values.
	]=]
	function component:patch(partialNewData)
		debug.profilebegin("patch")
		local patch = getmetatable(self).new(merge(self, partialNewData))
		debug.profileend()
		return patch
	end

	setmetatable(component, {
		__call = function(_, ...)
			return component.new(...)
		end,
		__tostring = function()
			return name
		end,
		[DIAGNOSTIC_COMPONENT_MARKER] = true,
	})

	return component
end

local function assertValidType(value, position)
	if typeof(value) ~= "table" then
		error(string.format("Component #%d is invalid: not a table", position), 3)
	end

	local metatable = getmetatable(value)

	if metatable == nil then
		error(string.format("Component #%d is invalid: has no metatable", position), 3)
	end
end

local function assertValidComponent(value, position)
	assertValidType(value, position)

	local metatable = getmetatable(value)

	if getmetatable(metatable) ~= nil and getmetatable(metatable)[DIAGNOSTIC_COMPONENT_MARKER] then
		error(
			string.format(
				"Component #%d is invalid: Component Instance %s was passed instead of the Component itself!",
				position,
				tostring(metatable)
			),
			3
		)
	end
end

local function assertValidComponentInstance(value, position)
	assertValidType(value, position)

	if getmetatable(value)[DIAGNOSTIC_COMPONENT_MARKER] ~= nil then
		error(
			string.format(
				"Component #%d is invalid: passed a Component instead of a Component instance; "
					.. "did you forget to call it as a function?",
				position
			),
			3
		)
	end
end

return {
	newComponent = newComponent,
	assertValidComponentInstance = assertValidComponentInstance,
	assertValidComponent = assertValidComponent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000403</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXD3C5716B4EC4425D94CFD8D50BC3B5CE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">debugger</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000404</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXEA0655A1254C48F2AE784C92DF895C62">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">EventBridge</string>
										<string name="ScriptGuid">{FFA05FFF-4CAE-4F62-95E9-1C8C508FB48C}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local EventBridge = {}
EventBridge.__index = EventBridge

local debouncedEvents = {
	InputChanged = true,
}

local debounce = {}

local function serialize(...)
	local first = ...

	if first and typeof(first) == "Instance" and first:IsA("InputObject") then
		return {
			Delta = first.Delta,
			KeyCode = first.KeyCode,
			Position = first.Position,
			UserInputState = first.UserInputState,
			UserInputType = first.UserInputType,
		}
	end

	return ...
end

local clientConnections = {}
EventBridge.clientActions = {
	connect = function(fire, instance, event)
		local instanceFromServer = instance

		if type(instance) == "string" then
			instance = game:GetService(instance)
		end

		if clientConnections[instance] == nil then
			clientConnections[instance] = {}
		end

		clientConnections[instance][event] = instance[event]:Connect(function(...)
			if debouncedEvents[event] and not RunService:IsStudio() then
				local args = table.pack(serialize(...))

				if debounce[instance] and debounce[instance][event] then
					debounce[instance][event] = args
				else
					if debounce[instance] == nil then
						debounce[instance] = {}
					end

					debounce[instance][event] = args

					task.delay(0.25, function()
						local args = debounce[instance][event]

						fire("event", instanceFromServer, event, unpack(args, 1, args.n))

						debounce[instance][event] = nil

						if next(debounce[instance]) == nil then
							debounce[instance] = nil
						end
					end)
				end

				return
			end

			fire("event", instanceFromServer, event, serialize(...))
		end)
	end,

	disconnect = function(_fire, instance, event)
		if type(instance) == "string" then
			instance = game:GetService(instance)
		end

		if clientConnections[instance] and clientConnections[instance][event] then
			clientConnections[instance][event]:Disconnect()
			clientConnections[instance][event] = nil
		end
	end,
}

function EventBridge.new(fire)
	return setmetatable({
		_fire = fire,
		_storage = {},
		players = {},
	}, EventBridge)
end

function EventBridge:connect(instance, event, handler)
	if RunService:IsClient() then
		return instance[event]:Connect(handler)
	end

	if not game:IsAncestorOf(instance) then
		local connection

		connection = instance.AncestryChanged:Connect(function()
			if connection == nil then
				return
			end

			if game:IsAncestorOf(instance) then
				connection:Disconnect()
				connection = nil
				self:connect(instance, event, handler)
			end
		end)

		return
	end

	if self._storage[instance] == nil then
		self._storage[instance] = {}

		instance.Destroying:Connect(function()
			for event in self._storage[instance] do
				self:_disconnect(instance, event)
			end
		end)
	end

	self._storage[instance][event] = handler

	for _, player in self.players do
		self:_connectPlayerEvent(player, instance, event)
	end

	return {
		Disconnect = function()
			self:_disconnect(instance, event)
		end,
	}
end

function EventBridge:_connectPlayerEvent(player, instance, event)
	if instance.Parent == game then
		instance = instance.ClassName
	end

	self._fire(player, "connect", instance, event)
end

function EventBridge:_disconnectPlayerEvent(player, instance, event)
	if instance.Parent == game then
		instance = instance.ClassName
	end

	self._fire(player, "disconnect", instance, event)
end

function EventBridge:connectPlayer(player)
	for instance, events in self._storage do
		for event in events do
			self:_connectPlayerEvent(player, instance, event)
		end
	end

	table.insert(self.players, player)
end

function EventBridge:disconnectPlayer(player)
	local index = table.find(self.players, player)

	if not index then
		return
	end

	table.remove(self.players, index)

	for instance, events in self._storage do
		for event in events do
			self:_disconnectPlayerEvent(player, instance, event)
		end
	end
end

function EventBridge:_disconnect(instance, event)
	self._storage[instance][event] = nil

	for _, player in self.players do
		self:_disconnectPlayerEvent(player, instance, event)
	end
end

function EventBridge:fireEventFromPlayer(player, instance, event, ...)
	if not table.find(self.players, player) then
		warn(player, "fired a debugger event but they aren't authorized")
		return
	end

	if type(instance) == "string" then
		instance = game:GetService(instance)
	end

	if not self._storage[instance] or not self._storage[instance][event] then
		-- warn(player, "fired a debugger event but the instance has no connections")
		return
	end

	self._storage[instance][event](...)
end

return EventBridge
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000405</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCD08148CEFEB447DAA84A676996CB3C1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">clientBindings</string>
										<string name="ScriptGuid">{63859436-1708-4EBA-B727-6B647905B407}</string>
										<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")
local CollectionService = game:GetService("CollectionService")
local function clientBindings(debugger)
	local connections = {}

	table.insert(
		connections,
		CollectionService:GetInstanceAddedSignal("MatterDebuggerSwitchToClientView"):Connect(function(instance)
			instance.Activated:Connect(function()
				debugger:switchToClientView()
			end)
		end)
	)

	table.insert(
		connections,
		UserInputService.InputChanged:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.MouseMovement then
				return
			end

			local mousePosition = UserInputService:GetMouseLocation()

			for _, gui in CollectionService:GetTagged("MatterDebuggerTooltip") do
				gui.Position = UDim2.new(0, mousePosition.X + 20, 0, mousePosition.Y)
			end
		end)
	)

	table.insert(
		connections,
		CollectionService:GetInstanceAddedSignal("MatterDebuggerTooltip"):Connect(function(gui)
			local mousePosition = UserInputService:GetMouseLocation()

			gui.Position = UDim2.new(0, mousePosition.X + 20, 0, mousePosition.Y)
		end)
	)

	return connections
end

return clientBindings
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000406</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXFB238F30A1454445A32BA32CCFE10B3D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">debugger</string>
										<string name="ScriptGuid">{595D5DEB-DABA-4EB5-932F-B1653D155A60}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local hookWidgets = require(script.Parent.hookWidgets)
local World = require(script.Parent.Parent.World)
local EventBridge = require(script.Parent.EventBridge)
local ui = require(script.Parent.ui)
local mouseHighlight = require(script.Parent.mouseHighlight)
local clientBindings = require(script.Parent.clientBindings)
local hookWorld = require(script.Parent.hookWorld)

local customWidgetConstructors: { [string]: any } = {
	panel = require(script.Parent.widgets.panel),
	selectionList = require(script.Parent.widgets.selectionList),
	container = require(script.Parent.widgets.container),
	frame = require(script.Parent.widgets.frame),
	link = require(script.Parent.widgets.link),
	realmSwitch = require(script.Parent.widgets.realmSwitch),
	valueInspect = require(script.Parent.widgets.valueInspect),
	worldInspect = require(script.Parent.widgets.worldInspect),
	entityInspect = require(script.Parent.widgets.entityInspect),
	tooltip = require(script.Parent.widgets.tooltip),
	hoverInspect = require(script.Parent.widgets.hoverInspect),
	queryInspect = require(script.Parent.widgets.queryInspect),
	codeText = require(script.Parent.widgets.codeText),
	errorInspect = require(script.Parent.widgets.errorInspect),
}

local IS_SERVER = RunService:IsServer()
local IS_CLIENT = RunService:IsClient()

local remoteEvent, clientBindingConnections

-- Assert plasma is compatible via feature detection
local function assertCompatiblePlasma(plasma)
	if not plasma.highlight then
		error("Plasma passed to Matter debugger is out of date, please update it to use the debugger.")
	end
end

--[=[
	@class Debugger

	Attaches a Debugger to the Matter instance, allowing you to create debug widgets in your systems.

	```lua
	local debugger = Matter.Debugger.new(Plasma)

	local widgets = debugger:getWidgets()
	local loop = Matter.Loop.new(world, widgets) -- pass the widgets to your systems

	debugger:autoInitialize(loop)

	if IS_CLIENT then
		debugger:show()
	end
	```

	When the debugger is not open, the widgets do not render.
]=]
local Debugger = {}
Debugger.__index = Debugger

--[=[
	@prop authorize (player: Player) -> boolean
	@within Debugger

	Create this property in Debugger to specify a function that will be called to determine if a player should be
	allowed to connect to the server-side debugger. In Studio, this property is ignored.

	If not specified, the default behavior is to allow anyone in Studio and disallow everyone in a live game.

	```lua
	debugger.authorize = function(player)
		if player:GetRankInGroup(372) > 250 then -- etc
			return true
		end
	end
	```
]=]

--[=[
	@prop findInstanceFromEntity (entityId: number) -> Instance?
	@within Debugger

	Create this property in Debugger to specify a function that will be called to determine what Instance is associated
	with an entity. This is used for the in-world highlight in the World inspector.

	If not specified, the in-world highlight will not work.

	```lua
	debugger.findInstanceFromEntity = function(id)
		if not world:contains(id) then
			return
		end

		local model = world:get(id, components.Model)

		return model and model.model or nil
	end
	```
]=]

--[=[
	@prop componentRefreshFrequency number
	@within Debugger

	Create this property in Debugger to specify the frequency (in seconds) that the unique component list will refresh.

	If not specified, it will use a default time of 3 seconds.

	```lua
	debugger.componentRefreshFrequency = 1
	```
]=]

--[=[
	@prop loopParameterNames {string}
	@within Debugger

	Create this property in Debugger to specify the names of the parameters to your Loop constructor. This is used to
	display a more accurate name in the debugger.

	If not specified, the default behavior is to label Worlds as "World" and tables as "table", followed by its index.

	```lua
	debugger.loopParameterNames = {"World", "State", "Widgets"}
	```
]=]

--[=[
	Creates a new Debugger.

	You need to depend on [Plasma](https://matter-ecs.github.io/plasma/) in your project and pass a handle to it here.

	@param plasma Plasma -- The instance of Plasma used in your game.
	@return Debugger
]=]
function Debugger.new(plasma)
	assertCompatiblePlasma(plasma)

	if not remoteEvent then
		if IS_SERVER then
			remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = "MatterDebuggerRemote"
			remoteEvent.Parent = ReplicatedStorage
		else
			remoteEvent = ReplicatedStorage:WaitForChild("MatterDebuggerRemote")

			remoteEvent.OnClientEvent:Connect(function(action, ...)
				if not EventBridge.clientActions[action] then
					return
				end

				EventBridge.clientActions[action](function(...)
					remoteEvent:FireServer(...)
				end, ...)
			end)
		end
	end

	local self = setmetatable({
		plasma = plasma,
		loop = nil,
		loopParameterNames = {},
		enabled = false,
		componentRefreshFrequency = 3,
		_windowCount = 0,
		_queries = {},
		_seenEvents = {},
		_eventOrder = {},
		_eventBridge = EventBridge.new(function(...)
			remoteEvent:FireClient(...)
		end),
		_playersUsingDebugger = {},
		_customWidgets = {},
	}, Debugger)

	for name, create in customWidgetConstructors do
		self._customWidgets[name] = create(plasma)
	end

	if IS_SERVER then
		self:_connectRemoteEvent()
	else
		if not clientBindingConnections then
			clientBindingConnections = clientBindings(self)
		end
	end

	return self
end

function Debugger:_connectRemoteEvent()
	remoteEvent.OnServerEvent:Connect(function(player, action, instance, event, ...)
		if action == "event" then
			self._eventBridge:fireEventFromPlayer(player, instance, event, ...)
		elseif action == "start" then
			if not RunService:IsStudio() then
				if self.authorize then
					if not self.authorize(player) then
						return
					end
				else
					warn("Player attempted to connect to matter debugger but no authorize function is configured.")
					return
				end
			end
			self:connectPlayer(player)
		elseif action == "stop" then
			self:disconnectPlayer(player)
		elseif action == "inspect" then
			self.debugEntity = instance
		elseif action == "hover" then
			self.hoverEntity = instance
		end
	end)
end

--[=[
	@client

	Shows the debugger panel
]=]
function Debugger:show()
	if not IS_CLIENT then
		error("show can only be called from the client")
	end

	self:_enable()
end

--[=[
	@client

	Hides the debugger panel
]=]
function Debugger:hide()
	if not IS_CLIENT then
		error("hide can only be called from the client")
	end

	self:_disable()

	if self:_isServerView() then
		self:switchToClientView()
	end
end

--[=[
	@client

	Toggles visibility of the debugger panel
]=]
function Debugger:toggle()
	if not IS_CLIENT then
		error("toggle can only be called from the client")
	end

	if self.enabled then
		self:_disable()
	else
		self:_enable()
	end
end

function Debugger:_enable()
	if self.enabled then
		return
	end

	-- TODO: Find a better way for the user to specify the world.
	if not self.debugWorld then
		for _, object in self.loop._state do
			if getmetatable(object) == World then
				self.debugWorld = object
				break
			end
		end
	end

	self.enabled = true
	self.loop.profiling = self.loop.profiling or {}

	hookWorld.hookWorld(self)
end

function Debugger:_disable()
	self.enabled = false
	self.debugSystem = nil
	self.loop.profiling = nil
	hookWorld.unhookWorld()

	if self.plasmaNode then
		self.plasma.start(self.plasmaNode, function() end)
	end
end

function Debugger:connectPlayer(player)
	if not IS_SERVER then
		error("connectClient can only be called from the server")
	end

	if not self.enabled then
		print("Matter server debugger started")
		self:_enable()
	end

	self._eventBridge:connectPlayer(player)
	self._playersUsingDebugger[player] = true
end

function Debugger:disconnectPlayer(player)
	if not IS_SERVER then
		error("disconnectClient can only be called from the server")
	end

	self._eventBridge:disconnectPlayer(player)
	self._playersUsingDebugger[player] = nil

	if #self._eventBridge.players == 0 then
		self:_disable()
		self.debugSystem = nil
		print("Matter server debugger stopped")
	end
end

--[=[
	Adds middleware to your Loop to set up the debugger every frame.

	:::tip
	The debugger must also be shown on a client with [Debugger:show] or [Debugger:toggle] to be used.
	:::

	:::caution
	[Debugger:autoInitialize] should be called before [Loop:begin] to function as expected.
	:::

	If you also want to use Plasma for more than just the debugger, you can opt to not call this function and instead
	do what it does yourself.

	@param loop Loop
]=]
function Debugger:autoInitialize(loop)
	self.loop = loop

	self.loop.trackErrors = true

	local parent = Instance.new("ScreenGui")
	parent.Name = "MatterDebugger"
	parent.DisplayOrder = 2 ^ 31 - 1
	parent.ResetOnSpawn = false
	parent.IgnoreGuiInset = true
	parent.AutoLocalize = false

	if IS_CLIENT then
		parent.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	else
		parent.Parent = ReplicatedStorage
	end

	local plasmaNode = self.plasma.new(parent)
	self.plasmaNode = plasmaNode

	self.loop:addMiddleware(function(nextFn, eventName)
		return function()
			if not self._seenEvents[eventName] then
				self._seenEvents[eventName] = true
				table.insert(self._eventOrder, eventName)
			end

			if not self.enabled then
				nextFn()
				return
			end

			if eventName == self._eventOrder[1] then
				self._continueHandle = self.plasma.beginFrame(plasmaNode, function()
					self.plasma.setEventCallback(function(...)
						return self._eventBridge:connect(...)
					end)

					self:update()

					nextFn()
				end)
			elseif self._continueHandle then
				self.plasma.continueFrame(self._continueHandle, function()
					self.plasma.setEventCallback(function(...)
						return self._eventBridge:connect(...)
					end)

					nextFn()
				end)
			end

			if eventName == self._eventOrder[#self._eventOrder] then
				self.plasma.finishFrame(plasmaNode)
			end
		end
	end)

	if IS_CLIENT then
		self.plasma.hydrateAutomaticSize()
	end
end

--[=[
	Alert the debugger when a system is hot reloaded.

	@param old System
	@param new System
]=]
function Debugger:replaceSystem(old, new)
	if self.debugSystem == old then
		self.debugSystem = new
	end
end

--[=[
	@client

	Switch the client to server view. This starts the server debugger if it isn't already started.
]=]
function Debugger:switchToServerView()
	if not IS_CLIENT then
		error("switchToServerView may only be called from the client.")
	end

	self.debugSystem = nil

	if not self.serverGui then
		self.serverGui = ReplicatedStorage:WaitForChild("MatterDebugger")

		self.serverGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
	end

	remoteEvent:FireServer("start")

	self.serverGui.Enabled = true
end

--[=[
	Switch the client to client view. This stops the server debugger if there are no other players connected.
]=]
function Debugger:switchToClientView()
	if not IS_CLIENT then
		error("switchToClientView may only be called from the client.")
	end

	if not self.serverGui then
		return
	end

	remoteEvent:FireServer("stop")

	self.serverGui.Enabled = false
end

function Debugger:_isServerView()
	return self.serverGui and self.serverGui.Enabled
end

--[=[
	This should be called to draw the debugger UI.

	This is automatically set up when you call [Debugger:autoInitialize], so you don't need to call this yourself unless
	you didn't call `autoInitialize`.
]=]
function Debugger:update()
	ui(self, self.loop)

	table.clear(self._queries)

	if IS_CLIENT then
		mouseHighlight(self, remoteEvent)
	end
end

--[=[
	Returns a handle to the debug widgets you can pass to your systems.

	All [plasma widgets](https://matter-ecs.github.io/plasma/api/Plasma#widgets) are available under this namespace.

	```lua
	-- ...
	local debugger = Debugger.new(Plasma)

	local loop = Loop.new(world, state, debugger:getWidgets())
	```

	When the Debugger is not open, calls to widgets are no-ops.

	If the widget normally returns a handle (e.g., button returns a table with `clicked`), it returns a static dummy
	handle that always returns a default value:

	- `checkbox`
		- `clicked`: false
		- `checked`: false
	- `button`
		- `clicked`: false
	- `slider`: 0

	@return {[string]: Widget}
]=]
function Debugger:getWidgets()
	return hookWidgets(self)
end

return Debugger
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000407</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX38F531AF917E41B886CD2541D5060AE3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">formatTable</string>
										<string name="ScriptGuid">{4BA30175-294A-4C05-81F5-A82D182832BE}</string>
										<ProtectedString name="Source"><![CDATA[local FormatMode = {
	Short = "Short",
	Long = "Long",
}
local function formatTable(object, mode, _padLength, _depth)
	mode = mode or FormatMode.Short
	_padLength = _padLength or 0
	_depth = _depth or 1

	local max = if mode == FormatMode.Short then 7 else 1000

	local str = ""

	if mode == FormatMode.Short or _depth > 1 then
		str ..= "{"
	end

	local values = {}

	for key, value in pairs(object) do
		table.insert(values, {
			key = key,
			value = value,
		})
	end

	table.sort(values, function(a, b)
		return tostring(a.key) < tostring(b.key)
	end)

	local count = 0
	local size = #values
	for _, entry in values do
		local key = entry.key
		local value = entry.value

		local part = ""

		if count > 0 then
			part ..= ", "
		end

		if mode == FormatMode.Long then
			local spaces = string.rep("  ", _depth - 1)
			part ..= if count == 0 then spaces else "\n" .. spaces
		end

		count += 1
		if type(key) == "string" then
			part ..= key .. (if mode == FormatMode.Short then "=" else " = ")
		elseif type(key) == "table" then
			if mode == FormatMode.Short then
				part ..= "[{..}]="
			else
				part ..= "["
				part ..= formatTable(key, FormatMode.Short, #str + #part + _padLength, _depth + 1)
				part ..= "] = "
			end
		end

		if type(value) == "string" then
			part ..= '"' .. value:sub(1, max) .. '"'
		elseif type(value) == "table" then
			if mode == FormatMode.Short then
				part ..= "{..}"
			else
				part ..= formatTable(value, FormatMode.Long, #str + #part + _padLength, _depth + 1)
			end
		elseif mode == FormatMode.Long and (type(value) == "userdata" or type(value) == "vector") then
			if typeof(value) == "CFrame" then
				local x, y, z = value:components()
				part ..= string.format("CFrame(%.1f, %.1f, %.1f, ..)", x, y, z)
			else
				part ..= typeof(value) .. "(" .. tostring(value) .. ")"
			end
		else
			part ..= tostring(value):sub(1, max)
		end

		if mode == FormatMode.Short and #str + #part + _padLength > 30 then
			if count > 1 then
				str ..= ", "
			end

			str ..= ".."

			break
		else
			str ..= part
		end

		if mode == FormatMode.Short and #part + _padLength > 30 then
			part ..= ", .."
			break
		end
	end

	if mode == FormatMode.Long then
		local spaces = string.rep("  ", _depth - 1)
		str ..= if count == size then spaces else "\n" .. spaces
	end

	if mode == FormatMode.Short or _depth > 1 then
		str ..= "}"
	end

	return str
end

return {
	formatTable = formatTable,
	FormatMode = FormatMode,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000408</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1155B341BE0F4C759121CCD208B4D1D6">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">hookWidgets</string>
										<string name="ScriptGuid">{09ECCD4E-78DF-41CB-BDFC-402F720E49CE}</string>
										<ProtectedString name="Source"><![CDATA[local useCurrentSystem = require(script.Parent.Parent.topoRuntime).useCurrentSystem

local widgets = {
	"arrow",
	"blur",
	"button",
	"checkbox",
	"error",
	"portal",
	"row",
	"slider",
	"spinner",
	"window",
	"label",
	"heading",
	"space",
	"table",
}

local dummyHandles = {
	checkbox = {
		clicked = function()
			return false
		end,
		checked = function()
			return false
		end,
	},

	button = {
		clicked = function()
			return false
		end,
	},

	slider = function(config)
		if type(config) == "table" then
			config = config.initial
		end
		return config
	end,

	window = {
		closed = function()
			return false
		end,
	},

	table = {
		selected = function() end,
		hovered = function() end,
	},
}

local function hookWidgets(debugger)
	local hookedWidgets = {}

	for _, name in widgets do
		local widget = debugger.plasma[name]

		hookedWidgets[name] = function(...)
			local debugSystem = debugger.debugSystem

			if debugSystem == nil or debugSystem ~= useCurrentSystem() then
				local dummyHandle = dummyHandles[name]
				if type(dummyHandle) == "function" then
					dummyHandle = dummyHandle(...)
				end
				return dummyHandle
			end

			if debugger._windowCount > 0 then
				return widget(...)
			end

			local args = table.pack(...)

			local parent = if name == "window" then debugger.parent else debugger.frame

			local returnValue
			debugger.plasma.portal(parent, function()
				returnValue = widget(unpack(args, 1, args.n))
			end)

			return returnValue
		end
	end

	local window = hookedWidgets.window
	hookedWidgets.window = function(title, fn)
		return window(title, function()
			debugger._windowCount += 1
			fn()
			debugger._windowCount -= 1
		end)
	end

	return hookedWidgets
end

return hookWidgets
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000409</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB39B7A3B2A68476CA7E5C81C42BCF271">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">hookWorld</string>
										<string name="ScriptGuid">{1EEA8B8D-8125-42B4-B979-BCB782FE8400}</string>
										<ProtectedString name="Source"><![CDATA[local useCurrentSystem = require(script.Parent.Parent.topoRuntime).useCurrentSystem
local World = require(script.Parent.Parent.World)

local originalQuery = World.query

local function hookWorld(debugger)
	World.query = function(world, ...)
		if useCurrentSystem() == debugger.debugSystem then
			table.insert(debugger._queries, {
				components = { ... },
				result = originalQuery(world, ...),
			})
		end

		return originalQuery(world, ...)
	end
end

local function unhookWorld()
	World.query = originalQuery
end

return {
	hookWorld = hookWorld,
	unhookWorld = unhookWorld,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000040a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3380DFF6B8254C9089B8F9258B6BF80C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">mouseHighlight</string>
										<string name="ScriptGuid">{FCF09CA1-8AD4-41DD-89E5-FFD818258291}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

function getInstanceOnMouse()
	local camera = workspace.CurrentCamera
	if not camera then
		return
	end

	local mouseLocation = UserInputService:GetMouseLocation()
	local ray = camera:ViewportPointToRay(mouseLocation.X, mouseLocation.Y)

	local result = workspace:Raycast(ray.Origin, ray.Direction * 1000)
	return result and result.Instance
end

local function mouseHighlight(debugger, remoteEvent)
	if not RunService:IsClient() then
		error("Hovering can only be checked on the client")
	end

	local lastSent, setLastSent = debugger.plasma.useState()

	if UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) then
		local instance = getInstanceOnMouse()

		if instance then
			local id
			while instance.Parent do
				id = instance:GetAttribute(debugger:_isServerView() and "serverEntityId" or "clientEntityId")

				if id then
					break
				end

				instance = instance.Parent
			end

			if id then
				if UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) then
					if debugger:_isServerView() then
						remoteEvent:FireServer("inspect", id)
					else
						debugger.debugEntity = id
					end
				else
					debugger.plasma.highlight(instance, {
						fillColor = Color3.fromRGB(218, 62, 62),
					})

					if debugger:_isServerView() then
						if lastSent ~= id then
							setLastSent(id)
							remoteEvent:FireServer("hover", id)
						end
					else
						debugger.hoverEntity = id
					end
				end

				return
			end
		end
	end

	if debugger:_isServerView() then
		if lastSent ~= nil then
			remoteEvent:FireServer("hover", nil)
			setLastSent(nil)
		end
	else
		debugger.hoverEntity = nil
	end
end

return mouseHighlight
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000040b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX097D64FC8BE74377A5126571A1ADC9A3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ui</string>
										<string name="ScriptGuid">{1BF03236-9FD8-443F-9661-3D041E55E729}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local World = require(script.Parent.Parent.World)
local rollingAverage = require(script.Parent.Parent.rollingAverage)

local function systemName(system)
	local systemFn = if type(system) == "table" then system.system else system
	local name = debug.info(systemFn, "n")

	if name ~= "" and name ~= "system" then
		return name
	end

	local source = debug.info(systemFn, "s")
	local segments = string.split(source, ".")

	return segments[#segments]
end

local timeUnits = { "s", "ms", "μs", "ns" }
local function formatDuration(duration)
	local unit = 1
	while duration < 1 and unit < #timeUnits do
		duration *= 1000
		unit += 1
	end

	return duration, timeUnits[unit]
end

local IS_SERVER = RunService:IsServer()
local IS_CLIENT = RunService:IsClient()

local function ui(debugger, loop)
	local plasma = debugger.plasma
	local custom = debugger._customWidgets

	plasma.setStyle({
		primaryColor = Color3.fromHex("bd515c"),
	})

	local objectStack = plasma.useState({})
	local worldViewOpen, setWorldViewOpen = plasma.useState(false)

	if debugger.hoverEntity then
		custom.hoverInspect(debugger.debugWorld, debugger.hoverEntity, custom)
	end

	custom.container(function()
		if debugger:_isServerView() then
			return
		end

		custom.panel(function()
			if
				custom
					.realmSwitch({
						left = "client",
						right = "server",
						isRight = IS_SERVER,
						tag = if IS_SERVER then "MatterDebuggerSwitchToClientView" else nil,
					})
					:clicked()
			then
				if IS_CLIENT then
					debugger:switchToServerView()
				end
			end

			plasma.space(15)
			plasma.heading("STATE")
			plasma.space(10)

			local items = {}

			for index, object in loop._state do
				if type(object) ~= "table" then
					continue
				end

				local isWorld = getmetatable(object) == World

				local selected = (#objectStack > 0 and object == objectStack[#objectStack].value)
					or (debugger.debugWorld == object and worldViewOpen)

				local name = debugger.loopParameterNames[index]
				local defaultName = (if isWorld then "World" else "table") .. " " .. index

				table.insert(items, {
					text = if name then name else defaultName,
					icon = if isWorld then "🌐" else "{}",
					object = object,
					selected = selected,
					isWorld = isWorld,
				})
			end

			local selectedState = custom.selectionList(items):selected()

			if selectedState then
				if selectedState.isWorld then
					if worldViewOpen and debugger.debugWorld == selectedState.object then
						debugger.debugWorld = nil
						setWorldViewOpen(false)
					else
						debugger.debugWorld = selectedState.object
						setWorldViewOpen(true)
					end
				else
					local previousFirstValue = if objectStack[1] then objectStack[1].value else nil
					table.clear(objectStack)

					if selectedState.object ~= previousFirstValue then
						objectStack[1] = {
							key = selectedState.text,
							icon = selectedState.icon,
							value = selectedState.object,
						}
					end
				end
			end

			plasma.space(15)
			plasma.heading("SYSTEMS")
			plasma.space(10)

			local durations = {}
			local longestDuration = 0

			for _, eventName in debugger._eventOrder do
				local systems = loop._orderedSystemsByEvent[eventName]

				if not systems then
					continue
				end

				plasma.heading(eventName, {
					font = Enum.Font.Gotham,
				})
				plasma.space(5)

				local items = {}

				for _, system in systems do
					local samples = loop.profiling[system]
					if samples then
						local duration = rollingAverage.getAverage(samples)

						durations[system] = duration
						longestDuration = math.max(longestDuration, duration)
					end
				end

				for index, system in systems do
					local averageFrameTime = ""
					local icon

					local duration = durations[system] or 0
					local humanDuration, unit = formatDuration(duration)
					averageFrameTime = string.format("%.0f%s", humanDuration, unit)

					if duration > 0.004 then -- 4ms
						icon = "\xe2\x9a\xa0\xef\xb8\x8f"
					end

					if loop._systemErrors[system] then
						icon = "\xf0\x9f\x92\xa5"
					end

					table.insert(items, {
						text = systemName(system),
						sideText = averageFrameTime,
						selected = debugger.debugSystem == system,
						system = system,
						icon = icon,
						barWidth = duration / longestDuration,
						index = index,
					})
				end

				local selected = custom.selectionList(items):selected()

				if selected then
					if selected.system == debugger.debugSystem then
						debugger.debugSystem = nil
					else
						debugger.debugSystem = selected.system
					end
				end

				plasma.space(10)
			end
		end)

		debugger.parent = custom.container(function()
			if debugger.debugWorld and worldViewOpen then
				local closed = custom.worldInspect(debugger, objectStack)

				if closed then
					setWorldViewOpen(false)
				end
			end

			if debugger.debugWorld and debugger.debugEntity then
				custom.entityInspect(debugger)
			end

			if #objectStack > 0 then
				custom.valueInspect(objectStack, custom)
			end

			if debugger.debugSystem then
				local queriesOpen, setQueriesOpen = plasma.useState(false)
				local logsOpen, setLogsOpen = plasma.useState(true)

				if loop._systemLogs[debugger.debugSystem] == nil then
					loop._systemLogs[debugger.debugSystem] = {}
				end

				local numLogs = #loop._systemLogs[debugger.debugSystem]

				local name = systemName(debugger.debugSystem)

				local closed = plasma
					.window({
						title = "System",
						closable = true,
					}, function()
						plasma.useKey(name)

						plasma.row(function()
							if plasma.button(string.format("View queries (%d)", #debugger._queries)):clicked() then
								setQueriesOpen(true)
							end

							if numLogs > 0 then
								if plasma.button(string.format("View logs (%d)", numLogs)):clicked() then
									setLogsOpen(true)
								end
							end
						end)

						local currentlyDisabled = loop._skipSystems[debugger.debugSystem]

						if
							plasma
								.checkbox("Disable system", {
									checked = currentlyDisabled,
								})
								:clicked()
						then
							loop._skipSystems[debugger.debugSystem] = not currentlyDisabled
						end
					end)
					:closed()

				if queriesOpen then
					local closed = custom.queryInspect(debugger)

					if closed then
						setQueriesOpen(false)
					end
				end

				if loop._systemErrors[debugger.debugSystem] then
					custom.errorInspect(debugger, custom)
				end

				plasma.useKey(name)

				if numLogs > 0 and logsOpen then
					local closed = plasma
						.window({
							closable = true,
							title = "Logs",
						}, function()
							local items = {}
							for i = numLogs, 1, -1 do
								table.insert(items, { loop._systemLogs[debugger.debugSystem][i] })
							end
							plasma.table(items, {
								font = Enum.Font.Code,
							})
						end)
						:closed()

					if closed then
						setLogsOpen(false)
					end
				end

				if closed then
					debugger.debugSystem = nil
				end
			end

			plasma.useKey(nil)
			debugger.frame = custom.frame()
		end, {
			marginTop = 46,
			marginLeft = 10,
			direction = Enum.FillDirection.Horizontal,
		})
	end, {
		direction = Enum.FillDirection.Horizontal,
		padding = 0,
	})
end

return ui
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000040c</UniqueId>
									</Properties>
								</Item>
								<Item class="Folder" referent="RBX5202BE19363142CFB36532520BBA0E1E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">widgets</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000040d</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBX46F3575905A84F33AE753678C8AC3AD5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">codeText</string>
											<string name="ScriptGuid">{616E17EF-EED3-47A5-A2CF-BAE53B0B8834}</string>
											<ProtectedString name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(text, options)
		options = options or {}

		local refs = Plasma.useInstance(function(ref)
			return create("TextButton", {
				[ref] = "label",
				BackgroundTransparency = 1,
				Text = "",
				AutomaticSize = Enum.AutomaticSize.Y,
				Font = Enum.Font.Code,
				TextSize = 18,
				TextStrokeTransparency = 0.5,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextWrapped = true,
				TextColor3 = Color3.new(1, 1, 1),
				Size = UDim2.new(0, 800, 0, 0),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 8),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 8),
				}),
			})
		end)

		refs.label.Text = text
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000040e</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXC685DD86C54E41FC8ABC9E2355A4E512">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">container</string>
											<string name="ScriptGuid">{D101D2D3-B948-450D-B9E2-98DF12214FC2}</string>
											<ProtectedString name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(fn, options)
		options = options or {}

		local padding = options.padding or 5

		local refs = Plasma.useInstance(function(ref)
			return create("Frame", {
				[ref] = "frame",
				BackgroundTransparency = 1,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(1, 0, 1, 0),
				AutoLocalize = false,

				create("UIPadding", {
					PaddingTop = UDim.new(0, options.marginTop or 0),
					PaddingLeft = UDim.new(0, options.marginLeft or 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = options.direction or Enum.FillDirection.Vertical,
					Padding = UDim.new(0, padding),
				}),
			})
		end)

		Plasma.scope(fn)

		return refs.frame
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000040f</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXA9C729D2794E4AF3AF2770A347914DA7">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">entityInspect</string>
											<string name="ScriptGuid">{E72F5364-D1E5-490A-B2FE-208D1EE0E2D6}</string>
											<ProtectedString name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable
local FormatMode = formatTableModule.FormatMode

return function(plasma)
	return plasma.widget(function(debugger)
		local style = plasma.useStyle()

		local closed = plasma
			.window({
				title = string.format("Entity %d", debugger.debugEntity),
				closable = true,
			}, function()
				if not debugger.debugWorld:contains(debugger.debugEntity) then
					debugger.debugEntity = nil
					return
				end

				if debugger.findInstanceFromEntity then
					local model = debugger.findInstanceFromEntity(debugger.debugEntity)

					if model then
						plasma.highlight(model, {
							fillColor = style.primaryColor,
						})
					end
				end

				plasma.row(function()
					if plasma.button("despawn"):clicked() then
						debugger.debugWorld:despawn(debugger.debugEntity)
						debugger.debugEntity = nil
					end
				end)

				if not debugger.debugEntity then
					return
				end

				local items = { { "Component", "Data" } }

				for component, data in debugger.debugWorld:_getEntity(debugger.debugEntity) do
					table.insert(items, {
						tostring(component),
						formatTable(data, FormatMode.Long),
					})
				end

				plasma.useKey(debugger.debugEntity)
				plasma.table(items, {
					headings = true,
					font = Enum.Font.Code,
				})
			end)
			:closed()

		if closed then
			debugger.debugEntity = nil
		end
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000410</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX612758D7C31A4495A42E0ED8F1A0B250">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">errorInspect</string>
											<string name="ScriptGuid">{ADCECE70-06A7-4752-BBC7-2C54064CA5A4}</string>
											<ProtectedString name="Source"><![CDATA[return function(plasma)
	return plasma.widget(function(debugger, custom)
		local loop = debugger.loop

		plasma.window("\xf0\x9f\x92\xa5 Errors", function()
			local text, setText = plasma.useState("")

			custom.codeText(text)

			local items = {}
			for index, errorData in loop._systemErrors[debugger.debugSystem] do
				local preview =
					errorData.error:gsub("^(.-):", ""):gsub("^%s?[%w%.]+%.(%w+:)", "%1"):gsub("\n", " "):sub(1, 60)

				items[index] = {
					DateTime.fromUnixTimestamp(errorData.when):ToIsoDate(),
					preview,

					errorData = errorData,
					selected = errorData.error == text,
				}
			end

			plasma.row(function()
				local selected = plasma
					.table(items, {
						selectable = true,
						font = Enum.Font.Code,
					})
					:selected()

				if selected then
					setText(selected.errorData.error)
				end

				if plasma.button("Clear"):clicked() then
					loop._systemErrors[debugger.debugSystem] = nil
				end
			end)
		end)
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000411</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX0AB69629C299470D98D110760F0F58B8">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">frame</string>
											<string name="ScriptGuid">{D992FB31-C10D-4C9F-A112-64C993BBE06D}</string>
											<ProtectedString name="Source"><![CDATA[return function(Plasma)
	return Plasma.widget(function()
		local refs = Plasma.useInstance(function(ref)
			local style = Plasma.useStyle()

			local Frame = Instance.new("Frame")
			Frame.BackgroundColor3 = style.bg2
			Frame.Position = UDim2.new(0.5, 0, 0.5, 0)
			Frame.AnchorPoint = Vector2.new(0.5, 0.5)
			Frame.Size = UDim2.new(0, 50, 0, 40)
			Frame.Visible = false
			Frame.AutoLocalize = false

			local UICorner = Instance.new("UICorner")
			UICorner.Parent = Frame

			local UIPadding = Instance.new("UIPadding")
			UIPadding.PaddingBottom = UDim.new(0, 10)
			UIPadding.PaddingLeft = UDim.new(0, 10)
			UIPadding.PaddingRight = UDim.new(0, 10)
			UIPadding.PaddingTop = UDim.new(0, 10)
			UIPadding.Parent = Frame

			local UIStroke = Instance.new("UIStroke")
			UIStroke.Parent = Frame

			local UIListLayout = Instance.new("UIListLayout")
			UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
			UIListLayout.Parent = Frame

			local numChildren = #Frame:GetChildren()

			Plasma.automaticSize(Frame)

			local function updateVisibility()
				Frame.Visible = #Frame:GetChildren() > numChildren
			end

			Frame.ChildAdded:Connect(updateVisibility)
			Frame.ChildRemoved:Connect(updateVisibility)

			ref.frame = Frame

			return Frame
		end)

		return refs.frame
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000412</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXAD12FA1369114091BDE2D785900A93BE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">hoverInspect</string>
											<string name="ScriptGuid">{EF75F934-00C6-4D73-8448-7A1BBC26DABB}</string>
											<ProtectedString name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable
local FormatMode = formatTableModule.FormatMode

return function(plasma)
	return plasma.widget(function(world, id, custom)
		local entityData = world:_getEntity(id)

		local str = "Entity " .. id .. "\n\n"

		for component, componentData in pairs(entityData) do
			str ..= tostring(component) .. " "

			if next(componentData) == nil then
				str ..= "{ }"
			else
				str ..= (formatTable(componentData, FormatMode.Long, 0, 2) .. "\n")
			end
		end

		custom.tooltip(str)
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000413</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX7862EE0C3E304DDEBDFE3D310922E362">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">link</string>
											<string name="ScriptGuid">{2F312CA5-BC4E-4B2F-95E6-129049F59085}</string>
											<ProtectedString name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(text, options)
		options = options or {}

		local clicked, setClicked = Plasma.useState(false)
		local style = Plasma.useStyle()

		local refs = Plasma.useInstance(function(ref)
			local colorHover = style.textColor

			local darker = colorHover.R * 255 * 0.8 -- 20% darker
			local color = Color3.fromRGB(darker, darker, darker)

			local button = create("TextButton", {
				[ref] = "button",
				BackgroundTransparency = 1,
				Text = "",

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 0),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 0),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					FillDirection = Enum.FillDirection.Horizontal,
				}),

				create("TextLabel", {
					Name = "Icon",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 30, 1, 0),
					Text = options.icon,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextSize = 16,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamBold,
				}),

				create("TextLabel", {
					[ref] = "mainText",
					Name = "MainText",
					BackgroundTransparency = 1,
					Size = UDim2.new(0, 0, 1, 0),
					Text = text,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextColor3 = color,
					TextSize = 14,
				}),

				Activated = function()
					if options.disabled then
						return
					end

					setClicked(true)
				end,

				MouseEnter = function()
					if options.disabled then
						return
					end

					ref.button.MainText.TextColor3 = colorHover
				end,

				MouseLeave = function()
					ref.button.MainText.TextColor3 = color
				end,
			})

			Plasma.automaticSize(button)
			Plasma.automaticSize(ref.mainText, {
				axis = Enum.AutomaticSize.X,
			})

			return button
		end)

		refs.button.MainText.Text = text

		refs.button.Icon.Text = options.icon or ""
		refs.button.Icon.Visible = not not options.icon

		refs.mainText.Font = options.font or Enum.Font.Gotham

		return {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000414</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXE22BA5A4034C4FE5B1E039DBCD2FBBEE">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">panel</string>
											<string name="ScriptGuid">{2C0DE79C-4DA4-42B7-85F9-BF62C3A1DD1C}</string>
											<ProtectedString name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create
	return Plasma.widget(function(children, options)
		options = options or {}

		Plasma.useInstance(function()
			local style = Plasma.useStyle()

			local frame = create("Frame", {
				Name = "Panel",
				BackgroundColor3 = style.bg2,
				Position = UDim2.new(0, 0, 0, 0),
				Size = UDim2.new(0, 260, 1, 0),

				create("Frame", {
					-- Account for GUI inset
					-- GuiService:GetGuiInset returns wrong info on the server :(
					Size = UDim2.new(1, 0, 0, 46),
					BackgroundColor3 = Color3.new(0, 0, 0),
					BackgroundTransparency = 0.5,

					create("ImageLabel", {
						Position = UDim2.new(1, -20, 0.5, 0),
						AnchorPoint = Vector2.new(1, 0.5),
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 120, 0, 26),
						Image = "rbxassetid://10111567777",
					}),
				}),

				create("UIStroke", {}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					HorizontalAlignment = Enum.HorizontalAlignment.Center,
				}),

				create("ScrollingFrame", {
					BackgroundTransparency = 1,
					Name = "Container",
					VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
					BorderSizePixel = 0,
					ScrollBarThickness = 6,
					Size = UDim2.new(1, -40, 0, 0),

					create("UIPadding", {
						PaddingTop = UDim.new(0, 20),
					}),

					create("UIListLayout", {
						SortOrder = Enum.SortOrder.LayoutOrder,
					}),
				}),
			})

			Plasma.automaticSize(frame.Container, {
				axis = Enum.AutomaticSize.Y,
				maxSize = UDim2.new(1, 0, 1, -46),
			})

			return frame, frame.Container
		end)

		Plasma.scope(children)
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000415</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX105B47C4C6A14C769580A15043D50882">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">queryInspect</string>
											<string name="ScriptGuid">{DC38E185-623B-44FE-8D34-8C1CDD9B000E}</string>
											<ProtectedString name="Source"><![CDATA[local format = require(script.Parent.Parent.formatTable)

return function(plasma)
	return plasma.widget(function(debugger)
		return plasma
			.window({
				title = "Queries",
				closable = true,
			}, function()
				if #debugger._queries == 0 then
					return plasma.label("No queries.")
				end

				for i, query in debugger._queries do
					if query.changedComponent then
						plasma.heading(string.format("Query Changed %d", i))

						plasma.label(tostring(query.changedComponent))

						continue
					end

					plasma.heading(string.format("Query %d", i))

					local componentNames = {}

					for _, component in query.components do
						table.insert(componentNames, tostring(component))
					end

					plasma.label(table.concat(componentNames, ", "))

					local items = { { "ID", unpack(componentNames) } }

					while #items <= 10 do
						local data = { query.result:next() }

						if #data == 0 then
							break
						end

						for index, value in data do
							if type(value) == "table" then
								data[index] = format.formatTable(value)
							else
								data[index] = tostring(value)
							end
						end

						table.insert(items, data)
					end

					plasma.table(items, {
						headings = true,
					})

					if #items > 10 and query.result:next() then
						plasma.label("(further results truncated)")
					end
				end
				return nil
			end)
			:closed()
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000416</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX9B07A5082BF649D6A09E2550998239F5">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">realmSwitch</string>
											<string name="ScriptGuid">{62E68A7A-87C4-4E4D-B189-7407C49D752D}</string>
											<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")

return function(Plasma)
	local create = Plasma.create

	return Plasma.widget(function(options)
		local style = Plasma.useStyle()

		options = options or {}
		local left = options.left
		local right = options.right
		local isRight = options.isRight

		local clicked, setClicked = Plasma.useState(false)
		local refs = Plasma.useInstance(function(ref)
			ref.corner = create("UICorner")

			local style = Plasma.useStyle()

			create("TextButton", {
				[ref] = "button",
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 0, 25),
				Text = "",

				create("UICorner"),

				create("UIListLayout", {
					FillDirection = Enum.FillDirection.Horizontal,
				}),

				create("TextLabel", {
					[ref] = "left",
					Text = left,
					Size = UDim2.new(0.5, 0, 1, 0),
					BackgroundColor3 = style.primaryColor,
					BorderSizePixel = 0,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamMedium,
					TextSize = 14,
				}),

				create("TextLabel", {
					[ref] = "right",
					Text = right,
					Size = UDim2.new(0.5, 0, 1, 0),
					BackgroundColor3 = style.bg1,
					BorderSizePixel = 0,
					TextColor3 = style.textColor,
					Font = Enum.Font.GothamMedium,
					TextSize = 14,
				}),

				MouseEnter = function()
					local other = isRight and ref.left or ref.right
					other.BackgroundTransparency = 0.5
				end,

				MouseLeave = function()
					local other = isRight and ref.left or ref.right
					other.BackgroundTransparency = 0
				end,

				Activated = function()
					setClicked(true)
				end,
			})

			if options.tag then
				CollectionService:AddTag(ref.button, options.tag)
			end

			return ref.button
		end)

		refs.left.BackgroundColor3 = isRight and style.bg1 or style.primaryColor
		refs.right.BackgroundColor3 = isRight and style.primaryColor or style.bg1

		refs.corner.Parent = isRight and refs.right or refs.left

		local handle = {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}

		return handle
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000417</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX5C5B100243C94B5E8DE2C9881FEB30A7">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">selectionList</string>
											<string name="ScriptGuid">{F7620F26-F2F2-40DE-B57D-87F817A1AB53}</string>
											<ProtectedString name="Source"><![CDATA[return function(Plasma)
	local create = Plasma.create

	local Item = Plasma.widget(function(text, selected, icon, sideText, _, barWidth, index)
		local clicked, setClicked = Plasma.useState(false)
		local style = Plasma.useStyle()

		local refs = Plasma.useInstance(function(ref)
			local button = create("TextButton", {
				[ref] = "button",
				Size = UDim2.new(1, 0, 0, 25),
				Text = "",

				create("UICorner", {
					CornerRadius = UDim.new(0, 8),
				}),

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 0),
					PaddingLeft = UDim.new(0, 8),
					PaddingRight = UDim.new(0, 8),
					PaddingTop = UDim.new(0, 0),
				}),

				create("Frame", {
					[ref] = "container",
					BackgroundTransparency = 1,
					Size = UDim2.new(1, 0, 1, 0),

					create("UIListLayout", {
						SortOrder = Enum.SortOrder.LayoutOrder,
						FillDirection = Enum.FillDirection.Horizontal,
						Padding = UDim.new(0, 10),
					}),

					create("TextLabel", {
						Name = "index",
						AutomaticSize = Enum.AutomaticSize.X,
						Size = UDim2.new(0, 0, 1, 0),
						BackgroundTransparency = 1,
						Text = index,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 11,
						TextColor3 = style.mutedTextColor,
						Font = Enum.Font.Gotham,
						Visible = index ~= nil,
					}),

					create("TextLabel", {
						Name = "Icon",
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 22, 1, 0),
						Text = icon,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 16,
						TextColor3 = style.textColor,
						Font = Enum.Font.GothamBold,
					}),

					create("TextLabel", {
						AutomaticSize = Enum.AutomaticSize.X,
						BackgroundTransparency = 1,
						Size = UDim2.new(0, 0, 1, 0),
						Text = text,
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 13,
						TextColor3 = style.textColor,
						Font = Enum.Font.Gotham,
						TextTruncate = Enum.TextTruncate.AtEnd,

						create("UISizeConstraint", {
							MaxSize = Vector2.new(165, math.huge),
						}),
					}),

					create("TextLabel", {
						[ref] = "sideText",
						BackgroundTransparency = 1,
						AutomaticSize = Enum.AutomaticSize.X,
						Size = UDim2.new(0, 0, 1, 0),
						Text = "",
						TextXAlignment = Enum.TextXAlignment.Left,
						TextSize = 11,
						TextColor3 = style.mutedTextColor,
						Font = Enum.Font.Gotham,
					}),
				}),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
				}),

				create("Frame", {
					[ref] = "bar",
					BackgroundColor3 = style.mutedTextColor,
					BorderSizePixel = 0,
					LayoutOrder = 1,
					ZIndex = 2,
				}),

				Activated = function()
					setClicked(true)
				end,
			})

			return button
		end)

		Plasma.useEffect(function()
			refs.button.container.TextLabel.Text = text
			refs.button.container.Icon.Text = icon or ""
			refs.button.container.Icon.Visible = icon ~= nil
		end, text, icon)

		refs.button.container.sideText.Visible = sideText ~= nil
		refs.button.container.sideText.Text = if sideText ~= nil then sideText else ""
		refs.button.container.sideText.TextColor3 = if selected then style.textColor else style.mutedTextColor
		refs.button.container.TextLabel.TextTruncate = sideText and Enum.TextTruncate.AtEnd or Enum.TextTruncate.None

		refs.button.bar.Size = UDim2.new(barWidth or 0, 0, 0, 1)

		Plasma.useEffect(function()
			refs.button.BackgroundColor3 = if selected then style.primaryColor else style.bg2
		end, selected)

		return {
			clicked = function()
				if clicked then
					setClicked(false)
					return true
				end

				return false
			end,
		}
	end)

	return Plasma.widget(function(items, options)
		options = options or {}

		Plasma.useInstance(function()
			local frame = create("Frame", {
				BackgroundTransparency = 1,
				Size = options.width and UDim2.new(0, options.width, 0, 0) or UDim2.new(1, 0, 0, 0),

				create("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
				}),
			})

			Plasma.automaticSize(frame, {
				axis = Enum.AutomaticSize.Y,
			})

			return frame
		end)

		local selected

		for _, item in items do
			if
				Item(item.text, item.selected, item.icon, item.sideText, options.width, item.barWidth, item.index):clicked()
			then
				selected = item
			end
		end

		return {
			selected = function()
				return selected
			end,
		}
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000418</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX6EBEE2066D2740E986E0A093D7E9C67F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">tooltip</string>
											<string name="ScriptGuid">{2C6F3598-FB02-41CE-BE72-2A26E619824B}</string>
											<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
return function(plasma)
	local create = plasma.create

	return plasma.widget(function(text)
		local refs = plasma.useInstance(function(ref)
			local style = plasma.useStyle()

			create("TextLabel", {
				[ref] = "label",
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
				TextSize = 15,
				BorderSizePixel = 0,
				Font = Enum.Font.Code,
				TextStrokeTransparency = 0.5,
				TextColor3 = Color3.new(1, 1, 1),
				BackgroundTransparency = 0.5,
				BackgroundColor3 = style.bg1,
				AutomaticSize = Enum.AutomaticSize.XY,

				create("UIPadding", {
					PaddingBottom = UDim.new(0, 4),
					PaddingLeft = UDim.new(0, 4),
					PaddingRight = UDim.new(0, 4),
					PaddingTop = UDim.new(0, 4),
				}),

				create("UICorner"),

				create("UIStroke", {
					ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
				}),
			})

			CollectionService:AddTag(ref.label, "MatterDebuggerTooltip")

			return ref.label
		end)

		refs.label.Text = text
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000419</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX2EF429C318F846FABE892D0D0AE0A5A8">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">valueInspect</string>
											<string name="ScriptGuid">{B4469287-44FE-4C4E-AD6F-D0BCAAD99B07}</string>
											<ProtectedString name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable

return function(plasma)
	return plasma.widget(function(objectStack, custom)
		local closed = plasma
			.window({
				title = "Inspect",
				closable = true,
			}, function()
				plasma.row({ padding = 5 }, function()
					for i, object in objectStack do
						if
							custom
								.link(object.key, {
									icon = object.icon or "{}",
								})
								:clicked()
						then
							local difference = #objectStack - i

							for _ = 1, difference do
								table.remove(objectStack, #objectStack)
							end
						end

						if i < #objectStack then
							custom.link("▶", {
								disabled = true,
							})
						end
					end
				end)

				local items = {}

				for key, value in pairs(objectStack[#objectStack].value) do
					local valueItem

					if type(value) == "table" then
						valueItem = function()
							if
								custom
									.link(formatTable(value), {
										font = Enum.Font.Code,
									})
									:clicked()
							then
								table.insert(objectStack, {
									key = if type(key) == "table" then formatTable(key) else tostring(key),
									value = value,
								})
							end
						end
					else
						valueItem = tostring(value)
					end

					table.insert(items, {
						tostring(key),
						valueItem,
					})
				end

				plasma.useKey(tostring(objectStack[#objectStack].key) .. ":" .. #objectStack)

				if #items == 0 then
					return plasma.label("(empty table)")
				end

				plasma.table(items, {
					font = Enum.Font.Code,
				})
				return nil
			end)
			:closed()

		if closed then
			table.clear(objectStack)
		end
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000041a</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX2C8C133F797642A686D032869E2E809F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">worldInspect</string>
											<string name="ScriptGuid">{F70053F2-0E24-4BF7-801B-473CA0BE788A}</string>
											<ProtectedString name="Source"><![CDATA[local formatTableModule = require(script.Parent.Parent.formatTable)
local formatTable = formatTableModule.formatTable

return function(plasma)
	return plasma.widget(function(debugger, objectStack)
		local style = plasma.useStyle()

		local world = debugger.debugWorld

		local cache, setCache = plasma.useState()
		-- TODO #97 Implement sorting by descending as well.
		local ascendingOrder, _ = plasma.useState(false)
		local skipIntersections, setSkipIntersections = plasma.useState(true)
		local debugComponent, setDebugComponent = plasma.useState()

		local closed = plasma
			.window({
				title = "World inspect",
				closable = true,
			}, function()
				if not cache or os.clock() - cache.createdTime > debugger.componentRefreshFrequency then
					cache = {
						createdTime = os.clock(),
						uniqueComponents = {},
						emptyEntities = 0,
					}

					setCache(cache)

					for _, entityData in world do
						if next(entityData) == nil then
							cache.emptyEntities += 1
						else
							for component in entityData do
								cache.uniqueComponents[component] = (cache.uniqueComponents[component] or 0) + 1
							end
						end
					end
				end

				plasma.row({
					verticalAlignment = Enum.VerticalAlignment.Center,
				}, function()
					plasma.heading("SIZE:")
					plasma.label(
						`{world:size()} {if cache.emptyEntities > 0 then `({cache.emptyEntities} empty)` else ""}`
					)

					if plasma.button("View Raw"):clicked() then
						table.clear(objectStack)
						objectStack[1] = {
							value = world,
							key = "Raw World",
						}
					end
				end)

				plasma.row({ padding = 15 }, function()
					if plasma.checkbox("Show intersections", { checked = not skipIntersections }):clicked() then
						setSkipIntersections(not skipIntersections)
					end
				end)

				local items = {}
				for component, count in cache.uniqueComponents do
					table.insert(items, {
						count,
						tostring(component),
						selected = debugComponent == component,
						component = component,
					})
				end

				table.sort(items, function(a, b)
					if ascendingOrder then
						return a[1] < b[1]
					end

					-- Default to alphabetical
					return a[2] < b[2]
				end)

				table.insert(items, 1, { "Count", "Component" })

				plasma.row({ padding = 30 }, function()
					local selectedRow = plasma
						.table(items, {
							width = 200,
							headings = true,
							selectable = true,
							font = Enum.Font.Code,
						})
						:selected()

					if selectedRow then
						setDebugComponent(selectedRow.component)
					end

					if debugComponent then
						local items = { { "Entity ID", tostring(debugComponent) } }
						local intersectingComponents = {}

						local intersectingData = {}

						for entityId, data in world:query(debugComponent) do
							table.insert(items, {
								entityId,
								formatTable(data),

								selected = debugger.debugEntity == entityId,
							})

							intersectingData[entityId] = {}

							if skipIntersections then
								continue
							end

							for component, value in world:_getEntity(entityId) do
								if component == debugComponent then
									continue
								end

								local index = table.find(intersectingComponents, component)

								if not index then
									table.insert(intersectingComponents, component)

									index = #intersectingComponents
								end

								intersectingData[entityId][index] = value
							end
						end

						for i, item in items do
							if i == 1 then
								for _, component in intersectingComponents do
									table.insert(item, tostring(component))
								end

								continue
							end

							for i = 1, #intersectingComponents do
								local data = intersectingData[item[1]][i]

								table.insert(item, if data then formatTable(data) else "")
							end
						end

						plasma.useKey(tostring(debugComponent))

						local tableWidget = plasma.table(items, {
							font = Enum.Font.Code,
							selectable = true,
							headings = true,
						})

						local selectedRow = tableWidget:selected()
						local hovered = tableWidget:hovered()

						if selectedRow then
							debugger.debugEntity = selectedRow[1]
						end

						if hovered then
							local entityId = hovered[1]

							if debugger.debugEntity == entityId or not world:contains(entityId) then
								return
							end

							if debugger.findInstanceFromEntity then
								local model = debugger.findInstanceFromEntity(entityId)

								if model then
									plasma.highlight(model, {
										fillColor = style.primaryColor,
									})
								end
							end
						end
					end
				end)
			end)
			:closed()

		if closed then
			return closed
		end
		return nil
	end)
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000041b</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX8C1D17CBE4584566BE9F16B70D5950E0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">hooks</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000041c</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX689DC1520B8C4A1A9EACE3480FEBA1CB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">log</string>
										<string name="ScriptGuid">{66111596-DDF3-43A1-B50B-BAD2FD1E0BAD}</string>
										<ProtectedString name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local format = require(script.Parent.Parent.debugger.formatTable)

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	@param ... any

	Logs some text. Readable in the Matter debugger.
]=]
local function log(...)
	local state = topoRuntime.useFrameState()

	if state.logs == nil then
		return
	end

	local segments = {}

	for i = 1, select("#", ...) do
		local value = select(i, ...)

		if type(value) == "table" then
			segments[i] = format.formatTable(value)
		else
			segments[i] = tostring(value)
		end
	end

	table.insert(state.logs, table.concat(segments, " "))

	if #state.logs > 100 then
		table.remove(state.logs, 1)
	end
end

return log
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000041d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXFF390AD65F2E44758FCC819B851B3CF8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">useDeltaTime</string>
										<string name="ScriptGuid">{D09108BE-ABB6-4501-91A7-2255DA20840D}</string>
										<ProtectedString name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Returns the `os.clock()` time delta between the start of this and last frame.
]=]
local function useDeltaTime(): number
	local state = topoRuntime.useFrameState()

	return state.deltaTime
end

return useDeltaTime
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000041e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX91C617A03CEA456596BC4A64D4C2252E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">useEvent</string>
										<string name="ScriptGuid">{6BC0E99E-1474-49B6-BC7F-A7054BBB98FC}</string>
										<ProtectedString name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)
local Queue = require(script.Parent.Parent.Queue)

local EVENT_CONNECT_METHODS = { "Connect", "on", "connect" }
local CONNECTION_DISCONNECT_METHODS = { "Disconnect", "Destroy", "disconnect", "destroy" }

local function connect(object, callback, event)
	local eventObject = object

	if typeof(event) == "RBXScriptSignal" or type(event) == "table" then
		eventObject = event
	elseif type(event) == "string" then
		eventObject = object[event]
	end

	if type(eventObject) == "function" then
		return eventObject(object)
	elseif typeof(eventObject) == "RBXScriptSignal" then
		return eventObject:Connect(callback)
	end

	if type(eventObject) == "table" then
		for _, method in EVENT_CONNECT_METHODS do
			if type(eventObject[method]) ~= "function" then
				continue
			end

			return eventObject[method](eventObject, callback)
		end
	end

	error(
		"Couldn't connect to event as no valid connect methods were found! Ensure the passed event has a 'Connect' or an 'on' method!"
	)
end

local function disconnect(connection)
	if connection == nil then
		return
	end

	if type(connection) == "function" then
		connection()
		return
	end

	for _, method in CONNECTION_DISCONNECT_METHODS do
		if type(connection[method]) ~= "function" then
			continue
		end

		connection[method](connection)
		break
	end
end

local function validateConnection(connection)
	if typeof(connection) == "function" or typeof(connection) == "RBXScriptConnection" then
		return
	end

	for _, method in CONNECTION_DISCONNECT_METHODS do
		if type(connection) ~= "table" or connection[method] == nil then
			continue
		end

		return
	end

	error("Ensure passed event returns a cleanup function, or a table with a 'Disconnect' or a 'Destroy' method!")
end

local function cleanup(storage)
	disconnect(storage.connection)
	storage.queue = nil
end

--[=[
	@type ConnectionObject {Disconnect: (() -> ())?, Destroy: (() - >())?, disconnect: (() -> ())?, destroy: (() -> ())?} | () -> ()
	@within Matter

	A connection object returned by a custom event must be either a table with any of the following methods, or a cleanup function.
]=]

--[=[
	@interface CustomEvent
	@within Matter
	.Connect ((...) -> ConnectionObject)?
	.on ((...) -> ConnectionObject)?
	.connect ((...) -> ConnectionObject)?

	A custom event must have any of these 3 methods.
]=]

--[=[
	@within Matter
	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Collects events that fire during the frame and allows iteration over event arguments.

	```lua
	for _, player in ipairs(Players:GetPlayers()) do
		for i, character in useEvent(player, "CharacterAdded") do
			world:spawn(
				Components.Target(),
				Components.Model({
					model = character,
				})
			)
		end
	end
	```

	Returns an iterator function that returns an ever-increasing number, starting at 1, followed by any event arguments
	from the specified event.

	Events are returned in the order that they were fired.

	:::caution
	`useEvent` keys storage uniquely identified by **the script and line number** `useEvent` was called from, and the
	first parameter (instance). If the second parameter, `event`, is not equal to the event passed in for this unique
	storage last frame, the old event is disconnected from and the new one is connected in its place.

	Tl;dr: on a given line, you should hard-code a single event to connect to. Do not dynamically change the event with
	a variable. Dynamically changing the first parameter (instance) is fine.

	```lua
	for _, instance in pairs(someTable) do
		for i, arg1, arg2 in useEvent(instance, "Touched") do -- This is ok
		end
	end

	for _, instance in pairs(someTable) do
		local event = getEventSomehow()
		for i, arg1, arg2 in useEvent(instance, event) do -- PANIC! This is NOT OK
		end
	end
	```
	:::

	If `useEvent` ceases to be called on the same line with the same instance and event, the event connection is
	disconnected from automatically.

	You can also pass the actual event object instead of its name as the second parameter:

	```lua
	useEvent(instance, instance.Touched)
	useEvent(instance, instance:GetPropertyChangedSignal("Name"))
	```

	`useEvent` supports custom events as well, so you can pass in an object with a `Connect`, `connect` or an `on` method.
	The object returned by any event must either be a cleanup function, or a table with a `Disconnect` or a `Destroy`
	method so that `useEvent` can later clean the event up when needed.	See [ConnectionObject] for more information.

	@param instance Instance | { [string]: CustomEvent } | CustomEvent -- The instance or the custom event, or a table that has the event you want to connect to
	@param event string | RBXScriptSignal | CustomEvent -- The name of, or the actual event that you want to connect to
]=]
local function useEvent(instance, event): () -> (number, ...any)
	assert(instance ~= nil, "Instance is nil")
	assert(event ~= nil, "Event is nil")

	local storage = topoRuntime.useHookState(instance, cleanup)

	if storage.event ~= event then
		if storage.event then
			disconnect(storage.connection)
			warn("useEvent event changed:", storage.event, "->", event)
			table.clear(storage)
		end

		local queue = Queue.new()
		storage.queue = queue
		storage.event = event

		local connection = connect(instance, function(...)
			queue:pushBack(table.pack(...))
		end, event)

		validateConnection(connection)
		storage.connection = connection
	end

	local index = 0
	return function(): any
		index += 1

		local arguments = storage.queue:popFront()

		if arguments then
			return index, unpack(arguments, 1, arguments.n)
		end
		return
	end
end

return useEvent
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000041f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3250F9F275284FD8B95A7A9EE31D10A4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">useThrottle</string>
										<string name="ScriptGuid">{A7F9BF3D-81A9-44EB-9909-469C9510EDFF}</string>
										<ProtectedString name="Source"><![CDATA[local topoRuntime = require(script.Parent.Parent.topoRuntime)

local function cleanup(storage)
	return os.clock() < storage.expiry
end

--[=[
	@within Matter

	:::info Topologically-aware function
	This function is only usable if called within the context of [`Loop:begin`](/api/Loop#begin).
	:::

	Utility for easy time-based throttling.

	Accepts a duration, and returns `true` if it has been that long since the last time this function returned `true`.
	Always returns `true` the first time.

	This function returns unique results keyed by script and line number. Additionally, uniqueness can be keyed by a
	unique value, which is passed as a second parameter. This is useful when iterating over a query result, as you can
	throttle doing something to each entity individually.

	```lua
	if useThrottle(1) then -- Keyed by script and line number only
		print("only prints every second")
	end

	for id, enemy in world:query(Enemy) do
		if useThrottle(5, id) then -- Keyed by script, line number, and the entity id
			print("Recalculate target...")
		end
	end
	```

	@param seconds number -- The number of seconds to throttle for
	@param discriminator? any -- A unique value to additionally key by
	@return boolean -- returns true every x seconds, otherwise false
]=]
local function useThrottle(seconds, discriminator)
	local storage = topoRuntime.useHookState(discriminator, cleanup)

	if storage.time == nil or os.clock() - storage.time >= seconds then
		storage.time = os.clock()
		storage.expiry = os.clock() + seconds
		return true
	end

	return false
end

return useThrottle
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000420</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX685BB958D9EA4077A4305D89396A5BE6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">immutable</string>
									<string name="ScriptGuid">{26064601-F155-49D0-886C-6D1A7FB4C989}</string>
									<ProtectedString name="Source"><![CDATA[local None = {}

local function merge(one, two)
	local new = table.clone(one)

	for key, value in two do
		if value == None then
			new[key] = nil
		else
			new[key] = value
		end
	end

	return new
end

-- https://github.com/freddylist/llama/blob/master/src/List/toSet.lua
local function toSet(list)
	local set = {}

	for _, v in ipairs(list) do
		set[v] = true
	end

	return set
end

-- https://github.com/freddylist/llama/blob/master/src/Dictionary/values.lua
local function values(dictionary)
	local valuesList = {}

	local index = 1

	for _, value in pairs(dictionary) do
		valuesList[index] = value
		index = index + 1
	end

	return valuesList
end

return {
	None = None,
	merge = merge,
	toSet = toSet,
	values = values,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000421</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX7AF419241D5A482DAC60FAB05562D4C9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">mock</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000422</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX68269D7EB87840DB889C3F95DE2FE355">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">BindableEvent</string>
										<string name="ScriptGuid">{8EB9598A-22B5-4C87-B736-30AD16793310}</string>
										<ProtectedString name="Source"><![CDATA[local BindableEvent = {}
BindableEvent.__index = BindableEvent

function BindableEvent.new()
	local self = setmetatable({
		_listeners = {},
		_locked = false,
	}, BindableEvent)

	self.Event = self

	return self
end

function BindableEvent:Connect(listener)
	table.insert(self._listeners, listener)

	return {
		Disconnect = function()
			local index = table.find(self._listeners, listener)

			if index then
				table.remove(self._listeners, index)
			end
		end,
	}
end

function BindableEvent:Fire(...)
	if self._locked then
		error("Cannot fire while firing")
	end

	self._locked = true
	for _, listener in self._listeners do
		local ok, errors = pcall(listener, ...)

		if not ok then
			warn(errors)
		end
	end
	self._locked = false
end

return BindableEvent
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000423</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX9C800A6E42B14DADAE47D756C2FD620D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">rollingAverage</string>
									<string name="ScriptGuid">{D4C52528-4A3E-43E7-83B1-93AF93FE5A88}</string>
									<ProtectedString name="Source"><![CDATA[local MAX_SAMPLES = 60

local function addSample(samples, value)
	samples[samples.index or 1] = value
	samples.index = if samples.index then (samples.index % MAX_SAMPLES) + 1 else 1
end

local function getAverage(samples)
	local sum = 0

	for i = 1, #samples do
		sum += samples[i]
	end

	return sum / #samples
end

return {
	addSample = addSample,
	getAverage = getAverage,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000424</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXFF54C9050D8B487980732F0623A0DA63">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">topoRuntime</string>
									<string name="ScriptGuid">{5FE2F54F-4368-42A6-9463-B70DF5FAC8D8}</string>
									<ProtectedString name="Source"><![CDATA[local stack = {}

local function newStackFrame(node)
	return {
		node = node,
		accessedKeys = {},
	}
end

local function cleanup()
	local currentFrame = stack[#stack]

	for baseKey, state in pairs(currentFrame.node.system) do
		for key, value in pairs(state.storage) do
			if not currentFrame.accessedKeys[baseKey] or not currentFrame.accessedKeys[baseKey][key] then
				local cleanupCallback = state.cleanupCallback

				if cleanupCallback then
					local shouldAbortCleanup = cleanupCallback(value)

					if shouldAbortCleanup then
						continue
					end
				end

				state.storage[key] = nil
			end
		end
	end
end

local function start(node, fn)
	table.insert(stack, newStackFrame(node))
	fn()
	cleanup()
	table.remove(stack, #stack)
end

local function withinTopoContext()
	return #stack ~= 0
end

local function useFrameState()
	return stack[#stack].node.frame
end

local function useCurrentSystem()
	if #stack == 0 then
		return
	end

	return stack[#stack].node.currentSystem
end

--[=[
	@within Matter

	:::tip
	**Don't use this function directly in your systems.**

	This function is used for implementing your own topologically-aware functions. It should not be used in your
	systems directly. You should use this function to implement your own utilities, similar to `useEvent` and
	`useThrottle`.
	:::

	`useHookState` does one thing: it returns a table. An empty, pristine table. Here's the cool thing though:
	it always returns the *same* table, based on the script and line where *your function* (the function calling
	`useHookState`) was called.

	### Uniqueness

	If your function is called multiple times from the same line, perhaps within a loop, the default behavior of
	`useHookState` is to uniquely identify these by call count, and will return a unique table for each call.

	However, you can override this behavior: you can choose to key by any other value. This means that in addition to
	script and line number, the storage will also only return the same table if the unique value (otherwise known as the
	"discriminator") is the same.

	### Cleaning up
	As a second optional parameter, you can pass a function that is automatically invoked when your storage is about
	to be cleaned up. This happens when your function (and by extension, `useHookState`) ceases to be called again
	next frame (keyed by script, line number, and discriminator).

	Your cleanup callback is passed the storage table that's about to be cleaned up. You can then perform cleanup work,
	like disconnecting events.

	*Or*, you could return `true`, and abort cleaning up altogether. If you abort cleanup, your storage will stick
	around another frame (even if your function wasn't called again). This can be used when you know that the user will
	(or might) eventually call your function again, even if they didn't this frame. (For example, caching a value for
	a number of seconds).

	If cleanup is aborted, your cleanup function will continue to be called every frame, until you don't abort cleanup,
	or the user actually calls your function again.

	### Example: useThrottle

	This is the entire implementation of the built-in `useThrottle` function:

	```lua
	local function cleanup(storage)
		return os.clock() < storage.expiry
	end

	local function useThrottle(seconds, discriminator)
		local storage = useHookState(discriminator, cleanup)

		if storage.time == nil or os.clock() - storage.time >= seconds then
			storage.time = os.clock()
			storage.expiry = os.clock() + seconds
			return true
		end

		return false
	end
	```

	A lot of talk for something so simple, right?

	@param discriminator? any -- A unique value to additionally key by
	@param cleanupCallback (storage: {}) -> boolean? -- A function to run when the storage for this hook is cleaned up
]=]
local function useHookState(discriminator, cleanupCallback): {}
	local file, line = debug.info(3, "sl")
	local fn = debug.info(2, "f")

	local baseKey = string.format("%s:%s:%d", tostring(fn), file, line)

	local currentFrame = stack[#stack]

	if currentFrame == nil then
		error("Attempt to access topologically-aware storage outside of a Loop-system context.", 3)
	end

	if not currentFrame.accessedKeys[baseKey] then
		currentFrame.accessedKeys[baseKey] = {}
	end

	local accessedKeys = currentFrame.accessedKeys[baseKey]

	local key = #accessedKeys

	if discriminator ~= nil then
		if type(discriminator) == "number" then
			discriminator = tostring(discriminator)
		end

		key = discriminator
	end

	accessedKeys[key] = true

	if not currentFrame.node.system[baseKey] then
		currentFrame.node.system[baseKey] = {
			storage = {},
			cleanupCallback = cleanupCallback,
		}
	end

	local storage = currentFrame.node.system[baseKey].storage

	if not storage[key] then
		storage[key] = {}
	end

	return storage[key]
end

return {
	start = start,
	useHookState = useHookState,
	useFrameState = useFrameState,
	useCurrentSystem = useCurrentSystem,
	withinTopoContext = withinTopoContext,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000425</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX8B9497AC29AB443A9867B6ECA0549BC6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">plasma</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000426</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXF472A72745AE49B3A58CD55F7DE5F501">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{41782154-D87F-4216-A596-E41AAFFACBA5}</string>
								<ProtectedString name="Source"><![CDATA[--- @class Plasma

local Runtime = require(script.Runtime)
local Style = require(script.Style)

return {
	new = Runtime.new,
	start = Runtime.start,
	continueFrame = Runtime.continueFrame,
	beginFrame = Runtime.beginFrame,
	finishFrame = Runtime.finishFrame,
	scope = Runtime.scope,
	widget = Runtime.widget,
	useState = Runtime.useState,
	useInstance = Runtime.useInstance,
	useEffect = Runtime.useEffect,
	useKey = Runtime.useKey,
	setEventCallback = Runtime.setEventCallback,
	createContext = Runtime.createContext,
	useContext = Runtime.useContext,
	provideContext = Runtime.provideContext,

	useStyle = Style.get,
	setStyle = Style.set,

	automaticSize = require(script.automaticSize),
	hydrateAutomaticSize = require(script.hydrateAutomaticSize),
	create = require(script.create),

	window = require(script.widgets.window),
	button = require(script.widgets.button),
	portal = require(script.widgets.portal),
	blur = require(script.widgets.blur),
	row = require(script.widgets.row),
	spinner = require(script.widgets.spinner),
	checkbox = require(script.widgets.checkbox),
	arrow = require(script.widgets.arrow),
	heading = require(script.widgets.heading),
	label = require(script.widgets.label),
	slider = require(script.widgets.slider),
	space = require(script.widgets.space),
	table = require(script.widgets.table),
	highlight = require(script.widgets.highlight),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000427</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX59BFA9D97F0D42F6AE2E59C1776B4AC1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Runtime</string>
									<string name="ScriptGuid">{43EFDB89-A2C3-49E3-966A-D14B72B36653}</string>
									<ProtectedString name="Source"><![CDATA[type EventCallback = (Instance, string, (...any) -> ()) -> ()

type Node = {
	instance: Instance?,
	refs: { [any]: Instance }?,
	containerInstance: Instance?,
	effects: {
		[TopoKey]: {
			lastDependencies: { any }?,
			lastDependenciesLength: number,
			destructor: (() -> ())?,
		},
	},
	states: { [TopoKey]: any },
	children: { [TopoKey]: Node },
	generation: number,
	eventCallback: EventCallback?,
}

type TopoKey = string

type StackFrame = {
	node: Node,
	contextValues: {
		[any]: any,
	},
	childrenCount: number,
	effectCounts: { [TopoKey]: number },
	stateCounts: { [TopoKey]: number },
	childCounts: { [TopoKey]: number },
	discriminator: string | number,
}

local stack: { StackFrame } = {}

local recentErrors = {}
local recentErrorLastTime = 0

local function newNode(state: {}): Node
	if state == nil then
		state = {}
	end

	return {
		instance = nil,
		containerInstance = nil,
		effects = {},
		states = {},
		children = {},
		generation = 0,
	}
end

local function destroyNode(node: Node)
	if node.instance ~= nil then
		node.instance:Destroy()
	end

	for _, effect in pairs(node.effects) do
		if effect.destructor ~= nil then
			effect.destructor()
		end
	end

	for _, child in pairs(node.children) do
		destroyNode(child)
	end
end

local function newStackFrame(node: Node): StackFrame
	return {
		node = node,
		contextValues = {},
		childrenCount = 0,
		effectCounts = {},
		stateCounts = {},
		childCounts = {},
	}
end

local Runtime = {}

--[=[
	@within Plasma
	@param rootInstance Instance -- The root instance of which to mount all children. Likely a ScreenGui.
	@return Node -- An opaque object which holds persistent state about your UI.
]=]
function Runtime.new(rootInstance: Instance): Node
	local node = newNode()
	node.instance = rootInstance
	return node
end

--[=[
	@within Plasma
	@param name string -- The human-readable name of the context. This is only for debug purposes.
	@return Context -- An opqaue Context object which holds persistent state.

	Creates a [Context] object which is used to pass state downwards through the tree without needing to thread it
	through every child as props.
]=]
function Runtime.createContext(name: string)
	local fullName = string.format("PlasmaContext(%s)", name)
	return setmetatable({}, {
		__tostring = function()
			return fullName
		end,
	})
end

--[=[
	@within Plasma
	@param context Context -- A context object previously created with `createContext`
	@return T
	@tag hooks

	Returns the value of this context provided by the most recent ancestor that used `provideContext` with this context.
]=]
function Runtime.useContext(context)
	for i = #stack - 1, 1, -1 do
		local frame = stack[i]

		if frame.contextValues[context] ~= nil then
			return frame.contextValues[context]
		end
	end

	return nil
end

--[=[
	@within Plasma
	@param context Context -- A context object previously created with `createContext`
	@param value T -- Any value you want to provide for this context

	Provides a value for this context for any subsequent uses of `useContext` in this scope.
]=]
function Runtime.provideContext(context, value)
	local frame = stack[#stack]
	frame.contextValues[context] = value
end

--[=[
	@within Plasma
	@param callback () -> () | () -> () -> () -- A callback function that optionally returns a cleanup function
	@param ... any -- Dependencies
	@tag hooks

	`useEffect` takes a callback as a parameter which is then only invoked if passed dependencies are different from the
	last time this function was called. The callback is always invoked the first time this code path is reached.

	If no dependencies are passed, the callback only runs once.

	This function can be used to skip expensive work if none of the dependencies have changed since the last run.
	For example, you might use this to set a bunch of properties in a widget if any of the inputs change.
]=]
function Runtime.useEffect(callback: () -> () | () -> () -> (), ...)
	local frame = stack[#stack]
	local effects = frame.node.effects

	local file = debug.info(2, "s")
	local line = debug.info(2, "l")
	local baseKey = string.format("%s:%s:%d", tostring(frame.discriminator) or "", file, line)

	frame.effectCounts[baseKey] = (frame.effectCounts[baseKey] or 0) + 1
	local key = string.format("%s:%d", baseKey, frame.effectCounts[baseKey])

	local existing = effects[key]
	local gottaRunIt = existing == nil -- We ain't never run this before!
		or select("#", ...) ~= existing.lastDependenciesLength -- I have altered the dependencies. Pray that I do not alter them further.

	if not gottaRunIt then
		for i = 1, select("#", ...) do
			if select(i, ...) ~= existing.lastDependencies[i] then
				gottaRunIt = true
				break
			end
		end
	end

	if gottaRunIt then
		if existing ~= nil and existing.destructor ~= nil then
			existing.destructor()
		end

		effects[key] = {
			destructor = callback(),
			lastDependencies = { ... },
			lastDependenciesLength = select("#", ...),
		}
	end
end

--[=[
	@within Plasma
	@param initialValue T -- The value this hook returns if the set callback has never been called
	@return T -- The previously set value, or the initial value if none has been set
	@return (newValue: T) -> () -- A function which when called stores the value in this hook for the next run
	@tag hooks

	```lua
	local checked, setChecked = useState(false)

	useInstance(function()
		local TextButton = Instance.new("TextButton")

		TextButton.Activated:Connect(function()
			setChecked(not checked)
		end)

		return TextButton
	end)

	TextButton.Text = if checked then "X" else ""
	```
]=]
function Runtime.useState<T>(initialValue: T): T
	local frame = stack[#stack]
	local states = frame.node.states

	local file = debug.info(2, "s")
	local line = debug.info(2, "l")
	local baseKey = string.format("%s:%s:%d", tostring(frame.discriminator) or "", file, line)
	frame.stateCounts[baseKey] = (frame.stateCounts[baseKey] or 0) + 1
	local key = string.format("%s:%d", baseKey, frame.stateCounts[baseKey])

	local existing = states[key]
	if existing == nil then
		states[key] = initialValue
	end

	local function setter(newValue)
		if type(newValue) == "function" then
			newValue = newValue(states[key])
		end

		states[key] = newValue
	end

	return states[key], setter
end

--[=[
	@within Plasma
	@param key

	Specify a key by which to store all future state in this scope. This is similar to React's `key` prop.

	This is important to use to prevent state from one source being still being applied when it should actually reset.
]=]
function Runtime.useKey(key: string | number)
	local frame = stack[#stack]

	frame.discriminator = key
end

--[=[
	@within Plasma
	@param creator (ref: {}) -> (Instance, Instance?) -- A callback which creates the widget and returns it
	@return Instance -- Returns the instance returned by `creator`
	@tag hooks

	`useInstance` takes a callback which should be used to create the initial UI for the widget.
	The callback is only ever invoked on the first time this widget runs and never again.
	The callback should return the instance it created.
	The callback can optionally return a second value, which is the instance where children of this widget should be
	placed. Otherwise, children are placed in the first instance returned.

	`useInstance` returns the `ref` table that is passed to it. You can use this to create references to objects
	you want to update in the widget body.
]=]
function Runtime.useInstance(creator: () -> Instance): Instance
	local node = stack[#stack].node
	local parentFrame = Runtime.nearestStackFrameWithInstance()

	if node.instance == nil then
		local parent = parentFrame.node.containerInstance or parentFrame.node.instance

		node.refs = {}
		local instance, container = creator(node.refs)

		if instance ~= nil then
			instance.Parent = parent
			node.instance = instance
		end

		if container ~= nil then
			node.containerInstance = container
		end
	end

	if node.instance ~= nil and node.instance:IsA("GuiObject") then
		parentFrame.childrenCount += 1
		node.instance.LayoutOrder = parentFrame.childrenCount
	end

	return node.refs
end

function Runtime.nearestStackFrameWithInstance(): StackFrame?
	for i = #stack - 1, 1, -1 do
		local frame = stack[i]

		if frame.node.containerInstance ~= nil or frame.node.instance ~= nil then
			return frame
		end
	end

	return nil
end

local function scope(level, scopeKey, fn, ...)
	local parentFrame = stack[#stack]
	local parentNode = parentFrame.node

	local file = debug.info(1 + level, "s")
	local line = debug.info(1 + level, "l")
	local baseKey = string.format("%s:%s:%s:%d", scopeKey, tostring(parentFrame.discriminator) or "", file, line)

	parentFrame.childCounts[baseKey] = (parentFrame.childCounts[baseKey] or 0) + 1
	local key = string.format("%s:%d", baseKey, parentFrame.childCounts[baseKey])

	local currentNode = parentNode.children[key]

	if currentNode == nil then
		currentNode = newNode()
		parentNode.children[key] = currentNode
	end

	currentNode.generation = parentNode.generation

	table.insert(stack, newStackFrame(currentNode))
	local thread = coroutine.create(fn)

	local success, widgetHandle = coroutine.resume(thread, ...)

	if coroutine.status(thread) ~= "dead" then
		success = false
		widgetHandle =
			"Plasma: Handler passed to Plasma.start yielded! Yielding is not allowed and the handler thread has been closed."

		coroutine.close(thread)
	end

	if not success then
		if os.clock() - recentErrorLastTime > 10 then
			recentErrorLastTime = os.clock()
			recentErrors = {}
		end

		local errorValue = debug.traceback(thread, tostring(widgetHandle))

		if not recentErrors[errorValue] then
			task.spawn(error, tostring(errorValue))
			warn("Plasma: The above error will be suppressed for the next 10 seconds")
			recentErrors[errorValue] = true
		end

		local errorWidget = require(script.Parent.widgets.error)

		errorWidget(tostring(errorValue))
	end

	table.remove(stack)

	for childKey, childNode in pairs(currentNode.children) do
		if childNode.generation ~= currentNode.generation then
			destroyNode(childNode)
			currentNode.children[childKey] = nil
		end
	end

	return widgetHandle
end

--[=[
	@within Plasma
	@param rootNode Node -- A node created by `Plasma.new`.
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`

	Begins a new frame for this Plasma instance. The `callback` is invoked immediately.
	Code run in the `callback` function that uses plasma APIs will be associated with this Plasma node.
	The `callback` function is **not allowed to yield**.

	If this function is used, `Plasma.beginFrame`, `Plasma.continueFrame`, and `Plasma.finishFrame` should not be used.
]=]
function Runtime.start(rootNode: Node, fn, ...)
	Runtime.beginFrame(rootNode, fn, ...)

	Runtime.finishFrame(rootNode)
end

--[=[
	@within Plasma
	@param rootNode Node -- A node created by `Plasma.new`.
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`
	@return ContinueHandle -- A handle to pass to `continueFrame`

	Begins a *continuable* Plasma frame. Same semantics as [Plasma.start].

	For a frame:
	- Call `beginFrame` once.
	- Call `continueFrame` any number of times.
	- Call `finishFrame` when the frame is complete.

	If this function is used, `Plasma.start` should not be used.
]=]
function Runtime.beginFrame(rootNode: Node, fn, ...)
	if #stack > 0 then
		error("Runtime.start cannot be called while Runtime.start is already running", 2)
	end

	debug.profilebegin("Plasma")

	if rootNode.generation == 0 then
		rootNode.generation = 1
	else
		rootNode.generation = 0
	end

	stack[1] = newStackFrame(rootNode)
	scope(2, "root", fn, ...)
	local continueHandle = table.remove(stack)

	debug.profileend()

	return continueHandle
end

--[=[
	Finishes a continuable Plasma frame, cleaning up any objects that have been removed since the last frame.
	@within Plasma
	@param rootNode Node -- A node created by `Plasma.new`.
]=]
function Runtime.finishFrame(rootNode: Node)
	for childKey, childNode in pairs(rootNode.children) do
		if childNode.generation ~= rootNode.generation then
			destroyNode(childNode)
			rootNode.children[childKey] = nil
		end
	end
end

--[=[
	Continue the Plasma frame with a new handler function. Calling this will not trigger any cleanup that typically
	happens every frame.

	This is intended to be used to continue creating UI within the same frame that you started on. You should call
	[Plasma.beginFrame] once per frame, then `Plasma.continueFrame` any number of times after that, finally calling
	[Plasma.finishFrame].

	@within Plasma
	@param continueHandle ContinueHandle -- An object returned by Plasma.start
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`
]=]
function Runtime.continueFrame(continueHandle, fn, ...)
	if #stack > 0 then
		error("Runtime.continue cannot be called while Runtime.start is already running", 2)
	end

	stack[1] = continueHandle

	scope(2, "root", fn, ...)

	table.remove(stack)
end

--[=[
	@within Plasma
	@param fn (...: T) -> ()
	@param ... T -- Additional parameters to `callback`

	Begins a new scope. This function may only be called within a `Plasma.start` callback.
	The `callback` is invoked immediately.

	Beginning a new scope associates all further calls to Plasma APIs with a nested scope inside this one.
]=]
function Runtime.scope(fn, ...)
	return scope(2, "", fn, ...)
end

--[=[
	@within Plasma
	@param fn (...: T) -> () -- The widget function
	@return (...: T) -> () -- A function which can be called to create the widget

	This function takes a widget function and returns a function that automatically starts a new scope when the function
	is called.
]=]
function Runtime.widget(fn)
	local file, line = debug.info(2, "sl")
	local scopeKey = string.format("%s+%d", file, line)

	return function(...)
		return scope(2, scopeKey, fn, ...)
	end
end

function Runtime.setEventCallback(callback: EventCallback)
	stack[1].node.eventCallback = callback
end

function Runtime.useEventCallback(): EventCallback?
	local frame = stack[1]

	if not frame then
		return nil
	end

	return frame.node.eventCallback
end

return Runtime
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000428</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX05F3DBBCBFD34654A1AE4BB88BCD2412">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Style</string>
									<string name="ScriptGuid">{77A36E81-6A9B-48A6-9791-A94603251E51}</string>
									<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Runtime)

local ContextKey = Runtime.createContext("Style")

local defaultStyle = {
	bg1 = Color3.fromRGB(31, 31, 31),
	bg2 = Color3.fromRGB(42, 42, 42),
	bg3 = Color3.fromRGB(54, 54, 54),
	mutedTextColor = Color3.fromRGB(147, 147, 147),
	textColor = Color3.fromRGB(255, 255, 255),
}

local Style = {}

--[=[
	@within Plasma
	@function useStyle
	@tag style

	Returns the current style information, with styles that are set more recently in the tree overriding styles that
	were set further up. In this way, styles cascade downwards, similar to CSS.
]=]
function Style.get()
	return Runtime.useContext(ContextKey) or defaultStyle
end

--[=[
	@within Plasma
	@function setStyle
	@tag style
	@param styleFragment {[string]: any} -- A dictionary of style information

	Defines style for any subsequent calls in this scope. Merges with any existing styles.
]=]
function Style.set(styleFragment)
	local existing = Runtime.useContext(ContextKey) or defaultStyle
	local newStyle = table.clone(existing)

	for key, value in pairs(styleFragment) do
		newStyle[key] = value
	end

	Runtime.provideContext(ContextKey, newStyle)
end

return Style
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000429</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7DB6DDDFC9CB4F7197AC5179BCAECA40">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">automaticSize</string>
									<string name="ScriptGuid">{28F6D44F-92EE-4960-80A9-05D6F8D79C53}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local function applyLayout(container, layout)
	local axisName = container:GetAttribute("axis") or "XY"
	local axis = Enum.AutomaticSize[axisName]

	local maxSize = container:GetAttribute("maxSize") or Vector2.new(math.huge, math.huge)
	local minSize = container:GetAttribute("minSize") or Vector2.new(0, 0)

	if typeof(maxSize) == "UDim2" then
		if container.Parent == nil then
			maxSize = Vector2.new(0, 0)
		else
			local parentSize = container.Parent.AbsoluteSize

			maxSize = Vector2.new(
				(parentSize.X / maxSize.X.Scale) + maxSize.X.Offset,
				(parentSize.Y / maxSize.Y.Scale) + maxSize.Y.Offset
			)
		end
	end

	local padX = 0
	local padY = 0
	local padding = container:FindFirstChildOfClass("UIPadding")
	if padding ~= nil then
		padX = padding.PaddingLeft.Offset + padding.PaddingRight.Offset
		padY = padding.PaddingTop.Offset + padding.PaddingBottom.Offset
	end

	local contentSize

	if layout then
		contentSize = layout.AbsoluteContentSize
	elseif container:IsA("TextButton") or container:IsA("TextLabel") then
		contentSize = container.TextBounds
	else
		contentSize = Vector2.new(0, 0)

		for _, child in container:GetChildren() do
			if child:IsA("GuiObject") then
				local farX = child.Position.X.Offset + child.Size.X.Offset
				local farY = child.Position.Y.Offset + child.Size.Y.Offset

				contentSize = Vector2.new(math.max(contentSize.X, farX), math.max(contentSize.Y, farY))
			end
		end
	end

	local baseX = math.max(contentSize.X + padX, minSize.X)
	local baseY = math.max(contentSize.Y + padY, minSize.Y)

	local x, y
	local xClamped, yClamped

	if axis == Enum.AutomaticSize.XY then
		x = UDim.new(0, baseX)
		y = UDim.new(0, baseY)
		xClamped = UDim.new(0, math.min(baseX, maxSize.X))
		yClamped = UDim.new(0, math.min(baseY, maxSize.Y))
	elseif axis == Enum.AutomaticSize.X then
		x = UDim.new(0, baseX)
		y = container.Size.Y
		xClamped = UDim.new(0, math.min(baseX, maxSize.X))
		yClamped = container.Size.Y
	else
		x = container.Size.X
		y = UDim.new(0, baseY)
		xClamped = container.Size.X
		yClamped = UDim.new(0, math.min(baseY, maxSize.Y))
	end

	if container:IsA("ScrollingFrame") then
		local canvasX = x
		local canvasY = y

		if x.Offset > xClamped.Offset then
			canvasY -= UDim.new(0, container.ScrollBarThickness)
		end
		if y.Offset > yClamped.Offset then
			canvasX -= UDim.new(0, container.ScrollBarThickness)
		end

		container.CanvasSize = UDim2.new(canvasX, canvasY)
	end

	container.Size = UDim2.new(xClamped, yClamped)
end

local function trackParentSize(instance, callback)
	local parent = nil
	local connection = nil

	local function parentChanged(newParent)
		if parent == newParent then
			return
		end

		if connection ~= nil then
			connection:Disconnect()
			connection = nil
		end

		if newParent == nil then
			return
		end

		connection = newParent:GetPropertyChangedSignal("AbsoluteSize"):Connect(callback)
		parent = newParent
	end

	parentChanged(instance.Parent)

	instance:GetPropertyChangedSignal("Parent"):Connect(function()
		parentChanged(instance.Parent)
	end)
end

local defaultOptions = {}

--[=[
	@within Plasma
	@function automaticSize
	@param container GuiObject -- The instance to apply automatic sizing to.
	@param options { axis: Enum.AutomaticSize, maxSize: Vector2 | UDim2, minSize: Vector2 } | nil
	@tag utilities

	Applies padding-aware automatic size to the given GUI instance. This function sets up events to listen to further changes, so
	should only be called once per object.

	Also supports ScrollingFrames by correctly clamping actual and canvas sizes.

	:::note
	If this function is called from the server, if `maxSize` is a UDim2, because of differing screen sizes, it instead
	configures the instance to be compatible with the [Plasma.hydrateAutomaticSize] function, adding the
	CollectionService tag and other attributes.

	You must also call `hydrateAutomaticSize` once on the client for this to work.
	:::

	::warning
	There is currently no way to undo this other than destroying the instance. Once automatic sizing has been applied,
	it is always applied to that instance.
	:::
]=]
local function automaticSize(container, options)
	options = options or defaultOptions

	if options.maxSize then
		container:SetAttribute("maxSize", options.maxSize)
	end

	if options.minSize then
		container:SetAttribute("minSize", options.minSize)
	end

	if options.axis then
		container:SetAttribute("axis", options.axis.Name)
	end

	if not RunService:IsClient() and typeof(container:GetAttribute("maxSize") or nil) == "UDim2" then
		CollectionService:AddTag(container, "PlasmaAutomaticSize")

		return
	end

	local layout = container:FindFirstChildWhichIsA("UIGridStyleLayout")

	applyLayout(container, layout)

	if typeof(container:GetAttribute("maxSize") or nil) == "UDim2" then
		trackParentSize(container, function()
			applyLayout(container, layout)
		end)
	end

	if layout then
		layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
			applyLayout(container, layout)
		end)
	elseif container:IsA("TextLabel") or container:IsA("TextButton") then
		container:GetPropertyChangedSignal("TextBounds"):Connect(function()
			applyLayout(container)
		end)
	else
		local function connect(child)
			if child:IsA("GuiObject") then
				child:GetPropertyChangedSignal("Size"):Connect(function()
					applyLayout(container)
				end)
			end
		end

		for _, child in container:GetChildren() do
			connect(child)
		end

		container.ChildAdded:Connect(function(child)
			applyLayout(container)

			connect(child)
		end)

		container.ChildRemoved:Connect(function()
			applyLayout(container)
		end)
	end

	container:GetAttributeChangedSignal("maxSize"):Connect(function()
		applyLayout(container, layout)
	end)

	container:GetAttributeChangedSignal("minSize"):Connect(function()
		applyLayout(container, layout)
	end)
end

return automaticSize
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000042a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7553183B595C4FE1BD2BF4DED7AA11C9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">create</string>
									<string name="ScriptGuid">{EA9E9A9C-D056-417A-B94C-817FE12CFF67}</string>
									<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Runtime)

--[=[
	@within Plasma
	@function create
	@param className string -- The class name of the Instance to create
	@param props CreateProps
	@return Instance -- The created instance
	@tag utilities

	A function that creates an Instance tree.

	CreateProps is a table:
	- String keys are interpreted as properties to set
	- Numerical keys are interpreted as children
	- Function values are interpreted as event handlers
	- Table keys can be used to get references to instances deep in the tree, the value becomes the key in the table

	This function doesn't do anything special. It just creates an instance.

	```lua
	create("Frame", {
		BackgroundTransparency = 1,
		Name = "Checkbox",

		create("TextButton", {
			BackgroundColor3 = Color3.fromRGB(54, 54, 54),
			Size = UDim2.new(0, 30, 0, 30),

			create("UICorner", {
				CornerRadius = UDim.new(0, 8),
			}),

			Activated = function()
				setClicked(true)
			end,
		}),
	})
	```

	Getting references to instances deep in a tree:

	```lua
	local ref = {}

	create("Frame", {
		create("TextButton", {
			[ref] = "button",
			Text = "hi"
		})
	})

	print(ref.button.Text) --> hi
	```
]=]

local GUI_BASE_2D = {
	"CanvasGroup",
	"Frame",
	"ImageLabel",
	"ScrollingFrame",
	"TextLabel",
	"TextButton",
	"ViewportFrame",
	"TextBox",
	"VideoFrame",
	"ScreenGui",
	"BillboardGui",
	"SurfaceGui",
}

local function create(className, props)
	props = props or {}

	local eventCallback = Runtime.useEventCallback()

	local instance = Instance.new(className)

	if props["AutoLocalize"] == nil and table.find(GUI_BASE_2D, className) then
		props["AutoLocalize"] = false
	end

	for key, value in pairs(props) do
		if type(value) == "function" then
			if eventCallback then
				eventCallback(instance, key, value)
			else
				instance[key]:Connect(value)
			end
		elseif type(key) == "number" then
			value.Parent = instance
		elseif type(key) == "table" then
			key[value] = instance

			if props.Name == nil then
				instance.Name = value
			end
		else
			instance[key] = value
		end
	end

	return instance
end

return create
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000042b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBC44F3B7E7DF472A8ED32CAF1E937C7D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createConnect</string>
									<string name="ScriptGuid">{F89B0079-67CE-4FAD-A136-C9A395FAE509}</string>
									<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Runtime)

local function createConnect()
	local eventCallback = Runtime.useEventCallback()

	return function(instance, eventName, handler)
		if eventCallback then
			return eventCallback(instance, eventName, handler)
		else
			return instance[eventName]:Connect(handler)
		end
	end
end

return createConnect
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000042c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB1E62DB1F87F463DBABDD6D256DAEBA7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">hydrateAutomaticSize</string>
									<string name="ScriptGuid">{6B402F2A-E3C7-4F20-B90C-AE82195383F9}</string>
									<ProtectedString name="Source"><![CDATA[local CollectionService = game:GetService("CollectionService")
local automaticSize = require(script.Parent.automaticSize)

--[=[
	Applies automatic sizing to any current or future instances in the DataModel that are tagged with
	`"PlasmaAutomaticSize"`. Attributes `axis` (string) and `maxSize` (UDim2 or Vector2) are allowed.

	@within Plasma
	@tag utilities
	@client
	@return RBXScriptConnection
]=]
local function hydrateAutomaticSize()
	for _, instance in CollectionService:GetTagged("PlasmaAutomaticSize") do
		automaticSize(instance)
	end

	return CollectionService:GetInstanceAddedSignal("PlasmaAutomaticSize"):Connect(function(instance)
		task.defer(automaticSize, instance) -- instance added signal fires before children are added
	end)
end

return hydrateAutomaticSize
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000042d</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXB2E364A5458E4D88B01290B1BEA25618">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">widgets</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000042e</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX718F7D2EE8DA48108CF654436AEDD636">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">arrow</string>
										<string name="ScriptGuid">{DED1D72E-C3ED-40DE-AD34-A17D8E88B859}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function arrow
	@tag widgets
	@param from Vector3 | CFrame | BasePart
	@param to Vector3 | BasePart | nil
	@param color Color3? -- Optional color. Random if not specified.

	- `arrow(from: Vector3, to: Vector3)` -> Creates an arrow between `from` and `to`
	- `arrow(point: Vector3)` -> Creates an arrow pointing at `point`
	- `arrow(cframe: CFrame)` -> Creates an arrow with its point at the CFrame position facing the CFrame LookVector
	- `arrow(part: BasePart)` -> Arrow represents the Part's CFrame
	- `arrow(fromPart: BasePart, toPart: BasePart)` -> Arrow between the two parts

	![Arrows](https://i.eryn.io/2150/arrows.png)

	```lua
	Plasma.arrow(Vector3.new(0, 0, 0))
	Plasma.arrow(Vector3.new(5, 5, 5), Vector3.new(10, 10, 10))
	```
]=]

local function arrow(name, container, scale, color, zindex)
	local body = Instance.new("CylinderHandleAdornment")

	body.Name = name .. "Body"
	body.Color3 = color
	body.Radius = 0.15
	body.Adornee = workspace.Terrain
	body.Transparency = 0
	body.Radius = 0.15 * scale
	body.Transparency = 0
	body.AlwaysOnTop = true
	body.ZIndex = zindex

	body.Parent = container

	local point = Instance.new("ConeHandleAdornment")

	scale = scale == 1 and 1 or 1.4

	point.Name = name .. "Point"
	point.Color3 = color
	point.Radius = 0.5 * scale
	point.Transparency = 0
	point.Adornee = workspace.Terrain
	point.Height = 2 * scale
	point.AlwaysOnTop = true
	point.ZIndex = zindex

	point.Parent = container
end

local function update(body, point, from, to, scale)
	body.Height = (from - to).magnitude - 2
	body.CFrame = CFrame.lookAt(((from + to) / 2) - ((to - from).unit * 1), to)
	point.CFrame = CFrame.lookAt((CFrame.lookAt(to, from) * CFrame.new(0, 0, -2 - ((scale - 1) / 2))).p, to)
end

local Runtime = require(script.Parent.Parent.Runtime)

return Runtime.widget(function(from, to, color)
	local fallbackColor = Runtime.useState(BrickColor.random().Color)
	color = color or fallbackColor

	if typeof(from) == "Instance" then
		if from:IsA("BasePart") then
			from = from.CFrame
		elseif from:IsA("Attachment") then
			from = from.WorldCFrame
		end

		if to ~= nil then
			from = from.p
		end
	end

	if typeof(to) == "Instance" then
		if to:IsA("BasePart") then
			to = to.Position
		elseif to:IsA("Attachment") then
			to = to.WorldPosition
		end
	end

	if typeof(from) == "CFrame" and to == nil then
		local look = from.lookVector
		to = from.p
		from = to + (look * -10)
	end

	if to == nil then
		to = from
		from = to + Vector3.new(0, 10, 0)
	end

	assert(typeof(from) == "Vector3" and typeof(to) == "Vector3", "Passed parameters are of invalid types")

	local refs = Runtime.useInstance(function(ref)
		local container = Instance.new("Folder")
		container.Name = "Arrow"

		ref.folder = container

		arrow("front", container, 1, color, 1)
		arrow("back", container, 2, Color3.new(0, 0, 0), -1)

		return container
	end)

	local folder = refs.folder

	update(folder.frontBody, folder.frontPoint, from, to, 1)
	update(folder.backBody, folder.backPoint, from, to, 1.4)

	folder.frontBody.Color3 = color
	folder.frontPoint.Color3 = color
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000042f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX328A2F244A644F979AEE0F88E4CD1D0A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">blur</string>
										<string name="ScriptGuid">{F3A7B08B-C022-471D-B4E5-27C85662FA9C}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function blur
	@tag widgets
	@param size number -- The size of the blur

	A blur effect in the world. Created in Lighting.
]=]

local Lighting = game:GetService("Lighting")
local Runtime = require(script.Parent.Parent.Runtime)
local portal = require(script.Parent.portal)

return function(size)
	portal(Lighting, function()
		Runtime.useInstance(function()
			local blur = Instance.new("BlurEffect")
			blur.Size = size
			return blur
		end)
	end)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000430</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX5039757820FD42D997A05477183A7A86">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">button</string>
										<string name="ScriptGuid">{ED448216-AA33-4755-B050-FA057B77CFD8}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function button
	@tag widgets
	@param label string -- The label for the checkbox
	@return ButtonWidgetHandle

	A text button.

	Returns a widget handle, which has the field:

	- `clicked`, a function you can call to check if the checkbox was clicked this frame

	![A button](https://i.eryn.io/2150/RobloxStudioBeta-iwRM0RMx.png)

	```lua
	Plasma.window("Button", function()
		if Plasma.button("button text"):clicked() then
			print("clicked!")
		end
	end)
	```
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local Style = require(script.Parent.Parent.Style)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(text)
	local clicked, setClicked = Runtime.useState(false)
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		return create("TextButton", {
			[ref] = "button",
			BackgroundColor3 = style.bg3,
			BorderSizePixel = 0,
			Font = Enum.Font.Gotham,
			TextColor3 = style.textColor,
			AutomaticSize = Enum.AutomaticSize.XY,
			TextSize = 14,

			create("UIPadding", {
				PaddingLeft = UDim.new(0, 5),
				PaddingRight = UDim.new(0, 5),
				PaddingTop = UDim.new(0, 5),
				PaddingBottom = UDim.new(0, 5),
			}),

			create("UICorner"),

			Activated = function()
				setClicked(true)
			end,
		})
	end)

	local instance = refs.button

	instance.Text = text

	local handle = {
		clicked = function()
			if clicked then
				setClicked(false)
				return true
			end

			return false
		end,
	}

	return handle
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000431</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA1C7903BC5264F538952735D7B5172FD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">checkbox</string>
										<string name="ScriptGuid">{4D676923-0043-4168-AB86-F747C7F628CA}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function checkbox
	@tag widgets
	@param label string -- The label for the checkbox
	@param options {disabled: boolean, checked: boolean}
	@return CheckboxWidgetHandle

	A checkbox. A checkbox may either be controlled or uncontrolled.

	By passing the `checked` field in `options`, you make the checkbox controlled. Controlling the checkbox means that
	the checked state is controlled by your code. Otherwise, the controlled state is controlled by the widget itself.

	Returns a widget handle, which has the fields:

	- `checked`, a function you can call to check if the checkbox is checked
	- `clicked`, a function you can call to check if the checkbox was clicked this frame

	![Checkboxes](https://i.eryn.io/2150/9Yg31gc8.png)

	```lua
	Plasma.window("Checkboxes", function()
		if Plasma.checkbox("Controlled checkbox", {
			checked = checked,
		}):clicked() then
			checked = not checked
		end

		Plasma.checkbox("Disabled checkbox", {
			checked = checked,
			disabled = true,
		})

		Plasma.checkbox("Uncontrolled checkbox")
	end)
	```
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(text, options)
	options = options or {}

	local checked, setChecked = Runtime.useState(false)
	local clicked, setClicked = Runtime.useState(false)

	local refs = Runtime.useInstance(function(ref)
		local Checkbox = create("Frame", {
			[ref] = "checkbox",
			BackgroundTransparency = 1,
			Name = "Checkbox",
			Size = UDim2.new(0, 20, 0, 20),
			AutomaticSize = Enum.AutomaticSize.X,

			create("TextButton", {
				BackgroundColor3 = Color3.fromRGB(54, 54, 54),
				BorderSizePixel = 0,
				Font = Enum.Font.GothamBold,
				Size = UDim2.new(0, 20, 0, 20),
				TextColor3 = Color3.fromRGB(153, 153, 153),
				TextSize = 16,

				create("UICorner", {
					CornerRadius = UDim.new(0, 8),
				}),

				Activated = function()
					setClicked(true)
					setChecked(function(currentlyChecked)
						return not currentlyChecked
					end)
				end,
			}),

			create("TextLabel", {
				BackgroundColor3 = Color3.fromRGB(255, 255, 255),
				Font = Enum.Font.GothamMedium,
				TextColor3 = Color3.fromRGB(203, 203, 203),
				TextSize = 14,
				AutomaticSize = Enum.AutomaticSize.X,
				RichText = true,
			}),

			create("UIListLayout", {
				FillDirection = Enum.FillDirection.Horizontal,
				Padding = UDim.new(0, 10),
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			}),
		})

		return Checkbox
	end)

	local instance = refs.checkbox

	instance.TextLabel.Text = text
	instance.TextButton.AutoButtonColor = not options.disabled

	Runtime.useEffect(function()
		local isChecked
		if options.checked ~= nil then
			isChecked = options.checked
		else
			isChecked = checked
		end

		instance.TextButton.Text = isChecked and "✓" or ""
	end, options.checked, checked)

	Runtime.useEffect(function()
		instance.TextButton.BackgroundColor3 = options.disabled and Color3.fromRGB(112, 112, 112)
			or Color3.fromRGB(54, 54, 54)
	end, options.disabled)

	local handle = {
		checked = function()
			if options.checked or checked then
				return true
			end

			return false
		end,
		clicked = function()
			if clicked then
				setClicked(false)
				return true
			end

			return false
		end,
	}

	return handle
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000432</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF32D2650E36C4008A968F372F7CA21FB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">error</string>
										<string name="ScriptGuid">{6743A840-657C-4615-86FA-00927016AA5E}</string>
										<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

return Runtime.widget(function(text)
	local refs = Runtime.useInstance(function(ref)
		return create("Frame", {
			[ref] = "error",
			BackgroundTransparency = 0,
			BackgroundColor3 = Color3.fromRGB(231, 76, 60),
			Name = "Error",
			AutomaticSize = Enum.AutomaticSize.XY,

			create("UICorner"),

			create("UIPadding", {
				PaddingLeft = UDim.new(0, 10),
				PaddingRight = UDim.new(0, 10),
				PaddingTop = UDim.new(0, 10),
			}),

			create("UIListLayout", {
				Padding = UDim.new(0, 10),
			}),

			create("TextLabel", {
				Font = Enum.Font.GothamBold,
				BackgroundTransparency = 1,
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 20,
				AutomaticSize = Enum.AutomaticSize.XY,
				Text = "⚠️  An Error Occurred",
			}),

			create("TextLabel", {
				Name = "error",
				Font = Enum.Font.GothamMedium,
				BackgroundTransparency = 1,
				TextColor3 = Color3.fromRGB(255, 255, 255),
				TextSize = 16,
				LineHeight = 1.2,
				AutomaticSize = Enum.AutomaticSize.XY,
				TextXAlignment = Enum.TextXAlignment.Left,
				TextYAlignment = Enum.TextYAlignment.Top,
			}),
		})
	end)

	local instance = refs.error

	instance.error.Text = text
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000433</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8ACF5C1DF5D74DE0A049D8ED1A018997">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">heading</string>
										<string name="ScriptGuid">{41328098-8DCE-46AA-B80A-6054CDD7A104}</string>
										<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)
local Style = require(script.Parent.Parent.Style)

--[=[
	@within Plasma
	@function heading
	@param text string
	@param options? {font: Font}
	@tag widgets

	Text, but bigger!
]=]
return Runtime.widget(function(text, options)
	options = options or {}
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		return create("TextLabel", {
			[ref] = "heading",
			BackgroundTransparency = 1,
			Font = Enum.Font.GothamBold,
			AutomaticSize = Enum.AutomaticSize.XY,
			TextColor3 = style.mutedTextColor,
			TextSize = 14,
			RichText = true,
		})
	end)

	local instance = refs.heading
	instance.Text = text
	instance.Font = options.font or Enum.Font.GothamBold
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000434</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX765F2962C8324EEF8117A8A570B18D82">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">highlight</string>
										<string name="ScriptGuid">{E4ABE61C-DAE5-485A-A3FE-9336D79806F0}</string>
										<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

--[=[
	@interface HighlightOptions
	@within Plasma

	.outlineColor?: Color3
	.fillColor?: Color3
	.fillTransparency?: number
	.outlineTransparency?: number
	.fillMode?: HighlightFillMode
]=]

--[=[
	@within Plasma
	@function highlight
	@param adornee Instance
	@param options? HighlightOptions


	Creates a highlight over an instance with the specified options, using the Roblox [Highlight] instance
]=]
return Runtime.widget(function(adornee, options)
	options = options or {}

	local refs = Runtime.useInstance(function(ref)
		return create("Highlight", {
			[ref] = "highlight",
		})
	end)

	refs.highlight.Adornee = adornee

	Runtime.useEffect(function()
		refs.highlight.OutlineColor = options.outlineColor or Color3.new(1, 1, 1)
		refs.highlight.FillColor = options.fillColor or Color3.new(1, 0, 0)
	end, options.fillColor, options.outlineColor)

	refs.highlight.FillTransparency = options.fillTransparency or 0.5
	refs.highlight.OutlineTransparency = options.outlineTransparency or 0
	refs.highlight.DepthMode = options.depthMode or Enum.HighlightDepthMode.AlwaysOnTop
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000435</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXAA6212E629064BAD9048583F0CAD4AB0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">label</string>
										<string name="ScriptGuid">{71885C66-B7F4-4F6C-A498-6CB434687628}</string>
										<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)
local Style = require(script.Parent.Parent.Style)
local automaticSize = require(script.Parent.Parent.automaticSize)

--[=[
	@within Plasma
	@function label
	@param text string
	@tag widgets

	Text.
]=]
return Runtime.widget(function(text)
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		create("TextLabel", {
			[ref] = "label",
			BackgroundTransparency = 1,
			Font = Enum.Font.Gotham,
			TextColor3 = style.textColor,
			TextSize = 16,
			RichText = true,
		})

		automaticSize(ref.label)

		return ref.label
	end)

	refs.label.Text = text
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000436</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA975CD934AA84E8F80FA035B6E5AA7BD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">portal</string>
										<string name="ScriptGuid">{1574FE8A-32B5-4449-B2E4-4F3394ADFFCF}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function portal
	@tag widgets
	@param targetInstance Instance -- Where the portal goes to
	@param children () -> () -- Children

	The portal widget creates its children inside the specified `targetInstance`. For example, you could use this
	to create lighting effects in Lighting as a widget:


	```lua
	return function(size)
		portal(Lighting, function()
			useInstance(function()
				local blur = Instance.new("BlurEffect")
				blur.Size = size
				return blur
			end)
		end)
	end
	```
]=]

local Runtime = require(script.Parent.Parent.Runtime)

return Runtime.widget(function(targetInstance, fn)
	Runtime.useInstance(function()
		return nil, targetInstance
	end)

	Runtime.scope(fn)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000437</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX85088ECA270A4A6F87AEFEB70B70500D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">row</string>
										<string name="ScriptGuid">{0C10ACC3-C18B-4E61-9F9A-9BF320D7592D}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function row
	@tag widgets
	@param options {padding: Vector2}
	@param children () -> () -- Children

	Lays out children horizontally
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local automaticSize = require(script.Parent.Parent.automaticSize)

return Runtime.widget(function(options, fn)
	if type(options) == "function" and fn == nil then
		fn = options
		options = {}
	end

	if options.padding then
		if type(options.padding) == "number" then
			options.padding = UDim.new(0, options.padding)
		end
	else
		options.padding = UDim.new(0, 10)
	end

	local refs = Runtime.useInstance(function(ref)
		local Frame = Instance.new("Frame")
		Frame.BackgroundTransparency = 1
		Frame.AutoLocalize = false

		local UIListLayout = Instance.new("UIListLayout")
		UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
		UIListLayout.FillDirection = Enum.FillDirection.Horizontal
		UIListLayout.Padding = options.padding
		UIListLayout.Parent = Frame

		ref.frame = Frame

		automaticSize(Frame)

		return Frame
	end)

	local frame = refs.frame

	frame.UIListLayout.HorizontalAlignment = options.alignment or Enum.HorizontalAlignment.Left
	frame.UIListLayout.VerticalAlignment = options.verticalAlignment or Enum.VerticalAlignment.Top

	Runtime.scope(fn)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000438</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX988572BF5780481886917A639FF49F2F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">slider</string>
										<string name="ScriptGuid">{B623A335-373C-4CE5-864C-671F9F1B3DFC}</string>
										<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local Runtime = require(script.Parent.Parent.Runtime)
local Style = require(script.Parent.Parent.Style)
local create = require(script.Parent.Parent.create)
local createConnect = require(script.Parent.Parent.createConnect)

return Runtime.widget(function(options)
	if type(options) == "number" then
		options = {
			max = options,
		}
	end

	local min = options.min or 0
	local max = options.max or 1
	local initial = options.initial or 0
	local initPercent = (initial - min) / (max - min)
	local percentageValue, setPercentageValue = Runtime.useState(initPercent)

	local refs = Runtime.useInstance(function(ref)
		local connect = createConnect()

		local style = Style.get()

		local connection

		local frame = create("Frame", {
			[ref] = "frame",
			BackgroundTransparency = 1,
			Size = UDim2.new(0, 200, 0, 30),

			create("Frame", {
				Name = "line",
				Size = UDim2.new(1, 0, 0, 2),
				BackgroundColor3 = style.mutedTextColor,
				BorderSizePixel = 0,
				Position = UDim2.new(0, 0, 0.5, 0),
			}),

			create("TextButton", {
				Name = "dot",
				[ref] = "dot",
				Size = UDim2.new(0, 15, 0, 15),
				AnchorPoint = Vector2.new(0.5, 0.5),
				BackgroundColor3 = style.textColor,
				Position = UDim2.new(0, 0, 0.5, 0),
				Text = "",

				create("UICorner", {
					CornerRadius = UDim.new(1, 0),
				}),

				InputBegan = function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then
						return
					end

					if connection then
						connection:Disconnect()
					end

					connection = connect(UserInputService, "InputChanged", function(moveInput)
						if moveInput.UserInputType ~= Enum.UserInputType.MouseMovement then
							return
						end

						local x = moveInput.Position.X

						local maxPos = ref.frame.AbsoluteSize.X - ref.dot.AbsoluteSize.X
						x -= ref.frame.AbsolutePosition.X + ref.dot.AbsoluteSize.X / 2
						x = math.clamp(x, 0, maxPos)

						local percent = x / maxPos

						setPercentageValue(percent)
					end)
				end,

				InputEnded = function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then
						return
					end

					if connection then
						connection:Disconnect()
						connection = nil
					end
				end,
			}),
		})

		return frame
	end)

	local maxPos = refs.frame.AbsoluteSize.X - refs.frame.dot.AbsoluteSize.X
	refs.frame.dot.Position = UDim2.new(0, percentageValue * maxPos + refs.frame.dot.AbsoluteSize.X / 2, 0.5, 0)

	local value = percentageValue * (max - min) + min
	return value
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000439</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9873866DC6944B7E82A1DADAB89B399A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">space</string>
										<string name="ScriptGuid">{8909939F-25D9-471F-92AF-BAF973E056E3}</string>
										<ProtectedString name="Source"><![CDATA[local Runtime = require(script.Parent.Parent.Runtime)
local create = require(script.Parent.Parent.create)

--[=[
	@within Plasma
	@function space
	@param size number

	Blank space of a certain size.

]=]
return Runtime.widget(function(size)
	local refs = Runtime.useInstance(function(ref)
		return create("Frame", {
			[ref] = "space",
			BackgroundTransparency = 1,
		})
	end)

	Runtime.useEffect(function()
		refs.space.Size = UDim2.new(0, size, 0, size)
	end, size)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000043a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX21C2B89D8D614F3F90F1C1B2D6140E2B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">spinner</string>
										<string name="ScriptGuid">{67EE0DBC-52E3-4571-9287-96E6DA2C7B4A}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	@within Plasma
	@function spinner
	@tag widgets

	A spinner widget, indicating loading.

	![A spinner](https://i.eryn.io/2150/RobloxStudioBeta-sEyci8qy.png)
]=]

local RunService = game:GetService("RunService")
local Runtime = require(script.Parent.Parent.Runtime)

return Runtime.widget(function()
	local refs = Runtime.useInstance(function(ref)
		local Frame = Instance.new("Frame")
		Frame.BackgroundTransparency = 1
		Frame.Size = UDim2.new(0, 100, 0, 100)
		Frame.AutoLocalize = false

		local ImageLabel = Instance.new("ImageLabel")
		ImageLabel.AnchorPoint = Vector2.new(0.5, 0.5)
		ImageLabel.BackgroundTransparency = 1
		ImageLabel.Image = "rbxassetid://2689141406"
		ImageLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
		ImageLabel.Size = UDim2.new(0, 100, 0, 100)
		ImageLabel.AutoLocalize = false
		ImageLabel.Parent = Frame

		ref.frame = Frame

		return Frame
	end)

	Runtime.useEffect(function()
		local connection = RunService.RenderStepped:Connect(function()
			refs.frame.ImageLabel.Rotation = os.clock() * 100 % 360
		end)

		return function()
			connection:Disconnect()
		end
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000043b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXC537E934D1C04866A9914183F48F559C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">table</string>
										<string name="ScriptGuid">{06A8A6B0-E22F-4BBB-8C20-09A578503B23}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Runtime = require(script.Parent.Parent.Runtime)
local Style = require(script.Parent.Parent.Style)
local create = require(script.Parent.Parent.create)
local automaticSize = require(script.Parent.Parent.automaticSize)

local cell = Runtime.widget(function(text, font)
	local clicked, setClicked = Runtime.useState(false)
	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		return create("TextButton", {
			[ref] = "button",
			BackgroundTransparency = 1,
			Font = Enum.Font.Gotham,
			AutomaticSize = Enum.AutomaticSize.XY,
			TextColor3 = style.textColor,
			TextSize = 16,
			TextXAlignment = Enum.TextXAlignment.Left,
			RichText = true,
			AutoButtonColor = false,
			Active = true,

			Activated = function()
				setClicked(true)
			end,

			create("UIPadding", {
				PaddingBottom = UDim.new(0, 6),
				PaddingLeft = UDim.new(0, 6),
				PaddingRight = UDim.new(0, 6),
				PaddingTop = UDim.new(0, 6),
			}),
		})
	end)

	refs.button.Font = font or Enum.Font.Gotham
	refs.button.Text = text

	return {
		clicked = function()
			if clicked then
				setClicked(false)
				return true
			end

			return false
		end,
	}
end)

local row = Runtime.widget(function(columns, darken, selectable, font)
	local clicked, setClicked = Runtime.useState()
	local hovering, setHovering = Runtime.useState(false)
	local selected = columns.selected

	local refs = Runtime.useInstance(function(ref)
		return create("TextLabel", {
			[ref] = "row",
			BackgroundTransparency = if darken then 0.7 else 1,
			BackgroundColor3 = Color3.fromRGB(0, 0, 0),
			Text = "",
			Active = false,

			MouseEnter = function()
				setHovering(true)
			end,

			MouseLeave = function()
				setHovering(false)
			end,
		})
	end)

	refs.row.Active = selectable and not selected or false

	local transparency = 1

	if selected then
		transparency = 0
	elseif hovering and selectable then
		transparency = 0.4
	elseif darken then
		transparency = 0.7
	end

	refs.row.BackgroundTransparency = transparency
	refs.row.BackgroundColor3 = selected and Color3.fromHex("bd515c") or Color3.fromRGB(0, 0, 0)

	for index, column in ipairs(columns) do
		if type(column) == "function" then
			Runtime.scope(column)
		else
			if cell(column, font):clicked() then
				setClicked(index)
			end
		end
	end

	return {
		clicked = function()
			if clicked then
				setClicked(nil)
				return clicked
			end

			return nil
		end,
		hovered = function()
			return hovering
		end,
	}
end)

--[=[
	@within Plasma
	@function table
	@param items {{string}}
	@param options {marginTop?: number, selectable?: boolean, font?: Font, headings?: boolean}
	@tag widgets
	@return TableWidgetHandle

	A table widget. Items is a list of rows, with each row being a list of cells. 

	Returns a widget handle, which has the fields:

	- `selected`, a function you can call to check what row and cell were selected this frame, if any
	- `selectedHeading`, a function you can call to check which heading was selected this frame, if any
	- `hovered`, a function you can call to check what row is being hovered over

	```lua
	local items = {
		{"cell one", "cell two"},
		{"cell three", "cell four"}
	}
	```

	![Table](https://i.eryn.io/2227/NEc4Dmnv.png)
]=]
return Runtime.widget(function(items, options)
	options = options or {}

	Runtime.useInstance(function(ref)
		create("Frame", {
			[ref] = "table",
			BackgroundTransparency = 1,
			Position = UDim2.new(0, 0, 0, options.marginTop or 0),

			create("UITableLayout", {
				[ref] = "layout",
				SortOrder = Enum.SortOrder.LayoutOrder,
			}),
		})

		local connection

		connection = ref.table:GetPropertyChangedSignal("Parent"):Connect(function()
			connection:Disconnect()
			connection = nil

			RunService.Heartbeat:Wait()
			RunService.Heartbeat:Wait()

			-- Wtf roblox

			for _, child in ref.table:GetChildren() do
				if child:IsA("GuiObject") then
					child.Visible = false
				end
			end

			local _ = ref.layout.AbsoluteContentSize

			for _, child in ref.table:GetChildren() do
				if child:IsA("GuiObject") then
					child.Visible = true
				end
			end
		end)

		automaticSize(ref.table)

		return ref.table
	end)

	local selected, setSelected = Runtime.useState()
	local selectedHeading, setSelectedHeading = Runtime.useState()
	local hovered

	for i, columns in items do
		local selectable = options.selectable
		local font = options.font
		local isHeading = options.headings and i == 1

		if isHeading then
			font = Enum.Font.GothamBold
		end

		local currentRow = row(columns, i % 2 == 1, selectable, font)
		local clickedCell = currentRow:clicked()
		if clickedCell then
			if isHeading then
				setSelectedHeading(clickedCell)
			else
				setSelected({ row = columns, cellIndex = clickedCell })
			end
		end

		if currentRow:hovered() then
			hovered = columns
		end
	end

	return {
		selectedHeading = function()
			if selectedHeading then
				setSelectedHeading(nil)
				return selectedHeading
			end

			return nil
		end,
		selected = function()
			if selected then
				setSelected(nil)
				return selected.row, selected.cellIndex
			end

			return nil
		end,
		hovered = function()
			return hovered
		end,
	}
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000043c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8A3F96E906F84A119DD0273FEF7D56B5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">window</string>
										<string name="ScriptGuid">{9BCDC534-C5D9-45BD-8A5E-45FF4C81C8F7}</string>
										<ProtectedString name="Source"><![CDATA[local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

--[=[
	@interface WindowOptions
	@within Plasma

	.title? string
	.closable? boolean
	.movable? boolean
	.resizable? boolean
]=]

--[=[
	@within Plasma
	@function window
	@param options string | WindowOptions -- The title of the window, or options
	@param children () -> () -- Children
	@tag widgets
	@return WindowWidgetHandle

	A window widget. Contains children.

	- Closable
	- Draggable
	- Resizable

	Returns a widget handle, which has the field:

	- `closed`, a function you can call to check if the close button was clicked.

	![Window with checkboxes](https://i.eryn.io/2150/TVkkOnxj.png)
]=]

local Runtime = require(script.Parent.Parent.Runtime)
local createConnect = require(script.Parent.Parent.createConnect)
local Style = require(script.Parent.Parent.Style)
local automaticSize = require(script.Parent.Parent.automaticSize)
local c = require(script.Parent.Parent.create)

local MIN_SIZE = Vector2.new(50, 50)
local MAX_SIZE = Vector2.new(1500, 500)

return Runtime.widget(function(options, fn)
	local closed, setClosed = Runtime.useState(false)

	local refs = Runtime.useInstance(function(ref)
		local style = Style.get()

		local dragConnection

		local connect = createConnect()

		c("Frame", {
			[ref] = "frame",
			BackgroundColor3 = style.bg2,
			Position = UDim2.new(0, 0, 0, 0),
			Size = UDim2.new(0, 50, 0, 40),

			c("UICorner", {}),

			c("UIPadding", {
				PaddingBottom = UDim.new(0, 20),
				PaddingLeft = UDim.new(0, 20),
				PaddingRight = UDim.new(0, 20),
				PaddingTop = UDim.new(0, 20),
			}),

			c("UIStroke", {}),

			c("TextButton", {
				[ref] = "titleBar",
				Size = UDim2.new(1, 0, 0, 0),
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundTransparency = 1,
				Text = "",

				InputBegan = function(clickInput)
					if not ref.titleBar.Active then
						return
					end
					if clickInput.UserInputType ~= Enum.UserInputType.MouseButton1 then
						return
					end

					local lastMousePosition = clickInput.Position

					if
						ref.frame.Parent:FindFirstChildWhichIsA("UIGridStyleLayout")
						and not ref.frame.Parent:IsA("ScreenGui")
					then
						local beforePosition = ref.frame.AbsolutePosition

						local screenGui = ref.frame:FindFirstAncestorOfClass("ScreenGui")

						if screenGui.IgnoreGuiInset then
							beforePosition += GuiService:GetGuiInset()
						end

						ref.frame.Parent = screenGui
						ref.frame.Position = UDim2.new(0, beforePosition.X, 0, beforePosition.Y)
					end

					dragConnection = connect(UserInputService, "InputChanged", function(moveInput)
						if moveInput.UserInputType ~= Enum.UserInputType.MouseMovement then
							return
						end

						local delta = lastMousePosition - moveInput.Position

						lastMousePosition = moveInput.Position

						ref.frame.Position = ref.frame.Position - UDim2.new(0, delta.X, 0, delta.Y)
					end)
				end,

				InputEnded = function(input)
					if dragConnection and input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragConnection:Disconnect()
						dragConnection = nil
					end
				end,

				c("Frame", {
					[ref] = "handle",
					Position = UDim2.new(0, -5, 0, 0),

					c("TextLabel", {
						Text = "..",
						Position = UDim2.new(0, 0, 0, 0),
						BackgroundTransparency = 1,
						TextSize = 16,
						TextColor3 = style.mutedTextColor,
					}),

					c("TextLabel", {
						Text = "..",
						Position = UDim2.new(0, 0, 0, 7),
						BackgroundTransparency = 1,
						TextSize = 16,
						TextColor3 = style.mutedTextColor,
					}),

					c("TextLabel", {
						Text = "..",
						Position = UDim2.new(0, 0, 0, -7),
						BackgroundTransparency = 1,
						TextSize = 16,
						TextColor3 = style.mutedTextColor,
					}),
				}),

				c("TextLabel", {
					[ref] = "title",
					BackgroundTransparency = 1,
					Font = Enum.Font.GothamBold,
					Size = UDim2.new(1, 0, 1, 0),
					TextColor3 = style.mutedTextColor,
					TextSize = 14,
					TextXAlignment = Enum.TextXAlignment.Left,
					TextYAlignment = Enum.TextYAlignment.Top,
					TextTruncate = Enum.TextTruncate.AtEnd,
				}),

				c("TextButton", {
					[ref] = "close",
					BackgroundColor3 = Color3.fromHex("e74c3c"),
					Size = UDim2.new(0, 14, 0, 14),
					Text = "",
					AnchorPoint = Vector2.new(0.5, 0),
					Position = UDim2.new(1, -10, 0, 0),
					TextColor3 = Color3.fromHex("#71190f"),
					TextSize = 16,
					Font = Enum.Font.Gotham,

					MouseEnter = function()
						ref.close.Text = "x"
					end,

					MouseLeave = function()
						ref.close.Text = ""
					end,

					Activated = function()
						setClosed(true)
					end,

					c("UICorner", {
						CornerRadius = UDim.new(1, 0),
					}),
				}),
			}),

			c("ScrollingFrame", {
				[ref] = "container",
				BackgroundTransparency = 1,
				VerticalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
				HorizontalScrollBarInset = Enum.ScrollBarInset.ScrollBar,
				BorderSizePixel = 0,
				ScrollBarThickness = 6,
				Position = UDim2.new(0, 0, 0, 25),

				c("UIListLayout", {
					SortOrder = Enum.SortOrder.LayoutOrder,
					Padding = UDim.new(0, 10),
				}),
			}),

			c("TextButton", {
				[ref] = "resizeHandle",
				Size = UDim2.new(0, 20, 0, 20),
				Text = "≡",
				Font = Enum.Font.Gotham,
				TextSize = 16,
				Rotation = -45,
				BackgroundTransparency = 1,
				TextColor3 = style.mutedTextColor,
				Position = UDim2.new(1, 0, 1, 0),

				InputBegan = function(clickInput)
					if clickInput.UserInputType ~= Enum.UserInputType.MouseButton1 then
						return
					end

					local initialMousePosition = clickInput.Position
					local initialSize = ref.container.AbsoluteSize

					dragConnection = connect(UserInputService, "InputChanged", function(moveInput)
						if moveInput.UserInputType ~= Enum.UserInputType.MouseMovement then
							return
						end

						local delta = Vector2.new(
							(moveInput.Position.X - initialMousePosition.X),
							(moveInput.Position.Y - initialMousePosition.Y)
						)

						local size = initialSize + delta

						ref.container:SetAttribute(
							"maxSize",
							Vector2.new(math.max(MIN_SIZE.X, size.X), math.max(MIN_SIZE.Y, size.Y))
						)
					end)
				end,

				InputEnded = function(input)
					if dragConnection and input.UserInputType == Enum.UserInputType.MouseButton1 then
						dragConnection:Disconnect()
						dragConnection = nil
					end
				end,
			}),
		})

		automaticSize(ref.container)
		automaticSize(ref.frame)

		return ref.frame, ref.container
	end)

	if type(options) == "string" then
		options = {
			title = options,
		}
	end

	local movable = if options.movable ~= nil then options.movable else true
	local resizable = if options.resizable ~= nil then options.movable else true

	refs.close.Visible = options.closable or false
	refs.handle.Visible = movable
	refs.titleBar.Active = movable
	refs.resizeHandle.Visible = resizable

	refs.title.Size = UDim2.new(1, if options.closable then -30 else 0, 1, 0)

	local spaces = if movable then "  " else ""
	refs.title.Text = options.title and spaces .. string.upper(options.title) or ""

	Runtime.useEffect(function()
		refs.container:SetAttribute("maxSize", options.maxSize or MAX_SIZE)
	end, options.maxSize)

	Runtime.useEffect(function()
		refs.container:SetAttribute("minSize", options.minSize)
	end, options.minSize)

	Runtime.scope(fn)

	local handle = {
		closed = function()
			if closed then
				setClosed(false)
				return true
			end

			return false
		end,
	}

	return handle
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000043d</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXFD1579F5F71C47A9B23B98518221E43B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">testez</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000056d</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXF02508D754F7488799FEDAA889D8F022">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{C2DD9A86-DC03-4BC8-BF93-07B1ACA85ADA}</string>
								<ProtectedString name="Source"><![CDATA[local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000056e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX7045C8A7CE8348C5BFD675CFA92EF2C3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Context</string>
									<string name="ScriptGuid">{85BCDB4C-74A3-4A4F-B0FF-A10035FA015F}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000056f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3B1234CE28D74602B3C40ACB1DB553FF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Expectation</string>
									<string name="ScriptGuid">{C844BEE2-BF31-45C8-849A-2DF4039D5B29}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end

function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()
			return self
		end)
	end

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (typeof(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

-- Make alias public on class
Expectation.an = Expectation.a

--[[
	Assert that our expectation value is not nil
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called.
	An optional error message can be passed to assert that the error message
	contains the given value.
]]
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(self.successCondition,
			("Expected function to throw an error containing %q, but it %s"):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			("Expected function to never throw an error containing %q, but it threw: %s"):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(
				tostring(err)
			)
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000570</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA0680F654FED471092EFAC33B0D6BD69">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ExpectationContext</string>
									<string name="ScriptGuid">{6161D4C0-F0AE-48E9-8528-EF8B2C56412A}</string>
									<ProtectedString name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}
ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end

function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end

function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000571</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5A4F2DEAE9E84950989CE411533D0E7D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">LifecycleHooks</string>
									<string name="ScriptGuid">{EE8F610A-269D-4683-BC42-FE704A31D96A}</string>
									<ProtectedString name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000572</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXB807AF80AA0A4089BBEE5923A9883FE8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Reporters</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000573</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXE2648404976C4D9A8B9E4EDD4E8B90F8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TeamCityReporter</string>
										<string name="ScriptGuid">{12A04DB4-BB2F-41B0-98CF-77C9E31C45DE}</string>
										<ProtectedString name="Source"><![CDATA[local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000574</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX82F136F83EFC4A07A509194A46808CB1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TextReporter</string>
										<string name="ScriptGuid">{6D7C4DAB-FF5C-49C1-904B-2D0F528D87E6}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() < b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000575</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXC034E4C077314CA68447DA88DF5A1266">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TextReporterQuiet</string>
										<string name="ScriptGuid">{AADA203D-2514-4CF4-9E7E-201EB515C721}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000576</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX4DE97CB062C64A9D978A78C744B578B4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestBootstrap</string>
									<string name="ScriptGuid">{77E56469-7DBF-4471-8169-0E8A1F3C7791}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000577</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX08A8F1D7FDD54360AA776A24AB875E5D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestEnum</string>
									<string name="ScriptGuid">{E3E68634-770E-4845-BD03-E72D1150C29F}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000578</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE1BA8340ED59435EA3970F2FE2100331">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestPlan</string>
									<string name="ScriptGuid">{64864C73-0463-479A-9E4A-25ACC37AC0D4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = setmetatable({
		extend = function(...)
			error("Cannot call \"expect.extend\" from within a \"describe\" node.")
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	-- Copy 'script' directly to new env to make Studio debugger happy.
	-- Studio debugger does not look into __index, because of security reasons
	callbackEnv.script = originalEnv.script
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000579</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBCA46E13599E4CEFAD0E0DE90895B35D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestPlanner</string>
									<string name="ScriptGuid">{08C230C8-9FC1-4B84-9168-D3FF6C6B144A}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting < b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000057a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX55CCB9A4FA274FC5A8502462220BC768">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestResults</string>
									<string name="ScriptGuid">{10B5D82C-2F9B-4AE6-A8A6-B721E0F7B98B}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000057b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8CF75FDE61574354AD1365A249DC164D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestRunner</string>
									<string name="ScriptGuid">{D3011A01-134A-4D6C-B5CF-38F663F41011}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end

		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. debug.traceback(tostring(message), 2)
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				if not testSuccess then
					return false, testErrorMessage .. "\nWhile cleaning up the failed test another error was found:\n" .. errorMessage
				end
				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000057c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX099ECBF711EF4D66AC6B3EF0DD836395">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TestSession</string>
									<string name="ScriptGuid">{D08E456D-BE54-48B3-8243-62D0D2339092}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)
	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)
	table.insert(self.expectationContextStack, expectationContext)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end


function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")
	return self.expectationContextStack[#self.expectationContextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000057d</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX85BD45AC30DB4CCB905D49A5B8232163">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">t</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000056a</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX3970111793684F6E9A098EF7C3630F5F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">lib</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000056b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX16F10CDC74624B1D913D93AFF04C3035">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ts</string>
									<string name="ScriptGuid">{86376F0A-0F4D-432B-B6EF-C6D17D1B3F45}</string>
									<ProtectedString name="Source"><![CDATA[-- t: a runtime typechecker for Roblox

local t = {}

function t.type(typeName)
	return function(value)
		local valueType = type(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

function t.typeof(typeName)
	return function(value)
		local valueType = typeof(value)
		if valueType == typeName then
			return true
		else
			return false
		end
	end
end

--[[**
	matches any type except nil

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.any(value)
	if value ~= nil then
		return true
	else
		return false
	end
end

--Lua primitives

--[[**
	ensures Lua primitive boolean type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.boolean = t.typeof("boolean")

--[[**
	ensures Lua primitive buffer type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.buffer = t.typeof("buffer")

--[[**
	ensures Lua primitive thread type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.thread = t.typeof("thread")

--[[**
	ensures Lua primitive callback type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.callback = t.typeof("function")
t["function"] = t.callback

--[[**
	ensures Lua primitive none type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.none = t.typeof("nil")
t["nil"] = t.none

--[[**
	ensures Lua primitive string type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.string = t.typeof("string")

--[[**
	ensures Lua primitive table type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.table = t.typeof("table")

--[[**
	ensures Lua primitive userdata type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.userdata = t.type("userdata")

--[[**
	ensures Lua primitive vector type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.vector = t.type("vector")

--[[**
	ensures value is a number and non-NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.number(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value == value then
			return true
		else
			return false
		end
	else
		return false
	end
end

--[[**
	ensures value is NaN

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.nan(value)
	local valueType = typeof(value)
	if valueType == "number" then
		if value ~= value then
			return true
		else
			return false
		end
	else
		return false
	end
end

-- roblox types

--[[**
	ensures Roblox Axes type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Axes = t.typeof("Axes")

--[[**
	ensures Roblox BrickColor type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.BrickColor = t.typeof("BrickColor")

--[[**
	ensures Roblox CatalogSearchParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CatalogSearchParams = t.typeof("CatalogSearchParams")

--[[**
	ensures Roblox CFrame type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.CFrame = t.typeof("CFrame")

--[[**
	ensures Roblox Color3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Color3 = t.typeof("Color3")

--[[**
	ensures Roblox ColorSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequence = t.typeof("ColorSequence")

--[[**
	ensures Roblox ColorSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.ColorSequenceKeypoint = t.typeof("ColorSequenceKeypoint")

--[[**
	ensures Roblox DateTime type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DateTime = t.typeof("DateTime")

--[[**
	ensures Roblox DockWidgetPluginGuiInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.DockWidgetPluginGuiInfo = t.typeof("DockWidgetPluginGuiInfo")

--[[**
	ensures Roblox Enum type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enum = t.typeof("Enum")

--[[**
	ensures Roblox EnumItem type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.EnumItem = t.typeof("EnumItem")

--[[**
	ensures Roblox Enums type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Enums = t.typeof("Enums")

--[[**
	ensures Roblox Faces type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Faces = t.typeof("Faces")

--[[**
	ensures Roblox FloatCurveKey type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.FloatCurveKey = t.typeof("FloatCurveKey")

--[[**
	ensures Roblox Font type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Font = t.typeof("Font")

--[[**
	ensures Roblox Instance type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Instance = t.typeof("Instance")

--[[**
	ensures Roblox NumberRange type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberRange = t.typeof("NumberRange")

--[[**
	ensures Roblox NumberSequence type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequence = t.typeof("NumberSequence")

--[[**
	ensures Roblox NumberSequenceKeypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.NumberSequenceKeypoint = t.typeof("NumberSequenceKeypoint")

--[[**
	ensures Roblox OverlapParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.OverlapParams = t.typeof("OverlapParams")

--[[**
	ensures Roblox PathWaypoint type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PathWaypoint = t.typeof("PathWaypoint")

--[[**
	ensures Roblox PhysicalProperties type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.PhysicalProperties = t.typeof("PhysicalProperties")

--[[**
	ensures Roblox Random type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Random = t.typeof("Random")

--[[**
	ensures Roblox Ray type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Ray = t.typeof("Ray")

--[[**
	ensures Roblox RaycastParams type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastParams = t.typeof("RaycastParams")

--[[**
	ensures Roblox RaycastResult type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RaycastResult = t.typeof("RaycastResult")

--[[**
	ensures Roblox RBXScriptConnection type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptConnection = t.typeof("RBXScriptConnection")

--[[**
	ensures Roblox RBXScriptSignal type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.RBXScriptSignal = t.typeof("RBXScriptSignal")

--[[**
	ensures Roblox Rect type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Rect = t.typeof("Rect")

--[[**
	ensures Roblox Region3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3 = t.typeof("Region3")

--[[**
	ensures Roblox Region3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Region3int16 = t.typeof("Region3int16")

--[[**
	ensures Roblox TweenInfo type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.TweenInfo = t.typeof("TweenInfo")

--[[**
	ensures Roblox UDim type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim = t.typeof("UDim")

--[[**
	ensures Roblox UDim2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.UDim2 = t.typeof("UDim2")

--[[**
	ensures Roblox Vector2 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2 = t.typeof("Vector2")

--[[**
	ensures Roblox Vector2int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector2int16 = t.typeof("Vector2int16")

--[[**
	ensures Roblox Vector3 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3 = t.typeof("Vector3")

--[[**
	ensures Roblox Vector3int16 type

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
t.Vector3int16 = t.typeof("Vector3int16")

--[[**
	ensures value is a given literal value

	@param literal The literal to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.literal(...)
	local size = select("#", ...)
	if size == 1 then
		local literal = ...
		return function(value)
			if value ~= literal then
				return false
			end

			return true
		end
	else
		local literals = {}
		for i = 1, size do
			local value = select(i, ...)
			literals[i] = t.literal(value)
		end

		return t.union(table.unpack(literals, 1, size))
	end
end

--[[**
	DEPRECATED
	Please use t.literal
**--]]
t.exactly = t.literal

--[[**
	Returns a t.union of each key in the table as a t.literal

	@param keyTable The table to get keys from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.keyOf(keyTable)
	local keys = {}
	local length = 0
	for key in pairs(keyTable) do
		length = length + 1
		keys[length] = key
	end

	return t.literal(table.unpack(keys, 1, length))
end

--[[**
	Returns a t.union of each value in the table as a t.literal

	@param valueTable The table to get values from

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.valueOf(valueTable)
	local values = {}
	local length = 0
	for _, value in pairs(valueTable) do
		length = length + 1
		values[length] = value
	end

	return t.literal(table.unpack(values, 1, length))
end

--[[**
	ensures value is an integer

	@param value The value to check against

	@returns True iff the condition is satisfied, false otherwise
**--]]
function t.integer(value)
	local success = t.number(value)
	if not success then
		return false
	end

	if value % 1 == 0 then
		return true
	else
		return false
	end
end

--[[**
	ensures value is a number where min <= value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMin(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value >= min then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value <= max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMax(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value <= max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where min < value

	@param min The minimum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMinExclusive(min)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if min < value then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value < max

	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberMaxExclusive(max)
	return function(value)
		local success = t.number(value)
		if not success then
			return false
		end

		if value < max then
			return true
		else
			return false
		end
	end
end

--[[**
	ensures value is a number where value > 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberPositive = t.numberMinExclusive(0)

--[[**
	ensures value is a number where value < 0

	@returns A function that will return true iff the condition is passed
**--]]
t.numberNegative = t.numberMaxExclusive(0)

--[[**
	ensures value is a number where min <= value <= max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrained(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMin(min)
	local maxCheck = t.numberMax(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a number where min < value < max

	@param min The minimum to use
	@param max The maximum to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.numberConstrainedExclusive(min, max)
	assert(t.number(min))
	assert(t.number(max))
	local minCheck = t.numberMinExclusive(min)
	local maxCheck = t.numberMaxExclusive(max)

	return function(value)
		local minSuccess = minCheck(value)
		if not minSuccess then
			return false
		end

		local maxSuccess = maxCheck(value)
		if not maxSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value matches string pattern

	@param string pattern to check against

	@returns A function that will return true iff the condition is passed
**--]]
function t.match(pattern)
	assert(t.string(pattern))
	return function(value)
		local stringSuccess = t.string(value)
		if not stringSuccess then
			return false
		end

		if string.match(value, pattern) == nil then
			return false
		end

		return true
	end
end

--[[**
	ensures value is either nil or passes check

	@param check The check to use

	@returns A function that will return true iff the condition is passed
**--]]
function t.optional(check)
	assert(t.callback(check))
	return function(value)
		if value == nil then
			return true
		end

		local success = check(value)
		if success then
			return true
		else
			return false
		end
	end
end

--[[**
	matches given tuple against tuple type definition

	@param ... The type definition for the tuples

	@returns A function that will return true iff the condition is passed
**--]]
function t.tuple(...)
	local checks = { ... }
	return function(...)
		local args = { ... }
		for i, check in ipairs(checks) do
			local success = check(args[i])
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all keys in given table pass check

	@param check The function to use to check the keys

	@returns A function that will return true iff the condition is passed
**--]]
function t.keys(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for key in pairs(value) do
			local success = check(key)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures all values in given table pass check

	@param check The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.values(check)
	assert(t.callback(check))
	return function(value)
		local tableSuccess = t.table(value)
		if tableSuccess == false then
			return false
		end

		for _, val in pairs(value) do
			local success = check(val)
			if success == false then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass keyCheck and all values pass valueCheck

	@param keyCheck The function to use to check the keys
	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.map(keyCheck, valueCheck)
	assert(t.callback(keyCheck))
	assert(t.callback(valueCheck))
	local keyChecker = t.keys(keyCheck)
	local valueChecker = t.values(valueCheck)

	return function(value)
		local keySuccess = keyChecker(value)
		if not keySuccess then
			return false
		end

		local valueSuccess = valueChecker(value)
		if not valueSuccess then
			return false
		end

		return true
	end
end

--[[**
	ensures value is a table and all keys pass valueCheck and all values are true

	@param valueCheck The function to use to check the values

	@returns A function that will return true iff the condition is passed
**--]]
function t.set(valueCheck)
	return t.map(valueCheck, t.literal(true))
end

do
	local arrayKeysCheck = t.keys(t.integer)
--[[**
		ensures value is an array and all values of the array match check

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.array(check)
		assert(t.callback(check))
		local valuesCheck = t.values(check)

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- # is unreliable for sparse arrays
			-- Count upwards using ipairs to avoid false positives from the behavior of #
			local arraySize = 0

			for _ in ipairs(value) do
				arraySize = arraySize + 1
			end

			for key in pairs(value) do
				if key < 1 or key > arraySize then
					return false
				end
			end

			local valueSuccess = valuesCheck(value)
			if not valueSuccess then
				return false
			end

			return true
		end
	end

--[[**
		ensures value is an array of a strict makeup and size

		@param check The check to compare all values with

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictArray(...)
		local valueTypes = { ... }
		assert(t.array(t.callback)(valueTypes))

		return function(value)
			local keySuccess = arrayKeysCheck(value)
			if keySuccess == false then
				return false
			end

			-- If there's more than the set array size, disallow
			if #valueTypes < #value then
				return false
			end

			for idx, typeFn in pairs(valueTypes) do
				local typeSuccess = typeFn(value[idx])
				if not typeSuccess then
					return false
				end
			end

			return true
		end
	end
end

do
	local callbackArray = t.array(t.callback)
--[[**
		creates a union type

		@param ... The checks to union

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.union(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				if check(value) then
					return true
				end
			end

			return false
		end
	end

--[[**
		Alias for t.union
	**--]]
	t.some = t.union

--[[**
		creates an intersection type

		@param ... The checks to intersect

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.intersection(...)
		local checks = { ... }
		assert(callbackArray(checks))

		return function(value)
			for _, check in ipairs(checks) do
				local success = check(value)
				if not success then
					return false
				end
			end

			return true
		end
	end

--[[**
		Alias for t.intersection
	**--]]
	t.every = t.intersection
end

do
	local checkInterface = t.map(t.any, t.callback)
--[[**
		ensures value matches given interface definition

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.interface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			return true
		end
	end

--[[**
		ensures value matches given interface definition strictly

		@param checkTable The interface definition

		@returns A function that will return true iff the condition is passed
	**--]]
	function t.strictInterface(checkTable)
		assert(checkInterface(checkTable))
		return function(value)
			local tableSuccess = t.table(value)
			if tableSuccess == false then
				return false
			end

			for key, check in pairs(checkTable) do
				local success = check(value[key])
				if success == false then
					return false
				end
			end

			for key in pairs(value) do
				if not checkTable[key] then
					return false
				end
			end

			return true
		end
	end
end

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceOf(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if value.ClassName ~= className then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

t.instance = t.instanceOf

--[[**
	ensure value is an Instance and it's ClassName matches the given ClassName by an IsA comparison

	@param className The class name to check for

	@returns A function that will return true iff the condition is passed
**--]]
function t.instanceIsA(className, childTable)
	assert(t.string(className))

	local childrenCheck
	if childTable ~= nil then
		childrenCheck = t.children(childTable)
	end

	return function(value)
		local instanceSuccess = t.Instance(value)
		if not instanceSuccess then
			return false
		end

		if not value:IsA(className) then
			return false
		end

		if childrenCheck then
			local childrenSuccess = childrenCheck(value)
			if not childrenSuccess then
				return false
			end
		end

		return true
	end
end

--[[**
	ensures value is an enum of the correct type

	@param enum The enum to check

	@returns A function that will return true iff the condition is passed
**--]]
function t.enum(enum)
	assert(t.Enum(enum))
	return function(value)
		local enumItemSuccess = t.EnumItem(value)
		if not enumItemSuccess then
			return false
		end

		if value.EnumType == enum then
			return true
		else
			return false
		end
	end
end

do
	local checkWrap = t.tuple(t.callback, t.callback)

--[[**
		wraps a callback in an assert with checkArgs

		@param callback The function to wrap
		@param checkArgs The function to use to check arguments in the assert

		@returns A function that first asserts using checkArgs and then calls callback
	**--]]
	function t.wrap(callback, checkArgs)
		assert(checkWrap(callback, checkArgs))
		return function(...)
			assert(checkArgs(...))
			return callback(...)
		end
	end
end

--[[**
	asserts a given check

	@param check The function to wrap with an assert

	@returns A function that simply wraps the given check in an assert
**--]]
function t.strict(check)
	return function(...)
		assert(check(...))
	end
end

do
	local checkChildren = t.map(t.string, t.callback)

--[[**
		Takes a table where keys are child names and values are functions to check the children against.
		Pass an instance tree into the function.
		If at least one child passes each check, the overall check passes.

		Warning! If you pass in a tree with more than one child of the same name, this function will always return false

		@param checkTable The table to check against

		@returns A function that checks an instance tree
	**--]]
	function t.children(checkTable)
		assert(checkChildren(checkTable))

		return function(value)
			local instanceSuccess = t.Instance(value)
			if not instanceSuccess then
				return false
			end

			local childrenByName = {}
			for _, child in ipairs(value:GetChildren()) do
				local name = child.Name
				if checkTable[name] then
					if childrenByName[name] then
						return false
					end

					childrenByName[name] = child
				end
			end

			for name, check in pairs(checkTable) do
				local success = check(childrenByName[name])
				if not success then
					return false
				end
			end

			return true
		end
	end
end

return { t = t }
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000056c</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX2BEBB39FB8424914AE4EEED971928BCD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">squash</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000568</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX4D14EEAD14ED4F6E9244CA5F89041CE9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{EA981648-583F-44EF-83EB-D2D855EAB47F}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--!optimize 2

--[=[
	@class Squash
]=]
local Squash = {}

--* Types *--

--[=[
	@within Squash
	@type Alphabet string

	A string of unique characters that represent the basis of other strings.
]=]
export type Alphabet = string

--[=[
	@within Squash
	@type Bytes number

	1, 2, 3, 4, 5, 6, 7, 8

	The number of bytes used to represent a number.
]=]
export type Bytes = number

--[=[
	@within Squash
	@type FloatBytes number

	4, 8

	The number of bytes used to represent a floating point number.
]=]
export type FloatBytes = number

--[=[
	@within Squash
	@type NumberSer (x: number, bytes: Bytes?) -> string

	A function that serializes a number into a string. Usually this is Squash's uint, int, or number ser methods.
]=]
export type NumberSer = (x: number, bytes: Bytes?) -> string

--[=[
	@within Squash
	@type NumberDes (y: string, bytes: Bytes?) -> number

	A function that deserializes a number from a string. Usually this is Squash's uint, int, or number des methods.
]=]
export type NumberDes = (y: string, bytes: Bytes?) -> number

--[=[
	@within Squash
	@interface NumberSerDes
	.ser NumberSer
	.des NumberDes
]=]
export type NumberSerDes = {
	ser: NumberSer,
	des: NumberDes,
}

type VectorSer<T> = (T, NumberSerDes?, number?) -> string
type VectorDes<T> = (string, NumberSerDes?, number?) -> T
type VectorSerDes<T, U> = {
	ser: VectorSer<T>,
	des: VectorDes<U>,
}

type VectorNoCodingSer<T> = (T, number?) -> string
type VectorNoCodingDes<T> = (string, number?) -> T
type VectorNoCodingSerDes<T> = {
	ser: VectorNoCodingSer<T>,
	des: VectorNoCodingDes<T>,
}

type FixedSer<T> = (T) -> string
type FixedDes<T> = (string) -> T
type FixedSerDes<T> = {
	ser: FixedSer<T>,
	des: FixedDes<T>,
}

type VariableSer<T, U...> = (T, U...) -> string
type VariableDes<T, U...> = (string, U...) -> T
type VariableSerDes<T, U...> = {
	ser: VariableSer<T, U...>,
	des: VariableDes<T, U...>,
}

--* Properties *--

--[=[
	@within Squash
	@prop delimiter string

	The delimiter used to separate strings or other types in variable sized arrays and act as the 0 element for base conversions.
]=]
Squash.delimiter = string.char(0) -- \0

--[=[
	@within Squash
	@prop binary Alphabet

	All digits in base 2.
]=]
Squash.binary = '01' :: Alphabet

--[=[
	@within Squash
	@prop octal Alphabet

	All digits in base 8.
]=]
Squash.octal = '01234567' :: Alphabet

--[=[
	@within Squash
	@prop decimal Alphabet

	All digits in base 10.
]=]
Squash.decimal = '0123456789' :: Alphabet

--[=[
	@within Squash
	@prop duodecimal Alphabet

	All digits in base 12.
]=]
Squash.duodecimal = '0123456789AB' :: Alphabet

--[=[
	@within Squash
	@prop hexadecimal Alphabet

	All digits in base 16.
]=]
Squash.hexadecimal = '0123456789ABCDEF' :: Alphabet

--[=[
	@within Squash
	@prop utf8 Alphabet

	All digits in base 256. The UTF-8 character set.
]=]
local utf8Characters = table.create(256)
for i = 0, 255 do
	utf8Characters[i + 1] = string.char(i)
end
Squash.utf8 = table.concat(utf8Characters) :: Alphabet

--[=[
	@within Squash
	@prop lower Alphabet

	All lowercase letters in the english language.
]=]
Squash.lower = 'abcdefghijklmnopqrstuvwxyz' :: Alphabet

--[=[
	@within Squash
	@prop upper Alphabet

	All uppercase letters in the english language.
]=]
Squash.upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' :: Alphabet

--[=[
	@within Squash
	@prop letters Alphabet

	All letters in the english language.
]=]
Squash.letters = Squash.lower .. Squash.upper :: Alphabet

--[=[
	@within Squash
	@prop punctuation Alphabet

	All punctuation symbols in the english language.
]=]
Squash.punctuation = ' .,?!:;\'"-_' :: Alphabet

--[=[
	@within Squash
	@prop english Alphabet

	All symbols in the english language.
]=]
Squash.english = Squash.letters .. Squash.punctuation :: Alphabet

--[=[
	@within Squash
	@prop filepath Alphabet

	All characters that may be used in a filepath.
]=]
Squash.filepath = Squash.letters .. ':/' :: Alphabet

--[=[
	@within Squash
	@prop datastore Alphabet

	All characters that will not be expanded when JSONEncoded.
]=]
Squash.datastore = ' !#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~'

--* Duplication Reducers *--

local bytesAssert = function(bytes: number)
	if bytes ~= math.floor(bytes) or bytes < 1 or bytes > 8 then
		error 'bytes must one of 1, 2, 3, 4, 5, 6, 7, 8'
	end
end

local floatAssert = function(bytes: number)
	if bytes ~= 4 and bytes ~= 8 then
		error(`Expected 4 or 8 bytes. Invalid number of bytes for floating point: {bytes}`)
	end
end

local serArrayNumber = function<T>(ser: (x: T, bytes: Bytes?) -> string)
	return function(x: { T }, bytes: Bytes?): string
		local bytes = bytes or 4
		bytesAssert(bytes)

		local y = {}
		for i, v in x do
			y[i] = ser(v, bytes)
		end
		return table.concat(y)
	end
end

local desArrayNumber = function<T>(des: (y: string, bytes: Bytes?) -> T)
	return function(y: string, bytes: Bytes?): { T }
		local bytes = bytes or 4
		bytesAssert(bytes)

		local x = {}
		for i = 1, #y / bytes do
			local a = bytes * (i - 1) + 1
			local b = bytes * i
			x[i] = des(string.sub(y, a, b), bytes)
		end
		return x
	end
end

local serArrayFixed = function<T>(serdes: FixedSerDes<T>)
	local ser = serdes.ser
	return function(x: { T }): string
		local y = {}
		for i, v in x do
			y[i] = ser(v)
		end
		return table.concat(y)
	end
end

local desArrayFixed = function<T>(serdes: FixedSerDes<T>, bytes: number)
	local des = serdes.des
	return function(y: string): { T }
		local x = {}
		for i = 1, #y / bytes do
			local a = bytes * (i - 1) + 1
			local b = bytes * i
			x[i] = des(string.sub(y, a, b))
		end
		return x
	end
end

local serArrayVariable = function<T, U...>(serdes: VariableSerDes<T, U...>)
	local ser = serdes.ser
	return function(x: { T }, ...: U...): string
		local y = {}
		for i, v in x do
			y[i] = ser(v, ...)
		end
		return table.concat(y, Squash.delimiter)
	end
end

local desArrayVariable = function<T, U...>(serdes: VariableSerDes<T, U...>)
	local des = serdes.des
	return function(y: string, ...: U...): { T }
		local x = {}
		for v in string.gmatch(y, '[^' .. Squash.delimiter .. ']+') do
			table.insert(x, des(v, ...))
		end
		return x
	end
end

local serArrayVector = function<T, U>(serializer: VectorSerDes<T, U>)
	local ser = serializer.ser
	return function(x: { T }, serdes: NumberSerDes?, bytes: Bytes?): string
		local bytes = bytes or 4
		local encoding = serdes or Squash.number

		local y = {}
		for i, v in x do
			y[i] = ser(v, encoding, bytes)
		end
		return table.concat(y)
	end
end

local desArrayVector = function<T, U>(deserializer: VectorSerDes<T, U>, elements: number, offsetBytes: number)
	local des = deserializer.des
	return function(y: string, serdes: NumberSerDes?, bytes: Bytes?): { U }
		local bytes = bytes or 4
		local decoding = serdes or Squash.number

		local size = offsetBytes + elements * bytes
		local x = {}
		for i = 1, #y / size do
			local a = size * (i - 1) + 1
			local b = size * i
			x[i] = des(string.sub(y, a, b), decoding, bytes)
		end
		return x
	end
end

local serArrayVectorNoCoding = function<T>(serializer: VectorNoCodingSerDes<T>)
	local ser = serializer.ser
	return function(x: { T }, bytes: Bytes?): string
		local bytes = bytes or 4

		local y = {}
		for i, v in x do
			y[i] = ser(v, bytes)
		end
		return table.concat(y)
	end
end

local desArrayVectorNoCoding = function<T>(deserializer: VectorNoCodingSerDes<T>, elements: number, offsetBytes: number)
	local des = deserializer.des
	return function(y: string, bytes: Bytes?): { T }
		local bytes = bytes or 4

		local size = offsetBytes + elements * bytes
		local x = {}
		for i = 1, #y / size do
			local a = size * (i - 1) + 1
			local b = size * i
			x[i] = des(string.sub(y, a, b), bytes)
		end
		return x
	end
end

local tau = 2 * math.pi
local angleRatio = 65536 / tau

local serAngle = function(x: number): string
	return Squash.uint.ser(x % tau * angleRatio, 2)
end

local desAngle = function(y: string): number
	return Squash.uint.des(y, 2) / angleRatio
end

local getBitSize = function(x: number): number
	return math.ceil(math.log(x, 2))
end

local getByteSize = function(x: number): number
	return math.ceil(math.log(x, 256))
end

local getItemData = function<T>(array: { T }): { items: { T }, lookup: { [T]: number }, bits: number, bytes: number }
	local lookup = {}

	for i, v in array do
		lookup[v] = i
	end

	return {
		items = array,
		lookup = lookup,
		bits = getBitSize(#array),
		bytes = getByteSize(#array),
	}
end

local enumData = getItemData(Enum:GetEnums() :: { Enum })
local enumItemData = {}
for _, enum in enumData.items do
	enumItemData[enum] = getItemData(enum:GetEnumItems() :: { EnumItem })
end

local desEnumItem = function<T>(y: string, offset: number, enum: Enum): (number, EnumItem)
	local enumData = enumItemData[enum]
	local enumItemId = Squash.uint.des(string.sub(y, offset, offset + enumData.bytes - 1), enumData.bytes)
	return offset + enumData.bytes, enumData.items[enumItemId]
end

local packBits = function(x: { number }, bits: number): string
	local packed = {}
	local byte = 0
	local count = 0
	for i = 1, #x do
		for b = bits - 1, 0, -1 do
			byte = byte * 2 + math.floor(x[i] * 2 ^ -b) % 2
			count += 1
			if count == 8 then
				table.insert(packed, string.char(byte))
				byte = 0
				count = 0
			end
		end
	end
	if count > 0 then
		byte = byte * 2 ^ (8 - count)
		table.insert(packed, string.char(byte))
	end
	return table.concat(packed)
end

local unpackBits = function(y: string, bits: number): { number }
	local x = {}
	local value = 0
	local count = 0
	for i = 1, #y do
		local byte = string.byte(y, i)
		for b = 7, 0, -1 do
			value = value * 2 + math.floor(byte * 2 ^ -b) % 2
			count += 1
			if count == bits then
				table.insert(x, value)
				value = 0
				count = 0
			end
		end
	end
	return x
end

--? Done this way because roblox luau does not support constant folding. This has been benchmarked.

local n2_2 = 2 ^ 2
local n2_3 = 2 ^ 3
local n2_4 = 2 ^ 4
local n2_5 = 2 ^ 5
local n2_6 = 2 ^ 6
local n2_7 = 2 ^ 7

local n2_1_ = 2 ^ -1
local n2_2_ = 2 ^ -2
local n2_3_ = 2 ^ -3
local n2_4_ = 2 ^ -4
local n2_5_ = 2 ^ -5
local n2_6_ = 2 ^ -6
local n2_7_ = 2 ^ -7

local n256_2 = 256 ^ 2
local n256_3 = 256 ^ 3
local n256_4 = 256 ^ 4
local n256_5 = 256 ^ 5
local n256_6 = 256 ^ 6
local n256_7 = 256 ^ 7

local n256_1_ = 256 ^ -1
local n256_2_ = 256 ^ -2
local n256_3_ = 256 ^ -3
local n256_4_ = 256 ^ -4
local n256_5_ = 256 ^ -5
local n256_6_ = 256 ^ -6
local n256_7_ = 256 ^ -7

--* Actual API *--

--[=[
	@class boolean
]=]
Squash.boolean = {}

--[=[
	@within boolean
	@function ser
	@param x1 boolean?
	@param x2 boolean?
	@param x3 boolean?
	@param x4 boolean?
	@param x5 boolean?
	@param x6 boolean?
	@param x7 boolean?
	@param x8 boolean?
	@return string
]=]
Squash.boolean.ser = function(
	x1: boolean?,
	x2: boolean?,
	x3: boolean?,
	x4: boolean?,
	x5: boolean?,
	x6: boolean?,
	x7: boolean?,
	x8: boolean?
): string
	return string.char(
		(if x1 then 1 else 0)
			+ (if x2 then 2 else 0)
			+ (if x3 then n2_2 else 0)
			+ (if x4 then n2_3 else 0)
			+ (if x5 then n2_4 else 0)
			+ (if x6 then n2_5 else 0)
			+ (if x7 then n2_6 else 0)
			+ (if x8 then n2_7 else 0)
	)
end

--[=[
	@within boolean
	@function des
	@param y string
	@return boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean
]=]
Squash.boolean.des = function(y: string): (boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean)
	local x = string.byte(y)
	return x % 2 >= 1,
		(x * n2_1_) % 2 >= 1,
		(x * n2_2_) % 2 >= 1,
		(x * n2_3_) % 2 >= 1,
		(x * n2_4_) % 2 >= 1,
		(x * n2_5_) % 2 >= 1,
		(x * n2_6_) % 2 >= 1,
		(x * n2_7_) % 2 >= 1
end

--[=[
	@within boolean
	@function serarr
	@param x { boolean }
	@return string
]=]
Squash.boolean.serarr = function(x: { boolean }): string
	local y = {}
	for i = 1, math.ceil(#x / 8) do
		y[i] = Squash.boolean.ser(x[i + 0], x[i + 1], x[i + 2], x[i + 3], x[i + 4], x[i + 5], x[i + 6], x[i + 7])
	end
	return table.concat(y)
end

--[=[
	@within boolean
	@function desarr
	@param y string
	@return { boolean }
]=]

Squash.boolean.desarr = function(y: string): { boolean }
	local x = {}
	for i = 1, #y do
		local j = 8 * i
		x[j - 7], x[j - 6], x[j - 5], x[j - 4], x[j - 3], x[j - 2], x[j - 1], x[j] =
			Squash.boolean.des(string.sub(y, i, i))
	end
	return x
end

--[=[
	@class uint
]=]
Squash.uint = {}

--[=[
	@within uint
	@function ser
	@param x number
	@param bytes Bytes?
	@return string
]=]
Squash.uint.ser = function(x: number, bytes: Bytes?): string
	local bytes = bytes or 4
	bytesAssert(bytes)

	--? Compared to a simple for loop, this is about 10x faster.
	--? The order of these if statements is attempted to be optimized for performance, with the most common cases first.
	if bytes == 4 then
		return string.char(
			math.floor(x) % 256,
			math.floor(x * n256_1_) % 256,
			math.floor(x * n256_2_) % 256,
			math.floor(x * n256_3_) % 256
		)
	elseif bytes == 8 then
		return string.char(
			math.floor(x * 1) % 256,
			math.floor(x * n256_1_) % 256,
			math.floor(x * n256_2_) % 256,
			math.floor(x * n256_3_) % 256,
			math.floor(x * n256_4_) % 256,
			math.floor(x * n256_5_) % 256,
			math.floor(x * n256_6_) % 256,
			math.floor(x * n256_7_) % 256
		)
	elseif bytes == 2 then
		return string.char(math.floor(x) % 256, math.floor(x * n256_1_) % 256)
	elseif bytes == 1 then
		return string.char(math.floor(x) % 256)
	elseif bytes == 3 then
		return string.char(math.floor(x) % 256, math.floor(x * n256_1_) % 256, math.floor(x * n256_2_) % 256)
	elseif bytes == 5 then
		return string.char(
			math.floor(x) % 256,
			math.floor(x * n256_1_) % 256,
			math.floor(x * n256_2_) % 256,
			math.floor(x * n256_3_) % 256,
			math.floor(x * n256_4_) % 256
		)
	elseif bytes == 6 then
		return string.char(
			math.floor(x) % 256,
			math.floor(x * n256_1_) % 256,
			math.floor(x * n256_2_) % 256,
			math.floor(x * n256_3_) % 256,
			math.floor(x * n256_4_) % 256,
			math.floor(x * n256_5_) % 256
		)
	elseif bytes == 7 then
		return string.char(
			math.floor(x) % 256,
			math.floor(x * n256_1_) % 256,
			math.floor(x * n256_2_) % 256,
			math.floor(x * n256_3_) % 256,
			math.floor(x * n256_4_) % 256,
			math.floor(x * n256_5_) % 256,
			math.floor(x * n256_6_) % 256
		)
	end

	--? Should never get called because of the bytesAssert at the top of the function. This is just to make the typechecker happy.
	error('Invalid bytes: ' .. bytes)
end

--[=[
	@within uint
	@function des
	@param y string
	@param bytes Bytes?
	@return number
]=]
Squash.uint.des = function(y: string, bytes: Bytes?): number
	local bytes = bytes or 4
	bytesAssert(bytes)

	--? The order of these if statements is attempted to be optimized for performance, with the most common cases first.
	if bytes == 4 then
		return math.floor(string.byte(y, 1))
			+ math.floor(string.byte(y, 2) * 256)
			+ math.floor(string.byte(y, 3) * n256_2)
			+ math.floor(string.byte(y, 4) * n256_3)
	elseif bytes == 8 then
		return math.floor(string.byte(y, 1))
			+ math.floor(string.byte(y, 2) * 256)
			+ math.floor(string.byte(y, 3) * n256_2)
			+ math.floor(string.byte(y, 4) * n256_3)
			+ math.floor(string.byte(y, 5) * n256_4)
			+ math.floor(string.byte(y, 6) * n256_5)
			+ math.floor(string.byte(y, 7) * n256_6)
			+ math.floor(string.byte(y, 8) * n256_7)
	elseif bytes == 2 then
		return math.floor(string.byte(y, 1)) + math.floor(string.byte(y, 2) * 256)
	elseif bytes == 1 then
		return math.floor(string.byte(y, 1))
	elseif bytes == 3 then
		return math.floor(string.byte(y, 1))
			+ math.floor(string.byte(y, 2) * 256)
			+ math.floor(string.byte(y, 3) * n256_2)
	elseif bytes == 5 then
		return math.floor(string.byte(y, 1))
			+ math.floor(string.byte(y, 2) * 256)
			+ math.floor(string.byte(y, 3) * n256_2)
			+ math.floor(string.byte(y, 4) * n256_3)
			+ math.floor(string.byte(y, 5) * n256_4)
	elseif bytes == 6 then
		return math.floor(string.byte(y, 1))
			+ math.floor(string.byte(y, 2) * 256)
			+ math.floor(string.byte(y, 3) * n256_2)
			+ math.floor(string.byte(y, 4) * n256_3)
			+ math.floor(string.byte(y, 5) * n256_4)
			+ math.floor(string.byte(y, 6) * n256_5)
	elseif bytes == 7 then
		return math.floor(string.byte(y, 1))
			+ math.floor(string.byte(y, 2) * 256)
			+ math.floor(string.byte(y, 3) * n256_2)
			+ math.floor(string.byte(y, 4) * n256_3)
			+ math.floor(string.byte(y, 5) * n256_4)
			+ math.floor(string.byte(y, 6) * n256_5)
			+ math.floor(string.byte(y, 7) * n256_6)
	end

	--? Should never get called because of the bytesAssert at the top of the function. This is just to make the typechecker happy.
	error('Invalid bytes: ' .. bytes)
end

--[=[
	@within uint
	@function serarr
	@param x { number }
	@param bytes Bytes?
	@return string
]=]
Squash.uint.serarr = serArrayNumber(Squash.uint.ser)

--[=[
	@within uint
	@function desarr
	@param y string
	@param bytes Bytes?
	@return { number }
]=]
Squash.uint.desarr = desArrayNumber(Squash.uint.des)

--[=[
	@class int
]=]
Squash.int = {}

--[=[
	@within int
	@function ser
	@param x number
	@param bytes Bytes?
	@return string
]=]
Squash.int.ser = function(x: number, bytes: Bytes?): string
	local bytes = bytes or 4
	bytesAssert(bytes)

	local sx = if x < 0 then x + 256 ^ bytes else x
	return Squash.uint.ser(sx, bytes)
end

--[=[
	@within int
	@function des
	@param y string
	@param bytes Bytes?
	@return number
]=]
Squash.int.des = function(y: string, bytes: Bytes?): number
	local bytes = bytes or 4
	bytesAssert(bytes)

	local x = Squash.uint.des(y, bytes)
	return if x > 0.5 * 256 ^ bytes - 1 then x - 256 ^ bytes else x
end

--[=[
	@within int
	@function serarr
	@param x { number }
	@param bytes Bytes?
	@return string
]=]
Squash.int.serarr = serArrayNumber(Squash.int.ser)

--[=[
	@within int
	@function desarr
	@param y string
	@param bytes Bytes?
	@return { number }
]=]
Squash.int.desarr = desArrayNumber(Squash.int.des)

--[=[
	@class number
]=]
Squash.number = {}

--[=[
	@within number
	@function ser
	@param x number
	@param bytes FloatBytes?
	@return string
]=]
Squash.number.ser = function(x: number, bytes: FloatBytes?): string
	local bytes = bytes or 4
	floatAssert(bytes)
	return string.pack(if bytes == 4 then 'f' else 'd', x)
end

--[=[
	@within number
	@function des
	@param y string
	@param bytes FloatBytes?
	@return number
]=]
Squash.number.des = function(y: string, bytes: FloatBytes?): number
	local bytes = bytes or 4
	floatAssert(bytes)
	local x = string.unpack(if bytes == 4 then 'f' else 'd', y) --! This is to avoid returning multiple values
	return x
end

--[=[
	@within number
	@function serarr
	@param x { number }
	@param bytes FloatBytes?
	@return string
]=]
Squash.number.serarr = serArrayNumber(Squash.number.ser)

--[=[
	@within number
	@function desarr
	@param y string
	@param bytes FloatBytes?
	@return { number }
]=]
Squash.number.desarr = desArrayNumber(Squash.number.des)

--[=[
	@class string
]=]
Squash.string = {}

--[=[
	@within string
	@function alphabet
	@param source string
	@return Alphabet

	Maps a string to the smallest sorted alphabet that represents it.
]=]
Squash.string.alphabet = function(source: string): Alphabet
	local lookup = {}
	local alphabet = table.create(#source)
	for i = 1, #source do
		local char = string.sub(source, i, i)
		if not lookup[char] then
			lookup[char] = true
			table.insert(alphabet, char)
		end
	end
	table.sort(alphabet)
	return table.concat(alphabet)
end

--[=[
	@within string
	@function convert
	@param x string
	@param inAlphabet Alphabet
	@param outAlphabet Alphabet
	@return string

	Converts a string from one alphabet to another.
]=]
Squash.string.convert = function(x: string, inAlphabet: Alphabet, outAlphabet: Alphabet): string
	local sourceDigits = {}
	for i = 1, #inAlphabet do
		sourceDigits[string.byte(inAlphabet, i)] = i - 1
	end

	local targetDigits = {}
	for i = 1, #outAlphabet do
		targetDigits[i - 1] = string.byte(outAlphabet, i)
	end

	local inputDigits = {}
	for i = 1, #x do
		table.insert(inputDigits, sourceDigits[string.byte(x, i)])
	end

	local output = {}
	local sourceBase = #inAlphabet
	local targetBase = #outAlphabet
	local carry, value
	while #inputDigits > 0 do
		carry = 0

		for i = 1, #inputDigits do
			value = inputDigits[i] + carry * sourceBase
			inputDigits[i] = math.floor(value / targetBase)
			carry = value % targetBase
		end

		while #inputDigits > 0 and inputDigits[1] == 0 do
			table.remove(inputDigits, 1)
		end

		table.insert(output, 1, string.char(targetDigits[carry]))
	end

	return table.concat(output)
end

--[=[
	@within string
	@function ser
	@param x string
	@param alphabet Alphabet?
	@return string
]=]
Squash.string.ser = function(x: string, alphabet: Alphabet?): string
	local inAlphabet = Squash.delimiter .. (alphabet or Squash.english)
	return Squash.string.convert(x, inAlphabet, Squash.utf8)
end

--[=[
	@within string
	@function des
	@param y string
	@param alphabet Alphabet?
	@return string
]=]
Squash.string.des = function(y: string, alphabet: Alphabet?): string
	local outAlphabet = Squash.delimiter .. (alphabet or Squash.english)
	return Squash.string.convert(y, Squash.utf8, outAlphabet)
end

--[=[
	@within string
	@function serarr
	@param x { string }
	@param alphabet Alphabet?
	@return string
]=]
Squash.string.serarr = function(x: { string }, alphabet: Alphabet?)
	local y = {}
	for i, v in x do
		y[i] = Squash.string.ser(v, alphabet)
	end
	return table.concat(y, Squash.delimiter)
end

--[=[
	@within string
	@function desarr
	@param y string
	@param alphabet Alphabet?
	@return { string }
]=]
Squash.string.desarr = function(y: string, alphabet: Alphabet?): { string }
	local x = {}
	for v in string.gmatch(y, '[^' .. Squash.delimiter .. ']+') do
		table.insert(x, Squash.string.des(v, alphabet))
	end
	return x
end

--[=[
	@class Vector2
]=]
Squash.Vector2 = {}

--[=[
	@within Vector2
	@function ser
	@param x Vector2
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Vector2.ser = function(x: Vector2, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return ser(x.X, bytes) .. ser(x.Y, bytes)
end

--[=[
	@within Vector2
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return Vector2
]=]
Squash.Vector2.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): Vector2
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4
	return Vector2.new(des(string.sub(y, 1, bytes), bytes), des(string.sub(y, 1 + bytes, 2 * bytes), bytes))
end

--[=[
	@within Vector2
	@function serarr
	@param x { Vector2 }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Vector2.serarr = serArrayVector(Squash.Vector2)

--[=[
	@within Vector2
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { Vector2 }
]=]
Squash.Vector2.desarr = desArrayVector(Squash.Vector2, 2, 0)

--[=[
	@class Vector3
]=]
Squash.Vector3 = {}

--[=[
	@within Vector3
	@function ser
	@param x Vector3
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Vector3.ser = function(x: Vector3, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return ser(x.X, bytes) .. ser(x.Y, bytes) .. ser(x.Z, bytes)
end

--[=[
	@within Vector3
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return Vector3
]=]
Squash.Vector3.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): Vector3
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4
	return Vector3.new(
		des(string.sub(y, 1 + 0 * bytes, 1 * bytes), bytes),
		des(string.sub(y, 1 + 1 * bytes, 2 * bytes), bytes),
		des(string.sub(y, 1 + 2 * bytes, 3 * bytes), bytes)
	)
end

--[=[
	@within Vector3
	@function serarr
	@param x { Vector3 }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Vector3.serarr = serArrayVector(Squash.Vector3)

--[=[
	@within Vector3
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { Vector3 }
]=]
Squash.Vector3.desarr = desArrayVector(Squash.Vector3, 3, 0)

--[=[
	@class Vector2int16
	Default bytes is 2, because int16 is 2 bytes.
]=]
Squash.Vector2int16 = {}

--[=[
	@within Vector2int16
	@function ser
	@param x Vector2int16
	@return string
]=]
Squash.Vector2int16.ser = function(x: Vector2int16, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.int.ser :: NumberSer
	local bytes = bytes or 2
	return ser(x.X, bytes) .. ser(x.Y, bytes)
end

--[=[
	@within Vector2int16
	@function des
	@param y string
	@return Vector2int16
]=]
Squash.Vector2int16.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): Vector2int16
	local des = if serdes then serdes.des else Squash.int.des :: NumberDes
	local bytes = bytes or 2
	return Vector2int16.new(des(string.sub(y, 1, bytes), bytes), des(string.sub(y, 1 + bytes, 2 * bytes), bytes))
end

--[=[
	@within Vector2int16
	@function serarr
	@param x { Vector2int16 }
	@return string
]=]
Squash.Vector2int16.serarr = serArrayVector(Squash.Vector2int16)

--[=[
	@within Vector2int16
	@function desarr
	@param y string
	@return { Vector2int16 }
]=]
Squash.Vector2int16.desarr = desArrayVector(Squash.Vector2int16, 3, 0)

--[=[
	@class Vector3int16
	Default bytes is 2, because int16 is 2 bytes.
]=]
Squash.Vector3int16 = {}

--[=[
	@within Vector3int16
	@function ser
	@param x Vector3int16
	@return string
]=]
Squash.Vector3int16.ser = function(x: Vector3int16, serdes: NumberSerDes?, bytes: Bytes?)
	local ser = if serdes then serdes.ser else Squash.int.ser :: NumberSer
	local bytes = bytes or 2
	return ser(x.X, bytes) .. ser(x.Y, bytes) .. ser(x.Z, bytes)
end

--[=[
	@within Vector3int16
	@function des
	@param y string
	@return Vector3int16
]=]
Squash.Vector3int16.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): Vector3int16
	local des = if serdes then serdes.des else Squash.int.des :: NumberDes
	local bytes = bytes or 2
	return Vector3int16.new(
		des(string.sub(y, 1 + 0 * bytes, 1 * bytes), bytes),
		des(string.sub(y, 1 + 1 * bytes, 2 * bytes), bytes),
		des(string.sub(y, 1 + 2 * bytes, 3 * bytes), bytes)
	)
end

--[=[
	@within Vector3int16
	@function serarr
	@param x { Vector3int16 }
	@return string
]=]
Squash.Vector3int16.serarr = serArrayVector(Squash.Vector3int16)

--[=[
	@within Vector3int16
	@function desarr
	@param y string
	@return { Vector3int16 }
]=]
Squash.Vector3int16.desarr = desArrayVector(Squash.Vector3int16, 3, 0)

--[=[
	@class CFrame
]=]
Squash.CFrame = {}

--[=[
	@within CFrame
	@function ser
	@param x CFrame
	@param serdes NumberSerDes?
	@param posBytes Bytes?
	@return string
]=]
Squash.CFrame.ser = function(x: CFrame, serdes: NumberSerDes?, posBytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local posBytes = posBytes or 4

	local rx, ry, rz = x:ToEulerAnglesYXZ()
	local px, py, pz = x.Position.X, x.Position.Y, x.Position.Z

	return serAngle(rx) .. serAngle(ry) .. serAngle(rz) .. ser(px, posBytes) .. ser(py, posBytes) .. ser(pz, posBytes)
end

--[=[
	@within CFrame
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param posBytes number?
	@return CFrame
]=]
Squash.CFrame.des = function(y: string, serdes: NumberSerDes?, posBytes: number?): CFrame
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local posBytes = posBytes or 4

	local rx = desAngle(string.sub(y, 1, 2))
	local ry = desAngle(string.sub(y, 3, 4))
	local rz = desAngle(string.sub(y, 5, 6))

	local px = des(string.sub(y, 7 + 0 * posBytes, 7 + 1 * posBytes - 1), posBytes)
	local py = des(string.sub(y, 7 + 1 * posBytes, 7 + 2 * posBytes - 1), posBytes)
	local pz = des(string.sub(y, 7 + 2 * posBytes, 7 + 3 * posBytes - 1), posBytes)

	return CFrame.fromOrientation(rx, ry, rz) + Vector3.new(px, py, pz)
end

--[=[
	@within CFrame
	@function serarr
	@param x { CFrame }
	@param serdes NumberSerDes?
	@param posBytes number?
	@return string
]=]
Squash.CFrame.serarr = serArrayVector(Squash.CFrame)

--[=[
	@within CFrame
	@function desarr
	@param y string
	@param posBytes number
	@param serdes NumberSerDes?
	@return { CFrame }
]=]
Squash.CFrame.desarr = function(y: string, posBytes: number, serdes: NumberSerDes?): { CFrame }
	local decoding = serdes or Squash.number
	local bytes = 7 + 3 * posBytes

	local x = {}
	for i = 1, #y / bytes do
		local a = bytes * (i - 1) + 1
		local b = bytes * i
		x[i] = Squash.CFrame.des(string.sub(y, a, b), decoding, posBytes)
	end
	return x
end

--[=[
	@class Enum
]=]
Squash.Enum = {}

--[=[
	@within Enum
	@function ser
	@param x Enum
	@return string
]=]
Squash.Enum.ser = function(x: Enum): string
	local enumId = enumData.lookup[x] :: number
	return Squash.uint.ser(enumId, enumData.bytes)
end

--[=[
	@within Enum
	@function des
	@param y string
	@return Enum
]=]
Squash.Enum.des = function(y: string): Enum
	local enumId = Squash.uint.des(y, enumData.bytes)
	return enumData.items[enumId]
end

--[=[
	@within Enum
	@function serarr
	@param x { Enum }
	@return string
]=]
Squash.Enum.serarr = serArrayVariable(Squash.Enum)

--[=[
	@within Enum
	@function desarr
	@param y string
	@return { Enum }
]=]
Squash.Enum.desarr = desArrayVariable(Squash.Enum)

--[=[
	@class EnumItem
]=]
Squash.EnumItem = {}

--[=[
	@within EnumItem
	@function ser
	@param x EnumItem
	@return string
]=]
Squash.EnumItem.ser = function(enumItem: EnumItem, enum: Enum): string
	local enumData = enumItemData[enum]
	local enumItemId = enumData.lookup[enumItem] :: number
	return Squash.uint.ser(enumItemId, enumData.bytes)
end

--[=[
	@within EnumItem
	@function des
	@param y string
	@param enum Enum
	@return EnumItem
]=]
Squash.EnumItem.des = function(y: string, enum: Enum): EnumItem
	local enumData = enumItemData[enum]
	local enumItemId = Squash.uint.des(y, enumData.bytes)
	return enumData.items[enumItemId]
end

--[=[
	@within EnumItem
	@function serarr
	@param x { EnumItem }
	@return string
]=]
Squash.EnumItem.serarr = function(x: { EnumItem }, enum: Enum)
	local y = {}
	for i, v in x do
		y[i] = Squash.EnumItem.ser(v, enum)
	end
	return table.concat(y)
end

--[=[
	@within EnumItem
	@function desarr
	@param y string
	@param enum Enum
	@return { EnumItem }
]=]
Squash.EnumItem.desarr = function(y: string, enum: Enum): { EnumItem }
	local bytes = enumItemData[enum].bytes
	local x = {}
	for i = 1, #y / bytes do
		x[i] = Squash.EnumItem.des(string.sub(y, bytes * (i - 1) + 1, bytes * i), enum)
	end
	return x
end

--[=[
	@class Axes
]=]
Squash.Axes = {}

--[=[
	@within Axes
	@function ser
	@param x Axes
	@return string
]=]
Squash.Axes.ser = function(x: Axes)
	return Squash.boolean.ser(x.X, x.Y, x.Z) .. Squash.boolean.ser(x.Top, x.Bottom, x.Left, x.Right, x.Back, x.Front)
end

--[=[
	@within Axes
	@function des
	@param y string
	@return Axes
]=]
Squash.Axes.des = function(y: string): Axes
	local fx, fy, fz = Squash.boolean.des(string.sub(y, 1, 1))
	local top, bottom, left, right, back, front = Squash.boolean.des(string.sub(y, 2, 2))
	return Axes.new(
		fx and Enum.Axis.X,
		fy and Enum.Axis.Y,
		fz and Enum.Axis.Z,
		top and Enum.NormalId.Top,
		bottom and Enum.NormalId.Bottom,
		left and Enum.NormalId.Left,
		right and Enum.NormalId.Right,
		back and Enum.NormalId.Back,
		front and Enum.NormalId.Front
	)
end

--[=[
	@within Axes
	@function serarr
	@param x { Axes }
	@return string
]=]
Squash.Axes.serarr = serArrayFixed(Squash.Axes)

--[=[
	@within Axes
	@function desarr
	@param y string
	@return { Axes }
]=]
Squash.Axes.desarr = desArrayFixed(Squash.Axes, 8)

--[=[
	@class BrickColor
]=]
Squash.BrickColor = {}

--[=[
	@within BrickColor
	@function ser
	@param x BrickColor
	@return string
]=]
Squash.BrickColor.ser = function(x: BrickColor): string
	return Squash.uint.ser(x.Number, 2)
end

--[=[
	@within BrickColor
	@function des
	@param y string
	@return BrickColor
]=]
Squash.BrickColor.des = function(y: string): BrickColor
	return BrickColor.new(Squash.uint.des(y, 2))
end

--[=[
	@within BrickColor
	@function serarr
	@param x { BrickColor }
	@return string
]=]
Squash.BrickColor.serarr = serArrayFixed(Squash.BrickColor)

--[=[
	@within BrickColor
	@function desarr
	@param y string
	@return { BrickColor }
]=]
Squash.BrickColor.desarr = desArrayFixed(Squash.BrickColor, 2)

--[=[
	@class Color3
]=]
Squash.Color3 = {}

--[=[
	@within Color3
	@function ser
	@param x Color3
	@return string
]=]
Squash.Color3.ser = function(x: Color3): string
	return string.char(x.R * 255, x.G * 255, x.B * 255)
end

--[=[
	@within Color3
	@function des
	@param y string
	@return Color3
]=]
Squash.Color3.des = function(y: string): Color3
	return Color3.fromRGB(string.byte(y, 1), string.byte(y, 2), string.byte(y, 3))
end

--[=[
	@within Color3
	@function serarr
	@param x { Color3 }
	@return string
]=]
Squash.Color3.serarr = serArrayFixed(Squash.Color3)

--[=[
	@within Color3
	@function desarr
	@param y string
	@return { Color3 }
]=]
Squash.Color3.desarr = desArrayFixed(Squash.Color3, 3)

--[=[
	@class CatalogSearchParams
]=]
Squash.CatalogSearchParams = {}

--[=[
	@within CatalogSearchParams
	@function ser
	@param x CatalogSearchParams
	@param alphabet Alphabet?
	@return string
]=]
Squash.CatalogSearchParams.ser = function(x: CatalogSearchParams, alphabet: Alphabet?): string
	local alphabet = alphabet or Squash.english

	local avatarAssetTypeData = enumItemData[Enum.AvatarAssetType]
	local bundleTypeData = enumItemData[Enum.BundleType]

	local assetIndices = {}
	for i, v in x.AssetTypes do
		assetIndices[i] = table.find(avatarAssetTypeData.items, v) :: number
	end

	local bundleIndices = {}
	for i, v in x.BundleTypes do
		bundleIndices[i] = table.find(bundleTypeData.items, v) :: number
	end

	return Squash.boolean.ser(x.IncludeOffSale)
		.. Squash.uint.ser(x.MinPrice, 4)
		.. Squash.uint.ser(x.MaxPrice, 4)
		.. Squash.EnumItem.ser(x.SalesTypeFilter, Enum.SalesTypeFilter)
		.. Squash.EnumItem.ser(x.CategoryFilter, Enum.CatalogCategoryFilter)
		.. Squash.EnumItem.ser(x.SortAggregation, Enum.CatalogSortAggregation)
		.. Squash.EnumItem.ser(x.SortType, Enum.CatalogSortType)
		.. packBits(assetIndices, avatarAssetTypeData.bits)
		.. Squash.delimiter
		.. packBits(bundleIndices, bundleTypeData.bits)
		.. Squash.delimiter
		.. Squash.string.ser(x.SearchKeyword, alphabet)
		.. Squash.delimiter
		.. Squash.string.ser(x.CreatorName, alphabet)
end

--[=[
	@within CatalogSearchParams
	@function des
	@param y string
	@param alphabet Alphabet?
	@return CatalogSearchParams
]=]
Squash.CatalogSearchParams.des = function(y: string, alphabet: Alphabet): CatalogSearchParams
	local alphabet = alphabet or Squash.english

	local avatarAssetTypeData = enumItemData[Enum.AvatarAssetType]
	local bundleTypeData = enumItemData[Enum.BundleType]

	local x = CatalogSearchParams.new()
	x.IncludeOffSale = Squash.boolean.des(string.sub(y, 1, 1))
	x.MinPrice = Squash.uint.des(string.sub(y, 2, 5), 4)
	x.MaxPrice = Squash.uint.des(string.sub(y, 6, 9), 4)

	local offset = 10
	offset, x.SalesTypeFilter = desEnumItem(y, offset, Enum.SalesTypeFilter)
	offset, x.CategoryFilter = desEnumItem(y, offset, Enum.CatalogCategoryFilter)
	offset, x.SortAggregation = desEnumItem(y, offset, Enum.CatalogSortAggregation)
	offset, x.SortType = desEnumItem(y, offset, Enum.CatalogSortType)

	local assetTypes = {}
	local delimiter1 = string.find(y, Squash.delimiter, offset, true) :: number
	for i, v in unpackBits(string.sub(y, offset, delimiter1 - 1), avatarAssetTypeData.bits) do
		assetTypes[i] = avatarAssetTypeData.items[v]
	end
	x.AssetTypes = assetTypes
	offset = delimiter1 + 1

	local bundleTypes = {}
	local delimiter2 = string.find(y, Squash.delimiter, offset, true) :: number
	for i, v in unpackBits(string.sub(y, offset, delimiter2 - 1), bundleTypeData.bits) do
		bundleTypes[i] = bundleTypeData.items[v]
	end
	x.BundleTypes = bundleTypes
	offset = delimiter2 + 1

	local delimiter3 = string.find(y, Squash.delimiter, offset, true) :: number
	x.SearchKeyword = Squash.string.des(string.sub(y, offset, delimiter3 - 1), alphabet)
	x.CreatorName = Squash.string.des(string.sub(y, delimiter3 + 1), alphabet)
	return x
end

--[=[
	@within CatalogSearchParams
	@function serarr
	@param x { CatalogSearchParams }
	@param alphabet Alphabet?
	@return string
]=]
Squash.CatalogSearchParams.serarr = serArrayVariable(Squash.CatalogSearchParams)

--[=[
	@within CatalogSearchParams
	@function desarr
	@param y string
	@param alphabet Alphabet?
	@return { CatalogSearchParams }
]=]
Squash.CatalogSearchParams.desarr = desArrayVariable(Squash.CatalogSearchParams)

--[=[
	@class DateTime
]=]
Squash.DateTime = {}

local dateTimeOffset = 17_987_443_200

--[=[
	@within DateTime
	@function ser
	@param x DateTime
	@return string
]=]
Squash.DateTime.ser = function(x: DateTime): string
	return Squash.uint.ser(x.UnixTimestamp + dateTimeOffset, 5)
end

--[=[
	@within DateTime
	@function des
	@param y string
	@return DateTime
]=]
Squash.DateTime.des = function(y: string): DateTime
	return DateTime.fromUnixTimestamp(Squash.uint.des(y, 5) - dateTimeOffset)
end

--[=[
	@within DateTime
	@function serarr
	@param x { DateTime }
	@return string
]=]
Squash.DateTime.serarr = serArrayFixed(Squash.DateTime)

--[=[
	@within DateTime
	@function desarr
	@param y string
	@return { DateTime }
]=]
Squash.DateTime.desarr = desArrayFixed(Squash.DateTime, 5)

--[=[
	@class DockWidgetPluginGuiInfo

	This is broken. Roblox doesn't allow us to access any of the fields even though they've made it very clear they should be accessible. Until this is addressed, this type's serdes functions will not function properly.
]=]
Squash.DockWidgetPluginGuiInfo = {}

--[=[
	@within DockWidgetPluginGuiInfo
	@function ser
	@param x DockWidgetPluginGuiInfo
	@return string
]=]
Squash.DockWidgetPluginGuiInfo.ser = function(x: DockWidgetPluginGuiInfo): string
	-- return Squash.boolean.ser(x.InitialEnabled, x.InitialEnabledShouldOverrideRestore)
	-- 	.. Squash.int.ser(x.FloatingXSize, 2)
	-- 	.. Squash.int.ser(x.FloatingYSize, 2)
	-- 	.. Squash.int.ser(x.MinWidth, 2)
	-- 	.. Squash.int.ser(x.MinHeight, 2)

	return ''
end

--[=[
	@within DockWidgetPluginGuiInfo
	@function des
	@param y string
	@return DockWidgetPluginGuiInfo
]=]
Squash.DockWidgetPluginGuiInfo.des = function(y: string): DockWidgetPluginGuiInfo
	local x = DockWidgetPluginGuiInfo.new()
	-- x.InitialEnabled, x.InitialEnabledShouldOverrideRestore = Squash.boolean.des(string.sub(y, 1, 1)) -- TODO: Fix this when possible.
	-- x.FloatingXSize = Squash.int.des(string.sub(y, 2, 3), 2)
	-- x.FloatingYSize = Squash.int.des(string.sub(y, 4, 5), 2)
	-- x.MinWidth = Squash.int.des(string.sub(y, 6, 7), 2)
	-- x.MinHeight = Squash.int.des(string.sub(y, 8, 9), 2)
	return x
end

--[=[
	@within DockWidgetPluginGuiInfo
	@function serarr
	@param x { DockWidgetPluginGuiInfo }
	@return string
]=]
Squash.DockWidgetPluginGuiInfo.serarr = serArrayFixed(Squash.DockWidgetPluginGuiInfo)

--[=[
	@within DockWidgetPluginGuiInfo
	@function desarr
	@param y string
	@return { DockWidgetPluginGuiInfo }
]=]
Squash.DockWidgetPluginGuiInfo.desarr = desArrayFixed(Squash.DockWidgetPluginGuiInfo, 9)

--[=[
	@class ColorSequenceKeypoint
]=]
Squash.ColorSequenceKeypoint = {}

--[=[
	@within ColorSequenceKeypoint
	@function ser
	@param x ColorSequenceKeypoint
	@return string
]=]
Squash.ColorSequenceKeypoint.ser = function(x: ColorSequenceKeypoint): string
	return string.char(x.Time * 255) .. Squash.Color3.ser(x.Value)
end

--[=[
	@within ColorSequenceKeypoint
	@function des
	@param y string
	@return ColorSequenceKeypoint
]=]
Squash.ColorSequenceKeypoint.des = function(y: string): ColorSequenceKeypoint
	return ColorSequenceKeypoint.new(string.byte(y, 1) / 255, Squash.Color3.des(string.sub(y, 2, 4)))
end

--[=[
	@within ColorSequenceKeypoint
	@function serarr
	@param x { ColorSequenceKeypoint }
	@return string
]=]
Squash.ColorSequenceKeypoint.serarr = serArrayFixed(Squash.ColorSequenceKeypoint)

--[=[
	@within ColorSequenceKeypoint
	@function desarr
	@param y string
	@return { ColorSequenceKeypoint }
]=]
Squash.ColorSequenceKeypoint.desarr = desArrayFixed(Squash.ColorSequenceKeypoint, 4)

--[=[
	@class ColorSequence
]=]
Squash.ColorSequence = {}

--[=[
	@within ColorSequence
	@function ser
	@param x ColorSequence
	@return string
]=]
Squash.ColorSequence.ser = function(x: ColorSequence): string
	return Squash.ColorSequenceKeypoint.serarr(x.Keypoints)
end

--[=[
	@within ColorSequence
	@function des
	@param y string
	@return ColorSequence
]=]
Squash.ColorSequence.des = function(y: string): ColorSequence
	return ColorSequence.new(Squash.ColorSequenceKeypoint.desarr(y))
end

--[=[
	@within ColorSequence
	@function serarr
	@param x { ColorSequence }
	@return string
]=]
Squash.ColorSequence.serarr = serArrayVariable(Squash.ColorSequence)

--[=[
	@within ColorSequence
	@function desarr
	@param y string
	@return { ColorSequence }
]=]
Squash.ColorSequence.desarr = desArrayVariable(Squash.ColorSequence)

--[=[
	@class Faces
]=]
Squash.Faces = {}

--[=[
	@within Faces
	@function ser
	@param x Faces
	@return string
]=]
Squash.Faces.ser = function(x: Faces): string
	return Squash.boolean.ser(x.Top, x.Bottom, x.Left, x.Right, x.Back, x.Front)
end

--[=[
	@within Faces
	@function des
	@param y string
	@return Faces
]=]
Squash.Faces.des = function(y: string): Faces
	local top, bottom, left, right, back, front = Squash.boolean.des(y)
	return Faces.new(
		top and Enum.NormalId.Top,
		bottom and Enum.NormalId.Bottom,
		left and Enum.NormalId.Left,
		right and Enum.NormalId.Right,
		back and Enum.NormalId.Back,
		front and Enum.NormalId.Front
	)
end

--[=[
	@within Faces
	@function serarr
	@param x { Faces }
	@return string
]=]
Squash.Faces.serarr = serArrayFixed(Squash.Faces)

--[=[
	@within Faces
	@function desarr
	@param y string
	@return { Faces }
]=]
Squash.Faces.desarr = desArrayFixed(Squash.Faces, 1)

--[=[
	@class FloatCurveKey
]=]
Squash.FloatCurveKey = {}

--[=[
	@within FloatCurveKey
	@function ser
	@param x FloatCurveKey
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.FloatCurveKey.ser = function(x: FloatCurveKey): string
	local y = Squash.EnumItem.ser(x.Interpolation, Enum.KeyInterpolationMode)
		.. Squash.number.ser(x.Time)
		.. Squash.number.ser(x.Value)

	if x.Interpolation == Enum.KeyInterpolationMode.Cubic then
		y ..= Squash.number.ser(x.LeftTangent) .. Squash.number.ser(x.RightTangent)
	end

	return y
end

--[=[
	@within FloatCurveKey
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return FloatCurveKey
]=]
Squash.FloatCurveKey.des = function(y: string): FloatCurveKey
	local offset = enumItemData[Enum.KeyInterpolationMode].bytes
	local x = FloatCurveKey.new(
		Squash.number.des(string.sub(y, offset + 1, offset + 4)),
		Squash.number.des(string.sub(y, offset + 5, offset + 8)),
		Squash.EnumItem.des(string.sub(y, 1, offset), Enum.KeyInterpolationMode) :: Enum.KeyInterpolationMode
	)

	if x.Interpolation == Enum.KeyInterpolationMode.Cubic then
		offset += 8
		x.LeftTangent = Squash.number.des(string.sub(y, offset + 1, offset + 4))
		offset += 4
		x.RightTangent = Squash.number.des(string.sub(y, offset + 1, offset + 4))
	end

	return x
end

--[=[
	@within FloatCurveKey
	@function serarr
	@param x { FloatCurveKey }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.FloatCurveKey.serarr = serArrayVariable(Squash.FloatCurveKey)

--[=[
	@within FloatCurveKey
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { FloatCurveKey }
]=]
Squash.FloatCurveKey.desarr = desArrayVariable(Squash.FloatCurveKey)

--[=[
	@class Font
]=]
Squash.Font = {}

--[=[
	@within Font
	@function ser
	@param x Font
	@return string
]=]
Squash.Font.ser = function(x: Font): string
	local family = string.match(x.Family, '(.+)%..+$')
	if not family then
		error 'Font Family must be a Roblox Font'
	end

	return Squash.EnumItem.ser(x.Style, Enum.FontStyle)
		.. Squash.EnumItem.ser(x.Weight, Enum.FontWeight)
		.. Squash.string.ser(family, Squash.filepath)
end

--[=[
	@within Font
	@function des
	@param y string
	@return Font
]=]
Squash.Font.des = function(y: string): Font
	local a, b = 1, enumItemData[Enum.FontStyle].bytes
	local style = Squash.EnumItem.des(string.sub(y, a, b), Enum.FontStyle) :: Enum.FontStyle
	a += b
	b += enumItemData[Enum.FontWeight].bytes
	local fontWeight = Squash.EnumItem.des(string.sub(y, a, b), Enum.FontWeight) :: Enum.FontWeight
	local family = Squash.string.des(string.sub(y, b + 1), Squash.filepath) .. '.json'
	return Font.new(family, fontWeight, style)
end

--[=[
	@within Font
	@function serarr
	@param x { Font }
	@return string
]=]
Squash.Font.serarr = serArrayVariable(Squash.Font)

--[=[
	@within Font
	@function desarr
	@param y string
	@return { Font }
]=]
Squash.Font.desarr = desArrayVariable(Squash.Font)

--[=[
	@class NumberRange
]=]
Squash.NumberRange = {}

--[=[
	@within NumberRange
	@function ser
	@param x NumberRange
	@param serdes NumberSerDes?
	@param bytes Bytes?
]=]
Squash.NumberRange.ser = function(x: NumberRange, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return ser(x.Min, bytes) .. ser(x.Max, bytes)
end

--[=[
	@within NumberRange
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return NumberRange
]=]
Squash.NumberRange.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): NumberRange
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4
	return NumberRange.new(des(string.sub(y, 1, bytes), bytes), des(string.sub(y, bytes + 1, 2 * bytes), bytes))
end

--[=[
	@within NumberRange
	@function serarr
	@param x { NumberRange }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.NumberRange.serarr = serArrayVector(Squash.NumberRange)

--[=[
	@within NumberRange
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { NumberRange }
]=]
Squash.NumberRange.desarr = desArrayVector(Squash.NumberRange, 2, 0)

--[=[
	@class NumberSequenceKeypoint
]=]
Squash.NumberSequenceKeypoint = {}

--[=[
	@within NumberSequenceKeypoint
	@function ser
	@param x NumberSequenceKeypoint
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.NumberSequenceKeypoint.ser = function(x: NumberSequenceKeypoint, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return string.char(x.Time * 255) .. ser(x.Value, bytes) .. ser(x.Envelope, bytes)
end

--[=[
	@within NumberSequenceKeypoint
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return NumberSequenceKeypoint
]=]
Squash.NumberSequenceKeypoint.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): NumberSequenceKeypoint
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4
	return NumberSequenceKeypoint.new(
		string.byte(y, 1) / 255,
		des(string.sub(y, 2, 1 + bytes), bytes),
		des(string.sub(y, 2 + bytes, 1 + 2 * bytes), bytes)
	)
end

--[=[
	@within NumberSequenceKeypoint
	@function serarr
	@param x { NumberSequenceKeypoint }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.NumberSequenceKeypoint.serarr = serArrayVector(Squash.NumberSequenceKeypoint)

--[=[
	@within NumberSequenceKeypoint
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { NumberSequenceKeypoint }
]=]
Squash.NumberSequenceKeypoint.desarr = desArrayVector(Squash.NumberSequenceKeypoint, 2, 1)

--[=[
	@class NumberSequence
]=]
Squash.NumberSequence = {}

--[=[
	@within NumberSequence
	@function ser
	@param x NumberSequence
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string

	Careful when calling this with Squash.uint,
]=]
Squash.NumberSequence.ser = function(x: NumberSequence, serdes: NumberSerDes?, bytes: Bytes?): string
	return Squash.NumberSequenceKeypoint.serarr(x.Keypoints, serdes, bytes) --TODO: Recognize that the start and end times are always 0 and 1 and omit them.
end

--[=[
	@within NumberSequence
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return NumberSequence
]=]
Squash.NumberSequence.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): NumberSequence
	return NumberSequence.new(Squash.NumberSequenceKeypoint.desarr(y, serdes, bytes))
end

--[=[
	@within NumberSequence
	@function serarr
	@param x { NumberSequence }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.NumberSequence.serarr = serArrayVariable(Squash.NumberSequence)

--[=[
	@within NumberSequence
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { NumberSequence }
]=]
Squash.NumberSequence.desarr = desArrayVariable(Squash.NumberSequence)

--[=[
	@class OverlapParams
]=]
Squash.OverlapParams = {}

--[=[
	@within OverlapParams
	@function ser
	@param x OverlapParams
	@return string

	The FilterDescedantsInstances property is not serialized because is an array of Instance objects, which are not supported.
]=]
Squash.OverlapParams.ser = function(x: OverlapParams): string
	return string.char(
		(if x.FilterType == Enum.RaycastFilterType.Include then 1 else 0) + (if x.RespectCanCollide then 2 else 0)
	) .. Squash.uint.ser(x.MaxParts, 2) .. Squash.string.ser(x.CollisionGroup) -- I wish we could use GetCollisionGroupId and restrict this to 1 or 2 bytes, but that was deprecated.
end

--[=[
	@within OverlapParams
	@function des
	@param y string
	@return OverlapParams
]=]
Squash.OverlapParams.des = function(y: string): OverlapParams
	local filterTypeAndRespectCanCollide = string.byte(y, 1)

	local x = OverlapParams.new()
	x.CollisionGroup = Squash.string.des(string.sub(y, 4))
	x.MaxParts = Squash.uint.des(string.sub(y, 2, 3), 2)
	x.RespectCanCollide = filterTypeAndRespectCanCollide >= 2
	x.FilterType = if filterTypeAndRespectCanCollide % 2 == 1
		then Enum.RaycastFilterType.Include
		else Enum.RaycastFilterType.Exclude

	return x
end

--[=[
	@within OverlapParams
	@function serarr
	@param x { OverlapParams }
	@return string
]=]
Squash.OverlapParams.serarr = serArrayVariable(Squash.OverlapParams)

--[=[
	@within OverlapParams
	@function desarr
	@param y string
	@return { OverlapParams }
]=]
Squash.OverlapParams.desarr = desArrayVariable(Squash.OverlapParams)

--[=[
	@class RaycastParams
]=]
Squash.RaycastParams = {}

--[=[
	@within RaycastParams
	@function ser
	@param x RaycastParams
	@return string
]=]
Squash.RaycastParams.ser = function(x: RaycastParams): string
	return Squash.boolean.ser(x.FilterType == Enum.RaycastFilterType.Include, x.IgnoreWater, x.RespectCanCollide)
		.. Squash.string.ser(x.CollisionGroup)
end

--[=[
	@within RaycastParams
	@function des
	@param y string
	@return RaycastParams
]=]
Squash.RaycastParams.des = function(y: string): RaycastParams
	local isInclude, ignoreWater, respectCanCollide = Squash.boolean.des(string.sub(y, 1, 1))

	local x = RaycastParams.new()
	x.CollisionGroup = Squash.string.des(string.sub(y, 2))
	x.RespectCanCollide = respectCanCollide
	x.IgnoreWater = ignoreWater
	x.FilterType = if isInclude then Enum.RaycastFilterType.Include else Enum.RaycastFilterType.Exclude

	return x
end

--[=[
	@within RaycastParams
	@function serarr
	@param x { RaycastParams }
	@return string
]=]
Squash.RaycastParams.serarr = serArrayVariable(Squash.RaycastParams)

--[=[
	@within RaycastParams
	@function desarr
	@param y string
	@return { RaycastParams }
]=]
Squash.RaycastParams.desarr = desArrayVariable(Squash.RaycastParams)

--[=[
	@class PathWaypoint
]=]
Squash.PathWaypoint = {}

--[=[
	@within PathWaypoint
	@function ser
	@param x PathWaypoint
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.PathWaypoint.ser = function(x: PathWaypoint, serdes: NumberSerDes?, bytes: Bytes?): string
	local bytes = bytes or 4
	return Squash.EnumItem.ser(x.Action, Enum.PathWaypointAction)
		.. Squash.Vector3.ser(x.Position, serdes, bytes)
		.. Squash.string.ser(x.Label)
end

--[=[
	@within PathWaypoint
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return PathWaypoint
]=]
Squash.PathWaypoint.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): PathWaypoint
	local bytes = bytes or 4
	local offset, action = 1, nil
	offset, action = desEnumItem(y, offset, Enum.PathWaypointAction)
	local position = Squash.Vector3.des(string.sub(y, offset, offset + 3 * bytes), serdes, bytes)
	offset += 3 * bytes
	local label = Squash.string.des(string.sub(y, offset + 1))
	return PathWaypoint.new(position, action :: Enum.PathWaypointAction, label)
end

--[=[
	@within PathWaypoint
	@function serarr
	@param x { PathWaypoint }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.PathWaypoint.serarr = serArrayVector(Squash.PathWaypoint)

--[=[
	@within PathWaypoint
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { PathWaypoint }
]=]
Squash.PathWaypoint.desarr = desArrayVector(Squash.PathWaypoint, 3, enumItemData[Enum.PathWaypointAction].bytes)

--[=[
	@class PhysicalProperties
]=]
Squash.PhysicalProperties = {}

--[=[
	@within PhysicalProperties
	@function ser
	@param x PhysicalProperties
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.PhysicalProperties.ser = function(x: PhysicalProperties, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return ser(x.Density, bytes)
		.. ser(x.Friction, bytes)
		.. ser(x.Elasticity, bytes)
		.. ser(x.FrictionWeight, bytes)
		.. ser(x.ElasticityWeight, bytes)
end

--[=[
	@within PhysicalProperties
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return PhysicalProperties

	The minimum density is 0.009999999776482582, so if the serialization rounds down to 0, it will be set to 0.009999999776482582 when deserialized.
]=]
Squash.PhysicalProperties.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): PhysicalProperties
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4
	return PhysicalProperties.new(
		des(string.sub(y, 1 + 0 * bytes, 1 * bytes), bytes),
		des(string.sub(y, 1 + 1 * bytes, 2 * bytes), bytes),
		des(string.sub(y, 1 + 2 * bytes, 3 * bytes), bytes),
		des(string.sub(y, 1 + 3 * bytes, 4 * bytes), bytes),
		des(string.sub(y, 1 + 4 * bytes, 5 * bytes), bytes)
	)
end

--[=[
	@within PhysicalProperties
	@function serarr
	@param x { PhysicalProperties }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.PhysicalProperties.serarr = serArrayVector(Squash.PhysicalProperties)

--[=[
	@within PhysicalProperties
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { PhysicalProperties }
]=]
Squash.PhysicalProperties.desarr = desArrayVector(Squash.PhysicalProperties, 5, 0)

--[=[
	@class Ray
]=]
Squash.Ray = {}

--[=[
	@within Ray
	@function ser
	@param x Ray
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Ray.ser = function(x: Ray, serdes: NumberSerDes?, bytes: Bytes?): string
	local bytes = bytes or 4
	return Squash.Vector3.ser(x.Origin, serdes, bytes) .. Squash.Vector3.ser(x.Direction, serdes, bytes)
end

--[=[
	@within Ray
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return Ray
]=]
Squash.Ray.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): Ray
	local bytes = bytes or 4
	return Ray.new(
		Squash.Vector3.des(string.sub(y, 1 + 0 * bytes, 3 * bytes), serdes, bytes),
		Squash.Vector3.des(string.sub(y, 1 + 3 * bytes, 6 * bytes), serdes, bytes)
	)
end

--[=[
	@within Ray
	@function serarr
	@param x { Ray }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Ray.serarr = serArrayVector(Squash.Ray)

--[=[
	@within Ray
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { Ray }
]=]
Squash.Ray.desarr = desArrayVector(Squash.Ray, 2, 0)

--[=[
	@class RaycastResult
]=]
Squash.RaycastResult = {}

--[=[
	@within RaycastResult
	@function ser
	@param x RaycastResult
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.RaycastResult.ser = function(x: RaycastResult, serdes: NumberSerDes?, bytes: Bytes?): string
	local bytes = bytes or 4
	return Squash.EnumItem.ser(x.Material, Enum.Material)
		.. Squash.uint.ser(x.Distance, bytes)
		.. Squash.Vector3.ser(x.Position, serdes, bytes)
		.. Squash.Vector3.ser(x.Normal, serdes, bytes)
end

--[=[
	@within Squash
	@interface SquashRaycastResult
	.Material Enum.Material
	.Distance number
	.Position Vector3
	.Normal Vector3
]=]
export type SquashRaycastResult = {
	Material: Enum.Material,
	Distance: number,
	Position: Vector3,
	Normal: Vector3,
}

--[=[
	@within RaycastResult
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { Material: Enum.Material, Distance: number, Position: Vector3, Normal: Vector3 }
]=]
Squash.RaycastResult.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): SquashRaycastResult
	local bytes = bytes or 4

	local offset, material = 1, nil
	offset, material = desEnumItem(y, offset, Enum.Material)
	offset -= 1

	local distance = Squash.uint.des(string.sub(y, offset + 1, offset + 1 * bytes), bytes)
	offset += bytes

	local position = Squash.Vector3.des(string.sub(y, offset + 1, offset + 3 * bytes), serdes, bytes)
	offset += 3 * bytes

	local normal = Squash.Vector3.des(string.sub(y, offset + 1, offset + 3 * bytes), serdes, bytes)

	return {
		Material = material :: Enum.Material,
		Distance = distance,
		Position = position,
		Normal = normal,
	}
end

--[=[
	@within RaycastResult
	@function serarr
	@param x { RaycastResult }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.RaycastResult.serarr = serArrayVector(Squash.RaycastResult)

--[=[
	@within RaycastResult
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { RaycastResult }
]=]
Squash.RaycastResult.desarr = desArrayVector(Squash.RaycastResult, 7, enumItemData[Enum.Material].bytes)

--[=[
	@class Rect
]=]
Squash.Rect = {}

--[=[
	@within Rect
	@function ser
	@param x Rect
	@param bytes Bytes?
	@return string
]=]
Squash.Rect.ser = function(x: Rect, bytes: Bytes?)
	local bytes = bytes or 4
	return Squash.uint.ser(x.Min.X, bytes)
		.. Squash.uint.ser(x.Min.Y, bytes)
		.. Squash.uint.ser(x.Max.X, bytes)
		.. Squash.uint.ser(x.Max.Y, bytes)
end

--[=[
	@within Rect
	@function des
	@param y string
	@param bytes Bytes?
	@return Rect
]=]
Squash.Rect.des = function(y: string, bytes: Bytes?): Rect
	local bytes = bytes or 4
	return Rect.new(
		Squash.uint.des(string.sub(y, 1 + 0 * bytes, 1 * bytes), bytes),
		Squash.uint.des(string.sub(y, 1 + 1 * bytes, 2 * bytes), bytes),
		Squash.uint.des(string.sub(y, 1 + 2 * bytes, 3 * bytes), bytes),
		Squash.uint.des(string.sub(y, 1 + 3 * bytes, 4 * bytes), bytes)
	)
end

--[=[
	@within Rect
	@function serarr
	@param x { Rect }
	@param bytes Bytes?
	@return string
]=]
Squash.Rect.serarr = serArrayVectorNoCoding(Squash.Rect)

--[=[
	@within Rect
	@function desarr
	@param y string
	@param bytes Bytes?
	@return { Rect }
]=]
Squash.Rect.desarr = desArrayVectorNoCoding(Squash.Rect, 4, 0)

--[=[
	@class Region3
	Finnicky with uints, beware.
]=]
Squash.Region3 = {}

--[=[
	@within Region3
	@function ser
	@param x Region3
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Region3.ser = function(x: Region3, serdes: NumberSerDes?, bytes: Bytes?): string
	local bytes = bytes or 4
	return Squash.Vector3.ser(x.Size, serdes, bytes) .. Squash.Vector3.ser(x.CFrame.Position, serdes, bytes)
end

--[=[
	@within Region3
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return Region3
]=]
Squash.Region3.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): Region3
	local bytes = bytes or 4
	local size = 0.5 * Squash.Vector3.des(string.sub(y, 1 + 0 * bytes, 3 * bytes), serdes, bytes)
	local position = Squash.Vector3.des(string.sub(y, 1 + 3 * bytes, 6 * bytes), serdes, bytes)
	return Region3.new(position - size, position + size)
end

--[=[
	@within Region3
	@function serarr
	@param x { Region3 }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.Region3.serarr = serArrayVector(Squash.Region3)

--[=[
	@within Region3
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { Region3 }
]=]
Squash.Region3.desarr = desArrayVector(Squash.Region3, 9, 6)

--[=[
	@class Region3int16
	Default bytes is 2, because int16 is 2 bytes. Region3int16 internally uses 2's compliment, where for example a value of 64700 is treated as -836. Beware of this when serdes-ing with uint.
]=]
Squash.Region3int16 = {}

--[=[
	@within Region3int16
	@function ser
	@param x Region3int16
	@return string
]=]
Squash.Region3int16.ser = function(x: Region3int16, serdes: NumberSerDes?, bytes: number?): string
	local bytes = bytes or 2
	return Squash.Vector3int16.ser(x.Min, serdes, bytes) .. Squash.Vector3int16.ser(x.Max, serdes, bytes)
end

--[=[
	@within Region3int16
	@function des
	@param y string
	@return Region3int16
]=]
Squash.Region3int16.des = function(y: string, serdes: NumberSerDes?, bytes: number?): Region3int16
	local bytes = bytes or 2
	return Region3int16.new(
		Squash.Vector3int16.des(string.sub(y, 1 + 0 * bytes, 3 * bytes), serdes, bytes),
		Squash.Vector3int16.des(string.sub(y, 1 + 3 * bytes, 6 * bytes), serdes, bytes)
	)
end

--[=[
	@within Region3int16
	@function serarr
	@param x { Region3int16 }
	@return string
]=]
Squash.Region3int16.serarr = serArrayFixed(Squash.Region3int16)

--[=[
	@within Region3int16
	@function desarr
	@param y string
	@return { Region3int16 }
]=]
Squash.Region3int16.desarr = desArrayFixed(Squash.Region3int16, 12)

--[=[
	@class TweenInfo
]=]
Squash.TweenInfo = {}

--[=[
	@within TweenInfo
	@function ser
	@param x TweenInfo
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.TweenInfo.ser = function(x: TweenInfo, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return Squash.boolean.ser(x.Reverses)
		.. Squash.EnumItem.ser(x.EasingStyle, Enum.EasingStyle)
		.. Squash.EnumItem.ser(x.EasingDirection, Enum.EasingDirection)
		.. Squash.uint.ser(x.RepeatCount, bytes)
		.. ser(x.Time, bytes)
		.. ser(x.DelayTime, bytes)
end

--[=[
	@within TweenInfo
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return TweenInfo
]=]
Squash.TweenInfo.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): TweenInfo
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4

	local offset = 1
	local reverses = Squash.boolean.des(string.sub(y, offset, offset))
	offset += 1

	local easingStyle
	offset, easingStyle = desEnumItem(y, offset, Enum.EasingStyle)

	local easingDirection
	offset, easingDirection = desEnumItem(y, offset, Enum.EasingDirection)

	local repeatCount = Squash.uint.des(string.sub(y, offset, offset + bytes - 1), bytes)
	offset += bytes

	local tweenTime = des(string.sub(y, offset, offset + bytes - 1), bytes)
	offset += bytes

	local delayTime = des(string.sub(y, offset, offset + bytes - 1), bytes)

	return TweenInfo.new(
		tweenTime,
		easingStyle :: Enum.EasingStyle,
		easingDirection :: Enum.EasingDirection,
		repeatCount,
		reverses,
		delayTime
	)
end

--[=[
	@within TweenInfo
	@function serarr
	@param x { TweenInfo }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.TweenInfo.serarr = serArrayVector(Squash.TweenInfo)

--[=[
	@within TweenInfo
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { TweenInfo }
]=]
Squash.TweenInfo.desarr = desArrayVector(
	Squash.TweenInfo,
	3,
	1 + enumItemData[Enum.EasingStyle].bytes + enumItemData[Enum.EasingDirection].bytes
)

--[=[
	@class UDim
]=]
Squash.UDim = {}

--[=[
	@within UDim
	@function ser
	@param x UDim
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.UDim.ser = function(x: UDim, serdes: NumberSerDes?, bytes: Bytes?): string
	local ser = if serdes then serdes.ser else Squash.number.ser :: NumberSer
	local bytes = bytes or 4
	return ser(x.Scale, bytes) .. ser(x.Offset, bytes)
end

--[=[
	@within UDim
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return UDim
]=]
Squash.UDim.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): UDim
	local des = if serdes then serdes.des else Squash.number.des :: NumberDes
	local bytes = bytes or 4
	return UDim.new(des(string.sub(y, 1, bytes), bytes), des(string.sub(y, bytes + 1, 2 * bytes), bytes))
end

--[=[
	@within UDim
	@function serarr
	@param x { UDim }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.UDim.serarr = serArrayVector(Squash.UDim)

--[=[
	@within UDim
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { UDim }
]=]
Squash.UDim.desarr = desArrayVector(Squash.UDim, 2, 0)

--[=[
	@class UDim2
]=]
Squash.UDim2 = {}

--[=[
	@within UDim2
	@function ser
	@param x UDim2
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.UDim2.ser = function(x: UDim2, serdes: NumberSerDes?, bytes: Bytes?): string
	local bytes = bytes or 4
	return Squash.UDim.ser(x.X, serdes, bytes) .. Squash.UDim.ser(x.Y, serdes, bytes)
end

--[=[
	@within UDim2
	@function des
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return UDim2
]=]
Squash.UDim2.des = function(y: string, serdes: NumberSerDes?, bytes: Bytes?): UDim2
	local bytes = bytes or 4
	return UDim2.new(
		Squash.UDim.des(string.sub(y, 1, 2 * bytes), serdes, bytes),
		Squash.UDim.des(string.sub(y, 2 * bytes + 1, 4 * bytes), serdes, bytes)
	)
end

--[=[
	@within UDim2
	@function serarr
	@param x { UDim2 }
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return string
]=]
Squash.UDim2.serarr = serArrayVector(Squash.UDim2)

--[=[
	@within UDim2
	@function desarr
	@param y string
	@param serdes NumberSerDes?
	@param bytes Bytes?
	@return { UDim2 }
]=]
Squash.UDim2.desarr = desArrayVector(Squash.UDim2, 4, 0)

return Squash
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000569</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX9989BDB0205D4560A465EFF1E45F3AC7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">spark</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000556</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX9E2FBC0D8AA54380A4E7FFFC9C68D012">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{322E87CE-BECB-46B7-A0D5-692456F4A129}</string>
								<ProtectedString name="Source"><![CDATA[--[=[
    @class Spark
]=]

--[=[
    [Enum.UserInputType] must represent a button. Inputs like [Enum.UserInputType.MouseMovement] will not work as a button.

    @type Button Enum.KeyCode | Enum.UserInputType
    @within Spark
]=]

--[=[
    [Enum.UserInputType] must represent a 2D value. Inputs like [Enum.UserInputType.MouseButton1] will not work as a 2D value.

    @type Input2d Enum.UserInputType | VirtualAxis2d
    @within Spark
]=]

--[=[
    @type Input Enum.KeyCode | Enum.UserInputType | VirtualAxis | VirtualAxis2d | Multiply2d
    @within Spark
]=]

--[=[
    @prop Actions Actions
    @within Spark
]=]

--[=[
    @prop InputMap InputMap
    @within Spark
]=]

--[=[
    @prop InputState InputState
    @within Spark
]=]

--[=[
    @prop Multiply2d Multiply2d
    @within Spark
]=]

--[=[
    @prop Rebind Rebind
    @within Spark
]=]

--[=[
    @prop Signal Signal
    @within Spark
]=]

--[=[
    @prop VirtualAxis VirtualAxis
    @within Spark
]=]

--[=[
    @prop VirtualAxis2d VirtualAxis2d
    @within Spark
]=]
return {
	Actions = require(script.Actions),
	InputMap = require(script.InputMap),
	InputState = require(script.InputState),
	Multiply2d = require(script.Multiply2d),
	Rebind = require(script.Rebind),
	VirtualAxis = require(script.VirtualAxis),
	VirtualAxis2d = require(script.VirtualAxis2d),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000557</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX4469FE69C0D649D1B3DC2080E64200DC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Actions</string>
									<string name="ScriptGuid">{D1458AF0-B953-4E45-BAF3-06360985FFFA}</string>
									<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local Signal = require(script.Parent.Signal)

--[=[
	Updates and reads action state.

	```lua
	local actions = Actions.new({ "move", "jump" })

	local disconnect = actions:justPressedSignal("jump"):connect(function()
		print("Jumped!")
	end)

	local moveVector = actions:axis2d("move")
	```

	:::note
	[Actions:update] should be called every frame before calling [InputState:clear].
	:::

	@class Actions
]=]
local Actions = {}
Actions.__index = Actions

--[=[
	Creates a new `Actions`.

	@param actions { string } -- List of action names
	@return Actions
]=]
function Actions.new(actions)
	local state = {}
	local justPressedSignals = {}
	local justReleasedSignals = {}

	for _, action in actions do
		state[action] = {
			manualHolds = 0,
			manualMove = Vector2.zero,
			pressed = false,
			value = 0,
			axis2d = Vector2.zero,
		}
		justPressedSignals[action] = Signal.new()
		justReleasedSignals[action] = Signal.new()
	end

	return setmetatable({
		state = state,
		justPressedSignals = justPressedSignals,
		justReleasedSignals = justReleasedSignals,
	}, Actions)
end

--[=[
	Updates action states.

	This should be called once every frame before calling [InputState:clear].

	@param inputState InputState
	@param inputMap InputMap -- The associated InputMap
]=]
function Actions:update(inputState, inputMap)
	local gamepad = inputMap.associatedGamepad
	if gamepad == nil then
		for _, candidateGamepad in UserInputService:GetConnectedGamepads() do
			if gamepad == nil or candidateGamepad.Value < gamepad.Value then
				gamepad = candidateGamepad
			end
		end
	end

	for action, state in self.state do
		local inputs = inputMap:get(action)
		local pressed = state.manualHolds > 0
			or state.manualMove.Magnitude > 0
			or inputState:anyPressed(inputs, gamepad)
		local wasPressed = state.pressed

		state.pressed = pressed

		local value = 0
		for _, input in inputs do
			value += inputState:value(input, gamepad)
		end

		state.value = value + state.manualMove.Magnitude + state.manualHolds

		local axis2d = state.manualMove
		for _, input in inputs do
			local inputValue = inputState:axis2d(input, gamepad)

			if inputValue ~= nil then
				axis2d += inputValue
			end
		end

		state.axis2d = axis2d

		state.manualMove = Vector2.zero

		if pressed and not wasPressed then
			self.justPressedSignals[action]:fire()
		elseif not pressed and wasPressed then
			self.justReleasedSignals[action]:fire()
		end
	end
end

--[=[
	Returns whether `action` is currently pressed.

	@param action string
	@return boolean
]=]
function Actions:pressed(action)
	return self.state[action].pressed
end

--[=[
	Returns whether `action` is currently released.

	@param action string
	@return boolean
]=]
function Actions:released(action)
	return not self.state[action].pressed
end

--[=[
	Returns a [Signal] that is fired when `action` is pressed.

	```lua
	local disconnect = actions:justPressedSignal("jump"):connect(function()
		print("Jump pressed!")
	end)

	disconnect()
	```

	@param action string
	@return Signal
]=]
function Actions:justPressedSignal(action)
	return self.justPressedSignals[action]
end

--[=[
	Returns a [Signal] that is fired when `action` is released.

	```lua
	local disconnect = actions:justReleasedSignal("jump"):connect(function()
		print("Jump released!")
	end)

	disconnect()
	```

	@param action string
	@return Signal
]=]
function Actions:justReleasedSignal(action)
	return self.justReleasedSignals[action]
end

--[=[
	Returns the sum of the values of each input bound to `action`.

	The value of an input depends on its kind:
	- Buttons have a value of `0` when released and `1` when pressed.
	- [Enum.UserInputType.MouseWheel] returns the `Z` value of [InputObject.Position].
	- [VirtualAxis] returns the value of the positive input minus the value of the negative input.
	- 2D axis values like [Enum.UserInputType.MouseMovement], [Enum.KeyCode.Thumbstick1], or [VirutalAxis2d] will return their magnitude.

	:::warning
	The return value is not clamped to any range.
	:::

	@param action string
	@return number
]=]
function Actions:value(action)
	return self.state[action].value
end

--[=[
	Returns the sum of `Vector2` values of each input bound to `action`.

	The value of an input depends on its kind:
	- Buttons and 1D axis values like [Enum.UserInputType.MouseWheel] or [VirtualAxis] will always return [Vector2.zero].
	- [Enum.KeyCode.Thumbstick1] and [Enum.KeyCode.Thumbstick2] returns the `(X, Y)` value of [InputObject.Position].
	- [Enum.UserInputType.MouseMovement] returns the `(X, -Y)` value of [InputObject.Delta].
	- [VirtualAxis2d] returns `Vector2.new(rightValue - leftValue, upValue - downValue)`.

	:::warning
	The returned Vector2 is not clamped to any range. Consider using [Actions:normalizedAxis2d] or [Actions:clampedAxis2d].
	:::

	@param action string
	@return Vector2
]=]
function Actions:axis2d(action)
	return self.state[action].axis2d
end

--[=[
	Returns the [Actions:axis2d] value but normalized. If the value is `Vector2.zero`, `Vector2.zero` will be returned.

	@param action string
	@return Vector2
]=]
function Actions:normalizedAxis2d(action)
	local state = self.state[action].axis2d

	if state.Magnitude > 0 then
		return state.Unit
	else
		return state
	end
end

--[=[
	Returns the [Actions:axis2d] value but with the length clamped to `1`. This allows for `Vector2s` with a length less than `1` which is useful for gamepad and mobile thumbsticks.

	@param action string
	@return Vector2
]=]
function Actions:clampedAxis2d(action)
	local state = self.state[action].axis2d

	if state.Magnitude > 1 then
		return state.Unit
	else
		return state
	end
end

--[=[
	Presses `action` manually like a button. It returns a function to cancel the hold.

	This can be called more than once at the same time and each call will represent a different button press.

	This is useful to implement mobile buttons.

	:::warning
	The returned function will error if called more than once.
	:::

	@param action string
	@return () -> () -- A function that when called, stops the hold.
]=]
function Actions:hold(action)
	local state = self.state[action]

	state.manualHolds += 1

	local called = false

	return function()
		if called then
			error("Cannot cancel hold instance more than once")
		end

		called = true
		state.manualHolds -= 1
	end
end

--[=[
	Increases the axis2d value of `action` by `vector`.

	This value resets after [Actions:update] is called.

	This is useful to implement a mobile thumbstick.

	@param action string
	@param vector Vector2
	@return Vector2
]=]
function Actions:move(action, vector)
	self.state[action].manualMove += vector
end

return Actions
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000558</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX7127A27686784864A395ACE5F65B423E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Actions.test</string>
									<string name="ScriptGuid">{21C20E61-B80F-49A6-9A54-D7D98A2D0623}</string>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Spark = require(script.Parent)
local VirtualAxis = require(script.Parent.VirtualAxis)
local VirtualAxis2d = require(script.Parent.VirtualAxis2d)
local MutableInputState = require(ReplicatedStorage.MutableInputState)

local Actions = Spark.Actions
local InputMap = Spark.InputMap

return function(x)
	local assertEqual = x.assertEqual
	local shouldThrow = x.shouldThrow

	x.test("button presses", function()
		local actions = Actions.new({ "jump" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("jump", Enum.KeyCode.Space)

		local counter = 0
		local disconnect = actions:justPressedSignal("jump"):connect(function()
			counter += 1
		end)

		actions:update(inputState, inputMap)
		assertEqual(counter, 0)
		assertEqual(actions:pressed("jump"), false)

		inputState:press(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
		assertEqual(actions:pressed("jump"), true)

		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
		assertEqual(actions:pressed("jump"), true)

		inputState:release(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(actions:pressed("jump"), false)

		disconnect()

		inputState:press(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
		assertEqual(actions:pressed("jump"), true)
	end)

	x.test("button releases", function()
		local actions = Actions.new({ "jump" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("jump", Enum.KeyCode.Space)

		local counter = 0
		local disconnect = actions:justReleasedSignal("jump"):connect(function()
			counter += 1
		end)

		actions:update(inputState, inputMap)
		assertEqual(counter, 0)
		assertEqual(actions:released("jump"), true)

		inputState:press(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(counter, 0)
		assertEqual(actions:released("jump"), false)

		inputState:release(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
		assertEqual(actions:released("jump"), true)

		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
		assertEqual(actions:released("jump"), true)

		disconnect()

		inputState:press(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(actions:released("jump"), false)

		inputState:release(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
		assertEqual(actions:released("jump"), true)
	end)

	x.test("handles mouse wheel", function()
		local actions = Actions.new({ "scroll" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("scroll", Enum.UserInputType.MouseWheel)

		actions:update(inputState, inputMap)
		assertEqual(actions:value("scroll"), 0)

		inputState:scroll(4)

		actions:update(inputState, inputMap)
		assertEqual(actions:value("scroll"), 4)

		-- Updating InputState should reset the mouse wheel.
		inputState:clear()
		actions:update(inputState, inputMap)
		assertEqual(actions:value("scroll"), 0)
	end)

	x.test("handles axis2d values", function()
		local actions = Actions.new({ "mouse" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("mouse", Enum.UserInputType.MouseMovement)

		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("mouse"), Vector2.zero)
		assertEqual(actions:normalizedAxis2d("mouse"), Vector2.zero)

		inputState:moveMouse(Vector2.new(4, 3))

		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("mouse"), Vector2.new(4, 3))
		assertEqual(actions:normalizedAxis2d("mouse"), Vector2.new(4, 3).Unit)

		-- Updating InputState should reset mouse movement.
		inputState:clear()
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("mouse"), Vector2.zero)
		assertEqual(actions:normalizedAxis2d("mouse"), Vector2.zero)
	end)

	x.test("handles VirtualAxis", function()
		local input = VirtualAxis.horizontalArrowKeys()

		local actions = Actions.new({ "action" })
		local inputMap = InputMap.new():insert("action", input)
		local inputState = MutableInputState.new()

		actions:update(inputState, inputMap)
		assertEqual(actions:value("action"), 0)

		inputState:press(Enum.KeyCode.Left)
		actions:update(inputState, inputMap)
		assertEqual(actions:value("action"), -1)

		inputState:press(Enum.KeyCode.Right)
		actions:update(inputState, inputMap)
		assertEqual(actions:value("action"), 0)

		inputState:release(Enum.KeyCode.Left)
		actions:update(inputState, inputMap)
		assertEqual(actions:value("action"), 1)

		-- nil inputs should work
		input.negative = nil
		actions:update(inputState, inputMap)
		assertEqual(actions:value("action"), 1)
	end)

	x.test("handles VirtualAxis2d", function()
		local input = VirtualAxis2d.wasd()

		local actions = Actions.new({ "action" })
		local inputMap = InputMap.new():insert("action", input)
		local inputState = MutableInputState.new()

		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("action"), Vector2.zero)

		inputState:press(Enum.KeyCode.W)
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("action"), Vector2.yAxis)

		inputState:press(Enum.KeyCode.D)
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("action"), Vector2.one)

		inputState:press(Enum.KeyCode.S)
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("action"), Vector2.xAxis)

		-- nil inputs should work
		input.down = nil
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("action"), Vector2.one)
	end)

	x.test("clampedAxis2d", function()
		local actions = Actions.new({ "mouse" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("mouse", Enum.UserInputType.MouseMovement)

		inputState:moveMouse(Vector2.new(0.25, 0.5))
		actions:update(inputState, inputMap)
		assertEqual(actions:clampedAxis2d("mouse"), Vector2.new(0.25, 0.5))

		inputState:clear()
		inputState:moveMouse(Vector2.new(0.9, 0.8))
		actions:update(inputState, inputMap)
		assertEqual(actions:clampedAxis2d("mouse"), Vector2.new(0.9, 0.8).Unit)
	end)

	x.test("gamepad buttons", function()
		local actions = Actions.new({ "jump" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("jump", Enum.KeyCode.ButtonA)

		local counter = 0
		actions:justPressedSignal("jump"):connect(function()
			counter += 1
		end)

		inputState:pressGamepad(Enum.KeyCode.ButtonA, Enum.UserInputType.Gamepad1)
		actions:update(inputState, inputMap)
		assertEqual(counter, 0)

		inputState:releaseGamepad(Enum.KeyCode.ButtonA, Enum.UserInputType.Gamepad1)
		inputMap.associatedGamepad = Enum.UserInputType.Gamepad1

		inputState:pressGamepad(Enum.KeyCode.ButtonA, Enum.UserInputType.Gamepad1)
		actions:update(inputState, inputMap)
		assertEqual(counter, 1)
	end)

	x.test("handles manual hold", function()
		local actions = Actions.new({ "jump" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("jump", Enum.KeyCode.Space)

		local pressedCount = 0
		actions:justPressedSignal("jump"):connect(function()
			pressedCount += 1
		end)

		local releasedCount = 0
		actions:justReleasedSignal("jump"):connect(function()
			releasedCount += 1
		end)

		local stopHold = actions:hold("jump")
		assertEqual(pressedCount, 0)

		actions:update(inputState, inputMap)
		assertEqual(pressedCount, 1)
		assertEqual(actions:value("jump"), 1)

		-- The action should not be released by an input if being held manually.
		inputState:press(Enum.KeyCode.Space)
		actions:update(inputState, inputMap)
		inputState:release(Enum.KeyCode.Space)
		assertEqual(releasedCount, 0)

		stopHold()

		actions:update(inputState, inputMap)
		assertEqual(releasedCount, 1)

		-- Should handle multiple holds.
		local stop1 = actions:hold("jump")
		local stop2 = actions:hold("jump")

		actions:update(inputState, inputMap)
		assertEqual(pressedCount, 2)
		assertEqual(actions:pressed("jump"), true)

		stop1()

		actions:update(inputState, inputMap)
		assertEqual(pressedCount, 2)
		assertEqual(actions:pressed("jump"), true)

		stop2()

		actions:update(inputState, inputMap)
		assertEqual(pressedCount, 2)
		assertEqual(actions:pressed("jump"), false)

		-- Stopping a hold more than once should error.
		shouldThrow(function()
			stop2()
		end)
	end)

	x.test("handles manual move", function()
		local actions = Actions.new({ "move" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("move", Enum.UserInputType.MouseMovement)

		actions:move("move", Vector2.new(1, 0))
		assertEqual(actions:axis2d("move"), Vector2.zero)

		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("move"), Vector2.new(1, 0))
		assertEqual(actions:pressed("move"), true)
		assertEqual(actions:value("move"), 1)

		-- Manual moves should reset the next update
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("move"), Vector2.zero)

		-- Manual moves should stack
		actions:move("move", Vector2.new(1, 0))
		actions:move("move", Vector2.new(2, 0))
		inputState:moveMouse(Vector2.new(0, 1))
		actions:update(inputState, inputMap)
		assertEqual(actions:axis2d("move"), Vector2.new(3, 1))
	end)

	x.test("justPressedSignal and justReleasedSignal should fire after values have updated", function()
		local actions = Actions.new({ "action" })

		local inputState = MutableInputState.new()
		local inputMap = InputMap.new():insert("action", Enum.UserInputType.MouseMovement)

		actions:move("action", Vector2.xAxis)

		local pressedFired = false
		actions:justPressedSignal("action"):connect(function()
			pressedFired = true
			assertEqual(actions:pressed("action"), true)
			assertEqual(actions:value("action"), 1)
			assertEqual(actions:axis2d("action"), Vector2.xAxis)
		end)

		actions:update(inputState, inputMap)

		assertEqual(pressedFired, true)

		local releasedFired = false
		actions:justReleasedSignal("action"):connect(function()
			releasedFired = true
			assertEqual(actions:pressed("action"), false)
			assertEqual(actions:value("action"), 0)
			assertEqual(actions:axis2d("action"), Vector2.zero)
		end)

		actions:update(inputState, inputMap)

		assertEqual(releasedFired, true)
	end)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000559</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3A3E45F3B7324EEEB16A378AA0F44B96">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">InputMap</string>
									<string name="ScriptGuid">{51F55630-358D-4D30-9DED-73B9DAD7F9E9}</string>
									<ProtectedString name="Source"><![CDATA[local Deserializer = require(script.Parent.Serialization.Deserializer)
local Serializer = require(script.Parent.Serialization.Serializer)
local getDeviceFromInput = require(script.Parent.getDeviceFromInput)

local HEADER = "SPARK"
local SERIALIZATION_VERSION = 0

local function push(list, value)
	local new = table.clone(list)

	table.insert(new, value)

	return table.freeze(new)
end

local function removeValue(list, value)
	local new = {}

	for _, v in list do
		if v ~= value then
			table.insert(new, v)
		end
	end

	return table.freeze(new)
end

local function isInputInDevices(input, devices)
	if typeof(input) == "table" then
		if input.kind == "VirtualAxis" then
			for _, direction in { "positive", "negative" } do
				if table.find(devices, getDeviceFromInput(input[direction])) then
					return true
				end
			end
		elseif input.kind == "VirtualAxis2d" then
			for _, direction in { "up", "down", "left", "right" } do
				if table.find(devices, getDeviceFromInput(input[direction])) then
					return true
				end
			end
		end
	end

	return table.find(devices, getDeviceFromInput(input)) ~= nil
end

local function deepCopy(original)
	local copy = setmetatable({}, getmetatable(original))

	for key, value in original do
		if type(value) == "table" then
			local tableCopy = deepCopy(value)

			setmetatable(tableCopy, getmetatable(value))

			copy[key] = tableCopy
		else
			copy[key] = value
		end
	end

	return copy
end

--[=[
	If `associatedGamepad` is nil, the connected gamepad with the lowest number will be used.

	The [Enum.UserInputType] must represent a gamepad.

	@prop associatedGamepad Enum.UserInputType?
	@within InputMap
]=]

--[=[
	Maps actions to their inputs.

	Multiple inputs can be mapped to the same action and each input can be mapped to multiple actions.

	```lua
	local inputMap = InputMap.new()
		:insert("fire", Enum.UserInputType.MouseButton1)
		:insert("jump", Enum.KeyCode.Space)
	```

	@class InputMap
]=]
local InputMap = {}
InputMap.__index = InputMap

--[=[
	Creates an empty InputMap.

	@return InputMap
]=]
function InputMap.new()
	return setmetatable({
		map = {},
	}, InputMap)
end

--[=[
	Deserializes the buffer returned from [InputMap:serialize] back into an InputMap.

	@param serialized buffer
	@return InputMap
]=]
function InputMap.deserialize(serialized)
	local deserializer = Deserializer.new(serialized)

	local header = deserializer:readString(#HEADER)
	local version = deserializer:readU8()

	if header ~= HEADER then
		error("Invalid header", 2)
	end

	if version ~= SERIALIZATION_VERSION then
		error("Invalid serialization version", 2)
	end

	local inputMap = InputMap.new()

	while not deserializer:empty() do
		local action, inputCount = deserializer:readActionHeader()

		for _ = 1, inputCount do
			local input = deserializer:readInput()

			inputMap:insert(action, input)
		end
	end

	return inputMap
end

--[=[
	Maps inputs to `action`.

	If an input is already mapped to the `action`, it won't be mapped again.

	@param action string
	@param ... Input
	@return InputMap -- Returns self
]=]
function InputMap:insert(action, ...)
	if self.map[action] == nil then
		self.map[action] = table.freeze({})
	end

	for _, input in { ... } do
		if not table.find(self.map[action], input) then
			self.map[action] = push(self.map[action], input)
		end
	end

	return self
end

--[=[
	Removes the mapping from `input` to `action` if it exists.

	@param action string
	@param input Input
]=]
function InputMap:remove(action, input)
	local inputs = self.map[action]

	if inputs == nil then
		return
	end

	self.map[action] = removeValue(inputs, input)
end

--[=[
	Gets the inputs mapped to `action`.

	@param action string
	@return { Input }
]=]
function InputMap:get(action)
	if self.map[action] == nil then
		return table.freeze({})
	end

	return self.map[action]
end

--[=[
	Gets the inputs mapped to `action` that belong to `devices`.

	If a [VirtualAxis] or [VirtualAxis2d] has a [Button] that belongs to `devices` it will be included.

	```lua
	local inputMap = InputMap.new():insert("action", Enum.KeyCode.Space, Enum.UserInputType.MouseButton1)

	print(inputMap:getByDevices("action", { "Keyboard" })) -- { Enum.KeyCode.Space }
	print(inputMap:getByDevices("action", { "Mouse" })) -- { Enum.UserInputType.MouseButton1 }
	```

	@param action string
	@param devices { Device }
	@return { Input }
]=]
function InputMap:getByDevices(action, devices)
	if self.map[action] == nil then
		return table.freeze({})
	end

	local inputs = {}
	for _, input in self.map[action] do
		if isInputInDevices(input, devices) then
			table.insert(inputs, input)
		end
	end

	return table.freeze(inputs)
end

--[=[
	Clones the `InputMap`.

	@return InputMap
]=]
function InputMap:clone()
	return deepCopy(self)
end

--[=[
	Returns a serialized version of the `InputMap` as a buffer. This can be used to save or replicate it.

	@return buffer
]=]
function InputMap:serialize()
	local length = #HEADER + 1 -- 1 byte for the version.

	for action, inputs in self.map do
		length += 2 + #action -- The 2 accounts for the length of the name and the input count.

		for _, input in inputs do
			length += 1 -- This accounts for the input kind.

			if typeof(input) == "EnumItem" then
				length += 2
			elseif input.kind == "Multiply2d" then
				length += 3 + 16 -- This accounts for the 3 byte input and the 16 byte Vector2 sensitivity.
			elseif input.kind == "VirtualAxis" then
				length += 2 * 3 -- This accounts for two 3 byte inputs.
			elseif input.kind == "VirtualAxis2d" then
				length += 4 * 3 -- This accounts for four 3 byte inputs.
			end
		end
	end

	local serialized = buffer.create(length)
	local serializer = Serializer.new(serialized)

	serializer:writeString(HEADER)
	serializer:writeU8(SERIALIZATION_VERSION)

	for action, inputs in self.map do
		local inputCount = 0
		for _ in inputs do
			inputCount += 1
		end

		serializer:writeActionHeader(action, inputCount)

		for _, input in inputs do
			if typeof(input) == "EnumItem" then
				serializer:writeEnumInput(input)
			elseif input.kind == "Multiply2d" then
				serializer:writeMultiply2d(input)
			elseif input.kind == "VirtualAxis" then
				serializer:writeVirtualAxis(input)
			elseif input.kind == "VirtualAxis2d" then
				serializer:writeVirtualAxis2d(input)
			end
		end
	end

	return serialized
end

return InputMap
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000055a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5E3858E559734DD29C54794EA8B54D38">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">InputMap.test</string>
									<string name="ScriptGuid">{067DC493-F1EC-4C71-9A64-39A570C63E25}</string>
									<ProtectedString name="Source"><![CDATA[local InputMap = require(script.Parent.InputMap)
local Multiply2d = require(script.Parent.Multiply2d)
local VirtualAxis = require(script.Parent.VirtualAxis)
local VirtualAxis2d = require(script.Parent.VirtualAxis2d)

local function equalsDeep(a, b)
	if type(a) ~= "table" or type(b) ~= "table" then
		return a == b
	end

	for key, value in a do
		if not equalsDeep(b[key], value) then
			return false
		end
	end

	for key, value in b do
		if not equalsDeep(a[key], value) then
			return false
		end
	end

	return true
end

return function(x)
	local assertEqual = x.assertEqual

	x.test("inserts inputs", function()
		local inputMap1 = InputMap.new():insert("jump", Enum.KeyCode.Space, Enum.KeyCode.ButtonA)
		local inputMap2 = InputMap.new():insert("jump", Enum.KeyCode.Space):insert("jump", Enum.KeyCode.ButtonA)

		assert(equalsDeep(inputMap1:get("jump"), { Enum.KeyCode.Space, Enum.KeyCode.ButtonA }))
		assert(equalsDeep(inputMap2:get("jump"), { Enum.KeyCode.Space, Enum.KeyCode.ButtonA }))
	end)

	x.test("doesn't duplicate inputs", function()
		local inputMap = InputMap.new():insert("jump", Enum.KeyCode.Space)

		inputMap:insert("jump", Enum.KeyCode.Space)

		assert(equalsDeep(inputMap:get("jump"), { Enum.KeyCode.Space }))

		inputMap:insert("jump", Enum.KeyCode.F, Enum.KeyCode.F)

		assert(equalsDeep(inputMap:get("jump"), { Enum.KeyCode.Space, Enum.KeyCode.F }))
	end)

	x.test("should freeze inputs", function()
		local inputMap = InputMap.new()

		assertEqual(table.isfrozen(inputMap:get("jump")), true)

		inputMap:insert("jump", Enum.KeyCode.Space)

		assertEqual(table.isfrozen(inputMap:get("jump")), true)
	end)

	x.test("remove inputs", function()
		local inputMap = InputMap.new():insert("jump", Enum.KeyCode.Space):insert("jump", Enum.KeyCode.F)

		inputMap:remove("jump", Enum.KeyCode.Space)
		assert(equalsDeep(inputMap:get("jump"), { Enum.KeyCode.F }))

		-- Removing an input that doesn't exist should do nothing
		inputMap:remove("jump", Enum.KeyCode.Unknown)
		assert(equalsDeep(inputMap:get("jump"), { Enum.KeyCode.F }))
	end)

	x.nested("getByDevices", function()
		x.test("gets correct controls", function()
			local inputMap = InputMap.new():insert("action", Enum.KeyCode.Space, Enum.UserInputType.MouseButton1)

			assert(equalsDeep(inputMap:getByDevices("action", {}), {}))
			assert(equalsDeep(inputMap:getByDevices("action", { "Keyboard" }), { Enum.KeyCode.Space }))
			assert(equalsDeep(inputMap:getByDevices("action", { "Mouse" }), { Enum.UserInputType.MouseButton1 }))
		end)

		x.test("gets correct virtual axes", function()
			local mouseKeyboard1d =
				VirtualAxis.new({ positive = Enum.KeyCode.A, negative = Enum.UserInputType.MouseButton1 })
			local gamepad1d = VirtualAxis.new({ negative = Enum.KeyCode.ButtonA, positive = Enum.KeyCode.ButtonB })

			local mouseKeyboard2d = VirtualAxis2d.new({
				up = Enum.KeyCode.W,
				down = Enum.KeyCode.S,
				left = Enum.UserInputType.MouseButton1,
				right = Enum.UserInputType.MouseButton2,
			})
			local dPad = VirtualAxis2d.dPad()

			local inputMap = InputMap.new()
				:insert("virtualAxis", mouseKeyboard1d, gamepad1d)
				:insert("virtualAxis2d", mouseKeyboard2d, dPad)

			assert(equalsDeep(inputMap:getByDevices("virtualAxis", {}), {}))
			assert(equalsDeep(inputMap:getByDevices("virtualAxis", { "Keyboard" }), { mouseKeyboard1d }))
			assert(equalsDeep(inputMap:getByDevices("virtualAxis", { "Mouse" }), { mouseKeyboard1d }))
			assert(equalsDeep(inputMap:getByDevices("virtualAxis", { "Gamepad" }), { gamepad1d }))

			assert(equalsDeep(inputMap:getByDevices("virtualAxis2d", {}), {}))
			assert(equalsDeep(inputMap:getByDevices("virtualAxis2d", { "Keyboard" }), { mouseKeyboard2d }))
			assert(equalsDeep(inputMap:getByDevices("virtualAxis2d", { "Mouse" }), { mouseKeyboard2d }))
			assert(equalsDeep(inputMap:getByDevices("virtualAxis2d", { "Gamepad" }), { dPad }))
		end)
	end)

	x.test("clones InputMap", function()
		local inputMap =
			InputMap.new():insert("action", Enum.KeyCode.Space):insert("other", VirtualAxis.horizontalArrowKeys())
		local clone = inputMap:clone()

		assert(equalsDeep(clone:get("action"), { Enum.KeyCode.Space }))

		local virtualAxis = clone:get("other")[1]

		assertEqual(typeof(virtualAxis), "table")

		-- Clone should not affect old InputMap.
		clone:insert("action", Enum.KeyCode.F)
		assert(equalsDeep(inputMap:get("action"), { Enum.KeyCode.Space }))

		-- Clone should not affect old InputMap.
		virtualAxis.positive = nil
		assertEqual(virtualAxis == inputMap:get("other")[1], false)
	end)

	x.test("serializes and deserializes", function()
		local virtualAxis = VirtualAxis.verticalArrowKeys()
		local virtualAxis2d = VirtualAxis2d.new({
			up = Enum.KeyCode.W,
			down = Enum.UserInputType.MouseButton1,
			left = Enum.KeyCode.A,
		})
		local multiply = Multiply2d.new(Enum.UserInputType.MouseMovement, Vector2.new(0.2, 0.5))

		local serialized = InputMap.new()
			:insert("button", Enum.KeyCode.O, Enum.UserInputType.MouseButton1)
			:insert("axis1d", virtualAxis)
			:insert("axis2d", virtualAxis2d, multiply)
			:serialize()

		assertEqual(typeof(serialized), "buffer")

		local deserialized = InputMap.deserialize(serialized)

		assert(equalsDeep(deserialized:get("button"), { Enum.KeyCode.O, Enum.UserInputType.MouseButton1 }))
		assert(equalsDeep(deserialized:get("axis1d"), { virtualAxis }))
		assert(equalsDeep(deserialized:get("axis2d"), { virtualAxis2d, multiply }))
	end)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000055b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6B95877F3BA24315BCCDBDDF377B0AE2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">InputState</string>
									<string name="ScriptGuid">{97C490AA-E76F-4CE0-AD21-F400294E9975}</string>
									<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local Inputs = require(script.Parent.Inputs)

local DEFAULT_DEADZONE = 0.1

--[=[
	Stores input state derived from [UserInputService] and is used to update [Actions].

	:::note
	You should only ever create one `InputState`.
	:::

	@class InputState
]=]
local InputState = {}
InputState.__index = InputState

--[=[
	Creates a new `InputState`.

	@return InputState
]=]
function InputState.new()
	local gamepadButtons = {}
	for keyCode in Inputs.GAMEPAD_BUTTONS do
		gamepadButtons[keyCode] = {}
	end

	local state = {
		keycodes = {},
		mouseButtons = {},
		mouseWheel = 0,
		mouseDelta = Vector2.zero,
		gamepadButtons = gamepadButtons,
		gamepadThumbsticks = {
			[Enum.KeyCode.Thumbstick1] = {},
			[Enum.KeyCode.Thumbstick2] = {},
		},
	}

	local function onInputBeganOrEnded(inputObject, sunk)
		if sunk then
			return
		end

		local keyCode = inputObject.KeyCode

		if Inputs.MOUSE_BUTTONS[inputObject.UserInputType] then
			state.mouseButtons[inputObject.UserInputType] = inputObject.UserInputState == Enum.UserInputState.Begin
		elseif Inputs.GAMEPAD_BUTTONS[keyCode] then
			local gamepad = inputObject.UserInputType

			gamepadButtons[keyCode][gamepad] = inputObject.UserInputState == Enum.UserInputState.Begin
		elseif keyCode ~= Enum.KeyCode.Unknown then
			state.keycodes[keyCode] = inputObject.UserInputState == Enum.UserInputState.Begin
		end
	end

	local function onInputChanged(inputObject, sunk)
		if sunk then
			return
		end

		if inputObject.UserInputType == Enum.UserInputType.MouseMovement then
			state.mouseDelta = Vector2.new(inputObject.Delta.X, -inputObject.Delta.Y)
		elseif inputObject.UserInputType == Enum.UserInputType.MouseWheel then
			state.mouseWheel = inputObject.Position.Z
		elseif inputObject.KeyCode == Enum.KeyCode.Thumbstick1 or inputObject.KeyCode == Enum.KeyCode.Thumbstick2 then
			local gamepad = inputObject.UserInputType

			state.gamepadThumbsticks[inputObject.KeyCode][gamepad] =
				Vector2.new(inputObject.Position.X, inputObject.Position.Y)
		end
	end

	UserInputService.InputBegan:Connect(onInputBeganOrEnded)
	UserInputService.InputEnded:Connect(onInputBeganOrEnded)
	UserInputService.InputChanged:Connect(onInputChanged)

	return setmetatable({
		state = state,
	}, InputState)
end

--[=[
	This clears mouse wheel and mouse delta data so it doesn't persist across frames. This should be called once every frame after [Actions:update] is called.
]=]
function InputState:clear()
	self.state.mouseWheel = 0
	self.state.mouseDelta = Vector2.zero
end

function InputState:pressed(input, gamepad)
	if typeof(input) == "EnumItem" then
		if input:IsA("KeyCode") then
			if input == Enum.KeyCode.Thumbstick1 or input == Enum.KeyCode.Thumbstick2 then
				if gamepad == nil then
					return false
				end

				local value = self.state.gamepadThumbsticks[input][gamepad]

				return if value == nil then false else value.Magnitude >= DEFAULT_DEADZONE
			elseif Inputs.GAMEPAD_BUTTONS[input] then
				if gamepad == nil then
					return false
				end

				return self.state.gamepadButtons[input][gamepad] == true
			else
				return self.state.keycodes[input]
			end
		elseif Inputs.MOUSE_BUTTONS[input] then
			return self.state.mouseButtons[input]
		elseif input == Enum.UserInputType.MouseMovement then
			return self.state.mouseDelta.Magnitude > 0
		elseif input == Enum.UserInputType.MouseWheel then
			return self.state.mouseWheel ~= 0
		end
	elseif input.kind == "VirtualAxis" then
		return self:value(input, gamepad) ~= 0
	elseif input.kind == "VirtualAxis2d" or input.kind == "Multiply2d" then
		local value = self:axis2d(input, gamepad)

		return if value == nil then false else value.Magnitude > 0
	end

	error("Invalid input")
end

function InputState:value(input, gamepad)
	if typeof(input) == "EnumItem" then
		if input:IsA("KeyCode") then
			if input == Enum.KeyCode.Thumbstick1 or input == Enum.KeyCode.Thumbstick2 then
				if gamepad == nil then
					return 0
				end

				local value = self.state.gamepadThumbsticks[input][gamepad]

				if value == nil or value.Magnitude < DEFAULT_DEADZONE then
					return 0
				else
					return value.Magnitude
				end
			elseif Inputs.GAMEPAD_BUTTONS[input] then
				if gamepad == nil then
					return 0
				end

				return if self.state.gamepadButtons[input][gamepad] then 1 else 0
			else
				return if self.state.keycodes[input] then 1 else 0
			end
		elseif Inputs.MOUSE_BUTTONS[input] then
			return if self.state.mouseButtons[input] then 1 else 0
		elseif input == Enum.UserInputType.MouseMovement then
			return self.state.mouseDelta.Magnitude
		elseif input == Enum.UserInputType.MouseWheel then
			return self.state.mouseWheel
		end
	elseif input.kind == "VirtualAxis" then
		local positive = if input.positive then self:value(input.positive, gamepad) else 0
		local negative = if input.negative then self:value(input.negative, gamepad) else 0

		return positive - negative
	elseif input.kind == "VirtualAxis2d" or input.kind == "Multiply2d" then
		local value = self:axis2d(input, gamepad)

		return if value == nil then 0 else value.Magnitude
	end

	error("Invalid input")
end

function InputState:axis2d(input, gamepad)
	if input == Enum.UserInputType.MouseMovement then
		return self.state.mouseDelta
	elseif input == Enum.KeyCode.Thumbstick1 or input == Enum.KeyCode.Thumbstick2 then
		local value = self.state.gamepadThumbsticks[input][gamepad]

		if value ~= nil and value.Magnitude >= DEFAULT_DEADZONE then
			return value
		end
	elseif typeof(input) == "table" then
		if input.kind == "VirtualAxis2d" then
			local right = if input.right then self:value(input.right, gamepad) else 0
			local left = if input.left then self:value(input.left, gamepad) else 0
			local up = if input.up then self:value(input.up, gamepad) else 0
			local down = if input.down then self:value(input.down, gamepad) else 0

			return Vector2.new(right - left, up - down)
		elseif input.kind == "Multiply2d" then
			local value = self:axis2d(input.input, gamepad)

			if value ~= nil then
				return value * input.multiplier
			end
		end
	end

	return nil
end

function InputState:anyPressed(inputs, gamepad)
	for _, input in inputs do
		if self:pressed(input, gamepad) then
			return true
		end
	end

	return false
end

return InputState
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000055c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0330F0C19F0D4333968DC88A1F12E730">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Inputs</string>
									<string name="ScriptGuid">{FA08E128-9E4C-4891-A3C9-E9ADBB8A1849}</string>
									<ProtectedString name="Source"><![CDATA[return {
	GAMEPAD_BUTTONS = {
		[Enum.KeyCode.ButtonA] = true,
		[Enum.KeyCode.ButtonB] = true,
		[Enum.KeyCode.ButtonX] = true,
		[Enum.KeyCode.ButtonY] = true,
		[Enum.KeyCode.ButtonL1] = true,
		[Enum.KeyCode.ButtonL2] = true,
		[Enum.KeyCode.ButtonL3] = true,
		[Enum.KeyCode.ButtonR1] = true,
		[Enum.KeyCode.ButtonR2] = true,
		[Enum.KeyCode.ButtonR3] = true,
		[Enum.KeyCode.DPadUp] = true,
		[Enum.KeyCode.DPadDown] = true,
		[Enum.KeyCode.DPadLeft] = true,
		[Enum.KeyCode.DPadRight] = true,
		[Enum.KeyCode.ButtonStart] = true,
		[Enum.KeyCode.ButtonSelect] = true,
	},
	MOUSE_BUTTONS = {
		[Enum.UserInputType.MouseButton1] = true,
		[Enum.UserInputType.MouseButton2] = true,
		[Enum.UserInputType.MouseButton3] = true,
	},
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000055d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6B85946C915F42E292EDCDE7817A4462">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Multiply2d</string>
									<string name="ScriptGuid">{FF3CC7C0-207F-495C-9062-CBCF9C9619C7}</string>
									<ProtectedString name="Source"><![CDATA[--[=[
	An input that wraps an [Input2d] and multiplies its value by `multiplier`.

	```lua
	inputMap:insert("look", Multiply2d.new(Enum.UserInputType.MouseMovement, Vector2.new(0.5, 0.8)))
	```

	@class Multiply2d
]=]
local Multiply2d = {}
Multiply2d.__index = Multiply2d

--[=[
	Creates a new `Multiply2d` given a 2D `input` and `multiplier`.

	@param input Input2d
	@param multiplier Vector2
	@return Multiply2d
]=]
function Multiply2d.new(input, multiplier)
	return {
		kind = "Multiply2d",
		input = input,
		multiplier = multiplier,
	}
end

return Multiply2d
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000055e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4AB05D07353B40CE849CB1DD82D974B2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rebind</string>
									<string name="ScriptGuid">{3A25A8AB-DA18-4C95-80D3-CED648182A66}</string>
									<ProtectedString name="Source"><![CDATA[local UserInputService = game:GetService("UserInputService")

local getDeviceFromInput = require(script.Parent.getDeviceFromInput)
local Inputs = require(script.Parent.Inputs)
local Promise = require(game.ReplicatedStorage["rbxts_include"].Promise) --require(script.Parent.Parent.Promise)

--[=[
    @type Device "Keyboard" | "Mouse" | "Gamepad"
    @within Rebind
]=]

--[=[
	Queries for the first button a user presses. This is useful for rebinding based on user input.

	```lua
	Rebind.new()
		:withDevices({ "Keyboard", "Mouse" })
		:withoutInputs({ Enum.KeyCode.Escape })
		:start()
		:andThen(function(button)
			print("User pressed", button)
		end)
	```

	@class Rebind
]=]
local Rebind = {}
Rebind.__index = Rebind

--[=[
	Creates a new `Rebind`. To query for a button, call [Rebind:start].

	@return Rebind
]=]
function Rebind.new()
	return setmetatable({
		devices = {},
		excludedInputs = {},
	}, Rebind)
end

--[=[
	By default, inputs from all devices are included. When called, this method will only include the specified `devices`.

	@param devices { Device }
	@return Rebind -- Returns self
]=]
function Rebind:withDevices(devices)
	for _, device in devices do
		self.devices[device] = true
	end

	return self
end

--[=[
	Excludes `inputs` from being chosen.

	@param inputs { Button }
	@return Rebind -- Returns self
]=]
function Rebind:withoutInputs(inputs)
	for _, input in inputs do
		self.excludedInputs[input] = true
	end

	return self
end

--[=[
	Returns a [Promise](https://eryn.io/roblox-lua-promise/api/Promise) that resolves with the first [Button] the user presses.

	The promise can be cancelled if you no longer need the result.

	@return Promise<Button>
]=]
function Rebind:start()
	return Promise.new(function(resolve, _, onCancel)
		local connection
		connection = UserInputService.InputBegan:Connect(function(inputObject)
			local input = if inputObject.KeyCode == Enum.KeyCode.Unknown
				then inputObject.UserInputType
				else inputObject.KeyCode

			-- The only UserInputType buttons are mouse buttons.
			if input:IsA("UserInputType") and Inputs.MOUSE_BUTTONS[input] == nil then
				return
			end

			if self.excludedInputs[input] then
				return
			end

			if next(self.devices) and self.devices[getDeviceFromInput(input)] == nil then
				return
			end

			resolve(input)
			connection:Disconnect()
		end)

		onCancel(function()
			connection:Disconnect()
		end)
	end)
end

return Rebind
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000055f</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXEA20A3BE8EC446708BE0B0B066651DDC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">Serialization</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000560</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXAB27C7D401F848AEB7C14CC776235067">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Deserializer</string>
										<string name="ScriptGuid">{8EA50980-E5D4-4816-9ECA-D8B27B88EC2C}</string>
										<ProtectedString name="Source"><![CDATA[local InputKinds = require(script.Parent.InputKinds)
local Multiply2d = require(script.Parent.Parent.Multiply2d)
local VirtualAxis = require(script.Parent.Parent.VirtualAxis)
local VirtualAxis2d = require(script.Parent.Parent.VirtualAxis2d)

local function enumItemFromValue(enum, value)
	for _, enumItem in enum:GetEnumItems() do
		if enumItem.Value == value then
			return enumItem
		end
	end

	error("Invalid enum value")
end

local Deserializer = {}
Deserializer.__index = Deserializer

function Deserializer.new(serialized)
	return setmetatable({
		buffer = serialized,
		length = buffer.len(serialized),
		cursor = 0,
	}, Deserializer)
end

function Deserializer:empty()
	return self.cursor >= self.length
end

function Deserializer:readU8()
	local number = buffer.readu8(self.buffer, self.cursor)
	self.cursor += 1

	return number
end

function Deserializer:readU16()
	local number = buffer.readu16(self.buffer, self.cursor)
	self.cursor += 2

	return number
end

function Deserializer:readF64()
	local number = buffer.readf64(self.buffer, self.cursor)
	self.cursor += 8

	return number
end

function Deserializer:readString(length)
	local value = buffer.readstring(self.buffer, self.cursor, length)
	self.cursor += length

	return value
end

function Deserializer:readActionHeader()
	local length = self:readU8()
	local name = self:readString(length)
	local inputCount = self:readU8()

	return name, inputCount
end

function Deserializer:readEnumInputFromKind(kind)
	local value = self:readU16()

	if kind == InputKinds.KeyCode then
		return enumItemFromValue(Enum.KeyCode, value)
	else
		return enumItemFromValue(Enum.UserInputType, value)
	end
end

function Deserializer:readEnumInput()
	local kind = self:readU8()

	if kind == InputKinds.None then
		return nil
	end

	return self:readEnumInputFromKind(kind)
end

function Deserializer:readMultiply2d()
	local input = self:readEnumInput()
	local sensitivityX = self:readF64()
	local sensitivityY = self:readF64()

	return Multiply2d.new(input, Vector2.new(sensitivityX, sensitivityY))
end

function Deserializer:readVirtualAxis()
	local positive = self:readEnumInput()
	local negative = self:readEnumInput()

	return VirtualAxis.new({ positive = positive, negative = negative })
end

function Deserializer:readVirtualAxis2d()
	local up = self:readEnumInput()
	local down = self:readEnumInput()
	local left = self:readEnumInput()
	local right = self:readEnumInput()

	return VirtualAxis2d.new({ up = up, down = down, left = left, right = right })
end

function Deserializer:readInput()
	local kind = self:readU8()

	if kind == InputKinds.KeyCode or kind == InputKinds.UserInputType then
		return self:readEnumInputFromKind(kind)
	elseif kind == InputKinds.Multiply2d then
		return self:readMultiply2d()
	elseif kind == InputKinds.VirtualAxis then
		return self:readVirtualAxis()
	elseif kind == InputKinds.VirtualAxis2d then
		return self:readVirtualAxis2d()
	end

	error(`Invalid input kind {kind}`)
end

return Deserializer
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000561</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX4BADEF1FD0BE4B8C8B69D09EEE50A998">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">InputKinds</string>
										<string name="ScriptGuid">{AB6F0D54-8545-4504-91E7-DF1FA0859A04}</string>
										<ProtectedString name="Source"><![CDATA[return {
	None = 0,
	KeyCode = 1,
	UserInputType = 2,
	Multiply2d = 3,
	VirtualAxis = 4,
	VirtualAxis2d = 5,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000562</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2A2FB3F885014E76BED1F6B0065D48B3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Serializer</string>
										<string name="ScriptGuid">{F2AD8C28-C316-4CEF-80AE-95C132E521F6}</string>
										<ProtectedString name="Source"><![CDATA[local InputKinds = require(script.Parent.InputKinds)

local Serializer = {}
Serializer.__index = Serializer

function Serializer.new(buffer)
	return setmetatable({
		buffer = buffer,
		cursor = 0,
	}, Serializer)
end

function Serializer:writeU8(number)
	buffer.writeu8(self.buffer, self.cursor, number)
	self.cursor += 1
end

function Serializer:writeU16(number)
	buffer.writeu16(self.buffer, self.cursor, number)
	self.cursor += 2
end

function Serializer:writeF64(number)
	buffer.writef64(self.buffer, self.cursor, number)
	self.cursor += 8
end

function Serializer:writeString(value)
	buffer.writestring(self.buffer, self.cursor, value)
	self.cursor += #value
end

function Serializer:writeActionHeader(action, inputCount)
	if #action > 255 then
		error("Action names must 255 characters or less")
	end

	self:writeU8(#action)
	self:writeString(action)

	if inputCount > 255 then
		error("Actions must have less than 255 inputs")
	end

	self:writeU8(inputCount)
end

function Serializer:writeInputKind(kind)
	self:writeU8(InputKinds[kind])
end

function Serializer:writeEnumInput(input)
	if input == nil then
		self:writeInputKind("None")
		return
	end

	if input:IsA("KeyCode") then
		self:writeInputKind("KeyCode")
	else
		self:writeInputKind("UserInputType")
	end

	self:writeU16(input.Value)
end

function Serializer:writeMultiply2d(multiply2d)
	self:writeInputKind("Multiply2d")
	self:writeEnumInput(multiply2d.input)
	self:writeF64(multiply2d.multiplier.X)
	self:writeF64(multiply2d.multiplier.Y)
end

function Serializer:writeVirtualAxis(virtualAxis)
	self:writeInputKind("VirtualAxis")
	self:writeEnumInput(virtualAxis.positive)
	self:writeEnumInput(virtualAxis.negative)
end

function Serializer:writeVirtualAxis2d(virtualAxis2d)
	self:writeInputKind("VirtualAxis2d")
	self:writeEnumInput(virtualAxis2d.up)
	self:writeEnumInput(virtualAxis2d.down)
	self:writeEnumInput(virtualAxis2d.left)
	self:writeEnumInput(virtualAxis2d.right)
end

return Serializer
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000563</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX9B5D0769C9AB41368D538E95F3341594">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Signal</string>
									<string name="ScriptGuid">{46BBB719-4487-475C-9F7B-1A757F2B12F5}</string>
									<ProtectedString name="Source"><![CDATA[--[=[
	@class Signal
]=]
local Signal = {}
Signal.__index = Signal

function Signal.new()
	return setmetatable({
		connections = {},
	}, Signal)
end

function Signal:fire(...)
	for _, connection in self.connections do
		task.spawn(connection, ...)
	end
end

--[=[
	@param connection function | thread
	@return () -> () -- A function that when called, disconnects the connection.
]=]
function Signal:connect(connection)
	local function unsubscribe()
		self.connections[unsubscribe] = nil
	end

	self.connections[unsubscribe] = connection

	return unsubscribe
end

return Signal
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000564</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX86A1E7E495CA45FAB959D44BBAC27195">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">VirtualAxis</string>
									<string name="ScriptGuid">{188DA371-10FF-43C4-86BD-5884263AF9DD}</string>
									<ProtectedString name="Source"><![CDATA[--[=[
	@prop positive Button?
	@within VirtualAxis
]=]

--[=[
	@prop negative Button?
	@within VirtualAxis
]=]

--[=[
	A virtual 1D axis input.

	If `positive` and `negative` are both pressed, the value will be `0`.

	@class VirtualAxis
]=]
local VirtualAxis = {}
VirtualAxis.__index = VirtualAxis

--[=[
	Creates a `VirtualAxis` with the corresponding `options`.

	@param options { postive: Button?, negative: Button? }
	@return VirtualAxis
]=]
function VirtualAxis.new(options)
	return setmetatable({
		kind = "VirtualAxis",
		positive = options.positive,
		negative = options.negative,
	}, VirtualAxis)
end

--[=[
	Creates a `VirtualAxis` corresponding to the left and right arrow keys.

	@return VirtualAxis
]=]
function VirtualAxis.horizontalArrowKeys()
	return VirtualAxis.new({
		positive = Enum.KeyCode.Right,
		negative = Enum.KeyCode.Left,
	})
end

--[=[
	Creates a `VirtualAxis` corresponding to the up and down arrow keys.

	@return VirtualAxis
]=]
function VirtualAxis.verticalArrowKeys()
	return VirtualAxis.new({
		positive = Enum.KeyCode.Up,
		negative = Enum.KeyCode.Down,
	})
end

return VirtualAxis
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000565</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX48BE7C29B90848CAB38C6DEA236C9705">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">VirtualAxis2d</string>
									<string name="ScriptGuid">{59C79C5C-3413-4B33-9A12-E5351D4EA95E}</string>
									<ProtectedString name="Source"><![CDATA[--[=[
	@prop up Button?
	@within VirtualAxis2d
]=]

--[=[
	@prop down Button?
	@within VirtualAxis2d
]=]

--[=[
	@prop left Button?
	@within VirtualAxis2d
]=]

--[=[
	@prop right Button?
	@within VirtualAxis2d
]=]

--[=[
	A virtual 2D axis input.

	If `up` and `down` are both pressed, the `Y` value will be `0`. If `left` and `right` are both presed, the `X` value will be `0`.

	@class VirtualAxis2d
]=]
local VirtualAxis2d = {}
VirtualAxis2d.__index = VirtualAxis2d

--[=[
	Creates a `VirtualAxis2d` with the corresponding `options`.

	@param options { up: Button?, down: Button?, left: Button?, right: Button? }
	@return VirtualAxis2d
]=]
function VirtualAxis2d.new(options)
	return setmetatable({
		kind = "VirtualAxis2d",
		up = options.up,
		down = options.down,
		left = options.left,
		right = options.right,
	}, VirtualAxis2d)
end

--[=[
	Creates a `VirtualAxis2d` corresponding to the arrow keys.

	@return VirtualAxis2d
]=]
function VirtualAxis2d.arrowKeys()
	return VirtualAxis2d.new({
		up = Enum.KeyCode.Up,
		down = Enum.KeyCode.Down,
		left = Enum.KeyCode.Left,
		right = Enum.KeyCode.Right,
	})
end

--[=[
	Creates a `VirtualAxis2d` corresponding to the `WASD` keys.

	@return VirtualAxis2d
]=]
function VirtualAxis2d.wasd()
	return VirtualAxis2d.new({
		up = Enum.KeyCode.W,
		down = Enum.KeyCode.S,
		left = Enum.KeyCode.A,
		right = Enum.KeyCode.D,
	})
end

--[=[
	Creates a `VirtualAxis2d` corresponding to the `DPad` on gamepads.

	@return VirtualAxis2d
]=]
function VirtualAxis2d.dPad()
	return VirtualAxis2d.new({
		up = Enum.KeyCode.DPadUp,
		down = Enum.KeyCode.DPadDown,
		left = Enum.KeyCode.DPadLeft,
		right = Enum.KeyCode.DPadRight,
	})
end

return VirtualAxis2d
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000566</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF0BCD446F70A48009D8BD1B1D8C16415">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">getDeviceFromInput</string>
									<string name="ScriptGuid">{3E0B7459-0072-4F7A-95B8-20C5BB911D01}</string>
									<ProtectedString name="Source"><![CDATA[local function getDeviceFromInput(input)
	if typeof(input) ~= "EnumItem" then
		return nil
	end

	if input:IsA("UserInputType") then
		if string.match(input.Name, "^Gamepad") ~= nil then
			return "Gamepad"
		elseif string.match(input.Name, "^Mouse") ~= nil then
			return "Mouse"
		elseif input == Enum.UserInputType.Keyboard then
			return "Keyboard"
		else
			return nil
		end
	elseif input:IsA("KeyCode") then
		if input == Enum.KeyCode.Unknown then
			return nil
		elseif input.Value >= 1000 then -- This works now but could break if they add new KeyCodes.
			return "Gamepad"
		else
			return "Keyboard"
		end
	end

	return nil
end

return getDeviceFromInput
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000567</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXE13043582FC648C381E43F2DFB1B810E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">react-reflex</string>
							<string name="ScriptGuid">{B564D9E7-F7B2-4779-91FA-DBF4675FB1BD}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
exports.ReflexProvider = TS.import(script, script, "components", "ReflexProvider").default
exports.ReflexContext = TS.import(script, script, "components", "ReflexContext").default
for _k, _v in TS.import(script, script, "hooks", "use-producer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "hooks", "use-selector") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "hooks", "use-selector-creator") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004d3</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX2C8A1672E44F453494F194F14D379B3E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">components</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004d4</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX1FC7E96EC1D044EA8CAC8B8AF7881EA6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReflexContext</string>
									<string name="ScriptGuid">{2117CFAE-4F9C-4104-A444-C0E1F3FCEDBC}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local createContext = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).createContext
local ReflexContext = createContext(nil)
local default = ReflexContext
return {
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004d5</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX262384C8B43C49C8A1F9C557A71B38D7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReflexProvider</string>
									<string name="ScriptGuid">{582F0C3E-C484-441F-BC84-F633C626AD31}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local Roact = _roact
local useMemo = _roact.useMemo
local ReflexContext = TS.import(script, script.Parent, "ReflexContext").default
local function ReflexProvider(_param)
	local producer = _param.producer
	local initialState = _param.initialState
	local children = _param[Roact.Children]
	useMemo(function()
		-- Run in useMemo to set the state before rendering children
		if initialState == nil then
			return nil
		end
		local _fn = producer
		local _object = {}
		local _spread = producer:getState()
		if type(_spread) == "table" then
			for _k, _v in _spread do
				_object[_k] = _v
			end
		end
		for _k, _v in initialState do
			_object[_k] = _v
		end
		_fn:setState(_object)
	end, {})
	local _attributes = {
		value = producer,
	}
	local _children = {}
	local _length = #_children
	if children then
		for _k, _v in children do
			if type(_k) == "number" then
				_children[_length + _k] = _v
			else
				_children[_k] = _v
			end
		end
	end
	return Roact.createElement(ReflexContext.Provider, _attributes, _children)
end
return {
	default = ReflexProvider,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004d6</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX9AA5E5089E0C4021A735A2E217C59781">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">hooks</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004d7</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXCD4E2A2D3CA1453392ABA0609A942231">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-selector-creator</string>
									<string name="ScriptGuid">{38247CB8-EF3A-40FB-9EBA-D4308E04F950}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useMemo = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useMemo
local useSelector = TS.import(script, script.Parent, "use-selector").useSelector
--[[
	*
	* A hook that returns the result of a selector function that is called
	* with the current state of the producer.
	*
	* This type is typically not necessary if your selector function is created
	* with an explicitly typed `state` parameter.
	*
	* @example
	* // reflex-hooks.ts
	* export const useAppSelectorCreator: UseSelectorCreatorHook<RootProducer> = useSelectorCreator;
	*
	* // selectors.ts
	* export const selectUsers = (state: RootState) => state.users;
	* export const selectUsername = (id: number) => {
	* 	return createSelector([selectUsers], (users) => users[id].name);
	* };
	*
	* // MyComponent.tsx
	* const username = useAppSelectorCreator(selectUsername, 1);
	*
	* @param selectorCreator A function that takes the current state of the producer
	* and returns a value to be used in the component.
	* @param args Arguments to pass to the selector creator
	* @returns The result of the selector function.
]]
--[[
	*
	* Similar to `useSelector`, but accepts a selector creator function that
	* returns a selector. The selector creator is only called when the arguments
	* change and the selector is memoized.
	*
	* @example
	* // selectors.ts
	* export const selectUsers = (state: RootState) => state.users;
	* export const selectUsername = (id: number) => {
	* 	return createSelector([selectUsers], (users) => users[id].name);
	* };
	*
	* // MyComponent.tsx
	* const username = useSelectorCreator(selectUsername, 1);
	*
	* @param selectorCreator A function that takes the current state of the producer
	* and returns a value to be used in the component.
	* @param args Arguments to pass to the selector creator function.
	* @returns The result of the selector function.
]]
local function useSelectorCreator(selectorCreator, ...)
	local args = { ... }
	local selector = useMemo(function()
		return selectorCreator(unpack(args))
	end, args)
	return useSelector(selector)
end
return {
	useSelectorCreator = useSelectorCreator,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006344</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX58EE0110E1E94CDDA5E852C2B15F70BC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-selector</string>
									<string name="ScriptGuid">{351E3B82-70EF-4FC0-8EA7-28CF89AC233E}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useEffect = _roact.useEffect
local useRef = _roact.useRef
local useState = _roact.useState
local useProducer = TS.import(script, script.Parent, "use-producer").useProducer
--[[
	*
	* A hook that returns the result of a selector function that is called
	* with the current state of the producer.
	*
	* This type is typically not necessary if your selector function is created
	* with an explicitly typed `state` parameter.
	*
	* @example
	* // reflex-hooks.ts
	* export const useAppSelector: UseSelectorHook<RootProducer> = useSelector;
	*
	* // MyComponent.tsx
	* const counter = useAppSelector((state) => state.counter);
	*
	* @param selector A function that takes the current state of the producer
	* and returns a value to be used in the component.
	* @param equalityFn An optional function that takes the previous and new
	* values returned by the selector and returns true if the new value should
	* be used in the component.
	* @returns The result of the selector function.
]]
--[[
	*
	* Returns the result of a selector function that is called with the current
	* state of the producer.
	*
	* Accepts a generic type parameter to narrow the type of the producer, but it
	* is typically not necessary if your selector function is created with an
	* explicitly typed `state` parameter.
	*
	* @example
	* const selectCounter = (state: RootState) => state.counter;
	* const counter = useSelector(selectCounter);
	*
	* @param selector A function that takes the current state of the producer
	* and returns a value to be used in the component.
	* @param equalityFn An optional function that takes the previous and new
	* values returned by the selector and returns true if the new value should
	* be used in the component.
	* @returns The result of the selector function.
]]
local function useSelector(selector, equalityFn)
	local producer = useProducer()
	local latestSelector = useRef(selector)
	local isMount = useRef(true)
	local selection, setSelection = useState(function()
		return producer:getState(selector)
	end)
	useEffect(function()
		if isMount.current then
			isMount.current = false
			return nil
		end
		setSelection(producer:getState(selector))
		latestSelector.current = selector
	end, { selector })
	useEffect(function()
		local prevSelection = selection
		return producer:subscribe(function(newState)
			local newSelection = latestSelector.current(newState)
			if if equalityFn then not equalityFn(newSelection, prevSelection) else newSelection ~= prevSelection then
				prevSelection = newSelection
				setSelection(newSelection)
			end
		end)
	end, { producer })
	return selection
end
return {
	useSelector = useSelector,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006385</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX55C065BC490B49239DADD8ABB8FAE730">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-producer</string>
									<string name="ScriptGuid">{C353F8A8-A0F7-42C8-B4E0-C23B01130669}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useContext = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useContext
local ReflexContext = TS.import(script, script.Parent.Parent, "components", "ReflexContext").default
--[[
	*
	* A hook that returns the producer from the ReflexProvider.
	*
	* @example
	* // reflex-hooks.ts
	* export const useAppProducer: UseProducerHook<RootProducer> = useProducer;
	*
	* // MyComponent.tsx
	* const producer = useAppProducer();
	* producer.incrementCounter();
	*
	* @returns The producer from the ReflexProvider.
]]
--[[
	*
	* Returns the producer from the ReflexProvider. Accepts a generic type
	* parameter that can be used to narrow the type of the producer.
	*
	* @example
	* const producer = useProducer<MyProducer>();
	* producer.incrementCounter();
	*
	* @returns The producer from the ReflexProvider.
]]
local function useProducer()
	local producer = useContext(ReflexContext)
	assert(producer, "A ReflexProvider must be rendered above this component to use Roact Reflex Hooks.")
	return producer
end
return {
	useProducer = useProducer,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006387</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX7E725229F64A40E5A86AB263363CD7E6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">reflex</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004e8</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXB1CC18C230914E7797FBBCC1DD7E649F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{667BA225-1119-42DB-A7EE-865CCEB552C0}</string>
								<ProtectedString name="Source"><![CDATA[local types = require(script.types)
local broadcast = require(script.broadcast)
local createProducer = require(script.createProducer)
local combineProducers = require(script.combineProducers)
local createSelector = require(script.createSelector)
local applyMiddleware = require(script.applyMiddleware)
local loggerMiddleware = require(script.middleware.loggerMiddleware)
local shallowEqual = require(script.utils.shallowEqual)

export type Broadcaster = types.Broadcaster
export type BroadcastAction = types.BroadcastAction
export type BroadcasterOptions = types.BroadcasterOptions

export type BroadcastReceiver = types.BroadcastReceiver
export type BroadcastReceiverOptions = types.BroadcastReceiverOptions

export type Producer<State = any, Dispatchers = { [string]: (...any) -> State }> = types.Producer<State, Dispatchers>
export type Middleware = types.Middleware

return {
	createProducer = createProducer,
	combineProducers = combineProducers,
	createSelector = createSelector,
	applyMiddleware = applyMiddleware,
	loggerMiddleware = loggerMiddleware,
	createBroadcaster = broadcast.createBroadcaster,
	createBroadcastReceiver = broadcast.createBroadcastReceiver,
	shallowEqual = shallowEqual,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004e9</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXBE07E299F3264D44851B3DE468C554A8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Promise</string>
									<string name="ScriptGuid">{AB646DE1-6637-4458-AA39-2DF8D54A2276}</string>
									<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local packages = script:FindFirstAncestor("rbxts_include")
	or script:FindFirstAncestor("include")
	or ReplicatedStorage:FindFirstChild("rbxts_include")
	or script.Parent.Parent

if packages and packages:FindFirstChild("Promise") then
	return require(packages.Promise)
else
	error(`Could not find Promise from {script:GetFullName()}`)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004ea</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF06568EB05824EE3B704EA160E491805">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">applyMiddleware</string>
									<string name="ScriptGuid">{A8414E08-6030-49DF-A37E-95D412D9EE4C}</string>
									<ProtectedString name="Source"><![CDATA[--!nolint ImportUnused
local types = require(script.Parent.types)

--[=[
	Creates a producer enhancer that applies the given middleware to the
	producer.

	Initially, a middleware is called once when it is applied to a producer.
	Next, the returned function is called on a dispatcher in the producer.
	The final function is called whenever the dispatcher is called.

	```lua
	local loggerMiddleware: Reflex.Middleware = function(producer)
		print("Initial state:", producer.getState())
		return function(dispatch, name)
			return function(...)
				print(`Dispatching {name}:`, ...args)
				return dispatch(...)
			end
		end
	end

	producer:enhance(applyMiddleware(loggerMiddleware))
	```

	@param middlewares A list of middleware to apply.
	@return A producer enhancer.
]=]
local function applyMiddleware(...: types.Middleware): <T>(producer: T) -> T
	local arguments = { ... }

	return function(producer)
		local middlewares = table.clone(arguments)
		local dispatchers = producer:getDispatchers()

		for index, middleware in middlewares do
			middlewares[index] = middleware(producer)
		end

		for name, dispatcher in dispatchers do
			for index = #middlewares, 1, -1 do
				dispatcher = middlewares[index](dispatcher, name)
			end

			dispatchers[name] = dispatcher
			producer[name] = dispatcher
		end

		return producer
	end
end

return applyMiddleware
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004eb</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA18EEF2891F24E2BA6E47551BD5D4B14">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">broadcast</string>
									<string name="ScriptGuid">{8589BC36-6483-4D31-8A7C-56D76A2A1CC1}</string>
									<ProtectedString name="Source"><![CDATA[local createBroadcaster = require(script.createBroadcaster)
local createBroadcastReceiver = require(script.createBroadcastReceiver)

return {
	createBroadcaster = createBroadcaster,
	createBroadcastReceiver = createBroadcastReceiver,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004ec</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXB88C4564D1EC4F2C99AAF2900C682A69">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createBroadcastReceiver</string>
										<string name="ScriptGuid">{D1E1DF15-2F91-4E0E-92C2-30C9AA7F5AE3}</string>
										<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local hydrate = require(script.Parent.hydrate)

--[=[
	Creates a broadcast receiver object that can be used to dispatch actions
	broadcasted by the server.
	@param options The options for the broadcast receiver.
	@return The broadcast receiver.
]=]
local function createBroadcastReceiver(options: types.BroadcastReceiverOptions): types.BroadcastReceiver
	local receiver = {} :: types.BroadcastReceiver
	local producer: types.Producer?

	local function hydrateState(serverState: { [string]: any })
		assert(producer, "Cannot use broadcast receiver before the middleware is applied.")

		local nextState = table.clone(producer:getState())

		for key, value in serverState do
			nextState[key] = value
		end

		producer:setState(nextState)
	end

	function receiver:dispatch(actions: { types.BroadcastAction })
		assert(producer, "Cannot dispatch actions before the middleware is applied")

		local dispatchers = producer:getDispatchers()

		for _, action in actions do
			local dispatcher = dispatchers[action.name]

			if dispatcher then
				dispatcher(table.unpack(action.arguments))
			elseif hydrate.isHydrate(action) then
				hydrateState(action.arguments[1])
			end
		end
	end

	function receiver:hydrate(serverState: { [string]: any })
		hydrateState(serverState)
	end

	function receiver.middleware(currentProducer)
		producer = currentProducer

		options.start()

		return function(dispatch)
			return dispatch
		end
	end

	return receiver
end

return createBroadcastReceiver
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004ed</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8388EC05E2D9427B992C9AC0C46B96F4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createBroadcaster</string>
										<string name="ScriptGuid">{01A3B3DE-8549-4AF6-A79C-3806834BACFA}</string>
										<ProtectedString name="Source"><![CDATA[local Players = game:GetService("Players")

local types = require(script.Parent.Parent.types)
local setInterval = require(script.Parent.Parent.utils.setInterval)
local hydrate = require(script.Parent.hydrate)

--[=[
	Creates a broadcaster that can be used to share actions with the client.
	It will track all actions that are dispatched by the provided producers and
	will broadcast them to the client.
	@param options The options for the broadcaster.
	@return The broadcaster.
]=]
local function createBroadcaster(options: types.BroadcasterOptions): types.Broadcaster
	local broadcaster = {} :: types.Broadcaster
	local producer: types.Producer?

	local pendingDispatch = false
	local pendingActionsByPlayer: { [Player]: { types.BroadcastAction } } = {}
	local actionFilter: { [string]: boolean } = {}

	for _, slice in options.producers do
		for name in slice:getDispatchers() do
			actionFilter[name] = true
		end
	end

	local function getSharedState()
		assert(producer, "Cannot use broadcaster before the middleware is applied.")

		local sharedState = {}
		local serverState = producer.getState()

		for name in options.producers do
			sharedState[name] = serverState[name]
		end

		return sharedState
	end

	local function hydratePlayer(player: Player)
		local state = getSharedState()

		if options.beforeHydrate then
			state = options.beforeHydrate(player, state)
		end

		if options.hydrate then
			options.hydrate(player, state)
		else
			options.dispatch(player, { hydrate.createHydrateAction(state) })
		end
	end

	local hydrateInterval = setInterval(function()
		for player in pendingActionsByPlayer do
			hydratePlayer(player)
		end
	end, options.hydrateRate or 60)

	local dispatchInterval = setInterval(function()
		broadcaster:flush()
	end, options.dispatchRate or 0)

	local playerRemoving = Players.PlayerRemoving:Connect(function(player)
		pendingActionsByPlayer[player] = nil
	end)

	function broadcaster:destroy()
		hydrateInterval()
		dispatchInterval()
		playerRemoving:Disconnect()
	end

	function broadcaster:flush()
		if not pendingDispatch then
			return
		end

		pendingDispatch = false

		for player, pendingActions in pendingActionsByPlayer do
			options.dispatch(player, pendingActions)
			pendingActionsByPlayer[player] = {}
		end
	end

	function broadcaster:start(player)
		if not pendingActionsByPlayer[player] then
			pendingActionsByPlayer[player] = {}
			hydratePlayer(player)
		end
	end

	broadcaster.middleware = function(currentProducer)
		producer = currentProducer

		return function(dispatch, name)
			if not actionFilter[name] then
				return dispatch
			end

			return function(...)
				for player, pendingActions in pendingActionsByPlayer do
					local action: types.BroadcastAction? = {
						name = name,
						arguments = { ... },
					}

					if options.beforeDispatch then
						action = options.beforeDispatch(player, action :: types.BroadcastAction)
					end

					table.insert(pendingActions, action)
				end

				pendingDispatch = true

				return dispatch(...)
			end
		end
	end

	return broadcaster
end

return createBroadcaster
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004ee</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX77A3823D54484BAB80209DB88B87C3C5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">hydrate</string>
										<string name="ScriptGuid">{A411CFC2-046E-4914-9B65-90B0DD27F541}</string>
										<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local HYDRATE = "__hydrate__"

local function createHydrateAction(state: any): types.BroadcastAction
	return {
		name = HYDRATE,
		arguments = { state },
	}
end

local function isHydrate(action: types.BroadcastAction): boolean
	return action.name == HYDRATE
end

return {
	createHydrateAction = createHydrateAction,
	isHydrate = isHydrate,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004ef</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXEC57D9F4746447EABCEAA1409F1F6A96">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">combineProducers</string>
									<string name="ScriptGuid">{51AA3D35-1606-458F-B002-6F3F36422202}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.types)
local createProducer = require(script.Parent.createProducer)

local function combineInitialState(producers: types.ProducerMap)
	local initialState = {}

	for name, producer in producers do
		initialState[name] = producer:getState()
	end

	return initialState
end

local function combineActions(producers: types.ProducerMap)
	local combinedActions = {}
	local actionsByName = {}
	local producerNamesByAction = {}

	for producerName, producer in producers do
		for actionName, action in producer:getActions() do
			if actionsByName[actionName] then
				table.insert(actionsByName[actionName], action)
			else
				actionsByName[actionName] = { action }
			end

			producerNamesByAction[action] = producerName
		end
	end

	for actionName, actions in actionsByName do
		combinedActions[actionName] = function(combinedState, ...)
			local nextState = table.clone(combinedState)

			for _, action in actions do
				local producerName = producerNamesByAction[action]
				local producerState = nextState[producerName]
				nextState[producerName] = action(producerState, ...)
			end

			return nextState
		end
	end

	return combinedActions
end

--[=[
	Combines multiple producers into a single producer. Any dispatchers called
	on the combined producer will call the dispatchers of the same name on each
	of the producers passed in.

	**Don't use the individual producers.** The combined producer is the only
	one that should be used to prevent unexpected behavior.

	@param producers A map of producers to combine.
	@return A combined producer.
]=]
local function combineProducers(producers: types.ProducerMap)
	return createProducer(combineInitialState(producers), combineActions(producers))
end

return combineProducers
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f0</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX366A189FB1C6427FA955EC5A8AEADF89">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createProducer</string>
									<string name="ScriptGuid">{4F0C4078-DBC9-4337-960F-BA5EA818CC96}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Promise = require(script.Parent.Promise)
local types = require(script.Parent.types)
local applyMiddleware = require(script.Parent.applyMiddleware)
local createSelectArrayDiffs = require(script.Parent.utils.createSelectArrayDiffs)
local testSelector = require(script.Parent.utils.testSelector)

--[=[
	Creates a producer that can be used to manage state.

	A producer is a state container that exposes a set of dispatchers that can
	be used to modify the state. The state is immutable, so the dispatchers
	return a new state object.

	The dispatchers are also exposed as callbacks in the producer, and are based
	on the actions parameter, but with the first argument omitted.

	@param initialState The initial state of the producer.
	@param actions A set of actions that can be used to modify the state.
	@return A producer that can be used to manage state.
]=]
local function createProducer<State>(
	initialState: State,
	actions: { [string]: (state: State, ...any) -> any }
): types.Producer<State>
	local producer = {} :: types.Producer<State>

	local dispatchers = {}
	local currentListeners: {}? = {}
	local nextListeners = currentListeners :: {}
	local listenerIdCounter = 1

	local state = initialState
	local stateSinceLastFlush = initialState
	local pendingFlush: RBXScriptConnection?

	local function ensureCanMutateNextListeners()
		if nextListeners == currentListeners then
			nextListeners = table.clone(currentListeners :: {})
		end
	end

	local function scheduleFlush()
		if not pendingFlush then
			pendingFlush = RunService.Heartbeat:Once(function()
				pendingFlush = nil
				producer:flush()
			end)
		end
	end

	local function subscribe(listener: (state: State) -> ())
		local connected = true

		local id = listenerIdCounter
		listenerIdCounter += 1

		ensureCanMutateNextListeners()
		nextListeners[id] = listener

		return function()
			if connected then
				connected = false
				ensureCanMutateNextListeners()
				nextListeners[id] = nil
				currentListeners = nil
			end
		end
	end

	function producer:getState(selector)
		return if selector then selector(state) else state
	end

	function producer:setState(newState)
		state = newState
		scheduleFlush()
	end

	function producer:resetState()
		state = initialState
		scheduleFlush()
	end

	function producer:getDispatchers()
		return dispatchers
	end

	function producer:getActions()
		return actions
	end

	function producer:clone()
		return createProducer(state, actions)
	end

	function producer:flush()
		if pendingFlush then
			pendingFlush:Disconnect()
			pendingFlush = nil
		end

		if state == stateSinceLastFlush then
			return
		end

		stateSinceLastFlush = state
		currentListeners = nextListeners

		local currentState = state

		for _, listener in currentListeners :: {} do
			task.spawn(listener, currentState)
		end
	end

	function producer:subscribe(...)
		local arguments = select("#", ...)
		local selector, predicate, listener

		if arguments >= 3 then
			selector, predicate, listener = ...
		elseif arguments == 2 then
			selector, listener = ...
		else
			listener = ...
		end

		local selection = self:getState(selector)

		if selector then
			testSelector(selector, selection, state)
		end

		return subscribe(function(nextState)
			local nextSelection = if selector then selector(nextState) else nextState

			if selection == nextSelection then
				return
			end

			local prevSelection = selection
			selection = nextSelection

			if predicate and not predicate(nextSelection, prevSelection) then
				return
			end

			listener(nextSelection, prevSelection)
		end)
	end

	function producer:once(...)
		local arguments = select("#", ...)
		local selector, predicate, listener

		if arguments >= 3 then
			selector, predicate, listener = ...
		elseif arguments == 2 then
			selector, listener = ...
		else
			listener = ...
		end

		local unsubscribe
		unsubscribe = self:subscribe(selector, predicate, function(state, prevState)
			unsubscribe()
			listener(state, prevState)
		end)

		return unsubscribe
	end

	function producer:wait(selector, predicate)
		return Promise.new(function(resolve, _, onCancel)
			local unsubscribe = self:once(selector, predicate, function(state)
				resolve(state)
			end)

			onCancel(unsubscribe)
		end)
	end

	function producer:observe(...)
		local arguments = select("#", ...)
		local selector, discriminator, observer

		if arguments >= 3 then
			selector, discriminator, observer = ...
		else
			selector, observer = ...
		end

		local idToCleanup = {}
		local selectDiffs = createSelectArrayDiffs(selector, discriminator)
		local connected = true

		local function checkDiffs(diffs)
			if not connected then
				return
			end

			for _, entry in diffs.deletions do
				local cleanup = idToCleanup[entry.id]

				if cleanup then
					idToCleanup[entry.id] = nil
					cleanup()
				end
			end

			for _, entry in diffs.additions do
				if not idToCleanup[entry.id] then
					idToCleanup[entry.id] = observer(entry.value, entry.key)
				end
			end
		end

		local unsubscribe = self:subscribe(selectDiffs, checkDiffs)

		checkDiffs(self:getState(selectDiffs))

		return function()
			connected = false
			unsubscribe()

			for _, cleanup in idToCleanup do
				cleanup()
			end

			table.clear(idToCleanup)
		end
	end

	function producer:observeWhile(...)
		local arguments = select("#", ...)
		local selector, predicate, observer

		if arguments >= 3 then
			selector, predicate, observer = ...
		else
			selector, observer = ...
		end

		local initialSelection = self:getState(selector)
		local connected = true
		local cleanup

		local function updateObserver(selection, lastSelection)
			if not connected then
				return
			end

			local shouldObserve = if predicate then predicate(selection, lastSelection) else selection

			if shouldObserve and not cleanup then
				cleanup = observer(selection)
			elseif not shouldObserve and cleanup then
				task.spawn(cleanup)
				cleanup = nil
			end
		end

		local unsubscribe = self:subscribe(selector, updateObserver)

		updateObserver(initialSelection, initialSelection)

		return function()
			connected = false
			unsubscribe()

			if cleanup then
				cleanup()
			end
		end
	end

	function producer:destroy()
		if pendingFlush then
			pendingFlush:Disconnect()
			pendingFlush = nil
		end

		if currentListeners then
			table.clear(currentListeners)
		end

		table.clear(nextListeners)
	end

	function producer:enhance(enhancer)
		return enhancer(self)
	end

	function producer:applyMiddleware(...)
		return self:enhance(applyMiddleware(...))
	end

	-- Support for APIs that require signal-like objects

	function producer:Connect(listener)
		local unsubscribe = self:subscribe(listener)
		return {
			Connected = true,
			Disconnect = function(self)
				self.Connected = false
				unsubscribe()
			end,
		}
	end

	function producer:Once(listener)
		local unsubscribe = self:once(listener)
		return {
			Connected = true,
			Disconnect = function(self)
				self.Connected = false
				unsubscribe()
			end,
		}
	end

	function producer:Wait()
		return self:wait(function(state)
			return state
		end):expect()
	end

	for name, action in actions do
		local function dispatch(...)
			state = action(state, ...)
			scheduleFlush()
			return state
		end

		dispatchers[name] = dispatch

		if not producer[name] then
			producer[name] = dispatch
		else
			warn(`Producer already has a property named {name}`)
		end
	end

	return producer
end

return createProducer
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX433A4BF15FD341D1AE054901E139DDC0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">createSelector</string>
									<string name="ScriptGuid">{B85BE405-F9C0-4182-AE6F-8C6FDDBFE6DA}</string>
									<ProtectedString name="Source"><![CDATA[type CreateSelectorFunction =
	(<Result, Arguments...>(
		dependencies: { (Arguments...) -> any },
		combiner: (...any) -> Result,
		equalityOrOptions: (MemoizeOptions<Result> | EqualityCheck<Result>)?
	) -> (Arguments...) -> Result)
	& (<Result, A, Arguments...>(
		a: (Arguments...) -> A,
		combiner: (A) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		combiner: (A, B) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		combiner: (A, B, C) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, D, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		d: (Arguments...) -> D,
		combiner: (A, B, C, D) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, D, E, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		d: (Arguments...) -> D,
		e: (Arguments...) -> E,
		combiner: (A, B, C, D, E) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (<Result, A, B, C, D, E, F, Arguments...>(
		a: (Arguments...) -> A,
		b: (Arguments...) -> B,
		c: (Arguments...) -> C,
		d: (Arguments...) -> D,
		e: (Arguments...) -> E,
		f: (Arguments...) -> F,
		combiner: (A, B, C, D, E, F) -> Result,
		options: MemoizeOptions<Result>?
	) -> (Arguments...) -> Result)
	& (...(((...any) -> any) | MemoizeOptions<any>)) -> (...any) -> any

type EqualityCheck<T = any> = (current: T, previous: T) -> boolean

type MemoizeOptions<Result> = {
	--[=[
		The equality function used when comparing dependencies before calling
		the combiner. By default, a strict equality check is used.
	]=]
	equalityCheck: EqualityCheck?,

	--[=[
		The equality function used when comparing the result of the combiner
		to the previous value. If `true`, it will return the previous value
		of the combiner. By default, the latest result is always returned.
	]=]
	resultEqualityCheck: EqualityCheck<Result>?,
}

--[=[
	Memoizes a function by caching the result of the last call. Recomputes the
	result if any of the arguments have changed.
	@param callback The function to memoize.
	@param equalityCheck An optional equality function to use when
	comparing the arguments of the callback. By default, a strict equality
	check is used.
	@param resultEqualityCheck An optional equality function to use when comparing
	the result of the callback. By default, the latest result is always
	returned.
	@return A memoized function.
]=]
local function memoize(
	callback: (...any) -> any,
	equalityCheck: EqualityCheck?,
	resultEqualityCheck: EqualityCheck?
): (...any) -> any
	local lastArguments = {}
	local lastArgumentCount = -1
	local lastResult
	local firstRun = true

	return function(...)
		local argumentCount = select("#", ...)
		local result = lastResult

		if argumentCount ~= lastArgumentCount then
			result = callback(...)
			lastArgumentCount = argumentCount
			lastArguments = { ... }
		else
			for index = 1, argumentCount do
				local current = select(index, ...)
				local previous = lastArguments[index]

				if current ~= previous and (not equalityCheck or not equalityCheck(current, previous)) then
					result = callback(...)
					lastArguments = { ... }
					break
				end
			end
		end

		if not resultEqualityCheck then
			lastResult = result
			return result
		elseif firstRun or (lastResult ~= result and not resultEqualityCheck(result, lastResult)) then
			firstRun = false
			lastResult = result
		end

		return lastResult
	end
end

local function createSelectorImpl(...: ((...any) -> any) | MemoizeOptions<any>): (...any) -> any
	local arguments = table.pack(...)
	local dependencies, combiner, equalityOrOptions

	if type(...) == "table" then
		-- { ... }, combiner, equalityOrOptions
		dependencies, combiner, equalityOrOptions = ...
	elseif type(arguments[arguments.n]) == "table" then
		-- ..., combiner, options
		dependencies = table.create(arguments.n - 2)
		table.move(arguments, 1, arguments.n - 2, 1, dependencies)
		combiner, equalityOrOptions = arguments[arguments.n - 1], arguments[arguments.n]
	else
		-- ..., combiner
		dependencies = table.create(arguments.n - 1)
		table.move(arguments, 1, arguments.n - 1, 1, dependencies)
		combiner = arguments[arguments.n]
	end

	local options = if type(equalityOrOptions) == "function"
		then { equalityCheck = equalityOrOptions }
		else equalityOrOptions

	local resultEqualityCheck = options and options.resultEqualityCheck
	local equalityCheck = options and options.equalityCheck

	local dependencyCount = #dependencies
	local inputs = table.create(dependencyCount)
	local memoizedCombiner = memoize(combiner, equalityCheck, resultEqualityCheck)

	return memoize(function(...)
		for index = 1, dependencyCount do
			inputs[index] = dependencies[index](...)
		end

		return memoizedCombiner(table.unpack(inputs, 1, dependencyCount))
	end)
end

--[=[
	Creates a memoized selector function. The selector is only called if the
	outputs of the dependencies have changed.

	This function is only necessary if your selector is expensive to compute,
	or returns a new object (i.e. mapping an array). This is because selectors
	are called every state change, and if the selector returns a new object,
	the component will re-render even if the inputs haven't changed.

	@param dependencies A list of dependencies that the selector depends on.
	@param combiner A function that takes the dependencies as arguments and
	returns the result of the selector.
	@param options Options for memoizing the selector.
	@return A memoized selector function.
]=]
local createSelector: CreateSelectorFunction = createSelectorImpl :: any

return createSelector
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f2</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX8AA14C12D98246CCA5647FC58C34CFC6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">middleware</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f3</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX0F78BC433F2B475FA0FE0B82BDDE5AC3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">loggerMiddleware</string>
										<string name="ScriptGuid">{21DEDE47-F59F-4F1A-A4AC-D5CF0EB4A711}</string>
										<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local function stringify(value: unknown, _depth: number?): string
	local depth = _depth or 0

	if type(value) == "string" then
		return string.format("%q", value)
	elseif type(value) == "table" and depth < 2 then
		local result = "{"

		for k, v in value :: {} do
			result ..= "[" .. stringify(k, depth + 1) .. "] = " .. stringify(v, depth + 1) .. ", "
		end

		return result .. "}"
	else
		return tostring(value)
	end
end

--[=[
	A middleware that logs every action that is dispatched, and the new state
	after the action is handled.
]=]
local loggerMiddleware: types.Middleware = function(producer)
	print("[Reflex]: Mounted with state", producer:getState())

	producer:subscribe(function(state)
		print("[Reflex]: State changed to", state)
	end)

	return function(dispatch, name)
		return function(...)
			local arguments = table.pack(...)

			for index = 1, arguments.n do
				arguments[index] = stringify(arguments[index])
			end

			print(`[Reflex]: Dispatching {name}({table.concat(arguments, ", ")})`)

			return dispatch(...)
		end
	end
end

return loggerMiddleware
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f4</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXFAE1FECCE5F849B38E6EE259239C09DA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">types</string>
									<string name="ScriptGuid">{8C82DA48-4A69-44FE-9C1B-A06BF042E559}</string>
									<ProtectedString name="Source"><![CDATA[--[=[
	A Producer is a state container that exposes a set of dispatchers that can
	be used to modify the state. The state is immmutable, so dispatchers return
	a new state object.
]=]
export type Producer<State = any, Dispatchers = { [string]: (...any) -> State }> = Dispatchers & {
	--[=[
		Returns the current state of the producer. Receives an optional selector
		function that can be used to select a subset of the state.
		@param selector An optional selector function that can be used to select
		a subset of the state.
		@return The current state of the producer.
	]=]
	getState: ((self: Producer<State, Dispatchers>) -> State)
		& (<Selection>(self: Producer<State, Dispatchers>, selector: (state: State) -> Selection) -> Selection),

	--[=[
		Sets the state of the producer to a shallow copy of the given state.
		Fires listeners on the next frame.
		@param state The new state of the producer.
	]=]
	setState: (self: Producer<State, Dispatchers>, state: State) -> (),

	--[=[
		Resets the state of the producer to the initial state. Fires listeners
		on the next frame if the state has changed.
	]=]
	resetState: (self: Producer<State, Dispatchers>) -> (),

	--[=[
		Returns the dispatchers for the actions passed to `createProducer`.
		@return A map of dispatchers.
	]=]
	getDispatchers: (self: Producer<State, Dispatchers>) -> Dispatchers,

	--[=[
		Returns the original action functions passed to `createProducer`.
		@return A map of action functions.
	]=]
	getActions: (self: Producer<State, Dispatchers>) -> {
		[string]: (state: State, ...any) -> any,
	},

	--[=[
		Returns a distinct copy of the producer. The new copy starts with the
		same state and actions, but functions independently.
	]=]
	clone: (self: Producer<State, Dispatchers>) -> Producer<State, Dispatchers>,

	--[=[
		Flushes any pending updates by calling listeners immediately.
	]=]
	flush: (self: Producer<State, Dispatchers>) -> (),

	--[=[
		Subscribes to changes in a specific part of the state. State updates
		are deferred until the next frame after all state updates have been
		processed.
		@param selector A selector function that can be used to select a subset
		of the state.
		@param predicate An optional predicate function that must return `true`
		for the listener to be called.
		@param listener A callback that is called when the selected part of the
		state changes.
		@return A function that can be used to unsubscribe from the listener.
	]=]
	subscribe: ((self: Producer<State, Dispatchers>, listener: (state: State, prevState: State) -> ()) -> () -> ())
		& (<Selection>(
			self: Producer<State, Dispatchers>,
			selector: (state: State) -> Selection,
			listener: (state: Selection, prevState: Selection) -> ()
		) -> () -> ())
		& <Selection>(
			self: Producer<State, Dispatchers>,
			selector: (state: State) -> Selection,
			predicate: (state: Selection, prevState: Selection) -> boolean,
			listener: (state: Selection, prevState: Selection) -> ()
		) -> () -> (),

	--[=[
		Similar to `subscribe`, but the listener is disconnect after the first
		time it is called.
		@param selector A selector function that can be used to select a subset
		of the state.
		@param predicate An optional predicate function that must return `true`
		for the listener to be called.
		@param listener A callback that is called when the selected part of the
		state changes.
		@return A function that can be used to unsubscribe from the listener.
	]=]
	once: (<Selection>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> Selection,
		listener: (state: Selection, prevState: Selection) -> ()
	) -> () -> ()) & <Selection>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> Selection,
		predicate: ((state: Selection, prevState: Selection) -> boolean)?,
		listener: (state: Selection, prevState: Selection) -> ()
	) -> () -> (),

	--[=[
		Returns a Promise that resolves once a specific part of the state changes.
		Unsubscribes the listener if the Promise is cancelled or resolved.

		Receives an optional `predicate` function that must return `true` for the
		Promise to resolve for a given state change.

		@param selector A selector function that can be used to select a subset
		of the state.
		@param predicate An optional predicate function that must return `true`
		for the Promise to resolve for a given state change.
		@return A Promise that resolves once the selected part of the state changes.
	]=]
	wait: <Selection>(
		self: Producer<State, Dispatchers>,
		selector: ((state: State) -> Selection)?,
		predicate: ((state: Selection, prevState: Selection) -> boolean)?
	) -> any,

	--[=[
		Tracks the addition and removal of items in an array. Calls the given
		observer for each added item and calls the cleanup function when the
		item is removed.

		If your array contains immutable objects, you can use the `discriminator`
		argument to return a unique identifier for each item. This allows the
		observer to avoid calling the observer for items that have already been
		added.

		@param selector The selector to track.
		@param discriminator Optional function that returns a unique identifier for
		each item. Useful when tracking immutable objects.
		@param observer The observer to call when an item is added. Returns a
		function that is called when the item is removed.
		@return An observer that calls the given observer for each added item and
		unsubscribes when the item is removed.
	]=]
	observe: (<K, V>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> { [K]: V },
		discriminator: ((item: V, index: K) -> unknown)?,
		observer: (item: V, index: K) -> (() -> ())?
	) -> () -> ()) & (<K, V>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> { [K]: V },
		observer: (item: V, index: K) -> (() -> ())?
	) -> () -> ()),

	--[=[
		Similar to `observe`, but it creates one observer while a selector or
		predicate is truthy, and destroys the observer when it's no longer truthy.
		@param selector The selector to track.
		@param predicate An optional predicate function that must return `true`
		for the observer to be created.
		@param observer The observer to call when the selector is truthy. Returns
		a function that is called when the selector is falsy.
		@return A cleanup function that removes all observers.
	]=]
	observeWhile: (<T>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> T,
		predicate: (state: T, prevState: T) -> boolean,
		observer: (state: T) -> (() -> ())?
	) -> () -> ()) & (<T>(
		self: Producer<State, Dispatchers>,
		selector: (state: State) -> T?,
		observer: (state: T) -> (() -> ())?
	) -> () -> ()),

	--[=[
		Disconnects all listeners and cancels all pending flushes.
	]=]
	destroy: (self: Producer<State, Dispatchers>) -> (),

	--[=[
		Enhances the producer with new functionality. The enhancer function
		is passed to the producer as an argument and should mutate the producer
		in place.
		@deprecated Use `applyMiddleware` instead.
		@param enhancer A function that mutates the producer.
		@return The enhanced producer.
	]=]
	enhance: <Enhanced>(self: Producer<State, Dispatchers>, enhancer: (producer: any) -> Enhanced) -> Enhanced,

	--[=[
		Applies the given middlewares to the producer and its dispatchers. Returns
		the producer for chaining.

		Initially, a middleware is called once when it is applied to a producer.
		Next, the returned function is called on a dispatcher in the producer.
		The final function is called whenever the dispatcher is called.

		```lua
		local loggerMiddleware: Reflex.Middleware = function(producer)
			print("Initial state:", producer.getState())
			return function(dispatch, name)
				return function(...)
					print(`Dispatching {name}:`, ...args)
					return dispatch(...)
				end
			end
		end

		producer:applyMiddleware(loggerMiddleware)
		```

		@param middlewares A list of middleware to apply.
		@return The producer.
	]=]
	applyMiddleware: (
		self: Producer<State, Dispatchers>,
		...(producer: any) -> (dispatch: (...any) -> any, name: string) -> (...any) -> any
	) -> Producer<State, Dispatchers>,
}

--[=[
	A middleware is a function that is called before an action is dispatched.

	Initially, a middleware is called once when it is applied to a producer.
	Next, the returned function is called on a dispatcher in the producer.
	The final function is called whenever that dispatcher is called.
]=]
export type Middleware = (producer: Producer) -> (dispatch: (...any) -> any, name: string) -> (...any) -> any

export type ProducerMap = { [string]: Producer }

--[=[
	A container for storing a Reflex dispatcher's name and arguments.
]=]
export type BroadcastAction = {
	name: string,
	arguments: {},
}

--[=[
	Options for the broadcast middleware.
]=]
export type BroadcasterOptions = {
	--[=[
		The producers that will be tracked.
	]=]
	producers: ProducerMap,

	--[=[
		The rate in seconds at which the server should hydrate the
		clients with the latest state.
		@default 60
	]=]
	hydrateRate: number?,

	--[=[
		The rate in seconds at which the server should dispatch
		actions to the clients. If set to `0`, actions will be
		dispatched within the next frame.
		@default 0
	]=]
	dispatchRate: number?,

	--[=[
		Runs before actions are dispatched to a player. Can be used to
		filter actions or manipulate them before sending.

		Avoid directly mutating the action. Instead, return a new action
		if you need to change it. Return `nil` to not share the action
		with this player.
	]=]
	beforeDispatch: ((player: Player, action: BroadcastAction) -> BroadcastAction?)?,

	--[=[
		Runs before the client is hydrated with the latest state. Can be
		used to filter the state or hide certain values from the client.

		Do not mutate the state in this function! Treat it as a read-only
		object, and return a new object if you need to change it.
	]=]
	beforeHydrate: ((player: Player, state: { [string]: any }) -> { [string]: any })?,

	--[=[
		An optional custom hydration function. If provided, this function
		will be called instead of being implicitly handled in 'dispatch'.

		Useful for reducing load on a single remote if your state is large.
	]=]
	hydrate: ((player: Player, state: { [string]: any }) -> ())?,

	--[=[
		The function that will send the actions to the client.
	]=]
	dispatch: (player: Player, actions: { BroadcastAction }) -> (),
}

--[=[
	Options for the broadcast receiver.
]=]
export type BroadcastReceiverOptions = {
	--[=[
		A function that, when called, should fire a remote that calls
		`start(player)` on the server broadcaster.
	]=]
	start: () -> any,
}

--[=[
	A broadcaster that can be used to share actions with the client.
]=]
export type Broadcaster = {
	--[=[
		The middleware that will broadcast actions to the client.
	]=]
	middleware: Middleware,

	--[=[
		Starts broadcasting state and actions to the given player.
	]=]
	start: (self: Broadcaster, player: Player) -> (),

	--[=[
		Disconnects all listeners and cancels all pending dispatches.
	]=]
	destroy: (self: Broadcaster) -> (),
}

--[=[
	A receiver that can be used to dispatch actions broadcasted by the server.
]=]
export type BroadcastReceiver = {
	--[=[
		A middleware that should be applied to the root producer. This will
		merge the producer's state with the server's state on join.
	]=]
	middleware: Middleware,

	--[=[
		Dispatches actions broadcasted by the server.
	]=]
	dispatch: (self: BroadcastReceiver, actions: { BroadcastAction }) -> (),

	--[=[
		Hydrates the client with the latest state from the server.
		Normally, hydration is implicitly handled in 'dispatch' unless a
		custom hydration handler is provided in the broadcaster options.

		Useful for reducing load on a single remote if your state is large.
	]=]
	hydrate: (self: BroadcastReceiver, state: { [string]: any }) -> (),
}

return nil
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f5</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX3418F6EAA8D14D6CB3CFF9DCF97DEAAF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">utils</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f6</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX3068B8BE8088433C902AFBAF61D03168">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">createSelectArrayDiffs</string>
										<string name="ScriptGuid">{ED350690-A05F-45A4-A514-C74B6F9558D1}</string>
										<ProtectedString name="Source"><![CDATA[--!strict
local createSelector = require(script.Parent.Parent.createSelector)

type ArrayDiffs<K, V> = {
	additions: { Entry<K, V> },
	deletions: { Entry<K, V> },
}

type Entry<K, V> = {
	key: K,
	value: V,
	id: unknown,
}

--[=[
	Tracks the addition and removal of items in an array. Creates a selector that
	returns an object containing the additions and deletions since the last update.

	If your array contains immutable objects, you can use the `discriminator`
	argument to return a unique identifier for each item. This prevents excessive
	re-renders when an item is updated but not added or removed.

	@param selector The selector to track.
	@param discriminator A function that returns a unique identifier for each
	item. Useful when tracking immutable objects.
	@returns A selector that returns an object containing the additions and
	deletions since the last update.
]=]
local function createSelectArrayDiffs<State, K, V>(
	selector: (state: State) -> { [K]: V },
	discriminator: ((item: V, index: K) -> unknown)?
): (state: State) -> ArrayDiffs<K, V>
	local lastEntries: { [unknown]: Entry<K, V> } = {}

	return createSelector(selector, function(items: { [K]: V })
		local additions: { Entry<K, V> } = {}
		local deletions: { Entry<K, V> } = {}
		local entries: { [unknown]: Entry<K, V> } = {}

		for key, item in items do
			local id = if discriminator then discriminator(item, key) else item
			local entry = { key = key, value = item, id = id }

			assert(id ~= nil, "Discriminator returned a nil value")

			if not lastEntries[id] then
				table.insert(additions, entry)
			end

			entries[id] = entry
		end

		for id, item in lastEntries do
			if not entries[id] then
				local entry = lastEntries[id]
				table.insert(deletions, entry)
			end
		end

		lastEntries = entries

		return {
			additions = additions,
			deletions = deletions,
		}
	end)
end

return createSelectArrayDiffs
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f7</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7B9426E896A642949DD129961FA9FF4E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">setInterval</string>
										<string name="ScriptGuid">{47DE1424-E0CE-41D9-8B03-B2510C12420B}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local function setInterval(callback: () -> (), interval: number): () -> ()
	if interval < 0 then
		return function() end
	end

	local timer = 0
	local connection

	connection = RunService.Heartbeat:Connect(function(dt)
		timer += dt

		if timer >= interval then
			timer -= interval
			callback()
		end
	end)

	return function()
		connection:Disconnect()
	end
end

return setInterval
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0EE6311D4D134C429D848C132128472D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">shallowEqual</string>
										<string name="ScriptGuid">{1A6CD045-DBE9-4FD1-BF0E-135FDEF5EAE7}</string>
										<ProtectedString name="Source"><![CDATA[--[=[
	Returns whether or not two tables are shallowly equal, or in other words,
	have the same set of key-value pairs.
	@param a The first table to compare.
	@param b The second table to compare.
	@returns Whether or not the tables are shallowly equal.
]=]
local function shallowEqual(a: any, b: any): boolean
	if a == b then
		return true
	end

	if type(a) ~= "table" or type(b) ~= "table" then
		return false
	end

	for key, value in a do
		if b[key] ~= value then
			return false
		end
	end

	for key, value in b do
		if a[key] ~= value then
			return false
		end
	end

	return true
end

return shallowEqual
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004f9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3D7E64F4CF654555B6DC126D6B23ACFB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">testSelector</string>
										<string name="ScriptGuid">{F4139634-0A95-4078-9E50-5DD014CA9661}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local IS_STUDIO = RunService:IsStudio()
local TEST_WARNING = [[
Reflex detected a selector function that returns conflicting values for the same input!
This is likely caused by one of the following:

- The selector function is not memoized and should use 'createSelector'
- The selector function is memoized but is not idempotent

Learn more about writing selectors here:
https://littensy.github.io/reflex/docs/guides/using-selectors

%s]]

--[=[
	Tests a selector function's memoization. If the selector function is not
	memoized, it will output a warning in Roblox Studio.
	@param selector The selector function to test.
	@param expectedValue The expected value of the selector function.
	@param ... The arguments to pass to the selector function.
	@returns Whether the test passed.
]=]
local function testSelector<T, U...>(selector: (U...) -> T, expectedValue: T, ...: U...)
	if selector(...) == expectedValue then
		return true
	end

	if IS_STUDIO then
		local traceback = debug.traceback("Function traceback", 2)
		warn(string.format(TEST_WARNING, traceback))
	end

	return false
end

return testSelector
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004fa</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXD704D94BDC614B799AAE846754E2411A">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">rewire</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004fb</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX1A82024965A84746BED171680A7B73F3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{8FF92F67-C2B3-47F9-A729-14A337D48450}</string>
								<ProtectedString name="Source"><![CDATA[local Constants = require(script.Constants)

return {
	HotReloader = require(script.HotReloader),
	CollectionServiceTag = Constants.CollectionServiceTag,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004fc</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX7F20504356AF4CF5A6498A8281C18A5C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Constants</string>
									<string name="ScriptGuid">{381BCCA7-953D-4D78-8082-333A82105A86}</string>
									<ProtectedString name="Source"><![CDATA[return {
	CollectionServiceTag = "RewireClonedModule"
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004fd</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6DC7B4CF9FAD45F2B48878CFEE086E1C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">HotReloader</string>
									<string name="ScriptGuid">{B12D1FBE-7BC3-4A1D-8690-BE740849C24A}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Constants = require(script.Parent.Constants)

local HotReloader = {}
HotReloader.__index = HotReloader

--[=[
	@class HotReloader
]=]

type Context = {
	originalModule: ModuleScript,
	isReloading: boolean,
}

--[=[
	@interface Context
	@within HotReloader

	.originalModule ModuleScript
	.isReloading boolean
]=]

--[=[
	Creates a new HotReloader.

	@return HotReloader
]=]
function HotReloader.new()
	local self = setmetatable({
		_listeners = {},
		_clonedModules = {},
	}, HotReloader)
	return self
end

--[=[
	Cleans up this HotReloader, forgetting about any previously modules that were being listened to.
]=]
function HotReloader:destroy()
	for _, listener: RBXScriptConnection in pairs(self._listeners) do
		listener:Disconnect()
	end
	self._listeners = {}
	for _, cloned in pairs(self._clonedModules) do
		cloned:Destroy()
	end
	self._clonedModules = {}
end

--[=[
	Listen to changes from a single module.

	Runs the given `callback` once to start, and then again whenever the module changes.

	Runs the given `cleanup` callback after a module is changed, but before `callback` is run.

	Both are passed a [Context] object, which contains information about the original module
	and whether or not the script is reloading.

	- For `callback`, `Context.isReloading` is true if running as a result of a hot-reload (false indicates first run).
	- For `cleanup`, `Context.isReloading` is true if the module is about to be hot-reloaded (false indicates this is the last cleanup).

	@param module -- The original module to attach listeners to
	@param callback -- A callback that runs when the ModuleScript is added or changed
	@param cleanup -- A callback that runs when the ModuleScript is changed or removed
]=]
function HotReloader:listen(
	module: ModuleScript,
	callback: (ModuleScript, Context) -> (),
	cleanup: (ModuleScript, Context) -> ()
)
	if RunService:IsStudio() then
		local moduleChanged = module.Changed:Connect(function()
			local originalStillExists = game:IsAncestorOf(module)

			local cleanupContext = {
				isReloading = originalStillExists,
				originalModule = module,
			}

			if self._clonedModules[module] then
				cleanup(self._clonedModules[module], cleanupContext)
				self._clonedModules[module]:Destroy()
			else
				cleanup(module, cleanupContext)
			end

			if not originalStillExists then
				return
			end

			local cloned = module:Clone()

			CollectionService:AddTag(cloned, Constants.CollectionServiceTag)

			cloned.Parent = module.Parent
			self._clonedModules[module] = cloned

			callback(cloned, {
				originalModule = module,
				isReloading = true,
			})
			warn(("HotReloaded %s!"):format(module:GetFullName()))
		end)
		table.insert(self._listeners, moduleChanged)
	end

	callback(module, {
		originalModule = module,
		isReloading = false,
	})
end

--[=[
	Scans current and new descendants of an object for ModuleScripts, and runs `callback` for each of them.

	This function has the same semantics as [HotReloader:listen].

	@param container -- The root instance
	@param callback -- A callback that runs when the ModuleScript is added or changed
	@param cleanup -- A callback that runs when the ModuleScript is changed or removed
]=]
function HotReloader:scan(
	container: Instance,
	callback: (ModuleScript, Context) -> (),
	cleanup: (ModuleScript, Context) -> ()
)
	local function add(module)
		self:listen(module, callback, cleanup)
	end

	for _, instance in container:GetDescendants() do
		if instance:IsA("ModuleScript") then
			add(instance)
		end
	end

	local descendantAdded = container.DescendantAdded:Connect(function(instance)
		if instance:IsA("ModuleScript") and not CollectionService:HasTag(instance, Constants.CollectionServiceTag) then
			add(instance)
		end
	end)

	table.insert(self._listeners, descendantAdded)
end

return HotReloader
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004fe</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX173E4F29F3704843A932E660CAA8C4D1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ripple</string>
							<string name="ScriptGuid">{0C5C06AC-CDE7-4B67-9A74-5C81A668E8A7}</string>
							<ProtectedString name="Source"><![CDATA[local types = require(script.types)

export type Motion<T = number> = types.Motion<T>

export type MotionState = types.MotionState

export type MotionSolver = types.MotionSolver

export type MotionGoal = types.MotionGoal

return {
	createMotion = require(script.createMotion),
	config = require(script.config),
	immediate = require(script.solvers.immediate),
	linear = require(script.solvers.linear),
	spring = require(script.solvers.spring),
	tween = require(script.solvers.tween),
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000004ff</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXB1237A4B964B44C7A747C73916817023">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">config</string>
								<string name="ScriptGuid">{8A2A8437-AC64-4766-BCD2-C85FD258AEE0}</string>
								<ProtectedString name="Source"><![CDATA[local config = {
	spring = {
		default = { tension = 170, friction = 26 },
		gentle = { tension = 120, friction = 14 },
		wobbly = { tension = 180, friction = 12 },
		stiff = { tension = 210, friction = 20 },
		slow = { tension = 280, friction = 60 },
		molasses = { tension = 280, friction = 120 },
	},

	linear = {
		default = { speed = 1 },
	},

	tween = {
		default = {
			time = 1,
			style = Enum.EasingStyle.Quad,
			direction = Enum.EasingDirection.Out,
			repeatCount = 0,
			reverses = false,
			delayTime = 0,
		},
	},
}

return config
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000500</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC739C81C7D3A4D9898C0ECBD84A63BCA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createMotion</string>
								<string name="ScriptGuid">{714CAC01-859F-4E51-B127-96A13381F623}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local types = require(script.Parent.types)
local immediateSolver = require(script.Parent.solvers.immediate)
local linearSolver = require(script.Parent.solvers.linear)
local springSolver = require(script.Parent.solvers.spring)
local tweenSolver = require(script.Parent.solvers.tween)
local intermediate = require(script.Parent.utils.intermediate)
local assign = require(script.Parent.utils.assign)
local merge = require(script.Parent.utils.merge)

local defaults = {
	heartbeat = RunService.Heartbeat,
	start = false,
}

local function createMotion<T>(initialValue: T, options: types.MotionOptions?): types.Motion<T>
	local config = merge(defaults, options or {})
	local valueType = typeof(initialValue)

	local motionState: { [any]: types.MotionState } = {}
	local motionSolvers: { [any]: types.MotionSolver } = {}

	local onStepListeners: { (value: T, deltaTime: number) -> () } = {}
	local onCompleteListeners: { (value: T) -> () } = {}
	local nextListenerId = 1

	local connection: RBXScriptConnection?
	local wasComplete = false
	local lastCompleteValue

	for key, value in intermediate.to(initialValue) do
		motionState[key] = {
			value = value,
			complete = true,
		}
	end

	local function stop()
		if connection then
			connection:Disconnect()
			connection = nil
		end
	end

	local function start(self)
		if connection then
			return stop
		end

		connection = config.heartbeat:Connect(function(deltaTime)
			self:step(deltaTime)
		end)

		return stop
	end

	local function get()
		local intermediates = {}

		for key, state in motionState do
			intermediates[key] = state.value
		end

		return intermediate.from(intermediates, valueType)
	end

	local function getVelocity()
		local intermediates = {}

		for key, state in motionState do
			intermediates[key] = state.velocity or 0
		end

		return intermediate.from(intermediates, valueType)
	end

	local function set(_self, value)
		local intermediates = intermediate.to(value)

		for key, state in motionState do
			local newValue = intermediates[key]

			if newValue then
				state.value = newValue
				state.complete = false
			end
		end
	end

	local function patch(_self, source)
		for key, state in motionState do
			local stateSource = source[key]

			if stateSource then
				state.complete = false
				assign(state, stateSource)
			end
		end
	end

	local function impulse(_self, impulses)
		if type(impulses) == "number" then
			for _, state in motionState do
				if not state.velocity then
					continue
				end

				state.complete = false
				state.velocity = state.velocity :: number + impulses
			end

			return
		end

		local intermediateImpulses = intermediate.to(impulses)

		for key, amount in intermediateImpulses do
			local state = motionState[key]

			if not state or not state.velocity then
				continue
			end

			state.complete = false
			state.velocity = state.velocity :: number + amount
		end

		return
	end

	local function to(_self, solvers)
		if type(solvers) == "function" then
			for key, state in motionState do
				if state.destructor then
					state.destructor()
					state.destructor = nil
				end

				state.complete = false

				if solvers(key, state, 0) ~= false then
					-- only sets the solver if this key is part of the new goal
					motionSolvers[key] = solvers
				end
			end

			return
		end

		for key, solver in solvers do
			local state = motionState[key]

			if not state then
				continue
			end

			if state.destructor then
				state.destructor()
				state.destructor = nil
			end

			state.complete = false

			if solver(key, state, 0) ~= false then
				-- only sets the solver if this key is part of the new goal
				motionSolvers[key] = solver
			end
		end
	end

	local function immediate(self, value)
		self:to(immediateSolver(value :: any))
	end

	local function linear(self, value, params)
		self:to(linearSolver(value :: any, params))
	end

	local function spring(self, value, params)
		self:to(springSolver(value :: any, params))
	end

	local function tween(self, value, params)
		self:to(tweenSolver(value :: any, params))
	end

	local function step(self, deltaTime)
		for key, handler in motionSolvers do
			local state = motionState[key]

			if state and not state.complete then
				handler(key, state, deltaTime)
			end
		end

		local value = self:get()
		local complete = self:isComplete()

		if not wasComplete or not complete then
			for _, listener in onStepListeners do
				task.spawn(listener, value, deltaTime)
			end
		end

		if complete and (not wasComplete or lastCompleteValue ~= value) then
			for _, listener in onCompleteListeners do
				task.spawn(listener, value)
			end
		end

		wasComplete = complete
		lastCompleteValue = value

		return value
	end

	local function isComplete()
		for _, state in motionState do
			if not state.complete then
				return false
			end
		end

		return true
	end

	local function onComplete(_self, callback)
		local listenerId = nextListenerId
		nextListenerId += 1
		onCompleteListeners[listenerId] = callback

		return function()
			onCompleteListeners[listenerId] = nil
		end
	end

	local function onStep(_self, callback)
		local listenerId = nextListenerId
		nextListenerId += 1
		onStepListeners[listenerId] = callback

		return function()
			onStepListeners[listenerId] = nil
		end
	end

	local function destroy()
		wasComplete = false
		nextListenerId = 1

		stop()

		table.clear(onStepListeners)
		table.clear(onCompleteListeners)
		table.clear(motionSolvers)

		for _, state in motionState do
			if state.destructor then
				state.destructor()
				state.destructor = nil
			end
		end
	end

	local motion: types.Motion<T> = {
		state = motionState,
		start = start,
		stop = stop,
		get = get,
		getVelocity = getVelocity,
		set = set,
		patch = patch,
		impulse = impulse,
		to = to,
		immediate = immediate,
		linear = linear,
		spring = spring,
		tween = tween,
		step = step,
		isComplete = isComplete,
		onComplete = onComplete,
		onStep = onStep,
		destroy = destroy,
	}

	if config.start then
		motion:start()
	end

	return motion
end

return createMotion
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000501</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXD3206275D1EC4DAFA4E7049D268C3723">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">solvers</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000502</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5A09CE1CFBBA419BB8E450F5246A1DD8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">immediate</string>
									<string name="ScriptGuid">{24AF1FAF-220D-49C8-B498-B0C5644C437E}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local intermediate = require(script.Parent.Parent.utils.intermediate)

local function immediate(motionGoal: types.MotionGoal): types.MotionSolver
	local goals = intermediate.to(motionGoal)

	return function(key, state)
		local goal = intermediate.index(goals, key)

		if not goal then
			return false
		end

		state.complete = true
		state.value = goal
	end
end

return immediate
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000503</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX45768F48DF5644B191DA37115B94CE19">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">linear</string>
									<string name="ScriptGuid">{3E0C5100-E066-4FD6-B198-32B7F68D52A3}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local config = require(script.Parent.Parent.config)
local intermediate = require(script.Parent.Parent.utils.intermediate)

local function configure(options: types.LinearOptions)
	local speed = if type(options) == "table" then options.speed else options

	return {
		speed = speed or config.linear.default.speed,
	}
end

local function linear(motionGoal: types.MotionGoal, options: types.LinearOptions): types.MotionSolver
	local props = configure(options)
	local goals = intermediate.to(motionGoal)

	return function(key, state, deltaTime)
		local goal = intermediate.index(goals, key)

		if not goal then
			return false
		end

		local velocity = props.speed * deltaTime * math.sign(goal - state.value)

		if math.abs(velocity) >= math.abs(goal - state.value) then
			state.complete = true
			state.value = goal
			state.velocity = 0
		else
			state.value += velocity
			state.velocity = velocity
		end
	end
end

return linear
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000504</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB6C8B26E0CBD4AAB9F9EE1C93D5A8BE5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">spring</string>
									<string name="ScriptGuid">{AFCE9A81-BBD9-4A38-8166-75392FB0E825}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local config = require(script.Parent.Parent.config)
local intermediate = require(script.Parent.Parent.utils.intermediate)

local STEP = 1 -- milliseconds
local MAX_PASS = 100

local function configure(options: types.SpringOptions)
	local mass = options.mass or 1
	local tension = options.tension or config.spring.default.tension
	local friction = options.friction or config.spring.default.friction

	if options.frequency or options.damping then
		local frequency = options.frequency or 0.5
		local damping = options.damping or 1
		tension = (2 * math.pi / frequency) ^ 2 * mass
		friction = (4 * math.pi * damping * mass) / frequency
	end

	return {
		mass = mass,
		tension = tension,
		friction = friction,
		position = options.position,
		velocity = options.velocity,
		impulse = options.impulse,
		restingVelocity = options.restingVelocity or 0.001,
		restingPosition = options.restingPosition or 0.0001,
	}
end

local function spring(motionGoal: types.MotionGoal, options: types.SpringOptions?): types.MotionSolver
	local props = configure(options or {})
	local goals = intermediate.to(motionGoal)
	local mounting = true

	return function(key, state, deltaTime)
		local goal = intermediate.index(goals, key)

		if not goal then
			return false
		end

		if mounting then
			mounting = false
			state.value = (props.position or state.value or 0)
			state.velocity = (props.velocity or state.velocity or 0) + (props.impulse or 0)
		end

		local position = state.value
		local velocity = state.velocity or 0
		local passes = math.min(math.ceil((deltaTime * 1000) / STEP), MAX_PASS)

		for _ = 1, passes do
			local springForce = -props.tension * 0.000001 * (position - goal)
			local dampingForce = -props.friction * 0.001 * velocity
			local acceleration = (springForce + dampingForce) / props.mass

			velocity += acceleration * STEP
			position += velocity * STEP
		end

		if math.abs(velocity) < props.restingVelocity and math.abs(position - goal) < props.restingPosition then
			state.complete = true
			state.value = goal
			state.velocity = 0
		else
			state.value = position
			state.velocity = velocity
		end
	end
end

return spring
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000505</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF819357CB6CA43C5B1061A0C42D39B1F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">tween</string>
									<string name="ScriptGuid">{B6056F29-0074-458B-B79D-F24B57323BB6}</string>
									<ProtectedString name="Source"><![CDATA[local TweenService = game:GetService("TweenService")

local types = require(script.Parent.Parent.types)
local config = require(script.Parent.Parent.config)
local intermediate = require(script.Parent.Parent.utils.intermediate)
local merge = require(script.Parent.Parent.utils.merge)

type TweenEntry = {
	value: NumberValue,
	tween: Tween,
	complete: boolean,
}

local function createTween(from: number, to: number, options: types.TweenOptions): TweenEntry
	local tweenInfo = TweenInfo.new(
		options.time,
		options.style,
		options.direction,
		options.repeatCount,
		options.reverses,
		options.delayTime
	)

	local value = Instance.new("NumberValue")
	local tween = TweenService:Create(value, tweenInfo, { Value = to })

	value.Value = from

	return {
		value = value,
		tween = tween,
		complete = false,
	}
end

local function tween(motionGoal: types.MotionGoal, options: types.TweenOptions?): types.MotionSolver
	local props = merge(config.tween.default, options or {})
	local goals = intermediate.to(motionGoal)
	local entries: { [unknown]: TweenEntry? } = {}

	return function(key, state)
		local goal = intermediate.index(goals, key)

		if not goal then
			return false
		end

		if not state.destructor then
			local entry = createTween(state.value, goal, props)

			entries[key] = entry

			entry.tween.Completed:Connect(function()
				entry.complete = true
				entry.value:Destroy()
				entry.tween:Destroy()
			end)

			entry.tween:Play()

			function state.destructor()
				entry.tween:Destroy()
				entry.value:Destroy()
				entries[key] = nil
			end
		end

		local entry = entries[key]

		if not entry then
			state.complete = true
		elseif entry.complete then
			state.complete = true
			state.value = goal
		else
			state.value = entry.value.Value
		end
	end
end

return tween
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000506</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX7EA12749DFAF4635BEC2289127CAB0AF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">types</string>
								<string name="ScriptGuid">{28175606-2375-43D0-8216-FD04ED525BC4}</string>
								<ProtectedString name="Source"><![CDATA[type Cleanup = () -> ()

export type Heartbeat = {
	Connect: (self: Heartbeat, callback: (deltaTime: number) -> ()) -> Disconnectable,
}

export type Disconnectable = {
	Disconnect: (self: Disconnectable) -> (),
}

export type Partial<T> = { [any]: any } & T

export type SpringOptions = {
	damping: number?,
	frequency: number?,
	mass: number?,
	tension: number?,
	friction: number?,
	position: number?,
	velocity: number?,
	impulse: number?,
	restingVelocity: number?,
	restingPosition: number?,
}

export type LinearOptions = {
	speed: number?,
} | number?

export type TweenOptions = {
	time: number?,
	style: Enum.EasingStyle?,
	direction: Enum.EasingDirection?,
	repeatCount: number?,
	reverses: boolean?,
	delayTime: number?,
}

export type Motion<T = number> = {
	state: { [any]: MotionState },
	start: (self: Motion<T>) -> Cleanup,
	stop: (self: Motion<T>) -> (),
	get: (self: Motion<T>) -> T,
	getVelocity: (self: Motion<T>) -> T,
	set: (self: Motion<T>, value: T | { [any]: number }) -> (),
	patch: (self: Motion<T>, patch: { [any]: Partial<MotionState> }) -> (),
	impulse: (self: Motion<T>, impulse: T | { [any]: number }) -> (),
	to: (self: Motion<T>, goal: MotionSolver | { [any]: MotionSolver }) -> (),
	immediate: (self: Motion<T>, goal: T) -> (),
	spring: (self: Motion<T>, goal: T, options: SpringOptions?) -> (),
	linear: (self: Motion<T>, goal: T, options: LinearOptions?) -> (),
	tween: (self: Motion<T>, goal: T, options: TweenOptions?) -> (),
	step: (self: Motion<T>, deltaTime: number) -> T,
	isComplete: (self: Motion<T>) -> boolean,
	onComplete: (self: Motion<T>, callback: (value: T) -> ()) -> Cleanup,
	onStep: (self: Motion<T>, callback: (value: T, deltaTime: number) -> ()) -> Cleanup,
	destroy: (self: Motion<T>) -> (),
}

export type MotionOptions = {
	heartbeat: Heartbeat?,
	start: boolean?,
}

export type MotionState = {
	value: number,
	complete: boolean,
	velocity: number?,
	destructor: (() -> ())?,
}

export type MotionSolver = (key: unknown, state: MotionState, deltaTime: number) -> ()

export type MotionGoal = { [any]: number } | number | UDim2 | UDim | Vector2 | Vector3 | Color3 | CFrame

return nil
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000507</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX78EDB28338F5474890508D1840037980">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">utils</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000508</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXC8657AA72831423EAF5C0D44CD001E6B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">assign</string>
									<string name="ScriptGuid">{CF006220-357C-4C8C-A9CF-41EBCFB8951A}</string>
									<ProtectedString name="Source"><![CDATA[local function assign<T>(object: T, ...: { [any]: any }): T
	assert(type(object) == "table", `Expected a table for first argument, got ${type(object)}`)

	for index = 1, select("#", ...) do
		local source = select(index, ...)

		for key, value in source do
			object[key] = value
		end
	end

	return object
end

return assign
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000509</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9B8E6C03819C432E95C7E22B87DFAACE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">graph</string>
									<string name="ScriptGuid">{BDF6425D-A95B-4074-9F93-7BA3A304545B}</string>
									<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local STEP = 1 / 50
local DURATION = 0.3
local WIDTH = 30

local function graph(label: string, solver: types.MotionSolver)
	local state: types.MotionState = { value = 0, complete = false }
	local output = ""

	for _ = 0, DURATION, STEP do
		output ..= `\n{string.format("%.2f", state.value)}: {string.rep(" ", math.round(state.value * WIDTH))}*`
		solver("value", state, STEP)
	end

	print(`📈 {label}{output}`)
end

return graph
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000050a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9D69837EFECA404E80E0A62105B43692">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">intermediate</string>
									<string name="ScriptGuid">{33936C33-029C-4B1B-BF96-5DE902A286C3}</string>
									<ProtectedString name="Source"><![CDATA[type Intermediate = { [any]: number }

local intermediates = {
	number = {
		to = function(value: number): Intermediate
			return { value }
		end,
		from = function(value: Intermediate): number
			return value[1]
		end,
	},

	table = {
		to = function(value: Intermediate): Intermediate
			return value
		end,
		from = function(value: Intermediate): Intermediate
			return value
		end,
	},

	UDim2 = {
		to = function(value: UDim2): Intermediate
			return { value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset }
		end,
		from = function(value: Intermediate): UDim2
			return UDim2.new(value[1], math.round(value[2]), value[3], math.round(value[4]))
		end,
	},

	UDim = {
		to = function(value: UDim): Intermediate
			return { value.Scale, value.Offset }
		end,
		from = function(value: Intermediate)
			return UDim.new(value[1], math.round(value[2]))
		end,
	},

	Vector2 = {
		to = function(value: Vector2): Intermediate
			return { value.X, value.Y }
		end,
		from = function(value: Intermediate): Vector2
			return Vector2.new(table.unpack(value, 1, 2))
		end,
	},

	Vector3 = {
		to = function(value: Vector3): Intermediate
			return { value.X, value.Y, value.Z }
		end,
		from = function(value: Intermediate): Vector3
			return Vector3.new(table.unpack(value, 1, 3))
		end,
	},

	Color3 = {
		to = function(value: Color3): Intermediate
			return { value.R, value.G, value.B }
		end,
		from = function(value: Intermediate): Color3
			return Color3.new(math.clamp(value[1], 0, 1), math.clamp(value[2], 0, 1), math.clamp(value[3], 0, 1))
		end,
	},

	CFrame = {
		to = function(value: CFrame): Intermediate
			return { value:GetComponents() }
		end,
		from = function(value: Intermediate): CFrame
			return CFrame.new(table.unpack(value))
		end,
	},
}

local function to(value: unknown): Intermediate
	local type = typeof(value)

	if intermediates[type] then
		return intermediates[type].to(value)
	else
		error(`Ripple received an unsupported value '{value}' of type '{type}'`)
	end
end

local function from<T>(value: Intermediate, type: string): T
	if intermediates[type] then
		return intermediates[type].from(value)
	else
		error(`Ripple received an unsupported value '{value}' of type '{type}'`)
	end
end

local function index(value: Intermediate, key: unknown): number?
	return value[key] or value[1]
end

return {
	to = to,
	from = from,
	index = index,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000050b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX882667820E9F4D78956FC5DF2E3A8421">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">merge</string>
									<string name="ScriptGuid">{06F5C8B8-A4DE-48D8-B9E8-5D13E5E5B084}</string>
									<ProtectedString name="Source"><![CDATA[local function merge<T, U>(a: T & { [any]: any }, b: U & { [any]: any }): T & U
	local copy = table.clone(a)

	for key, value in pairs(b) do
		copy[key] = value
	end

	return copy :: never
end

return merge
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000050c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9FCC2122876A4423B9F2F5D2DA732FA6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">snapshot</string>
									<string name="ScriptGuid">{098B20CD-317D-4AD9-959C-8997FC09D2CE}</string>
									<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")

local types = require(script.Parent.Parent.types)
local createMotion = require(script.Parent.Parent.createMotion)

local STEP = 0.1
local MAX_LENGTH = 20

local function createSnapshot(solver: types.MotionSolver, length: number?)
	local data: { number } = {}
	local motion = createMotion(0)

	motion:to(solver)

	for _ = 1, length or MAX_LENGTH do
		local value = motion:step(STEP)

		value = if value < 1
			then math.floor(value * 100) / 100
			elseif value > 1 then math.ceil(value * 100) / 100
			else value

		table.insert(data, value)

		if value == 1 then
			break
		end
	end

	return HttpService:JSONEncode(data), motion
end

local function testSnapshot(solver: types.MotionSolver, expected: string)
	local length = select(2, string.gsub(expected, ",", ",")) + 1
	local snapshot, motion = createSnapshot(solver, length)

	if snapshot ~= expected then
		error(`Snapshot does not match expected value.\n\nExpected:\n{expected}\n\nActual:\n{snapshot}`, 2)
	end

	return motion
end

return {
	createSnapshot = createSnapshot,
	testSnapshot = testSnapshot,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000050d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9EF097BB3F794623861A92CB572D63B7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">spy</string>
									<string name="ScriptGuid">{9D5CDE84-E06B-4FCD-AD18-F9835A32BF4C}</string>
									<ProtectedString name="Source"><![CDATA[type Spy = {
	calls: number,
	arguments: { { unknown } },
	handle: (...any) -> (),
}

local function spy(): Spy
	local self: Spy

	local function handle(...)
		self.calls += 1
		self.arguments[self.calls] = { ... }
	end

	self = {
		calls = 0,
		arguments = {},
		handle = handle,
	}

	return self
end

return spy
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000050e</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX2C1DE991434640B987D3D318D37F3A3B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">yetanothernet</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000581</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX6BC45DADA8B646258F3D57F879983BD1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">lib</string>
								<string name="ScriptGuid">{85B62E61-9159-47F7-9F01-16FE6EF967F4}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local Bridge = require(script.Bridge)
type Bridge = Bridge.Bridge

type Recipient = Bridge.Recipient
type IncomingPacket = Bridge.IncomingPacket
type OutgoingPacket = Bridge.OutgoingPacket

type IncomingQueue = Bridge.IncomingQueue
type OutgoingQueue = Bridge.OutgoingQueue

type NetServer = Bridge.NetServer

local Identifier = require(script.Identifier)
export type Identifier = Identifier.Identifier

local read = Identifier.read

local QueryResult = require(script.QueryResult)
export type QueryResult<U...> = QueryResult.QueryResult<U...>

local SendRequest = require(script.SendRequest)
export type SendRequest = SendRequest.SendRequest

local isClient = RunService:IsClient()

--[=[
	@interface Configuration
	@within Route
	@field Channel "Reliable" | "Unreliable" -- Default: Reliable
	@field Event string -- The event to schedule the Route on in your Matter Loop -- Default: "default"
	@field Ratelimit number -- Amount of allowed invocations a frame

	:::note
	As of v0.5.0, Ratelimiting is not implemented. This feature will come in future versions.
	:::

	### Channel

	**Reliable**: All packets will be sent and received per frame in order.
	**Unreliable**: Packets may be dropped but will be received in order.
]=]
export type Configuration = {
	Channel: ("Reliable" | "Unreliable")?,
	Event: string?,
	Ratelimit: number?,
}

--[=[
	@class Route

	A Networking Library, inspired by BridgeNet2 & Bevy_Renet, made for ECS.

	See the [Intro](/docs/intro) to get started.
]=]
type RouteImpl<U...> = {
	server: NetServer,
	_identifier: Identifier,
	_configuration: Configuration,
	_outgoingQueue: { OutgoingPacket },
	_currentPlayers: { Player },
	_snapshot: IncomingQueue,
	_middleware: {
		Incoming: ((...any?) -> U...)?,
		Outgoing: ((U...) -> ...any?)?,
	},

	__index: RouteImpl<U...>,
	__iter: (self: Route<U...>) -> QueryResult<U...>,

	_queuePackets: (Route<U...>, Bridge) -> (),
	_updateSnapshot: (Route<U...>, Bridge) -> (),
	addIncomingMiddleware: (self: Route<U...>, middleware: (...any?) -> U...?) -> (),
	addOutgoingMiddleware: (self: Route<U...>, middleware: (U...) -> ...any?) -> (),
	send: (self: Route<U...>, U...) -> SendRequest,
	query: (self: Route<U...>) -> QueryResult<U...>,

	start: (loop: any, { Route<U...> }) -> (),
	createHook: ({ Route<U...> }) -> () -> (),

	new: (Configuration) -> Route<U...>,
}

export type Route<U...> = typeof(setmetatable(
	{} :: {
		_configuration: Configuration,
		_outgoingQueue: { OutgoingPacket },
		_snapshot: IncomingQueue,
		_currentPlayers: { Player },
	},
	{} :: RouteImpl<U...>
))

local Route: RouteImpl<...any> = {} :: RouteImpl<...any>
Route.__index = Route

Route.server = Bridge.server

--[=[
	@method __iter
	@within Route
	@private
	
	Creates a QueryResult that returns all Packets in the current frame's snapshot
	from the Route's identifier.
	
	See [Route:query] to filter by Senders.

	@return QueryResult
]=]
function Route:__iter()
	return QueryResult.new(self._snapshot, self._identifier)
end

--[=[
	@method query
	@within Route
	
	Allows for iteration of all packets of the previous frame.
	You can filter by Senders by chaining the ``QueryResult:from()`` method onto the query method.

	:::note
	Due to certain limitations with the Luau Type System, iterating over the QueryResult Object
	will not return typed values. In order to fix this, call ``:__iter()`` on the QueryResult Object.

	For example:
	```lua
	for i, sender, ... in route:query():__iter() do
		-- Do something
	end
	```
	:::

	See [Querying Data](/docs/getting-started/routes#querying) for more information.

	@return QueryResult
]=]
function Route:query()
	return self:__iter()
end

--[=[
	@method send
	@within Route
	
	Sends data to all clients or to specific recipients from the Route's identifier.

	By default, [Route:send] will send the data to all Clients. You can specify which
	Clients to receive the data by chaining [SendRequest:to] and passing
	``{ Player }``, ``Player``, or ``Route.Server``.

	See [Sending Data](/docs/getting-started/routes#sending) for more information.
]=]
function Route:send(...)
	local packet = {} :: OutgoingPacket
	packet.data = { ... }
	packet.recipient = isClient and Bridge.server or self._currentPlayers
	-- Identifier and Channel are assigned when queuing to the Bridge

	table.insert(self._outgoingQueue, packet)

	local sendRequest = {}
	SendRequest._outgoingQueue = self._outgoingQueue
	SendRequest._position = #self._outgoingQueue
	setmetatable(sendRequest, SendRequest)

	return sendRequest
end

--[=[
	@method _queuePackets
	@within Route
	@private
	
	Processes the Route's internal queue and sends it to the supplied Bridge.
	Doing this will reset the internal queue.
]=]
function Route:_queuePackets(bridge: Bridge)
	local channel = self._configuration.Channel or "Reliable"

	local queue = self._outgoingQueue :: { OutgoingPacket }
	self._outgoingQueue = {}

	for _, packet in queue do
		-- Implement middleware
		if self._middleware.Outgoing then
			local newData = { self._middleware.Outgoing(table.unpack(packet.data)) }
			if #newData > 0 then
				packet.data = newData
			else
				continue
			end
		end

		packet.identifier = self._identifier
		packet.channel = channel :: "Reliable" | "Unreliable"

		-- Typecheck recipients
		if bridge:_getContext() == "client" then
			if packet.recipient ~= Bridge.server then
				warn("Clients can only send to Net.Server")
				continue
			end
		elseif bridge:_getContext() == "server" then
			if not bridge:_isPlayer(packet.recipient) then
				if typeof(packet.recipient) == "table" then
					for _, player in packet.recipient do
						if not bridge:_isPlayer(player) then
							warn("Attempt to send a table with a non-player instance as a recipient")
							continue
						end
					end
				else
					warn("Attempt to send a non-player instance as a recipient")
					continue
				end
			end
		end

		-- Typecheck identifier
		if typeof(packet.identifier) ~= "buffer" then
			warn("Invalid Identifier")

			continue
		end

		if typeof(packet.recipient) == "string" and packet.recipient ~= Bridge.server then
			warn("Invalid Recipient: must be a player instance or Route.server")
			continue
		end

		table.insert(bridge._outgoingQueue[channel], packet)
	end
end

function Route:_updateSnapshot(bridge)
	local snapshot = bridge:snapshot()[self._configuration.Channel]

	for _, packet in snapshot :: { IncomingPacket } do
		if not self._middleware.Incoming or read(packet.identifier) ~= read(self._identifier) then
			continue
		end

		-- Implement middleware
		local newData = { self._middleware.Incoming(table.unpack(packet.data)) }
		if #newData > 0 then
			packet.data = newData
		end
	end

	self._snapshot = snapshot
	self._currentPlayers = Players:GetPlayers()
end

--[=[
	@method addIncomingMiddleware
	@within Route
	
	Sets a function to be ran on Incoming packets before they are processed.
	For example, this would run after the Client receives a Packet from the Server over the network:
	after calling ``Route:send()`` on the Server and before calling ``Route:query()`` on the Client.

	See [Middleware](/docs/getting-started/middleware) for more information.
]=]
function Route:addIncomingMiddleware(middleware)
	if not middleware or typeof(middleware) ~= "function" then
		error("Middleware should be a function.", 2)
	end

	self._middleware.Incoming = middleware
end

--[=[
	@method addOutgoingMiddleware
	@within Route
	
	Sets a function to be ran on Outgoing packets before they are sent over the network.
	For example, this would run before the Server sends a Packet to the Client over the network:
	after calling ``Route:send()`` on the Server and before the Client ever receives the Packet.

	See [Middleware](/docs/getting-started/middleware) for more information.
]=]
function Route:addOutgoingMiddleware(middleware)
	if not middleware or typeof(middleware) ~= "function" then
		error("Middleware should be a function.", 2)
	end

	self._middleware.Outgoing = middleware
end

--[=[
	@function new
	@within Route
	
	Creates a new Route with a unique identifier, channel, and event.

	:::note
	All Routes with the same Channel will share a single Remote. It's recommended that you run all your
	Net scheduling code on a single event.
	:::

	@param configuration Configuration?
]=]
function Route.new(configuration: Configuration?)
	local self = {}
	setmetatable(self, Route)

	self._configuration = configuration or {} :: Configuration

	-- Validate Channel
	if self._configuration.Channel and not table.find({ "Reliable", "Unreliable" }, self._configuration.Channel) then
		error("Channel should be Reliable or Unreliable.", 2)
	end

	-- Implement default channel
	if not self._configuration.Channel then
		self._configuration.Channel = "Reliable"
	end

	-- Validate Event
	if self._configuration.Event and typeof(self._configuration.Event) ~= "string" then
		error("Event should be a string.", 2)
	end

	self._middleware = {
		Incoming = nil,
		Outgoing = nil,
	}
	self._identifier = Identifier.new()
	self._outgoingQueue = {}
	self._currentPlayers = Players:GetPlayers()
	self._snapshot = {
		Reliable = {},
		Unreliable = {},
	}

	return self
end

--[=[
	@class Loop

	A [Matter Loop](https://matter-ecs.github.io/matter/api/Loop).

	For technical details, if you were to use a custom Loop object or try to integrate this Net Library in a ECS other than Matter,
	the ``Net.start(loop, { Route })`` function uses a similar implementation to ``Net.createHook({ Net })`` internally.

	For more information on this, see [Net.createHook].
]=]

--[=[
	@within Net

	Initializes your Routes by adding middleware to your Matter Loop.
	This ensures that your Routes run between each frame.

	:::note
	Please make sure that the event you set in the Configuration, or the default, is the same index you used for your
	``RunService.Heartbeat`` event in your ``Loop:begin()`` method.

	Your Routes are meant to run on the heartbeat, like most systems. In some cases you may want to run your Routes on different events,
	in this case it is acceptable to change it to a different event.
	:::

	@param loop Loop -- A Matter Loop
	@param routes { Route } -- A table of your Routes
]=]
function start(loop, routes)
	local events = {}
	for _, route in routes do
		local event = route._configuration.Event or "default"

		local exists = events[event]
		if not exists then
			events[event] = {}
		end

		table.insert(events[event], route)
	end

	local bridges = {}
	for event, _ in events do
		bridges[event] = Bridge.new()
	end

	-- Performs queue tasks after each frame finishes
	loop:addMiddleware(function(nextFn, eventName)
		local function networkingMiddleware()
			local bridge = bridges[eventName]
			if not bridge then
				nextFn()
				return
			end

			for _, route in events[eventName] do
				route:_updateSnapshot(bridge)
				route:_queuePackets(bridge)
			end

			-- Middleware runs before/after each frame,
			bridge:step()

			nextFn()
		end

		return networkingMiddleware
	end)

	return
end

--[=[
	@within Net

	This function allows you to run Net scheduling code on your own events.

	When you provide a table of Routes, this function will return another function
	you can call which will step each Route and process it's Packet Queue.

	For example, to run scheduling on the Heartbeat:
	```lua
	local hook = Net.createHook({ Route })
	RunService.Heartbeat:Connect(hook)
	```

	@param routes { Net } -- A table of your Routes
	@return () -> ()
]=]
function createHook(routes)
	local bridge = Bridge.new()

	return function()
		for _, route in routes do
			route:_updateSnapshot(bridge)
			route:_queuePackets(bridge)
		end

		bridge:step()
	end
end

--- @prop server "Net_Server"
--- @within Net
--- A unique identifier used for to identify the Server when sending/querying.

--- @prop Route Route
--- @within Net
--- A uniquely identified Object responsible for handling queries and send requests.

--[=[
	@class Net

	YetAnotherNet is a networking library for Roblox, or rather its a library that wraps around Roblox's RemoteEvents to solve certain issues and provide new API for networking on Roblox.

	Some of the issues this library solves are:
	- Overhead from RemoteEvents
	- Ordering of Networking Events
	- Lack of Type-Checking and Intellisense for working with RemoteEvents

	YetAnotherNet also provides several utilities:
	- Middleware
	- Strict Type-Checking & Auto-completion
	- Simple integration with Hooks
	- Data-driven Design

	You can learn more about how YetAnotherNet works and how to use it by visiting [Getting Started with Routes](/docs/getting-started/routes).
	Or, you can keep reading to learn more about the technical details and design choices that went into creating Net in the [Introduction](/docs/intro).
]=]
return table.freeze({
	server = Bridge.server :: NetServer,
	Route = Route,

	createHook = createHook,
	start = start,
})
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000582</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX9A7E4D6A6B2A4E4084D6C5FEBCFFD84E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Bridge</string>
									<string name="ScriptGuid">{28AB1A74-1FAD-4FFA-B0C3-114E8F0076D9}</string>
									<ProtectedString name="Source"><![CDATA[--!native
local RunService = game:GetService("RunService")

local serdes = require(script.Parent.serdes)
local instance = serdes.Instance
local dictionary = serdes.dictionary

local Identifier = require(script.Parent.Identifier)
export type Identifier = Identifier.Identifier

export type Channel = "Reliable" | "Unreliable"
export type NetServer = "NET_SERVER"

export type IncomingPacket = {
	identifier: Identifier,
	sender: Player | NetServer,
	data: { any },
}

export type IncomingQueue = {
	Reliable: { IncomingPacket },
	Unreliable: { IncomingPacket },
}

export type Recipient = { Player } | Player | NetServer

export type OutgoingPacket = {
	channel: Channel,
	identifier: Identifier,
	recipient: Recipient,
	data: { any },
}

export type OutgoingQueue = {
	Reliable: { OutgoingPacket },
	Unreliable: { OutgoingPacket },
}

type Payload = {
	[Identifier]: { { any } },
}

type ServerPayload = {
	Reliable: Payload,
	Unreliable: Payload,
}

type ClientPayloads = {
	[Player]: {
		Reliable: Payload,
		Unreliable: Payload,
	},
}

export type BridgeImpl = {
	__index: BridgeImpl,

	server: NetServer,
	reliableChannel: RemoteEvent,
	unreliableChannel: UnreliableRemoteEvent,

	_incomingQueue: IncomingQueue,
	_instanceMap: { [number]: Instance },
	_outgoingQueue: OutgoingQueue,
	_snapshot: IncomingQueue,

	step: (self: Bridge) -> (),
	snapshot: (self: Bridge) -> IncomingQueue,

	_getInstanceMapChanges: (self: Bridge) -> { [number]: Instance }?,
	_processIncoming: (
		self: Bridge,
		channel: Channel,
		sender: Player | NetServer,
		package: Payload | buffer,
		instanceMapChanges: {
			[number]: Instance,
		}?
	) -> (),
	_processOutgoingQueue: (self: Bridge) -> (ClientPayloads, ServerPayload),
	_sendPayloads: (self: Bridge, clientPayloads: ClientPayloads, serverPayloads: ServerPayload) -> (),

	_initialize: (self: Bridge) -> (),

	_getContext: (self: Bridge) -> "client" | "server",
	_getRemotes: (self: Bridge) -> (RemoteEvent, UnreliableRemoteEvent),
	_isPlayer: (self: Bridge, player: any) -> boolean,

	new: () -> Bridge,
}

export type Bridge = typeof(setmetatable({}, {} :: BridgeImpl))

--[=[
	@class Bridge

	Bridges are the Transport and SerDes Layer of YetAnotherNet, responsible for
	serializing and deserializing data as well as sending it over the network.

	The Bridge class should only be used internally within the Library, when
	creating behavior identical to hooks, or when performing Unit/Integration Tests.

	The Bridge is structured in a way to enable simple mocking using Jest-Lua.
]=]
local Bridge: BridgeImpl = {} :: BridgeImpl
Bridge.__index = Bridge
Bridge.server = "NET_SERVER"

function Bridge:_getInstanceMapChanges()
	local changes = {}
	local currentMap = instance.getInstanceMap()

	for identifier, _instance in currentMap do
		if self._instanceMap[identifier] ~= _instance then
			changes[identifier] = _instance
			continue
		end
	end

	self._instanceMap = currentMap

	return next(changes) ~= nil and changes or nil
end

--[=[
	@method _sendPayloads
	@within Bridge
	
	Before sending the Payloads over the network, this method will
	attempt to serialize the Payloads into buffers. If the payload
	fails to serialize, it will send the unserialized payload
	instead.
]=]
function Bridge:_sendPayloads(clientPayloads, serverPayload)
	if self:_getContext() == "client" then
		for channel, remote in pairs({ Reliable = self.reliableChannel, Unreliable = self.unreliableChannel }) do
			local n = 0
			for _ in serverPayload[channel] do
				n += 1
			end

			-- Do not send empty payloads
			if n == 0 then
				continue
			end

			local _buffer = dictionary.serialize(serverPayload[channel])
			local instanceMapChanges = self:_getInstanceMapChanges()

			local package: buffer? | { [number]: any } = _buffer
			if not package then
				local newPackage = {}

				-- Buffers as indices get converted to strings
				for identifier, packets in serverPayload[channel] do
					newPackage[Identifier.read(identifier)] = packets
				end

				package = newPackage
			end

			remote:FireServer(_buffer or serverPayload[channel], instanceMapChanges)
		end
	elseif self:_getContext() == "server" then
		for player, payload in clientPayloads do
			for channel, remote in pairs({ Reliable = self.reliableChannel, Unreliable = self.unreliableChannel }) do
				local n = 0
				for _ in payload[channel] do
					n += 1
				end

				-- Do not send empty payloads
				if n == 0 then
					continue
				end

				local _buffer = dictionary.serialize(payload[channel])
				local instanceMapChanges = self:_getInstanceMapChanges()

				local package: buffer? | { [number]: any } = _buffer
				if not package then
					local newPackage = {}

					-- Buffers as indices get converted to strings
					for identifier, packets in payload[channel] do
						newPackage[Identifier.read(identifier)] = packets
					end

					package = newPackage
				end

				remote:FireClient(player, _buffer or payload[channel], instanceMapChanges)
			end
		end
	end
end

local function addPacketToPayload(payload: ServerPayload, packet: OutgoingPacket)
	if not payload[packet.identifier] then
		payload[packet.identifier] = {}
	end

	local data = {}

	for _, value in packet.data do
		table.insert(data, value)
	end

	table.insert(payload[packet.identifier], data)

	return
end

local function updateClientPayload(clientPayloads: ClientPayloads, player: Player, packet: OutgoingPacket)
	if not clientPayloads[player] then
		clientPayloads[player] = {
			Reliable = {},
			Unreliable = {},
		}
	end

	addPacketToPayload(clientPayloads[player][packet.channel], packet)

	return
end

--[=[
	@method _processOutgoingQueue
	@within Bridge
	
	This method will process the OutgoingQueue and pack it into Payloads for
	use in Bride:_sendPayloads()

	@return ClientPayloads, ServerPayload
]=]
function Bridge:_processOutgoingQueue()
	local serverPayload = {
		Reliable = {},
		Unreliable = {},
	} :: ServerPayload
	local clientPayloads = {} :: ClientPayloads

	local snapshot = self._outgoingQueue
	self._outgoingQueue = { Reliable = {}, Unreliable = {} }

	-- Add each packet to it's respective payload
	for channel, package in pairs(snapshot) do
		for _, packet in package do
			if self:_isPlayer(packet.recipient) then
				updateClientPayload(clientPayloads, packet.recipient, packet)
			elseif typeof(packet.recipient) == "table" then
				for _, player in packet.recipient do
					if not self:_isPlayer(player) then
						continue
					end

					updateClientPayload(clientPayloads, player, packet)
				end
			else
				addPacketToPayload(serverPayload[channel], packet)
			end
		end
	end

	return clientPayloads, serverPayload
end

--[=[
	@method snapshot
	@within Bridge
	
	Returns a copy of the snapshot.
	The snapshot is a snapshot of the last frame's IncomingQueue.
]=]
function Bridge:snapshot()
	return self._snapshot
end

--[=[
	@method step
	@within Bridge
	
	This will empty the IncomingQueue and produce a new Snapshot of it, then
	it will process the OutgoingQueue and send the payloads over the network.

	You should only use this function if creating custom scheduling behavior
	similar to the Hooks API, which you should use instead of trying to achieve
	this behavior using the Bridge itself.
]=]
function Bridge:step()
	self._snapshot = table.freeze(self._incomingQueue)
	self._incomingQueue = {
		Reliable = {},
		Unreliable = {},
	}

	local clientPayloads, serverPayloads = self:_processOutgoingQueue()
	self:_sendPayloads(clientPayloads, serverPayloads)
end

--[=[
	@method _processIncoming
	@within Bridge
	@private
	
	This method will process any packages sent over either channel of the Bridge.
	It will attempt to deserialize the package and add it to our IncomingQueue.
]=]
function Bridge:_processIncoming(channel, sender, package, instanceMapChanges)
	if instanceMapChanges then
		for identifier, _instance in instanceMapChanges do
			instance.setIdentifier(identifier, _instance)
			self._instanceMap = instance.getInstanceMap()
		end
	end

	-- Todo: Stricter typechecking for Payload
	local payload: Payload? = typeof(package) == "table" and package or nil
	if not payload and typeof(package) == "buffer" then
		payload = dictionary.deserialize(package)
		if not payload then
			warn("Error when attempting to deserialize package")
			return
		end
	elseif not payload then
		warn("Invalid package sent over network.")
		return
	end

	-- Unpack each packet and add it to the queue
	for identifier, packets in payload :: { [any]: any } do
		if type(identifier) == "string" then
			identifier = Identifier.new(tonumber(identifier))
		end

		for _, data in packets do
			local pos = #self._incomingQueue[channel] + 1

			local packet = {
				identifier = identifier,
				sender = sender,
				data = data,
			}

			table.insert(self._incomingQueue[channel], pos, packet)
		end
	end
end

--[=[
	@method _initialize
	@within Bridge
	@private
	
	Assigns starting values, creates connections for channels, and other initialization work.

	This is intentionally abstracted out of Bridge.new() so we can overwrite Bridge.new()
	during mocking without having to rewrite the contents of this function.
]=]
function Bridge:_initialize()
	self._incomingQueue = { Reliable = {}, Unreliable = {} } :: IncomingQueue
	self._outgoingQueue = { Reliable = {}, Unreliable = {} } :: OutgoingQueue
	self._snapshot = table.freeze({ Reliable = {}, Unreliable = {} }) :: IncomingQueue
	self._instanceMap = instance.getInstanceMap()

	local reliable, unreliable = self:_getRemotes()
	self.reliableChannel = reliable
	self.unreliableChannel = unreliable

	if self:_getContext() == "server" then
		reliable.OnServerEvent:Connect(function(player, package, instanceMapChanges)
			self:_processIncoming("Reliable", player, package, instanceMapChanges)
		end)

		unreliable.OnServerEvent:Connect(function(player, package, instanceMapChanges)
			self:_processIncoming("Unreliable", player, package, instanceMapChanges)
		end)
	elseif self:_getContext() == "client" then
		reliable.OnClientEvent:Connect(function(package, instanceMapChanges)
			self:_processIncoming("Reliable", "NET_SERVER", package, instanceMapChanges)
		end)

		unreliable.OnClientEvent:Connect(function(package, instanceMapChanges)
			self:_processIncoming("Unreliable", "NET_SERVER", package, instanceMapChanges)
		end)
	end
end

--[=[
	@method _getContext
	@within Bridge
	@private
	
	This is a wrapper around RunService:IsServer() and RunService:IsClient()
	to enable us to mock the Click/Server Boundary during Unit Testing.

	@return "client" | "server"
]=]
function Bridge:_getContext()
	return RunService:IsServer() and "server" or RunService:IsClient() and "client"
end

--[=[
	@method _getRemotes
	@within Bridge
	@private
	
	When mocking, we use Mock RemoteEvents instead of actual RemoteEvents,
	this function allows us to replace the Remotes with these Mock RemoteEvents
	without having to rewrite any functionality of the library during mocking.

	@return RemoteEvent, UnreliableRemoveEvent
]=]
function Bridge:_getRemotes()
	-- Fix for typescript
	if not script.Parent:FindFirstChild("Remotes") then
		local folder = Instance.new("Folder")
		folder.Name = "Remotes"
		folder.Parent = script.Parent
	end

	local remotes = script.Parent.Remotes

	local reliableRemote, unreliableRemote = remotes:FindFirstChild("Reliable"), remotes:FindFirstChild("Unreliable")
	if reliableRemote and unreliableRemote then
		return reliableRemote, unreliableRemote
	end

	if self:_getContext() == "server" then
		reliableRemote = Instance.new("RemoteEvent")
		reliableRemote.Name = "Reliable"
		reliableRemote.Parent = remotes

		unreliableRemote = Instance.new("RemoteEvent")
		unreliableRemote.Name = "Unreliable"
		unreliableRemote.Parent = remotes

		return reliableRemote, unreliableRemote
	else
		return remotes:WaitForChild("Reliable"), remotes:WaitForChild("Unreliable")
	end
end

--[=[
	@method _isPlayer
	@within Bridge
	@private
	
	Since we mock the Client/Server Boundary in Unit Tests, we also fake the
	Players in our games with Mock Players. This function allows us to
	switch out the typechecking for Players with typechecking for Mock Players.

	@return boolean
]=]
function Bridge:_isPlayer(player: any)
	return typeof(player) == "Instance" and player:IsA("Player") or false
end

--[=[
	@function new
	@within Bridge
	
	This creates a new Bridge and performs initialization work.

	You should not create or use Bridges in your code unless creating
	custom scheduling behavior similar to hooks. If you can use the
	native Hooks API, it is recommended you do instead of using the Bridge
	directly.

	Creating a new Bridge does not create new Remotes, all Remotes are shared
	by all Bridges. During Mocking, we can change this behavior by overwriting
	the Bridge:_getRemotes() method.

	@return boolean
]=]
function Bridge.new()
	local self = setmetatable({}, Bridge) :: Bridge
	self:_initialize()

	return self
end

return Bridge
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000583</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2AC2A885806A462AA13937B8CC83BA74">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Identifier</string>
									<string name="ScriptGuid">{07A77760-8BCA-4767-AC78-736F21B73DB7}</string>
									<ProtectedString name="Source"><![CDATA[local identifier = require(script.Parent.serdes.datatypes.custom.identifier)
export type Identifier = buffer

local function new(uniquePosition: number?): buffer
	return identifier.serialize(uniquePosition)
end

local function read(_buffer: buffer): number
	return identifier.deserialize(_buffer)
end

return {
	new = new,
	read = read,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000584</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBECF4273E8054FCE960418E19C5E6AB4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">QueryResult</string>
									<string name="ScriptGuid">{F72AEEF7-50C3-4A31-AF8B-920B7CC81D1A}</string>
									<ProtectedString name="Source"><![CDATA[local Bridge = require(script.Parent.Bridge)
type Bridge = Bridge.Bridge

type Recipient = Bridge.Recipient
type IncomingPacket = Bridge.IncomingPacket
type OutgoingPacket = Bridge.OutgoingPacket

type IncomingQueue = Bridge.IncomingQueue
type OutgoingQueue = Bridge.OutgoingQueue

type NetServer = Bridge.NetServer

local Identifier = require(script.Parent.Identifier)
export type Identifier = Identifier.Identifier

local read = Identifier.read

--[=[
	@class QueryResult
	@since v0.4.0

	An iterable object returned as the result of [Net:query] that can filter snapshots
	by Identifier and Senders.

	:::note
	Due to certain limitations with the Luau Type System, iterating over the QueryResult Object
	will not return typed values. In order to fix this, call ``:__iter()`` on the QueryResult Object.

	For example:
	```lua
	for i, sender, ... in net:query():__iter() do
		-- Do something
	end
	```
	:::

	See [Querying Data](/docs/getting-started/routes#querying) for more information.
]=]
type QueryResultImpl<U...> = {
	_snapshot: { IncomingPacket },
	_identifier: Identifier,
	_senders: { Player | NetServer },

	__index: QueryResultImpl<U...>,
	__iter: (self: QueryResult<U...>) -> () -> (number?, (Player | NetServer)?, U...),

	from: (self: QueryResult<U...>, ...(Player | NetServer)) -> QueryResult<U...>,

	new: (snapshot: { IncomingPacket }, identifier: Identifier, senders: { Recipient }?) -> QueryResult<U...>,
}

export type QueryResult<U...> = typeof(setmetatable({}, {} :: QueryResultImpl<U...>))

local QueryResult: QueryResultImpl<...any> = {} :: QueryResultImpl<...any>
QueryResult.__index = QueryResult

--[=[
	@method __iter
	@within QueryResult
	
	Iterating over a QueryResult will return the Packets in the QueryResult's Snapshot that
	match the supplied Senders from [QueryResult:from].

	Usage:
	```lua
	for pos, sender, ... in net:query():from(...senders) do
		-- Do something
	end
	```

	@return number
	@return Player | string
	@return ...any
]=]
function QueryResult:__iter()
	local senders = self._senders
	local identifier = self._identifier

	local snapshot = self._snapshot
	local i = 0

	return function()
		-- Tick for new packet
		i += 1

		local packet = snapshot[i]
		if not packet then
			return
		end

		-- Return all packets if no Senders are supplied, or filter by Senders
		local filterSenders = #senders > 0
		local isSenderAllowed = if filterSenders then table.find(senders, packet.sender) else true

		-- Don't return packet if filtered
		if read(packet.identifier) ~= read(identifier) or not isSenderAllowed then
			return
		end

		return i, packet.sender, unpack(packet.data)
	end
end

--[=[
	@method from
	@within QueryResult
	
	Filters Packets from the QueryResult's Snapshot based on the provided Senders.

	@param senders ...sender -- The Senders to filter
	@return QueryResult
]=]
function QueryResult:from(...)
	local senders = {} :: { { Player } | Player | "NET_SERVER" }

	local params = { ... }
	for _, param in params do
		if typeof(param) == "table" and param.__type ~= "Player" then
			for _, player in param do
				table.insert(senders, player)
			end

			continue
		end

		table.insert(senders, param)
	end
	return self.new(self._snapshot, self._identifier, senders)
end

--[=[
	@function new
	@within QueryResult
	@private

	Creates a new QueryResult with the supplied Snapshot.

	@return QueryResult
]=]
function QueryResult.new(snapshot, identifier, senders)
	return setmetatable({
		_snapshot = snapshot,
		_identifier = identifier,
		_senders = senders or {},
	}, QueryResult)
end

return QueryResult
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000585</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB5F1B73447E7483A805F39EAC9A3DCCB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SendRequest</string>
									<string name="ScriptGuid">{7A6BFAEB-4EF3-48D0-B2E5-93E635F4453F}</string>
									<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local Bridge = require(script.Parent.Bridge)
type Bridge = Bridge.Bridge

type Recipient = Bridge.Recipient
type IncomingPacket = Bridge.IncomingPacket
type OutgoingPacket = Bridge.OutgoingPacket

type IncomingQueue = Bridge.IncomingQueue
type OutgoingQueue = Bridge.OutgoingQueue

type NetServer = Bridge.NetServer

local Identifier = require(script.Parent.Identifier)
export type Identifier = Identifier.Identifier

--[=[
	@class SendRequest
	@since v0.4.0

	Allows for modification of queued packets before they're sent.
]=]
type SendRequestImpl = {
	_outgoingQueue: { OutgoingPacket },
	_position: number,

	__index: SendRequestImpl,

	to: (self: SendRequest, recipient: Recipient) -> (),
}

export type SendRequest = typeof(setmetatable({}, {} :: SendRequestImpl))

local SendRequest: SendRequestImpl = {} :: SendRequestImpl
SendRequest.__index = SendRequest

--[=[
	@method to
	@within SendRequest

	Modifies the recipients of the packet to the one(s) provided in the parameter.

	@param recipient { Player } | Player | "NET_SERVER"
]=]
function SendRequest:to(recipient: Recipient)
	if RunService:IsRunning() and RunService:IsClient() then
		warn("You should not use the SendRequest:to() method on the Client")
	end

	local position = self._position

	local packet = self._outgoingQueue[position]
	local newPacket = {
		channel = packet.channel,
		identifier = packet.identifier,
		recipient = recipient,
		data = packet.data,
	}

	self._outgoingQueue[position] = newPacket

	return
end

return SendRequest
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000586</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBXABA242B1FC1C497BA4CFFF8452394ABB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">__mocks__</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000587</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX2A3E1BCB9407447DB2ACCFF884E3F4B8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">mockBridge</string>
										<string name="ScriptGuid">{1D6A16E2-C9F5-4D3C-AE27-DC0718536C58}</string>
										<ProtectedString name="Source"><![CDATA[--!nonstrict
local root = script.Parent.Parent
local Bridge = require(root.Bridge)

local utils = root.__utils__
local mockRemoteEvents = require(utils.mockRemoteEvents)
local mockPlayers = require(utils.mockPlayers)

local ServerRemoteEvent = mockRemoteEvents.ServerRemoteEvent
local ClientRemoteEvent = mockRemoteEvents.ClientRemoteEvent

local n = 0

local mockedModule = table.clone(Bridge)
mockedModule.__index = mockedModule

function mockedModule:_getContext()
	return self.context
end

function mockedModule:_isPlayer(player)
	if table.find(mockPlayers.getAllPlayers(), player) then
		return true
	end

	return false
end

function mockedModule:_getRemotes()
	local identifier = tostring(n)

	if self:_getContext() == "server" then
		local reliable = ServerRemoteEvent.new(identifier, "Reliable")
		local unreliable = ServerRemoteEvent.new(identifier, "Unreliable")
		return reliable, unreliable
	elseif self:_getContext() == "client" then
		local reliable = ClientRemoteEvent.new(self._owner, identifier, "Reliable")
		local unreliable = ClientRemoteEvent.new(self._owner, identifier, "Unreliable")
		return reliable, unreliable
	end

	return
end

function mockedModule.new(context: "client" | "server", owner: any)
	local self = {}
	setmetatable(self, mockedModule)

	self.context = context
	self._owner = owner

	self:_initialize()

	return self
end

export type MockedBridge = typeof(mockedModule)

return function()
	n += 1
	return mockedModule
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000588</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX2010232F2D494ACC90530EFA6A58A132">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">__tests__</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000589</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX6A7CAABA9A8341B68A553B0BDED8F736">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Identifier.test</string>
										<string name="ScriptGuid">{6FD4FB8C-D308-4ABF-A259-B09DCFF5AFE3}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local it = JestGlobals.it

local Identifier = require(script.Parent.Parent.Identifier)

describe("Identifier", function()
	it("Should return unique strings", function()
		local identifierOne = Identifier.new()
		local identifierTwo = Identifier.new()

		expect(identifierOne).never.toEqual(identifierTwo)
	end)

	it("Should have the correct position when a position is given", function()
		local identifierThree = Identifier.new(1)
		local _identifierFour = Identifier.new(2)
		local identifierFive = Identifier.new(1)

		expect(identifierThree).toEqual(identifierFive)
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000058a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX957CD0DBD1FC4AD99B6BF92D8BC63C75">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">QueryResult.test</string>
										<string name="ScriptGuid">{9A0079E3-B234-4E36-AB7F-DB21301B3BBA}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local test = JestGlobals.test
local it = JestGlobals.it

local root = script.Parent.Parent
local QueryResult = require(root.QueryResult)

local utils = root.__utils__
local mockPlayers = require(utils.mockPlayers)

local Identifier = require(root.Identifier)

local identifier = Identifier.new()

describe("QueryResult", function()
	test("When iterating, should return all expected values", function()
		local snapshot = {
			{
				data = { 1, 2, 3 },
				identifier = identifier,
				sender = "NET_SERVER" :: "NET_SERVER",
			},
		}

		local result = QueryResult.new(snapshot, identifier)
		for i, sender, num1, num2, num3 in result do
			expect(i).toEqual(1)
			expect(sender).toEqual("NET_SERVER")
			expect(num1).toEqual(1)
			expect(num2).toEqual(2)
			expect(num3).toEqual(3)
		end
	end)

	test("When calling `from()`, should query for the sender", function()
		local snapshot = {
			{
				data = { 1, 2, 3 },
				identifier = identifier,
				sender = "NET_SERVER" :: "NET_SERVER",
			},
			{
				data = { "a", "b", "c" },
				identifier = identifier,
				sender = mockPlayers.createPlayer(),
			},
		} :: { any }

		local result = QueryResult.new(snapshot, identifier)

		local n = 0
		for i, sender, num1, num2, num3 in result:from("NET_SERVER") do
			n += 1

			expect(i).toEqual(n)
			expect(sender).toEqual("NET_SERVER")
			expect(num1).toEqual(1)
			expect(num2).toEqual(2)
			expect(num3).toEqual(3)
		end
	end)

	it("Should respect it's identifier", function()
		local identifier1 = Identifier.new()
		local identifier2 = Identifier.new()

		local snapshot = {
			{
				data = { 1, 2, 3 },
				identifier = identifier1,
				sender = "NET_SERVER" :: "NET_SERVER",
			},
			{
				data = { "a", "b", "c" },
				identifier = identifier2,
				sender = "NET_SERVER" :: "NET_SERVER",
			},
		} :: { any }

		local result = QueryResult.new(snapshot, identifier1)

		local n = 0
		for i, sender, num1, num2, num3 in result:from("NET_SERVER") do
			n += 1

			expect(i).toEqual(n)
			expect(sender).toEqual("NET_SERVER")
			expect(num1).toEqual(1)
			expect(num2).toEqual(2)
			expect(num3).toEqual(3)
		end
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000058b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8061E9314C9740D486B975F01BB3F58C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">SendRequest.test</string>
										<string name="ScriptGuid">{95210454-B266-4C30-96F0-16176EEE28E3}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local Identifier = require(ReplicatedStorage.Packages.Net.Identifier)
local describe = JestGlobals.describe
local test = JestGlobals.test

local root = script.Parent.Parent
local SendRequest = require(root.SendRequest)

describe("SendRequest", function()
	test("When calling `to()`, should modify the recipient", function()
		local outgoingQueue = {}

		local identifier = Identifier.new()

		local packet = {
			channel = "Reliable",
			data = { 1, 2, 3 },
			identifier = identifier,
			recipient = nil,
		}
		table.insert(outgoingQueue, packet)

		local sendRequest = {
			_outgoingQueue = outgoingQueue,
			_position = #outgoingQueue,
		}
		setmetatable(sendRequest, SendRequest)
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000058c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1FDBA04F3560435FB3CEE517320C467B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Bridge.test</string>
										<string name="ScriptGuid">{3D759935-2C97-470E-BA07-E274CB2BEB12}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local Bridge = require(ReplicatedStorage.Packages.Net.Bridge)
local beforeAll = JestGlobals.beforeAll
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local test = JestGlobals.test
local jest = JestGlobals.jest

local root = script.Parent.Parent
local BridgeModule = root.Bridge

local utils = root.__utils__
local mockPlayers = require(utils.mockPlayers)

local mocks = script.Parent.Parent.__mocks__
local mockBridge = require(mocks.mockBridge)

local Identifier = require(script.Parent.Parent.Identifier)

local MockedBridge

local serverBridge
local clientBridge
local player

local globalIdentifier = Identifier.new()

function queueFakePackets(bridge: any, mockPlayer: any, ...)
	local channel = "Reliable"

	local queue = {
		{
			channel = "Reliable",
			identifier = globalIdentifier,
			recipient = mockPlayer,
			data = { 1, 2, 3 },
		},
		...,
	}

	for _, packet in queue do
		table.insert(bridge._outgoingQueue[channel], packet)
	end
end

describe("Bridge", function()
	beforeAll(function()
		jest.mock(BridgeModule, mockBridge)
		MockedBridge = require(BridgeModule) :: mockBridge.MockedBridge

		player = mockPlayers.createPlayer()
		clientBridge = MockedBridge.new("client", player)

		serverBridge = MockedBridge.new("server")
	end)

	test("Should work across the Client-Server Boundary", function()
		MockedBridge = require(BridgeModule) :: mockBridge.MockedBridge

		queueFakePackets(serverBridge, player)

		serverBridge:step()
		clientBridge:step()

		local snapshot = clientBridge:snapshot()

		expect(snapshot["Reliable"][1]).toEqual({
			data = { 1, 2, 3 },
			identifier = globalIdentifier,
			sender = "NET_SERVER",
		})
	end)

	test("When called, `_processOutgoingQueue` should properly package Client/Server payloads", function()
		MockedBridge = require(BridgeModule) :: mockBridge.MockedBridge

		local identifier = Identifier.new()

		local fakeClientPacket = {
			channel = "Reliable",
			identifier = identifier,
			recipient = serverBridge.server,
			data = { "a", "b", "c" },
		}

		-- Fill the outgoingQueue with fake packets
		queueFakePackets(serverBridge, player, fakeClientPacket)

		local clientPayloads: { [any]: any }, serverPayloads = serverBridge:_processOutgoingQueue()

		-- Check client payloads
		expect(clientPayloads[player].Reliable).toEqual(expect.objectContaining({
			[globalIdentifier] = {
				{ 1, 2, 3 },
			},
		}))

		-- Check server payloads
		expect(serverPayloads.Reliable).toEqual(expect.objectContaining({
			[fakeClientPacket.identifier] = { fakeClientPacket.data },
		}))
	end)

	describe("Should send payloads to their appropriate Channel and Recipient on the Client", function()
		test("Client -> Server", function()
			local identifier = Identifier.new()

			local packet = {
				channel = "Reliable",
				identifier = identifier,
				recipient = Bridge.server,
				data = { "a", "b", "c" },
			} :: Bridge.OutgoingPacket

			-- Add to the queue
			table.insert(clientBridge._outgoingQueue.Reliable, packet)

			-- Process and send payloads
			local clientPayloads, serverPayloads = clientBridge:_processOutgoingQueue()
			clientBridge:_sendPayloads(clientPayloads, serverPayloads)

			-- Find the packet in the queue
			expect(serverBridge._incomingQueue.Reliable).toEqual(expect.arrayContaining({
				{
					identifier = packet.identifier,
					sender = player,
					data = packet.data,
				},
			}))
		end)

		test("Server -> Client", function()
			local identifier = Identifier.new()

			local packet = {
				channel = "Reliable",
				identifier = identifier,
				recipient = player,
				data = { "a", "b", "c" },
			} :: Bridge.OutgoingPacket

			-- Add to the queue
			table.insert(serverBridge._outgoingQueue.Reliable, packet)

			-- Process and send payloads
			local clientPayloads, serverPayloads = serverBridge:_processOutgoingQueue()
			serverBridge:_sendPayloads(clientPayloads, serverPayloads)

			-- Find the packet in the queue
			expect(clientBridge._incomingQueue.Reliable).toEqual(expect.arrayContaining({
				{
					identifier = packet.identifier,
					sender = serverBridge.server,
					data = packet.data,
				},
			}))
		end)
	end)

	test("Should not send empty payloads", function()
		-- Clear queue
		clientBridge:step()

		-- Track whether or not the RemoteEvent was fired
		local wasFired = false
		clientBridge.reliableChannel.OnClientEvent:Connect(function()
			wasFired = true
		end)

		-- Send empty payload
		local clientPayloads, serverPayloads = serverBridge:_processOutgoingQueue()
		serverBridge:_sendPayloads(clientPayloads, serverPayloads)

		expect(clientBridge._incomingQueue.Reliable).toEqual({})
		expect(wasFired).toBe(false)
	end)

	describe("Ser/Des Integration", function()
		test("Should provide an Instance map when serializing Instances", function()
			MockedBridge = require(BridgeModule) :: mockBridge.MockedBridge

			local identifier = Identifier.new()

			local instance = Instance.new("Part")

			table.insert(serverBridge._outgoingQueue["Reliable"], {
				channel = "Reliable",
				identifier = identifier,
				recipient = player,
				data = { instance },
			})

			serverBridge:step()
			clientBridge:step()

			expect(clientBridge._instanceMap).toContain(instance)

			local snapshot = clientBridge:snapshot()

			expect(snapshot["Reliable"][1]).toEqual({
				identifier = identifier,
				sender = "NET_SERVER",
				data = { instance },
			})
		end)
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062cb</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9C7F553028CE4481B45A1B0B87B8FCA0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Route.test</string>
										<string name="ScriptGuid">{1C8191C4-156F-436C-96DF-FFD0BE5DFE4E}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")

local Net = require(script.Parent.Parent)
local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local beforeAll = JestGlobals.beforeAll
local afterEach = JestGlobals.afterEach
local beforeEach = JestGlobals.beforeEach
local describe = JestGlobals.describe
local expect = JestGlobals.expect
local test = JestGlobals.test
local jest = JestGlobals.jest

local root = script.Parent.Parent
local BridgeModule = root.Bridge

local utils = root.__utils__
local mockPlayers = require(utils.mockPlayers)

local mocks = script.Parent.Parent.__mocks__
local mockBridge = require(mocks.mockBridge)

local MockedBridge

local serverRoute
local serverHook

local clientRoute
local clientHook
local mockPlayer

local processHooks

describe("Route", function()
	beforeAll(function()
		jest.mock(BridgeModule, mockBridge)

		MockedBridge = require(BridgeModule) :: mockBridge.MockedBridge

		local function createHook(routes: { Net.Route<...any> }, context: "server" | "client", player: any?)
			local bridge = MockedBridge.new(context, player)

			return function()
				for _, route in routes do
					route:_updateSnapshot(bridge)
					route:_queuePackets(bridge)
				end

				bridge:step()
			end
		end

		-- Setup server

		serverRoute = Net.Route.new({
			Channel = "Reliable",
		}) :: Net.Route<number, boolean, string>

		serverHook = createHook({ serverRoute }, "server")

		-- Setup client

		mockPlayer = mockPlayers.createPlayer()

		clientRoute = Net.Route.new({
			Channel = "Reliable",
		}) :: Net.Route<number, boolean, string>
		clientRoute["_identifier"] = serverRoute["_identifier"]

		clientHook = createHook({ clientRoute }, "client", mockPlayer)

		processHooks = function()
			serverHook()
			clientHook()

			-- To account for data being deferred by one frame
			serverHook()
			clientHook()
		end
	end)

	-- Schedule cleanup
	beforeEach(function()
		processHooks()
	end)

	-- Schedule cleanup
	afterEach(function()
		processHooks()
	end)

	test("When calling `:send()`, it should properly queue the packets to it's bridge", function()
		local sendRequest = serverRoute:send(1, true, "Hello, world")
		sendRequest:to(mockPlayer)

		expect(sendRequest._outgoingQueue).toEqual(serverRoute._outgoingQueue)
		expect(sendRequest._outgoingQueue[sendRequest._position]).toEqual({
			recipient = mockPlayer,
			data = { 1, true, "Hello, world" } :: { any },
		})
	end)

	test("When calling `:query()`, it should return a valid QueryResult", function()
		local sendRequest = serverRoute:send(1, true, "Hello, world")
		sendRequest:to(mockPlayer)
		processHooks()

		local queryResult = clientRoute:query()

		expect(queryResult._identifier).toEqual(serverRoute._identifier)
		expect(queryResult._snapshot).toContainEqual({
			identifier = serverRoute._identifier,
			sender = Net.server,
			data = { 1, true, "Hello, world" } :: { any },
		})
	end)

	test("Incoming Middleware should overwrite each packet's data", function()
		clientRoute:addIncomingMiddleware(function(num, bool, str)
			local returnValues = {} :: { any }

			table.insert(returnValues, if typeof(num) ~= "number" then 1 else num)
			table.insert(returnValues, if typeof(bool) ~= "boolean" then true else bool)
			table.insert(returnValues, if typeof(str) ~= "string" then "Hello, world" else str)

			return table.unpack(returnValues)
		end)

		-- Send incorrect values
		local sendRequest = serverRoute:send(false :: any, "Oops" :: any, 1 :: any)
		sendRequest:to(mockPlayer)

		processHooks()

		local queryResult = clientRoute:query()

		expect(queryResult._identifier).toEqual(serverRoute._identifier)
		expect(queryResult._snapshot).toContainEqual({
			identifier = serverRoute._identifier,
			sender = Net.server,
			data = { 1, true, "Hello, world" } :: { any },
		})
	end)

	test("Outgoing Middleware should overwrite each packet's data", function()
		serverRoute:addOutgoingMiddleware(function(num, bool, str)
			local returnValues = {} :: { any }

			table.insert(returnValues, if typeof(num) ~= "number" then 1 else num)
			table.insert(returnValues, if typeof(bool) ~= "boolean" then true else bool)
			table.insert(returnValues, if typeof(str) ~= "string" then "Hello, world" else str)

			return table.unpack(returnValues)
		end)

		-- Send incorrect values
		local sendRequest = serverRoute:send(false :: any, "Oops" :: any, 1 :: any)
		sendRequest:to(mockPlayer)

		processHooks()

		local queryResult = clientRoute:query()

		expect(queryResult._identifier).toEqual(serverRoute._identifier)
		expect(queryResult._snapshot).toContainEqual({
			identifier = serverRoute._identifier,
			sender = Net.server,
			data = { 1, true, "Hello, world" } :: { any },
		})
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062d3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX412EC4B61D5D437CA091D1E2F72BF3F8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">serdes.test</string>
										<string name="ScriptGuid">{554691A1-9A95-42A9-9104-12856A6B80CA}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local JestGlobals = require(ReplicatedStorage.DevPackages.JestGlobals)
local expect = JestGlobals.expect
local describe = JestGlobals.describe
local test = JestGlobals.test

local root = script.Parent.Parent

local typeToValue = {
	array = { 1, 2, 3 },
	dictionary = {
		a = 1,
		b = 2,
		c = 3,
	},
	identifier = 1,
	boolean = true,
	number = 22,
	string = "Hello, world!",
	BrickColor = BrickColor.Yellow(),
	CFrame = CFrame.new(Vector3.new(20, 40, 60)) * CFrame.fromEulerAnglesXYZ(math.rad(45), math.rad(90), math.rad(180)),
	Color3 = Color3.fromHex("54bbff"),
	DateTime = DateTime.fromUnixTimestampMillis(1686894720000),
	EnumItem = Enum.Genre.Scary,
	Instance = Instance.new("Part"),
	Rect = Rect.new(Vector2.new(10, 20), Vector2.new(40, 80)),
	Region3 = Region3.new(Vector3.zero, Vector3.new(30, 30, 30)),
	Region3int16 = Region3int16.new(Vector3int16.new(0, 0, 0), Vector3int16.new(30, 30, 30)),
	TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut, -1, true, 5),
	UDim = UDim.new(0.5, 10),
	UDim2 = UDim2.new(UDim.new(0.1, 10), UDim.new(0.7, 30)),
	Vector2 = Vector2.new(10, 20),
	Vector2int16 = Vector2int16.new(30, 60),
	Vector3 = Vector3.new(20, 40, 60),
	Vector3int16 = Vector3int16.new(40, 80, 120),
}

local customTests = {
	"buffer",
}

describe("Ser/Des", function()
	describe("Serialization and Deserialization should return exact value", function()
		for _, module in root.serdes.datatypes:GetDescendants() do
			if not module:IsA("ModuleScript") then
				continue
			end

			if not typeToValue[module.Name] then
				if table.find(customTests, module.Name) then
					continue
				end

				test.todo(module.Name)
				continue
			end

			test(module.Name, function()
				local serdes = require(module) :: any

				local _buffer = serdes.serialize(typeToValue[module.Name])
				expect(_buffer).toEqual(expect.any("buffer"))

				local value = serdes.deserialize(_buffer)
				expect(value).toEqual(typeToValue[module.Name])
			end)
		end
	end)

	test("Array should return nil when failing serialization", function()
		local part = Instance.new("Part")
		part.Anchored = true
		part.Position = Vector3.new(0, 3, 0)
		part.Parent = Workspace

		-- RaycastResults have no constructor, meaning we can't deserialize it
		local raycastResult = Workspace:Raycast(Vector3.zero, Vector3.new(0, 5, 0))

		local serdes = require(root.serdes.datatypes.custom.array)
		local array: { any } = {
			1,
			true,
			raycastResult,
		}

		part:Destroy()

		local _buffer = serdes.serialize(array)
		expect(_buffer).toBeNil()
	end)

	test("Array should be able to serialize/deserialize empty arrays", function()
		local serdes = require(root.serdes.datatypes.custom.array)
		local array = {}

		local _buffer = serdes.serialize(array)
		expect(_buffer).toEqual(expect.any("buffer"))

		local value = serdes.deserialize(_buffer)
		expect(value).toEqual(array)
	end)

	test("Dictionary should return nil when failing serialization", function()
		local part = Instance.new("Part")
		part.Anchored = true
		part.Position = Vector3.new(0, 3, 0)
		part.Parent = Workspace

		-- RaycastResults have no constructor, meaning we can't deserialize it
		local raycastResult = Workspace:Raycast(Vector3.zero, Vector3.new(0, 5, 0))

		local serdes = require(root.serdes.datatypes.custom.dictionary)
		local dictionary = {
			a = 1,
			b = true,
			c = raycastResult,
		}

		part:Destroy()

		local _buffer = serdes.serialize(dictionary)
		expect(_buffer).toBeNil()
	end)
end)
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062dd</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX1C687D4519E7477D89E6B4F589C2BBEF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">__utils__</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000058d</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX8A58735C9B7D422AB5B4FB566954DE52">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">mockPlayers</string>
										<string name="ScriptGuid">{9D60CC5E-59B8-4A6F-966E-59B9F191040A}</string>
										<ProtectedString name="Source"><![CDATA[local mockedPlayers = {}

function createPlayer()
	local n = #mockedPlayers + 1
	table.insert(mockedPlayers, {
		__type = "Player",
		Name = `MockPlayer{n}`,
		UserId = -n,
	})

	return mockedPlayers[n]
end

function getAllPlayers()
	return mockedPlayers
end

return {
	createPlayer = createPlayer,
	getAllPlayers = getAllPlayers,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000058e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX19B68D1A5D8B460481789A7F310A951F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">mockRemoteEvents</string>
										<string name="ScriptGuid">{B2CA1F0E-3F7F-402E-9616-DF926268BB13}</string>
										<ProtectedString name="Source"><![CDATA[--!nocheck
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DevPackages = ReplicatedStorage.DevPackages

local Signal = require(DevPackages.Signal)

local clientRemotes = {}
local serverRemotes = {}

local ClientRemoteEvent = {}
ClientRemoteEvent.__index = ClientRemoteEvent

local utils = script.Parent
local mockPlayers = require(utils.mockPlayers)

function ClientRemoteEvent:FireServer(...: any)
	local container = serverRemotes[self._identifier]
	if not container then
		return
	end

	for _, remote in container do
		if remote._channel ~= self._channel then
			return
		end
		remote.OnServerEvent:Fire(self._owner, ...)
	end
end

function ClientRemoteEvent.new(player, identifier: string, channel: "Reliable" | "Unreliable")
	local remote = {}
	setmetatable(remote, ClientRemoteEvent)

	remote._owner = player
	remote._channel = channel
	remote._identifier = identifier
	remote.OnClientEvent = Signal.new()

	local container = clientRemotes[remote._identifier]
	if not container then
		container = {}
		clientRemotes[remote._identifier] = container
	end

	table.insert(container, remote)

	return remote
end

local ServerRemoteEvent = {}
ServerRemoteEvent.__index = ServerRemoteEvent

function ServerRemoteEvent:FireAllClient(...: any)
	for _, player in mockPlayers.getAllPlayers() do
		self:FireClient(player, ...)
	end
end

function ServerRemoteEvent:FireClient(player, ...: any)
	local container = clientRemotes[self._identifier]
	if not container then
		return
	end

	for _, remote in container do
		if remote._owner ~= player or remote._channel ~= self._channel then
			continue
		end

		remote.OnClientEvent:Fire(...)
	end
end

function ServerRemoteEvent.new(identifier: string, channel: "Reliable" | "Unreliable")
	local remote = {}
	setmetatable(remote, ServerRemoteEvent)

	remote._channel = channel
	remote._identifier = identifier
	remote.OnServerEvent = Signal.new()

	local container = serverRemotes[remote._identifier]
	if not container then
		container = {}
		serverRemotes[remote._identifier] = container
	end

	table.insert(container, remote)

	return remote
end

function getAllPlayersRemotes(identifier: string)
	for _, player in mockPlayers.getAllPlayers() do
		getPlayerRemotes(player, identifier)
	end
end

function getPlayerRemotes(player, identifier: string)
	local container = clientRemotes[identifier]
	if not container then
		return {}
	end

	local remotes = {}

	for _, remote in container do
		if remote._owner ~= player then
			continue
		end

		table.insert(remotes, player)
	end

	return remotes
end

function getServerRemotes(identifier: string)
	local container = serverRemotes[identifier]
	if not container then
		return {}
	end

	return container
end

return {
	ClientRemoteEvent = ClientRemoteEvent,
	ServerRemoteEvent = ServerRemoteEvent,

	getPlayerRemotes = getPlayerRemotes,
	getAllPlayersRemotes = getAllPlayersRemotes,
	getServerRemotes = getServerRemotes,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000058f</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX83B4C4B010DE48409BD286ECDC3FCE01">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">serdes</string>
									<string name="ScriptGuid">{3ED39AB1-190E-4040-9FCB-D2C1F776C808}</string>
									<ProtectedString name="Source"><![CDATA[local array = require(script.datatypes.custom.array)
local dictionary = require(script.datatypes.custom.dictionary)

local boolean = require(script.datatypes.primitive.boolean)
local number = require(script.datatypes.primitive.number)
local _string = require(script.datatypes.primitive.string)

local BrickColor = require(script.datatypes.userdata.BrickColor)
local CFrame = require(script.datatypes.userdata.CFrame)
local Color3 = require(script.datatypes.userdata.Color3)
local DateTime = require(script.datatypes.userdata.DateTime)
local EnumItem = require(script.datatypes.userdata.EnumItem)
local Instance = require(script.datatypes.userdata.Instance)
local Rect = require(script.datatypes.userdata.Rect)
local Region3 = require(script.datatypes.userdata.Region3)
local Region3int16 = require(script.datatypes.userdata.Region3int16)
local TweenInfo = require(script.datatypes.userdata.TweenInfo)
local UDim = require(script.datatypes.userdata.UDim)
local UDim2 = require(script.datatypes.userdata.UDim2)
local Vector2 = require(script.datatypes.userdata.Vector2)
local Vector2int16 = require(script.datatypes.userdata.Vector2int16)
local Vector3 = require(script.datatypes.userdata.Vector3)
local Vector3int16 = require(script.datatypes.userdata.Vector3int16)

return {
	array = array,
	dictionary = dictionary,

	boolean = boolean,
	number = number,
	string = _string,

	BrickColor = BrickColor,
	CFrame = CFrame,
	Color3 = Color3,
	DateTime = DateTime,
	EnumItem = EnumItem,
	Instance = Instance,
	Rect = Rect,
	Region3 = Region3,
	Region3int16 = Region3int16,
	TweenInfo = TweenInfo,
	UDim = UDim,
	UDim2 = UDim2,
	Vector2 = Vector2,
	Vector2int16 = Vector2int16,
	Vector3 = Vector3,
	Vector3int16 = Vector3int16,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006291</UniqueId>
								</Properties>
								<Item class="Folder" referent="RBX65C045E9963D4DA4BE02843242C17A6B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<string name="Name">datatypes</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006292</UniqueId>
									</Properties>
									<Item class="Folder" referent="RBXE791DCF182D044A5AB229149408DDE2F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">custom</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006293</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="RBXC463AA78AE4D4BB48938CE79EE4C7D43">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">array</string>
												<string name="ScriptGuid">{6F2737FF-DDE3-440C-8264-49A6A98B7BF7}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local root = script.Parent.Parent.Parent

local utilities = require(root.utilities)
local deserializeBuffer = utilities.deserializeBuffer
local getSerDes = utilities.getSerDes
local isArray = utilities.isArray

--[[
	Structure of Array Buffers:

	Buffer {
		type: u8, -- Type of the Buffer (Array)
		size: u32, -- Size of the Array Buffer

		-- Then the sub-buffers
		...

		type: u8,
		size: u32?,
		buffer,
	}

	type: u8
	The type slice of the Buffer is a u8 that acts as an identifier
	for each Datatype. These will be hardcoded into the library in
	each Datatype's respective module.

	size: u32?
	This is a slice that will only be written to the Buffer if the
	type is Dynamic as we cannot hardcode the size in the library.
	This allows us to know where the buffer is when packed into
	a parent buffer.

	buffer
	This is the sub-buffer for the given Datatype that contains
	our data. The type and size slices will be used to deserialize
	this buffer to extract the data at runtime.
]]

local function serialize(array: { any }): buffer?
	local buffers = {}

	local sum = 0

	-- Serialize each value in array
	for i, value in array do
		-- Get the type, accounting for array and dictionary types (and other custom types)
		local _type = typeof(value)
		if _type == "table" then
			_type = isArray(value) and "array" or "dictionary"
		end

		local serdes = getSerDes(_type)
		if not serdes then
			warn(`Cannot serialize type {_type} when serializing Array value`)
			return
		end

		local _buffer = serdes.serialize(value)
		if not _buffer then
			return
		end

		local length = buffer.len(_buffer)
		sum += length

		local idBuffer = buffer.create(1)
		buffer.writeu8(idBuffer, 0, serdes.id)
		sum += buffer.len(idBuffer)

		local sizeBuffer
		if serdes.size ~= length then
			sizeBuffer = buffer.create(4)
			buffer.writeu32(sizeBuffer, 0, length)
			sum += buffer.len(sizeBuffer)
		end

		buffers[i] = {
			type = idBuffer,
			size = sizeBuffer,
			buffer = _buffer,
		}
	end

	local _buffer = buffer.create(sum)
	local cursor = 0

	for _, _buffers in buffers do
		buffer.copy(_buffer, cursor, _buffers.type)
		cursor += buffer.len(_buffers.type)

		if _buffers.size then
			buffer.copy(_buffer, cursor, _buffers.size)
			cursor += buffer.len(_buffers.size)
		end

		buffer.copy(_buffer, cursor, _buffers.buffer)
		cursor += buffer.len(_buffers.buffer)
	end

	return _buffer
end

local function deserialize(_buffer: buffer): { any }
	local array = {}

	if buffer.len(_buffer) == 0 then
		return array
	end

	local cursor = 0
	local i = 0

	repeat
		i += 1
		local value, cursorPosition = deserializeBuffer(_buffer, cursor)
		cursor = cursorPosition
		array[i] = value
	until cursor == buffer.len(_buffer)

	return array
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 1,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006294</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX348E29A9B6754F5595D0F3B465F5659D">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">dictionary</string>
												<string name="ScriptGuid">{88814152-D44C-4FE0-90D9-91B0AAA9C2E7}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local root = script.Parent.Parent.Parent

local utilities = require(root.utilities)
local deserializeBuffer = utilities.deserializeBuffer
local getSerDes = utilities.getSerDes
local isArray = utilities.isArray

--[[
	Structure of Dictionary Buffers:

	Buffer {
		type: u8, -- Type of the Buffer (Dictionary)
		size: u32, -- Size of the Dictionary Buffer

		-- Then the sub-buffers
		...

		-- Key
		type: u8,
		size: u32?,
		buffer,

		-- Index
		type: u8,
		size: u32?,
		buffer,
	}

	type: u8
	The type slice of the Buffer is a u8 that acts as an identifier
	for each Datatype. These will be hardcoded into the library in
	each Datatype's respective module.

	size: u32?
	This is a slice that will only be written to the Buffer if the
	type is Dynamic as we cannot hardcode the size in the library.
	This allows us to know where the buffer is when packed into
	a parent buffer.

	buffer
	This is the sub-buffer for the given Datatype that contains
	our data. The type and size slices will be used to deserialize
	this buffer to extract the data at runtime.
]]

local function serialize(dictionary: { [any]: any }): buffer?
	local buffers = {}

	local sum = 0

	-- Serialize each value in array
	for key, value in dictionary do
		local _type = typeof(value)
		if _type == "table" then
			_type = isArray(value) and "array" or "dictionary"
		end

		local valueSerdes = getSerDes(_type)
		if not valueSerdes then
			warn(`Cannot serialize type {_type} when serializing Dictionary Value`)
			return
		end

		local valueBuffer = valueSerdes.serialize(value)
		if not valueBuffer then
			return
		end

		local length = buffer.len(valueBuffer)
		sum += length

		local idBuffer = buffer.create(1)
		buffer.writeu8(idBuffer, 0, valueSerdes.id)
		sum += buffer.len(idBuffer)

		local sizeBuffer
		if valueSerdes.size ~= length then
			sizeBuffer = buffer.create(4)
			buffer.writeu32(sizeBuffer, 0, length)
			sum += buffer.len(sizeBuffer)
		end

		local keyType = typeof(key)
		if keyType == "table" then
			keyType = isArray(key) and "array" or "dictionary"
		end

		local keySerdes = getSerDes(keyType)
		if not keySerdes then
			warn(`Cannot serialize type {_type} when serializing Dictionary Key`)
			return
		end

		local keyBuffer = keySerdes.serialize(key)
		if not keyBuffer then
			return
		end

		local keyLength = buffer.len(keyBuffer)
		sum += keyLength

		local keyTypeBuffer = buffer.create(1)
		buffer.writeu8(keyTypeBuffer, 0, keySerdes.id)
		sum += buffer.len(keyTypeBuffer)

		local keySizeBuffer
		if keySerdes.size ~= keyLength then
			keySizeBuffer = buffer.create(4)
			buffer.writeu32(keySizeBuffer, 0, keyLength)
			sum += buffer.len(keySizeBuffer)
		end

		buffers[key] = {
			key = {
				type = keyTypeBuffer,
				size = keySizeBuffer,
				buffer = keyBuffer,
			},
			value = {
				type = idBuffer,
				size = sizeBuffer,
				buffer = valueBuffer,
			},
		}
	end

	local _buffer = buffer.create(sum)
	local cursor = 0

	for _, _buffers in buffers do
		local key = _buffers.key
		buffer.copy(_buffer, cursor, key.type)
		cursor += buffer.len(key.type)

		if key.size then
			buffer.copy(_buffer, cursor, key.size)
			cursor += buffer.len(key.size)
		end

		buffer.copy(_buffer, cursor, key.buffer)
		cursor += buffer.len(key.buffer)

		local value = _buffers.value
		buffer.copy(_buffer, cursor, value.type)
		cursor += buffer.len(value.type)

		if value.size then
			buffer.copy(_buffer, cursor, value.size)
			cursor += buffer.len(value.size)
		end

		buffer.copy(_buffer, cursor, _buffers.value.buffer)
		cursor += buffer.len(_buffers.value.buffer)
	end

	return _buffer
end

local function deserialize(_buffer: buffer): { [any]: any }
	local dictionary = {}

	local cursor = 0
	local i = 0

	repeat
		i += 1

		local key, cursorPosition = deserializeBuffer(_buffer, cursor)
		cursor = cursorPosition

		local value, _cursorPosition = deserializeBuffer(_buffer, cursor)
		cursor = _cursorPosition

		dictionary[key] = value
	until cursor == buffer.len(_buffer)

	return dictionary
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 2,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006295</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX265AF0D708A54F96AB014169BD295AC9">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">identifier</string>
												<string name="ScriptGuid">{C75E54C2-951A-4F55-AF9D-86BE09577105}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 2

local nextIdentifier = 1

local function serialize(position: number?): buffer
	if not position then
		position = nextIdentifier
		nextIdentifier += 1
	end

	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writeu16(_buffer, 0, position :: number)

	return _buffer
end

local function deserialize(_buffer: buffer): number
	local position = buffer.readu16(_buffer, 0)
	return position
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 50,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006296</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBX208F7F92614644B59F01DD181CA7A3DD">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">primitive</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006297</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="RBX0F710C09F08F436987683F13E3CAE045">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">boolean</string>
												<string name="ScriptGuid">{A67FFBDE-F547-4A5F-92BA-54F9C8583871}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 1

local map = {
	[true] = 1,
	[false] = 0,
}

local function serialize(bool: boolean?): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writei8(_buffer, 0, bool and map[bool] or -1)

	return _buffer
end

local function deserialize(_buffer: buffer): boolean?
	local number = buffer.readi8(_buffer, 0)
	return if number == 1 then true elseif number == 0 then false else nil
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,

	id = 3,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006298</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXD6519D452D38489D8C1BFF25EDD03A19">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">buffer</string>
												<string name="ScriptGuid">{43AB92DA-8AFA-4318-B5DA-607E568FEF6C}</string>
												<ProtectedString name="Source"><![CDATA[--!native

--[[
    This exists purely to add support for buffers into
    Arrays, Dictionaries, and other custom types which may
    contain a buffer.

    Instead of defining unique behavior for buffers, this
    module allows us to use the prexisting framework for
    serializing/deserializing datatypes for buffers.
]]

local function serialize(_buffer: buffer): buffer
	return _buffer
end

local function deserialize(_buffer: buffer): buffer
	return _buffer
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 49,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a00006299</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX4DBAB20D9A014CEB8FA0BBC10599C83C">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">number</string>
												<string name="ScriptGuid">{C693D640-3C92-421C-8528-F1CAF7318546}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 4

local function serialize(number: number): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writef32(_buffer, 0, number)
	return _buffer
end

local function deserialize(_buffer: buffer): number
	return buffer.readf32(_buffer, 0)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 4,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a0000629a</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXDA9947918A1A42179A158C27CD3DFE8C">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">string</string>
												<string name="ScriptGuid">{47941242-1A04-4DCC-ABC7-8CF4AFBAA153}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local function serialize(_string: string): buffer
	return buffer.fromstring(_string)
end

local function deserialize(_buffer: buffer): string
	return buffer.tostring(_buffer)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 5,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a0000629b</UniqueId>
											</Properties>
										</Item>
									</Item>
									<Item class="Folder" referent="RBXC789F055DABA4694BA57CF3F9BC97477">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<string name="Name">userdata</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">570c562c1ba24e0606470e9a0000629c</UniqueId>
										</Properties>
										<Item class="ModuleScript" referent="RBX1AA75A061A834DC186AF68493C90DDCE">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">BrickColor</string>
												<string name="ScriptGuid">{5C9638D1-9691-4839-8C69-FAD0C9ADBEF9}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 2

local function serialize(color: BrickColor): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writeu16(_buffer, 0, color.Number)

	return _buffer
end

local function deserialize(_buffer: buffer): BrickColor
	local colorNumber = buffer.readu16(_buffer, 0)
	return BrickColor.new(colorNumber)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 7,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a0000629d</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX071D8DA79A024756872ABA9049BDABBA">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">CFrame</string>
												<string name="ScriptGuid">{A112322D-6457-48AD-BA47-E265D71D27C0}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 48

local function serialize(cframe: CFrame): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = cframe:GetComponents()
	buffer.writef32(_buffer, 0, x)
	buffer.writef32(_buffer, 4, y)
	buffer.writef32(_buffer, 8, z)
	buffer.writef32(_buffer, 12, R00)
	buffer.writef32(_buffer, 16, R01)
	buffer.writef32(_buffer, 20, R02)
	buffer.writef32(_buffer, 24, R10)
	buffer.writef32(_buffer, 28, R11)
	buffer.writef32(_buffer, 32, R12)
	buffer.writef32(_buffer, 36, R20)
	buffer.writef32(_buffer, 40, R21)
	buffer.writef32(_buffer, 44, R22)

	return _buffer
end

local function deserialize(_buffer: buffer): CFrame
	local x = buffer.readf32(_buffer, 0)
	local y = buffer.readf32(_buffer, 4)
	local z = buffer.readf32(_buffer, 8)
	local R00 = buffer.readf32(_buffer, 12)
	local R01 = buffer.readf32(_buffer, 16)
	local R02 = buffer.readf32(_buffer, 20)
	local R10 = buffer.readf32(_buffer, 24)
	local R11 = buffer.readf32(_buffer, 28)
	local R12 = buffer.readf32(_buffer, 32)
	local R20 = buffer.readf32(_buffer, 36)
	local R21 = buffer.readf32(_buffer, 40)
	local R22 = buffer.readf32(_buffer, 44)

	return CFrame.new(x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 9,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a0000629e</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX554C524EF8E14D04A83684B9BB58C153">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Color3</string>
												<string name="ScriptGuid">{1FDEBAB3-79EB-4CF1-988C-868CE9AC4E79}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 12

local function serialize(color: Color3): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writef32(_buffer, 0, color.R)
	buffer.writef32(_buffer, 4, color.G)
	buffer.writef32(_buffer, 8, color.B)

	return _buffer
end

local function deserialize(_buffer: buffer): Color3
	local r = buffer.readf32(_buffer, 0)
	local g = buffer.readf32(_buffer, 4)
	local b = buffer.readf32(_buffer, 8)

	return Color3.new(r, g, b)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 10,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a0000629f</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX6D5E45AD194B4311B1775BD8AA021F3B">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">DateTime</string>
												<string name="ScriptGuid">{32FB946C-1044-4F47-8361-FE14B9E831C9}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 8

local function serialize(dateTime: DateTime): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writef64(_buffer, 0, dateTime.UnixTimestampMillis)
	return _buffer
end

local function deserialize(_buffer: buffer): DateTime
	return DateTime.fromUnixTimestampMillis(buffer.readf64(_buffer, 0))
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 14,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a0</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX2B378FA6876C4A0688198928C3298762">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">EnumItem</string>
												<string name="ScriptGuid">{EF31ECC6-D0F0-4C23-9932-549E9E02E74A}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local function serialize(enumItem: EnumItem): buffer
	local typeBuffer = buffer.fromstring(tostring(enumItem.EnumType))

	local _buffer = buffer.create(1 + buffer.len(typeBuffer))
	buffer.writei8(_buffer, 0, enumItem.Value)
	buffer.copy(_buffer, 1, typeBuffer)

	return _buffer
end

local function deserialize(_buffer: buffer): EnumItem
	local typeBuffer = buffer.create(buffer.len(_buffer) - 1)
	buffer.copy(typeBuffer, 0, _buffer, 1)

	local _type = buffer.tostring(typeBuffer)
	local value = buffer.readi8(_buffer, 0)
	local enumItem

	for _, enum in Enum:GetEnums() do
		for _, _enumItem in enum:GetEnumItems() do
			if tostring(_enumItem.EnumType) == _type and _enumItem.Value == value then
				enumItem = _enumItem
			end
		end
	end

	return enumItem
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 17,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a1</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX29C51BAAA83F4F5BAE9449FA24E8FBB1">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Instance</string>
												<string name="ScriptGuid">{FFE99E19-A016-4D80-98C8-2FB1EFF095A6}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 4

local nextIdentifer = 1
local instanceMap = {}

local function setIdentifier(identifier: number, instance: Instance)
	instanceMap[identifier] = instance
end

local function getInstanceMap()
	return table.freeze(table.clone(instanceMap))
end

local function serialize(instance: Instance): (buffer, number)
	local identifier = table.find(instanceMap, instance) or nextIdentifer
	if identifier == nextIdentifer then
		setIdentifier(identifier, instance)
		nextIdentifer += 1
	end

	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writeu32(_buffer, 0, identifier)

	return _buffer, identifier
end

local function deserialize(_buffer: buffer): Instance
	local identifier = buffer.readu32(_buffer, 0)
	return instanceMap[identifier]
end

return {
	serialize = serialize,
	deserialize = deserialize,
	setIdentifier = setIdentifier,
	getInstanceMap = getInstanceMap,

	size = BUFFER_SIZE,
	id = 22,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a2</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX8A6DFF2E662147D4896C985A03B0C395">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Rect</string>
												<string name="ScriptGuid">{F35F211F-9A61-4803-A12E-CAFEE6F6FF17}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local vector2 = require(script.Parent.Vector2)

local BUFFER_SIZE = vector2.size * 2

local function serialize(rect: Rect): buffer
	local min = vector2.serialize(rect.Min)
	local max = vector2.serialize(rect.Max)

	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.copy(_buffer, 0, min, 0, vector2.size)
	buffer.copy(_buffer, vector2.size, max, 0, vector2.size)

	return _buffer
end

local function deserialize(_buffer: buffer): Rect
	local minBuffer = buffer.create(vector2.size)
	local maxBuffer = buffer.create(vector2.size)

	buffer.copy(minBuffer, 0, _buffer, 0, vector2.size)
	buffer.copy(maxBuffer, 0, _buffer, vector2.size, vector2.size)

	local min = vector2.deserialize(minBuffer)
	local max = vector2.deserialize(maxBuffer)

	return Rect.new(min, max)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 36,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a3</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX06ED68B8A2E74E62805DF5A98C4B8DA7">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Region3</string>
												<string name="ScriptGuid">{FE2C8BDC-83B5-4782-BADD-81C65765E9F3}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local cframe = require(script.Parent.CFrame)
local vector3 = require(script.Parent.Vector3)

local BUFFER_SIZE = cframe.size + vector3.size

local function serialize(region: Region3): buffer
	local _cframe = cframe.serialize(region.CFrame)
	local size = vector3.serialize(region.Size)

	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.copy(_buffer, 0, _cframe, 0, cframe.size)
	buffer.copy(_buffer, cframe.size, size, 0, vector3.size)

	return _buffer
end

local function deserialize(_buffer: buffer): Region3
	local cframeBuffer = buffer.create(cframe.size)
	local sizeBuffer = buffer.create(vector3.size)

	buffer.copy(cframeBuffer, 0, _buffer, 0, cframe.size)
	buffer.copy(sizeBuffer, 0, _buffer, cframe.size, vector3.size)

	local _cframe = cframe.deserialize(cframeBuffer)
	local size = vector3.deserialize(sizeBuffer)

	local min = _cframe.Position - (size / 2)
	local max = _cframe.Position + (size / 2)

	return Region3.new(min, max)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 37,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a4</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX2B1163EDC51749259F74BF8C7345908B">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Region3int16</string>
												<string name="ScriptGuid">{41FB886E-0AD8-446A-841A-1270AC05508B}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local vector3int16 = require(script.Parent.Vector3int16)

local BUFFER_SIZE = vector3int16.size * 2

local function serialize(region: Region3int16): buffer
	local min = vector3int16.serialize(region.Min)
	local max = vector3int16.serialize(region.Max)

	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.copy(_buffer, 0, min, 0, vector3int16.size)
	buffer.copy(_buffer, 6, max, 0, vector3int16.size)

	return _buffer
end

local function deserialize(_buffer: buffer): Region3int16
	local minBuffer = buffer.create(vector3int16.size)
	local maxBuffer = buffer.create(vector3int16.size)

	buffer.copy(minBuffer, 0, _buffer, 0, vector3int16.size)
	buffer.copy(maxBuffer, 0, _buffer, vector3int16.size, vector3int16.size)

	local min = vector3int16.deserialize(minBuffer)
	local max = vector3int16.deserialize(maxBuffer)

	return Region3int16.new(min, max)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 38,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a5</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX1E2CA077843F4819B2BD80C268072E0A">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">TweenInfo</string>
												<string name="ScriptGuid">{C0DB847F-44B4-4002-A07F-082BFC29562B}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local root = script.Parent.Parent.Parent

local enumItem = require(root.datatypes.userdata.EnumItem)
local number = require(root.datatypes.primitive.number)
local boolean = require(root.datatypes.primitive.boolean)
local _string = require(root.datatypes.primitive.string)

local PARTIAL_BUFFER_SIZE = (number.size * 3) + boolean.size

local function serialize(tweenInfo: TweenInfo): buffer
	local time = number.serialize(tweenInfo.Time)
	local delayTime = number.serialize(tweenInfo.DelayTime)
	local repeatCount = number.serialize(tweenInfo.RepeatCount)
	local reverses = boolean.serialize(tweenInfo.Reverses)
	local easingDirection = enumItem.serialize(tweenInfo.EasingDirection)
	local easingStyle = enumItem.serialize(tweenInfo.EasingStyle)

	local _buffer = buffer.create(PARTIAL_BUFFER_SIZE + 8 + buffer.len(easingDirection) + buffer.len(easingStyle))

	buffer.copy(_buffer, 0, time, 0, number.size)
	buffer.copy(_buffer, number.size, delayTime, 0, number.size)
	buffer.copy(_buffer, number.size * 2, repeatCount, 0, number.size)
	buffer.copy(_buffer, number.size * 3, reverses, 0, boolean.size)

	local cursor = PARTIAL_BUFFER_SIZE

	local easingDirectionSizeBuffer = buffer.create(4)
	buffer.writeu32(easingDirectionSizeBuffer, 0, buffer.len(easingDirection))

	buffer.copy(_buffer, cursor, easingDirectionSizeBuffer)
	cursor += buffer.len(easingDirectionSizeBuffer)

	buffer.copy(_buffer, cursor, easingDirection)
	cursor += buffer.len(easingDirection)

	local easingStyleSizeBuffer = buffer.create(4)
	buffer.writeu32(easingStyleSizeBuffer, 0, buffer.len(easingStyle))

	buffer.copy(_buffer, cursor, easingStyleSizeBuffer)
	cursor += buffer.len(easingStyleSizeBuffer)

	buffer.copy(_buffer, cursor, easingStyle)
	cursor += buffer.len(easingStyle)

	return _buffer
end

local function deserialize(_buffer: buffer): TweenInfo
	local timeBuffer = buffer.create(number.size)
	local delayTimeBuffer = buffer.create(number.size)
	local repeatCountBuffer = buffer.create(number.size)
	local reversesBuffer = buffer.create(boolean.size)

	buffer.copy(timeBuffer, 0, _buffer, 0, number.size)
	buffer.copy(delayTimeBuffer, 0, _buffer, number.size, number.size)
	buffer.copy(repeatCountBuffer, 0, _buffer, number.size * 2, number.size)
	buffer.copy(reversesBuffer, 0, _buffer, number.size * 3, boolean.size)

	local cursor = PARTIAL_BUFFER_SIZE

	local easingDirectionSizeBuffer = buffer.create(4)
	buffer.copy(easingDirectionSizeBuffer, 0, _buffer, cursor, 4)
	cursor += 4

	local easingDirectionSize = buffer.readu32(easingDirectionSizeBuffer, 0)

	local easingDirectionBuffer = buffer.create(easingDirectionSize)
	buffer.copy(easingDirectionBuffer, 0, _buffer, cursor, easingDirectionSize)
	cursor += buffer.len(easingDirectionBuffer)

	local easingStyleSizeBuffer = buffer.create(4)
	buffer.copy(easingStyleSizeBuffer, 0, _buffer, cursor, 4)
	cursor += 4

	local easingStyleSize = buffer.readu32(easingStyleSizeBuffer, 0)

	local easingStyleBuffer = buffer.create(easingStyleSize)
	buffer.copy(easingStyleBuffer, 0, _buffer, cursor, easingStyleSize)
	cursor += buffer.len(easingStyleBuffer)

	local time = number.deserialize(timeBuffer)
	local delayTime = number.deserialize(delayTimeBuffer)
	local repeatCount = number.deserialize(repeatCountBuffer)
	local reverses = boolean.deserialize(reversesBuffer)
	local easingDirection = enumItem.deserialize(easingDirectionBuffer) :: Enum.EasingDirection
	local easingStyle = enumItem.deserialize(easingStyleBuffer) :: Enum.EasingStyle

	return TweenInfo.new(time, easingStyle, easingDirection, repeatCount, reverses, delayTime)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 42,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a6</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXD40E986F52404C268BD9CBD6584A0990">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">UDim</string>
												<string name="ScriptGuid">{B5E12740-60F5-481C-AF0C-949CEBE95E34}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 8

local function serialize(udim: UDim): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writef32(_buffer, 0, udim.Scale)
	buffer.writeu32(_buffer, 4, udim.Offset)

	return _buffer
end

local function deserialize(_buffer: buffer): UDim
	local scale = buffer.readf32(_buffer, 0)
	local offset = buffer.readu32(_buffer, 4)

	return UDim.new(scale, offset)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 43,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a7</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX309E19A751C64C6A8C11A9156E0CBBAC">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">UDim2</string>
												<string name="ScriptGuid">{B7F58933-0600-4D64-ABEA-E4A7E07EC1CA}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local udim = require(script.Parent.UDim)

local BUFFER_SIZE = udim.size * 2

local function serialize(_udim: UDim2): buffer
	local x = udim.serialize(_udim.X)
	local y = udim.serialize(_udim.Y)

	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.copy(_buffer, 0, x)
	buffer.copy(_buffer, udim.size, y)

	return _buffer
end

local function deserialize(_buffer: buffer): UDim2
	local xBuffer = buffer.create(udim.size)
	local yBuffer = buffer.create(udim.size)
	buffer.copy(xBuffer, 0, _buffer, 0, udim.size)
	buffer.copy(yBuffer, 0, _buffer, udim.size, udim.size)

	local x = udim.deserialize(xBuffer)
	local y = udim.deserialize(yBuffer)

	return UDim2.new(x, y)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	id = 44,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a8</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX72780809002740B0BA6F890F97EA926E">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Vector2</string>
												<string name="ScriptGuid">{4B7B8F9C-B7B6-43BB-8258-73752D2DCE0D}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 8

local function serialize(vector: Vector2): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writef32(_buffer, 0, vector.X)
	buffer.writef32(_buffer, 4, vector.Y)

	return _buffer
end

local function deserialize(_buffer: buffer): Vector2
	local x = buffer.readf32(_buffer, 0)
	local y = buffer.readf32(_buffer, 4)

	return Vector2.new(x, y)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = 8,
	id = 45,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062a9</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX1FC57CA1E0664747AAD0172A3699B085">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Vector2int16</string>
												<string name="ScriptGuid">{4B39D889-DE04-40F9-ABAC-BC31EEDFB0B5}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 4

local function serialize(vector: Vector2int16): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writei16(_buffer, 0, vector.X)
	buffer.writei16(_buffer, 2, vector.Y)

	return _buffer
end

local function deserialize(_buffer: buffer): Vector2int16
	local x = buffer.readi16(_buffer, 0)
	local y = buffer.readi16(_buffer, 2)

	return Vector2int16.new(x, y)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 46,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062aa</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBX2F99CFD8618243C7B0F9BE59CF585120">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Vector3</string>
												<string name="ScriptGuid">{D1E6B9B2-B1D0-45B3-A150-BEA889CE110D}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 12

local function serialize(vector: Vector3): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writef32(_buffer, 0, vector.X)
	buffer.writef32(_buffer, 4, vector.Y)
	buffer.writef32(_buffer, 8, vector.Z)

	return _buffer
end

local function deserialize(_buffer: buffer): Vector3
	local x = buffer.readf32(_buffer, 0)
	local y = buffer.readf32(_buffer, 4)
	local z = buffer.readf32(_buffer, 8)

	return Vector3.new(x, y, z)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 47,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062ab</UniqueId>
											</Properties>
										</Item>
										<Item class="ModuleScript" referent="RBXBD0D7B78BA99487EA57E4D38885AC22F">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
												<bool name="DefinesCapabilities">false</bool>
												<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
												<Content name="LinkedSource"><null></null></Content>
												<string name="Name">Vector3int16</string>
												<string name="ScriptGuid">{FEBDC6A0-2733-4B07-94B4-4A370C85E158}</string>
												<ProtectedString name="Source"><![CDATA[--!native

local BUFFER_SIZE = 6

local function serialize(vector: Vector3int16): buffer
	local _buffer = buffer.create(BUFFER_SIZE)
	buffer.writei16(_buffer, 0, vector.X)
	buffer.writei16(_buffer, 2, vector.Y)
	buffer.writei16(_buffer, 4, vector.Z)

	return _buffer
end

local function deserialize(_buffer: buffer): Vector3int16
	local x = buffer.readi16(_buffer, 0)
	local y = buffer.readi16(_buffer, 2)
	local z = buffer.readi16(_buffer, 4)

	return Vector3int16.new(x, y, z)
end

return {
	serialize = serialize,
	deserialize = deserialize,

	size = BUFFER_SIZE,
	id = 48,
}
]]></ProtectedString>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062ac</UniqueId>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBXA30BCE78ECB04F2E9592165C0F8A1696">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">utilities</string>
										<string name="ScriptGuid">{82580F3D-D2F5-41FB-9CF6-A7522DA94624}</string>
										<ProtectedString name="Source"><![CDATA[local datatypes = script.Parent.datatypes

local primitives = datatypes.primitive
local userdata = datatypes.userdata
local custom = datatypes.custom

local idsToTypeMap

local function getSerDesById(id: number)
	if not idsToTypeMap then
		idsToTypeMap = {}

		for _, module in datatypes:GetDescendants() do
			if not module:IsA("ModuleScript") then
				continue
			end

			local serdes = require(module) :: any
			idsToTypeMap[serdes.id] = serdes
		end
	end

	return idsToTypeMap[id]
end

local function getSerDes(_type: string)
	-- Nil is grouped with the Boolean primitive
	if _type == "nil" then
		_type = "boolean"
	end

	local module = primitives:FindFirstChild(_type) or userdata:FindFirstChild(_type) or custom:FindFirstChild(_type)
	if module then
		return require(module) :: any
	end

	warn(`Unexpected type {_type} passed`)
	return
end

local function deserializeBuffer(_buffer: buffer, cursor: number): (any, number)
	local idBuffer = buffer.create(1)
	buffer.copy(idBuffer, 0, _buffer, cursor, 1)
	cursor += 1

	local id = buffer.readu8(idBuffer, 0)

	local serdes = getSerDesById(id)
	local size = serdes.size

	if not size then
		local sizeBuffer = buffer.create(4)

		buffer.copy(sizeBuffer, 0, _buffer, cursor, 4)
		cursor += 4

		size = buffer.readu32(sizeBuffer, 0)
	end

	local subBuffer = buffer.create(size)
	buffer.copy(subBuffer, 0, _buffer, cursor, size)
	cursor += size

	return serdes.deserialize(subBuffer), cursor
end

-- Source: https://github.com/jsdotlua/luau-polyfill/blob/main/modules/collections/src/Array/isArray.lua
local function isArray(value)
	if next(value) == nil then
		return true
	end

	local length = #value
	if length == 0 then
		return false
	end

	local count = 0
	local sum = 0
	for key in pairs(value) do
		if typeof(key) ~= "number" then
			return false
		end

		if key % 1 ~= 0 or key < 1 then
			return false
		end

		count += 1
		sum += key
	end

	return sum == (count * (count + 1) / 2)
end

return {
	deserializeBuffer = deserializeBuffer,
	getSerDesById = getSerDesById,
	getSerDes = getSerDes,
	isArray = isArray,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062ad</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX38B21B438E61453784F3A403D2EBE858">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">set-timeout</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000526</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXE2B1528216F4459D9C5AE732E9129110">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{999547CB-BB82-4BAB-A6D2-D19E1E5987BE}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "set-countdown") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "set-interval") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "set-timeout") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "throttle") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "debounce") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000527</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX46064A27B8D247A382D2D7A77F562A3D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">debounce</string>
									<string name="ScriptGuid">{FC2E4576-ABFF-4BA5-AC93-5552F859D9FF}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local setTimeout = TS.import(script, script.Parent, "set-timeout").setTimeout
--[[
	*
	* Creates a debounced function that delays invoking `callback` until after `wait`
	* seconds have elapsed since the last time the debounced function was invoked.
	* The debounced function comes with a `cancel` method to cancel delayed
	* `callback` invocations and a `flush` method to immediately invoke them.
	*
	* Provide `options` to indicate whether `callback` should be invoked on the
	* leading and/or trailing edge of the `wait` timeout. The `callback` is invoked
	* with the last arguments provided to the debounced function. Subsequent calls
	* to the debounced function return the result of the last `callback` invocation.
	*
	* **Note:** If `leading` and `trailing` options are `true`, `callback` is
	* invoked on the trailing edge of the timeout only if the debounced function
	* is invoked more than once during the `wait` timeout.
	*
	* If `wait` is `0` and `leading` is `false`, `callback` invocation is deferred
	* until the next tick, similar to `setTimeout` with a timeout of `0`.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `debounce` and `throttle`.
	*
	* @param callback The function to debounce.
	* @param wait The number of seconds to delay. Defaults to `0`.
	* @param options The options object.
	* @returns The new debounced function.
	* @see https://github.com/lodash/lodash/blob/master/debounce.js/
	* @see https://css-tricks.com/debouncing-throttling-explained-examples/
]]
local function debounce(callback, wait, options)
	if wait == nil then
		wait = 0
	end
	if options == nil then
		options = {}
	end
	local _binding = options
	local leading = _binding.leading
	if leading == nil then
		leading = false
	end
	local trailing = _binding.trailing
	if trailing == nil then
		trailing = true
	end
	local maxWait = _binding.maxWait
	local maxing = maxWait ~= nil
	local lastCallTime = 0
	local lastInvokeTime = 0
	local lastArgs
	local result
	local cancelTimeout
	local invoke = function(time)
		local args = lastArgs
		lastArgs = nil
		lastInvokeTime = time
		result = callback(unpack(args))
		return result
	end
	local timerExpired
	local leadingEdge = function(time)
		-- Reset any `maxWait` timer.
		lastInvokeTime = time
		-- Start the timer for the trailing edge.
		cancelTimeout = setTimeout(timerExpired, wait)
		-- Invoke the leading edge.
		return if leading then invoke(time) else result
	end
	local remainingWait = function(time)
		local timeSinceLastCall = time - lastCallTime
		local timeSinceLastInvoke = time - lastInvokeTime
		local timeWaiting = wait - timeSinceLastCall
		return if maxing then math.min(timeWaiting, maxWait - timeSinceLastInvoke) else timeWaiting
	end
	local shouldInvoke = function(time)
		local timeSinceLastCall = time - lastCallTime
		local timeSinceLastInvoke = time - lastInvokeTime
		-- Either this is the first call, activity has stopped and we're at the
		-- trailing edge, the system time has gone backwards and we're treating
		-- it as the trailing edge, or we've hit the `maxWait` limit.
		return lastCallTime == nil or (timeSinceLastCall >= wait or (timeSinceLastCall < 0 or (maxing and timeSinceLastInvoke >= maxWait)))
	end
	local trailingEdge
	timerExpired = function()
		local time = os.clock()
		if shouldInvoke(time) then
			return trailingEdge(time)
		end
		-- Restart the timer.
		cancelTimeout = setTimeout(timerExpired, remainingWait(time))
	end
	trailingEdge = function(time)
		cancelTimeout = nil
		-- Only invoke if we have `lastArgs` which means `invoke` was
		-- debounced at least once.
		if trailing and lastArgs then
			return invoke(time)
		end
		lastArgs = nil
		return result
	end
	local cancel = function()
		local _result = cancelTimeout
		if _result ~= nil then
			_result()
		end
		cancelTimeout = nil
		lastInvokeTime = 0
		lastArgs = nil
		lastCallTime = 0
	end
	local flush = function()
		return if cancelTimeout == nil then result else trailingEdge(os.clock())
	end
	local pending = function()
		return cancelTimeout ~= nil
	end
	local debounced = function(...)
		local args = { ... }
		local time = os.clock()
		local isInvoking = shouldInvoke(time)
		lastArgs = args
		lastCallTime = time
		if isInvoking then
			if cancelTimeout == nil then
				return leadingEdge(lastCallTime)
			end
			if maxing then
				-- Handle invocations in a tight loop.
				cancelTimeout = setTimeout(timerExpired, wait)
				return invoke(lastCallTime)
			end
		end
		if cancelTimeout == nil then
			cancelTimeout = setTimeout(timerExpired, wait)
		end
		return result
	end
	return setmetatable({
		cancel = cancel,
		flush = flush,
		pending = pending,
	}, {
		__call = function(_, ...)
			local args = { ... }
			return debounced(unpack(args))
		end,
	})
end
return {
	debounce = debounce,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000528</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX23915A216C1D42B8B548C4959084A036">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">set-countdown</string>
									<string name="ScriptGuid">{33557735-C5E2-4204-95ED-D5D0DCD54A94}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
--[[
	*
	* Calls a function every `interval` seconds until the countdown reaches 0.
	* Returns a promise that resolves when the countdown is over. Canceling the
	* promise will stop the countdown.
	* @param callback The callback to call every second.
	* @param countdown The countdown in seconds.
	* @param interval The interval in seconds.
	* @returns A promise that resolves when the countdown reaches 0.
]]
local function setCountdown(callback, countdown, interval)
	if interval == nil then
		interval = 1
	end
	-- Note that 'index' here is 1-based
	return TS.Promise.each(table.create(countdown, 0), function(_, index)
		callback(countdown - (index - 1))
		return TS.Promise.delay(interval)
	end)
end
return {
	setCountdown = setCountdown,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900000529</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX00F44D271CB3436BBF8E63B96C74C86D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">set-interval</string>
									<string name="ScriptGuid">{57BFE802-4414-40B5-9F61-B4A55AC1635C}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
--[[
	*
	* Schedule a callback to be called every `interval` seconds. Returns a
	* function that can be called to stop the timer.
	* @param callback The callback to call every `interval` seconds.
	* @param interval The interval in seconds.
	* @returns A cleanup function.
]]
local function setInterval(callback, interval)
	local timer = 0
	local connection = RunService.Heartbeat:Connect(function(delta)
		timer += delta
		if timer >= interval then
			timer = 0
			callback()
		end
	end)
	return function()
		return connection:Disconnect()
	end
end
return {
	setInterval = setInterval,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000052a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB6D0C969E32E47BC9B992FBD579A9472">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">set-timeout</string>
									<string name="ScriptGuid">{3FA62621-5370-47FA-8843-B903259A994E}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
--[[
	*
	* Schedule a callback to be called once after `timeout` seconds. Returns a
	* function that can be called to stop the timer.
	* @param callback The callback to call after `timeout` seconds.
	* @param timeout The timeout in seconds.
	* @returns A cleanup function.
]]
local function setTimeout(callback, timeout)
	local timer = 0
	local connection
	connection = RunService.Heartbeat:Connect(function(delta)
		timer += delta
		if timer >= timeout then
			connection:Disconnect()
			callback()
		end
	end)
	return function()
		return connection:Disconnect()
	end
end
return {
	setTimeout = setTimeout,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000052b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAEA1CF27E467460E8F334A386BF47C83">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">throttle</string>
									<string name="ScriptGuid">{02175AD9-1E82-4099-9ED9-26AF16181516}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local debounce = TS.import(script, script.Parent, "debounce").debounce
--[[
	*
	* Creates a throttled function that only invokes `callback` at most once per
	* every `wait` seconds. The throttled function comes with a `cancel` method to
	* cancel delayed `callback` invocations and a `flush` method to immediately
	* invoke them.
	*
	* Provide `options` to indicate whether `callback` should be invoked on the
	* leading and/or trailing edge of the `wait` timeout. The `callback` is invoked
	* with the most recent arguments provided to the throttled function. Subsequent
	* calls to the throttled function return the result of the last `callback`
	* invocation.
	*
	* **Note:** If `leading` and `trailing` options are `true`, `callback` is
	* invoked on the trailing edge of the timeout only if the throttled function
	* is invoked more than once during the `wait` timeout.
	*
	* If `wait` is `0` and `leading` is `false`, `callback` invocation is deferred
	* until the next tick, similar to `setTimeout` with a timeout of `0`.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `throttle` and `debounce`.
	*
	* @param callback The function to throttle.
	* @param wait The number of seconds to throttle invocations to. Defaults to `0`.
	* @param options The options object.
	* @returns The new throttled function.
	* @see https://github.com/lodash/lodash/blob/master/throttle.js/
	* @see https://css-tricks.com/debouncing-throttling-explained-examples/
]]
local function throttle(callback, wait, options)
	if wait == nil then
		wait = 0
	end
	if options == nil then
		options = {}
	end
	local _binding = options
	local leading = _binding.leading
	if leading == nil then
		leading = true
	end
	local trailing = _binding.trailing
	if trailing == nil then
		trailing = true
	end
	return debounce(callback, wait, {
		leading = leading,
		trailing = trailing,
		maxWait = wait,
	})
end
return {
	throttle = throttle,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000052c</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX51EE50016A9743BF90E0F7CA4145BADF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">services</string>
							<string name="ScriptGuid">{15F5C530-CC33-4E06-99D4-E9FAB6D45E27}</string>
							<ProtectedString name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">570c562c1ba24e0606470e9a000062d1</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX093FA6E59CFA4862AF9545EEEB2D6AB1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Promise</string>
							<string name="ScriptGuid">{3EB0DEE0-3C8B-4E15-8351-1365F0FC7477}</string>
							<ProtectedString name="Source"><![CDATA[local rbxts_include = script:FindFirstAncestor("rbxts_include")
local node_modules = script:FindFirstAncestor("node_modules")
local include = rbxts_include or (node_modules and node_modules.Parent) or script.Parent

assert(include, "Could not find rbxts_include from " .. script:GetFullName())
assert(include:FindFirstChild("Promise"), "Could not find Promise from " .. include:GetFullName())

return require(include.Promise)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed000060ed</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE3152A305EBC4CABA9C1D1E7D15BFF2E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">RoactCompat</string>
							<string name="ScriptGuid">{4B814D09-4C4F-42AC-95BB-C80E176731D8}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent

local React = require(Packages.React)
local ReactRoblox = require(Packages.ReactRoblox)
local Shared = require(Packages.Shared)

local RoactTree = require(script.RoactTree)

return {
	-- Overlapping contents of public `React` interface
	Component = React.Component,
	PureComponent = React.PureComponent,
	createElement = React.createElement,
	createRef = React.createRef,
	forwardRef = React.forwardRef,
	createContext = React.createContext,
	-- This public interface is aligned but is a deviation in React. It's
	-- necessary to accommodate lua table semantics when merging state
	None = React.None,

	-- Compatibility layer for top-level interface, stands in for `createRoot`
	-- and similar APIs
	mount = RoactTree.mount,
	update = RoactTree.update,
	unmount = RoactTree.unmount,

	-- API compatibility layers to accommodate old interfaces
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	setGlobalConfig = require(script.setGlobalConfig),
	Portal = require(script.Portal),

	-- Compatibility layer for special symbol keys which will be replaced with
	-- reserved prop names in Roact 17
	Ref = "ref",
	-- FIXME: React actually _does_ have a `.Children`, which has different
	-- behavior (none of which overlaps with Roact). Should we keep this as is
	-- and accept that React.Children and RoactCompat.Children will be totally
	-- different things?
	Children = "children",

	-- Event/Change keys for Roact-specific event subscription behavior
	Event = Shared.Event,
	Change = Shared.Change,

	-- Binding interface entry-point for Roact-specific 'bindings' feature
	createBinding = React.createBinding,
	joinBindings = React.joinBindings,

	act = ReactRoblox.act,
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed000060ef</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX034EF61FD7D7427C8DA9C3C399E311D0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Portal</string>
								<string name="ScriptGuid">{6E3EAC35-85B2-460B-A497-6793EF95B473}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local Packages = script.Parent.Parent
local ReactRoblox = require(Packages.ReactRoblox)

local warnOnce = require(script.Parent.warnOnce)

local function PortalComponent(props)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("Roact.Portal", "Please use the createPortal API on ReactRoblox instead")
	end
	return ReactRoblox.createPortal(props.children, props.target)
end

return PortalComponent
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060f0</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF7EE8B78D79D44248A7AFC461742C990">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">RoactTree</string>
								<string name="ScriptGuid">{57341D80-EC22-4EEA-8E0B-4B8F875E811B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect
local ReactRoblox = require(Packages.ReactRoblox)
type RootType = ReactRoblox.RootType

local warnOnce = require(script.Parent.warnOnce)

type RoactHandle = {
	root: RootType,
	key: string | number,
	parent: any, -- TODO: Instance?
}

local function mount(element: any, parent: any, key: string?): RoactHandle
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("mount", "Please use the createRoot API in ReactRoblox")
	end

	if parent ~= nil and typeof(parent) ~= "Instance" then
		error(
			string.format(
				"Cannot mount element (`%s`) into a parent that is not a Roblox Instance (got type `%s`) \n%s",
				(function()
					if element then
						return tostring(element.type)
					end
					return "<unknown>"
				end)(),
				typeof(parent),
				(function()
					if parent ~= nil then
						return inspect(parent)
					end
					return ""
				end)()
			)
		)
	end

	-- Since we use portals to actually parent to the provided parent argument,
	-- the container instance that we provide to createRoot is just a
	-- dummy instance.
	local root
	if _G.__ROACT_17_COMPAT_LEGACY_ROOT__ then
		root = ReactRoblox.createLegacyRoot(Instance.new("Folder"))
	else
		root = ReactRoblox.createRoot(Instance.new("Folder"))
	end
	if parent == nil then
		parent = Instance.new("Folder")
		parent.Name = "Target"
	end
	if key == nil then
		if _G.__ROACT_17_COMPAT_LEGACY_ROOT__ then
			key = "ReactLegacyRoot"
		else
			key = "ReactRoot"
		end
	end

	-- TODO: remove INLINE_ACT flag when all tests are updated to use
	-- `act` explicitly
	if _G.__ROACT_17_INLINE_ACT__ then
		ReactRoblox.act(function()
			root:render(ReactRoblox.createPortal({ [key] = element }, parent))
		end)
	else
		root:render(ReactRoblox.createPortal({ [key] = element }, parent))
	end

	return {
		root = root,
		-- To preserve the same key and portal to the same parent on update, we
		-- need to stash them in the opaque "tree" reference returned by `mount`
		parent = parent,
		key = key :: string,
	}
end

local function update(roactHandle: RoactHandle, element)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("update", "Please use the createRoot API in ReactRoblox")
	end

	local key = roactHandle.key
	local parent = roactHandle.parent
	-- TODO: remove INLINE_ACT flag when all tests are updated to use
	-- `act` explicitly
	if _G.__ROACT_17_INLINE_ACT__ then
		ReactRoblox.act(function()
			roactHandle.root:render(ReactRoblox.createPortal({ [key :: string] = element }, parent))
		end)
	else
		roactHandle.root:render(ReactRoblox.createPortal({ [key :: string] = element }, parent))
	end

	return roactHandle
end

local function unmount(roactHandle: RoactHandle)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("unmount", "Please use the createRoot API in ReactRoblox")
	end

	-- TODO: remove INLINE_ACT flag when all tests are updated to use
	-- `act` explicitly
	if _G.__ROACT_17_INLINE_ACT__ then
		ReactRoblox.act(function()
			roactHandle.root:unmount()
		end)
	else
		roactHandle.root:unmount()
	end
end

return {
	mount = mount,
	update = update,
	unmount = unmount,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060f1</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5C365B85EDB543158E26071A36F90315">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createFragment</string>
								<string name="ScriptGuid">{0FD909F2-D021-4A73-A358-F80A32536DBC}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent.Parent
local React = require(Packages.React)

local warnOnce = require(script.Parent.warnOnce)

return function(elements)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce("createFragment", "Please instead use:\n\tReact.createElement(React.Fragment, ...)")
	end
	return React.createElement(React.Fragment, nil, elements)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060f2</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3807986BF2D4496EB0708966374B96DF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">oneChild</string>
								<string name="ScriptGuid">{0A859E64-5979-4EC6-9602-96AA07AB92F0}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/Roblox/roact/blob/master/src/oneChild.lua
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent.Parent
local React = require(Packages.React)

local warnOnce = require(script.Parent.warnOnce)

local function oneChild(children)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce(
			"oneChild",
			"You likely don't need this at all! If you were assigning children "
				.. "via `React.oneChild(someChildren)`, you can simply use "
				.. "`someChildren` directly."
		)
	end

	-- This behavior is a bit different from upstream, so we're adapting current
	-- Roact's logic (which will unwrap a table with a single member)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most one child, had more than one child.", 2)
	end

	return React.Children.only(child)
end

return oneChild
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060f3</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFDA8847980C347E195ADA7B512CBFFDB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">setGlobalConfig</string>
								<string name="ScriptGuid">{AEF47BFA-C7C0-4A11-87AA-0495A04DE603}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local warnOnce = require(script.Parent.warnOnce)

return function(_config)
	if _G.__DEV__ and _G.__COMPAT_WARNINGS__ then
		warnOnce(
			"setGlobalConfig",
			"Roact 17 uses a `_G.__DEV__` flag to enable development behavior. "
				.. "If you're seeing this warning, you already have it enabled. "
				.. "Please remove any redundant uses of `setGlobalConfig`."
		)
	end
	-- No equivalent behavior can be applied here
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060f4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX454FB42D9E7149E0857DC6FFDC986648">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">warnOnce</string>
								<string name="ScriptGuid">{2A9129E7-DBB2-48AF-9D5B-6D918B68C9FC}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local Packages = script.Parent.Parent
local console = require(Packages.Shared).console

local warnedAbout = {}

local function warnOnce(name: string, message: string)
	if not warnedAbout[name] then
		console.warn(
			"The legacy Roact API '%s' is deprecated, and will be removed " .. "in a future release.\n\n%s",
			name,
			message
		)
	end
	warnedAbout[name] = true
end

return warnOnce
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060f5</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXA6821C9D374246389D4803514A857D6F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ReactReconciler</string>
							<string name="ScriptGuid">{F6B16A13-700A-4486-9BD6-DEAF3C2ACCF9}</string>
							<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/43363e2795393a00fd77312a16d6b80e626c29de/packages/react-reconciler/src/index.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

--!strict
local ReactInternalTypes = require(script.ReactInternalTypes)
local ReactRootTags = require(script.ReactRootTags)

export type Dispatcher = ReactInternalTypes.Dispatcher
export type Fiber = ReactInternalTypes.Fiber
export type FiberRoot = ReactInternalTypes.FiberRoot

-- deviation: explicit export for use in createReactNoop
export type UpdateQueue<T> = ReactInternalTypes.UpdateQueue<T>

export type RootTag = ReactRootTags.RootTag

-- deviation: In order to allow host config to be spliced in, we export
-- this top-level package as an initializer function that returns the configured
-- reconciler module
-- TODO: this effectively disconnects type checking from above to reconciler to below
local function initialize(config): { [string]: any }
	local ReactFiberHostConfig = require(script.ReactFiberHostConfig)
	for name, implementation in config do
		ReactFiberHostConfig[name] = implementation
	end

	return require(script.ReactFiberReconciler)
end

return initialize
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed000060fd</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXDC53E46F9E5946D5A82746773C12FA0B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DebugTracing</string>
								<string name="ScriptGuid">{F952CF1A-7641-4362-A01B-ACED2FAA9030}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/43363e2795393a00fd77312a16d6b80e626c29de/packages/react-reconciler/src/DebugTracing.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent
type Array<T> = { [number]: T }
type Map<K, V> = { [K]: V }
type Object = { [string]: any }
type Function = (any) -> any?
local Shared = require(Packages.Shared)
local console = Shared.console
local exports = {}

-- deviation: hoist log so it's visible
local log
-- deviation: the nucelus emoji `(%c\u{269B}\u{FE0F}%c)` has been replaced with `*`

local ReactFiberLaneModule = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLaneModule.Lane
type Lanes = ReactFiberLaneModule.Lanes
type Wakeable = Shared.Wakeable

local enableDebugTracing = require(Packages.Shared).ReactFeatureFlags.enableDebugTracing

local nativeConsole: Object = console
local nativeConsoleLog: nil | Function = nil

local pendingGroupArgs: Array<any> = {}
-- deviation: adjust starting indea for Lua 1-based arrays
local printedGroupIndex: number = 0

-- deviation: Luau has no built-in way to convert decimal number to binary string
function decimalToBinaryString(decimal: number): string
	local result = ""
	repeat
		local divres = decimal / 2
		local int, frac = math.modf(divres)
		decimal = int
		result = math.ceil(frac) .. result
	until decimal == 0

	local nbZero = 31 - string.len(result)
	return string.rep("0", nbZero) .. result
end

local function formatLanes(laneOrLanes: Lane | Lanes): string
	return "0b"
		-- deviation: Luau has no built-in way to convert decimal number to binary string
		.. decimalToBinaryString(laneOrLanes)
end

local function group(...): ()
	for _, groupArg in { ... } do
		table.insert(pendingGroupArgs, groupArg)
	end
	if nativeConsoleLog == nil then
		nativeConsoleLog = nativeConsole.log
		nativeConsole.log = log
	end
end

local function groupEnd(): ()
	table.remove(pendingGroupArgs, 1)
	while printedGroupIndex > #pendingGroupArgs do
		nativeConsole.groupEnd()
		printedGroupIndex -= 1
	end
	if #pendingGroupArgs == 0 then
		nativeConsole.log = nativeConsoleLog
		nativeConsoleLog = nil
	end
end

function log(...): ()
	if printedGroupIndex < #pendingGroupArgs then
		for i = printedGroupIndex + 1, #pendingGroupArgs do
			local groupArgs = pendingGroupArgs[i]
			nativeConsole.group(groupArgs)
		end
		printedGroupIndex = #pendingGroupArgs
	end
	if typeof(nativeConsoleLog) == "function" then
		(nativeConsoleLog :: any)(...)
	else
		nativeConsole.log(...)
	end
end

-- deviation: remove color styling
local REACT_LOGO_STYLE = ""

local function logCommitStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* commit (%s)", formatLanes(lanes)),
				REACT_LOGO_STYLE,
				"",
				-- deviation: remove style
				""
			)
		end
	end
end
exports.logCommitStarted = logCommitStarted

local function logCommitStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logCommitStopped = logCommitStopped

-- deviation: use raw Lua table
-- const PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;
-- $FlowFixMe: Flow cannot handle polymorphic WeakMaps

-- TODO: restore the color message formatting from upstream
-- local wakeableIDs: Map<Wakeable, number> = {}
-- local wakeableID: number = 0
-- local function getWakeableID(wakeable: Wakeable): number
-- 	if not wakeableIDs[wakeable] ~= nil then
-- 		wakeableIDs[wakeable] =
-- 			(function()
-- 				local result = wakeableID
-- 				wakeableID += 1
-- 				return result
-- 			end)()
-- 	end
-- 	return wakeableIDs[wakeable]
-- end

local function logComponentSuspended(componentName: string, wakeable: Wakeable): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			-- local _id = getWakeableID(wakeable)
			-- deviation: our Wakeable can be a function or a callable table
			-- local _display = wakeable.displayName or wakeable
			log(
				string.format("* %s suspended", componentName)
				-- REACT_LOGO_STYLE,
				-- deviation: remove color styling
				-- "",
				-- id,
				-- display
			)
			wakeable:andThen(function()
				log(
					string.format("* %s resolved", componentName)
					-- REACT_LOGO_STYLE,
					-- deviation: remove color styling
					-- "",
					-- id,
					-- display
				)
			end, function()
				log(
					string.format("* %s rejected", componentName)
					-- REACT_LOGO_STYLE,
					-- deviation: remove color styling
					-- "",
					-- id,
					-- display
				)
			end)
		end
	end
end
exports.logComponentSuspended = logComponentSuspended

local function logLayoutEffectsStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* layout effects (%s)", formatLanes(lanes))
				-- REACT_LOGO_STYLE,
				-- "",
				-- deviation: strip color styling
				-- ""
			)
		end
	end
end
exports.logLayoutEffectsStarted = logLayoutEffectsStarted

local function logLayoutEffectsStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logLayoutEffectsStopped = logLayoutEffectsStopped

local function logPassiveEffectsStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* passive effects (%s)", formatLanes(lanes))
				-- REACT_LOGO_STYLE,
				-- "",
				-- deviation: strip color styling
				-- ""
			)
		end
	end
end
exports.logPassiveEffectsStarted = logPassiveEffectsStarted

local function logPassiveEffectsStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logPassiveEffectsStopped = logPassiveEffectsStopped

local function logRenderStarted(lanes: Lanes): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			group(
				string.format("* render (%s)", formatLanes(lanes))
				-- REACT_LOGO_STYLE,
				-- "",
				-- deviation: strip color styling
				-- ""
			)
		end
	end
end
exports.logRenderStarted = logRenderStarted

local function logRenderStopped(): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			groupEnd()
		end
	end
end
exports.logRenderStopped = logRenderStopped

local function logForceUpdateScheduled(componentName: string, lane: Lane): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			log(
				string.format("* %s forced update (%s)", componentName, formatLanes(lane))
				-- REACT_LOGO_STYLE,
				-- deviation: strip color styling
				-- "",
				-- ""
			)
		end
	end
end
exports.logForceUpdateScheduled = logForceUpdateScheduled

local function logStateUpdateScheduled(componentName: string, lane: Lane, payloadOrAction: any): ()
	if _G.__DEV__ then
		if enableDebugTracing then
			log(
				string.format("* %s updated state (%s)", componentName, formatLanes(lane))
				-- REACT_LOGO_STYLE,
				-- deviation: strip color styling
				-- "",
				-- "",
				-- payloadOrAction
			)
		end
	end
end
exports.logStateUpdateScheduled = logStateUpdateScheduled
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060fe</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC7A762A6F70842FE9BD610D6D489896F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">MaxInts</string>
								<string name="ScriptGuid">{4603CC8A-A162-4D59-9547-CC2A27DC6DAA}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/MaxInts.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

-- // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
-- // Math.pow(2, 30) - 1
-- // 0b111111111111111111111111111111
return { MAX_SIGNED_31_BIT_INT = 1073741823 }
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000060ff</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3280C56B1DFA471CAF867E6AD4609B39">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactCapturedValue</string>
								<string name="ScriptGuid">{6E0ED929-A8FB-40B6-A6DB-C04A7CA6B418}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactCapturedValue.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local getStackByFiberInDevAndProd = require(script.Parent.ReactFiberComponentStack).getStackByFiberInDevAndProd

export type CapturedValue<T> = {
	value: T,
	source: Fiber | nil,
	stack: string | nil,
}

local exports = {}

exports.createCapturedValue = function<T>(value: T, source: Fiber | nil): CapturedValue<T>
	-- If the value is an error, call this function immediately after it is thrown
	-- so the stack is accurate.
	return {
		value = value,
		source = source,
		stack = getStackByFiberInDevAndProd(source),
	}
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006100</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXCEC5D8541B3C45C6A8BFBB57F6BC84E4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactChildFiber.new</string>
								<string name="ScriptGuid">{87D01446-0658-4754-814A-ED389401591A}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactChildFiber.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
type Array<T> = { [number]: T }
type Set<T> = { [T]: boolean }
type Object = { [any]: any }
type Map<K, V> = { [K]: V }
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local describeError = require(Packages.Shared).describeError

local ReactTypes = require(Packages.Shared)
-- deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type ReactElement = ReactTypes.ReactElement<any, any>
type ReactPortal = ReactTypes.ReactPortal

local React = require(Packages.React)
type LazyComponent<T, P> = React.LazyComponent<T, P>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type RoactStableKey = ReactInternalTypes.RoactStableKey
local ReactFiberLanes = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLanes.Lanes

local getComponentName = require(Packages.Shared).getComponentName
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Placement = ReactFiberFlags.Placement
local Deletion = ReactFiberFlags.Deletion
local ReactSymbols = require(Packages.Shared).ReactSymbols
local getIteratorFn = ReactSymbols.getIteratorFn
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local Block = ReactWorkTags.Block
local invariant = require(Packages.Shared).invariant
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- deviation: we do not support string refs
-- local warnAboutStringRefs = ReactFeatureFlags.warnAboutStringRefs
local enableLazyElements = ReactFeatureFlags.enableLazyElements
local enableBlocksAPI = ReactFeatureFlags.enableBlocksAPI

local ReactFiber = require(script.Parent["ReactFiber.new"])
local createWorkInProgress = ReactFiber.createWorkInProgress
local resetWorkInProgress = ReactFiber.resetWorkInProgress
local createFiberFromElement = ReactFiber.createFiberFromElement
local createFiberFromFragment = ReactFiber.createFiberFromFragment
local createFiberFromText = ReactFiber.createFiberFromText
local createFiberFromPortal = ReactFiber.createFiberFromPortal
-- deviation: we do not support string refs
-- local emptyRefsObject =
-- 	require(script.Parent["ReactFiberClassComponent.new"]).emptyRefsObject
-- local ReactFiberHotReloading = require(script.Parent["ReactFiberHotReloading.new"])
-- local isCompatibleFamilyForHotReloading =
-- 	ReactFiberHotReloading.isCompatibleFamilyForHotReloading
-- deviation: we do not support string refs, which removes our use of StrictMode
-- local StrictMode = require(script.Parent.ReactTypeOfMode).StrictMode

local exports = {}

local didWarnAboutMaps
-- deviation: Lua doesn't have built-in generators
-- local didWarnAboutGenerators
-- deviation: we do not support string refs
-- local didWarnAboutStringRefs
local ownerHasKeyUseWarning
local ownerHasFunctionTypeWarning
local warnForMissingKey = function(child: any, returnFiber: Fiber) end

if __DEV__ then
	didWarnAboutMaps = false
	-- deviation: Lua doesn't have built-in generators
	--   didWarnAboutGenerators = false

	-- deviation: we do not support string refs
	-- didWarnAboutStringRefs = {}

	--[[
	Warn if there's no key explicitly set on dynamic arrays of children or
	object keys are not valid. This allows us to keep track of children between
	updates.
  ]]
	ownerHasKeyUseWarning = {}
	ownerHasFunctionTypeWarning = {}

	-- FIXME: This may need to change depending on how we want children to
	-- be passed. Current Roact accepts a table (keys are built-in) and leaves
	-- ordering up to users via LayoutOrder, but if we accept arrays (and attempt
	-- to somehow map them to LayoutOrder??) we'll need keys for stability
	warnForMissingKey = function(child: any, returnFiber: Fiber)
		if child == nil or type(child) ~= "table" then
			return
		end
		if not child._store or child._store.validated or child.key ~= nil then
			return
		end
		invariant(
			child._store ~= nil and type(child._store) == "table",
			"React Component in warnForMissingKey should have a _store. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
		child._store.validated = true

		local componentName = getComponentName(returnFiber.type) or "Component"

		if ownerHasKeyUseWarning[componentName] then
			return
		end
		ownerHasKeyUseWarning[componentName] = true

		console.error(
			"Each child in a list should have a unique "
				.. '"key" prop. See https://reactjs.org/link/warning-keys for '
				.. "more information."
		)
	end
end

local isArray = Array.isArray

function coerceRef(returnFiber: Fiber, current: Fiber | nil, element: ReactElement)
	local mixedRef = element.ref
	if mixedRef ~= nil and type(mixedRef) == "string" then
		-- deviation: we do not support string refs, and will not coerce
		if not element._owner or not element._self or element._owner.stateNode == element._self then
			-- performance: don't get component name unless we have to use it
			local componentName
			if __DEV__ then
				componentName = getComponentName(returnFiber.type) or "Component"
			else
				componentName = "<enable __DEV__ mode for component names>"
			end
			error(
				Error.new(
					string.format(
						'Component "%s" contains the string ref "%s". Support for string refs '
							-- deviation: we removed string ref support ahead of upstream schedule
							.. "has been removed. We recommend using "
							.. "useRef() or createRef() instead. "
							.. "Learn more about using refs safely here: "
							.. "https://reactjs.org/link/strict-mode-string-ref",
						componentName,
						tostring(mixedRef)
					)
				)
			)
		end

		if not element._owner then
			error("Expected ref to be a function or an object returned by React.createRef(), or nil.")
		end

		-- if __DEV__ then
		-- 	-- TODO: Clean this up once we turn on the string ref warning for
		-- 	-- everyone, because the strict mode case will no longer be relevant
		-- 	if
		-- 		(bit32.band(returnFiber.mode, StrictMode) ~= 0 or warnAboutStringRefs)
		-- 		-- We warn in ReactElement.js if owner and self are equal for string refs
		-- 		-- because these cannot be automatically converted to an arrow function
		-- 		-- using a codemod. Therefore, we don't have to warn about string refs again.
		-- 		and not (
		-- 			element._owner
		-- 			and element._self
		-- 			and element._owner.stateNode ~= element._self
		-- 		)
		-- 	then
		-- 		local componentName = getComponentName(returnFiber.type) or "Component"
		-- 		if not didWarnAboutStringRefs[componentName] then
		-- 			if warnAboutStringRefs then
		-- 				console.error(
		-- 					'Component "%s" contains the string ref "%s". Support for string refs '
		-- 						.. "will be removed in a future major release. We recommend using "
		-- 						.. "useRef() or createRef() instead. "
		-- 						.. "Learn more about using refs safely here: "
		-- 						.. "https://reactjs.org/link/strict-mode-string-ref",
		-- 					componentName,
		-- 					mixedRef
		-- 				)
		-- 			else
		-- 				console.error(
		-- 					'A string ref, "%s", has been found within a strict mode tree. '
		-- 						.. "String refs are a source of potential bugs and should be avoided. "
		-- 						.. "We recommend using useRef() or createRef() instead. "
		-- 						.. "Learn more about using refs safely here: "
		-- 						.. "https://reactjs.org/link/strict-mode-string-ref",
		-- 					mixedRef
		-- 				)
		-- 			end
		-- 			didWarnAboutStringRefs[componentName] = true
		-- 		end
		-- 	end
		-- end

		-- if element._owner then
		-- 	local owner: Fiber? = element._owner
		-- 	local inst
		-- 	if owner then
		-- 		local ownerFiber = owner
		-- 		invariant(
		-- 			ownerFiber.tag == ClassComponent,
		-- 			"Function components cannot have string refs. "
		-- 				.. "We recommend using useRef() instead. "
		-- 				.. "Learn more about using refs safely here: "
		-- 				.. "https://reactjs.org/link/strict-mode-string-ref"
		-- 		)
		-- 		inst = ownerFiber.stateNode
		-- 	end
		-- 	invariant(
		-- 		inst,
		-- 		"Missing owner for string ref %s. This error is likely caused by a "
		-- 			.. "bug in React. Please file an issue.",
		-- 		mixedRef
		-- 	)

		-- 	-- deviation: explicitly convert to string
		-- 	local stringRef = tostring(mixedRef)
		-- 	-- Check if previous string ref matches new string ref
		-- 	if
		-- 		current ~= nil
		-- 		and (current :: Fiber).ref ~= nil
		-- 		-- deviation: Lua doesn't support fields on functions, so invert this check
		-- 		-- typeof((current :: Fiber).ref) == 'function' and
		-- 		and typeof((current :: Fiber).ref) ~= "function"
		-- 		-- deviation: this partially inlines the ref type from Fiber to workaround Luau refinement issues
		-- 		and ((current :: Fiber).ref :: { _stringRef: string? })._stringRef
		-- 			== stringRef
		-- 	then
		-- 		return (current :: Fiber).ref
		-- 	end
		-- 	-- deviation: make ref a callable table rather than a function
		-- 	local callableRef = function(value)
		-- 		local refs = inst.__refs
		-- 		if refs == emptyRefsObject then
		-- 			-- This is a lazy pooled frozen object, so we need to initialize.
		-- 			inst.__refs = {}
		-- 			refs = inst.__refs
		-- 		end
		-- 		if value == nil then
		-- 			refs[stringRef] = nil
		-- 		else
		-- 			refs[stringRef] = value
		-- 		end
		-- 	end
		-- 	local ref = setmetatable({}, { __call = callableRef })
		-- 	ref._stringRef = stringRef
		-- 	return ref
		-- else
		-- 	invariant(
		-- 		typeof(mixedRef) == "string",
		-- 		"Expected ref to be a function, a string, an object returned by React.createRef(), or nil."
		-- 	)
		-- 	invariant(
		-- 		element._owner,
		-- 		"Element ref was specified as a string (%s) but no owner was set. This could happen for one of"
		-- 			.. " the following reasons:\n"
		-- 			.. "1. You may be adding a ref to a function component\n"
		-- 			.. "2. You may be adding a ref to a component that was not created inside a component's render method\n"
		-- 			.. "3. You have multiple copies of React loaded\n"
		-- 			.. "See https://reactjs.org/link/refs-must-have-owner for more information.",
		-- 		mixedRef
		-- 	)
		-- end
	end
	return mixedRef
end

-- performance: all uses commented out
-- local function throwOnInvalidObjectType(returnFiber: Fiber, newChild: { [any]: any })
-- 	if returnFiber.type ~= "textarea" then
-- FIXME: Need to adjust this to check for "table: <address>" instead
-- and print appropriately
-- unimplemented("throwOnInvalidObjectType textarea")

-- TODO: This is likely a bigger deviation; in Roact today, we allow
-- tables and use the keys as equivalents to the `key` prop
-- invariant(
--   false,
--   "Objects are not valid as a React child (found: %s). " ..
--     "If you meant to render a collection of children, use an array " ..
--     "instead.",
--   tostring(newChild) == "[object Object]"
--     ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
--     : newChild,
-- )
-- 	end
-- end

local function warnOnFunctionType(returnFiber: Fiber)
	if __DEV__ then
		local componentName = getComponentName(returnFiber.type) or "Component"

		if ownerHasFunctionTypeWarning[componentName] then
			return
		end
		ownerHasFunctionTypeWarning[componentName] = true

		console.error(
			"Functions are not valid as a React child. This may happen if "
				.. "you return a Component instead of <Component /> from render. "
				.. "Or maybe you meant to call this function rather than return it."
		)
	end
end

-- // We avoid inlining this to avoid potential deopts from using try/catch.
-- /** @noinline */
function resolveLazyType<T, P>(lazyComponent: LazyComponent<T, P>): LazyComponent<T, P> | T
	-- performance: hoist non-throwable lines so we eliminate an anon function for the pcall
	-- If we can, let's peek at the resulting type.
	local payload = lazyComponent._payload
	local init = lazyComponent._init
	local ok, result = xpcall(init, describeError, payload)
	if not ok then
		-- Leave it in place and let it throw again in the begin phase.
		return lazyComponent
	end

	return result
end

-- This wrapper function exists because I expect to clone the code in each path
-- to be able to optimize each path individually by branching early. This needs
-- a compiler or we can do it manually. Helpers that don't need this branching
-- live outside of this function.
local function ChildReconciler(shouldTrackSideEffects)
	local function deleteChild(returnFiber: Fiber, childToDelete: Fiber)
		if not shouldTrackSideEffects then
			-- Noop.
			return
		end
		local deletions = returnFiber.deletions
		if deletions == nil then
			returnFiber.deletions = { childToDelete }
			returnFiber.flags = bit32.bor(returnFiber.flags, Deletion)
		else
			table.insert(deletions, childToDelete)
		end
	end

	local function deleteRemainingChildren(returnFiber: Fiber, currentFirstChild: Fiber | nil)
		if not shouldTrackSideEffects then
			-- Noop.
			return nil
		end

		-- TODO: For the shouldClone case, this could be micro-optimized a bit by
		-- assuming that after the first child we've already added everything.
		local childToDelete = currentFirstChild
		while childToDelete ~= nil do
			deleteChild(returnFiber, childToDelete)
			childToDelete = childToDelete.sibling
		end
		return nil
	end

	local function mapRemainingChildren(returnFiber: Fiber, currentFirstChild: Fiber): { [string | number]: Fiber }
		-- Add the remaining children to a temporary map so that we can find them by
		-- keys quickly. Implicit (null) keys get added to this set with their index
		-- instead.
		local existingChildren: { [string | number]: Fiber } = {}

		-- FIXME Luau: Luau doesn't correctly infer in repeat until nil scenarios
		local existingChild: Fiber? = currentFirstChild
		while existingChild ~= nil do
			if existingChild.key ~= nil then
				existingChildren[existingChild.key] = existingChild
			else
				existingChildren[existingChild.index] = existingChild
			end
			existingChild = existingChild.sibling
		end
		return existingChildren
	end

	local function useFiber(fiber: Fiber, pendingProps: any): Fiber
		-- We currently set sibling to nil and index to 0 here because it is easy
		-- to forget to do before returning it. E.g. for the single child case.
		local clone = createWorkInProgress(fiber, pendingProps)
		-- deviation: set index to 1 for 1-indexing
		clone.index = 1
		clone.sibling = nil
		return clone
	end

	local function placeChild(newFiber: Fiber, lastPlacedIndex: number, newIndex: number): number
		newFiber.index = newIndex
		if not shouldTrackSideEffects then
			-- Noop.
			return lastPlacedIndex
		end
		local current = newFiber.alternate
		if current ~= nil then
			local oldIndex = current.index
			if oldIndex < lastPlacedIndex then
				-- This is a move.
				newFiber.flags = bit32.bor(newFiber.flags, Placement)
				return lastPlacedIndex
			else
				-- This item can stay in place.
				return oldIndex
			end
		else
			-- This is an insertion.
			newFiber.flags = bit32.bor(newFiber.flags, Placement)
			return lastPlacedIndex
		end
	end

	local function placeSingleChild(newFiber: Fiber): Fiber
		-- This is simpler for the single child case. We only need to do a
		-- placement for inserting new children.
		if shouldTrackSideEffects and newFiber.alternate == nil then
			newFiber.flags = bit32.bor(newFiber.flags, Placement)
		end
		return newFiber
	end

	local function updateTextNode(returnFiber: Fiber, current: Fiber | nil, textContent: string, lanes: Lanes)
		-- FIXME: Luau narrowing issue
		if current == nil or (current :: Fiber).tag ~= HostText then
			-- Insert
			local created = createFiberFromText(textContent, returnFiber.mode, lanes)
			created.return_ = returnFiber
			return created
		else
			-- Update
			local existing = useFiber(current :: Fiber, textContent)
			existing.return_ = returnFiber
			return existing
		end
	end

	local function updateElement(returnFiber: Fiber, current: Fiber | nil, element: ReactElement, lanes: Lanes): Fiber
		if current ~= nil then
			if
				(current :: Fiber).elementType == element.type
				-- performance: avoid always-false cmp, hot reloading isn't enabled in Roblox yet
				-- Keep this check inline so it only runs on the false path:
				-- or (__DEV__ and isCompatibleFamilyForHotReloading(current, element))
			then
				-- Move based on index
				local existing = useFiber(current :: Fiber, element.props)
				existing.ref = coerceRef(returnFiber, current, element)
				existing.return_ = returnFiber
				if __DEV__ then
					existing._debugSource = element._source
					existing._debugOwner = element._owner
				end
				return existing
			elseif enableBlocksAPI and (current :: Fiber).tag == Block then
				-- The new Block might not be initialized yet. We need to initialize
				-- it in case initializing it turns out it would match.
				-- FIXME Luau: Luau should analyze closure and create union of assignments
				local type_: any = element.type
				if type(type_) == "table" and type_["$$typeof"] == REACT_LAZY_TYPE then
					type_ = resolveLazyType(type_) :: LazyComponent<any, any>
				end
				if type_["$$typeof"] == REACT_BLOCK_TYPE and type_._render == (current :: Fiber).type._render then
					-- Same as above but also update the .type field.
					local existing = useFiber(current :: Fiber, element.props)
					existing.return_ = returnFiber
					existing.type = type_
					if __DEV__ then
						existing._debugSource = element._source
						existing._debugOwner = element._owner
					end
					return existing
				end
			end
		end
		-- Insert
		local created = createFiberFromElement(element, returnFiber.mode, lanes)
		created.ref = coerceRef(returnFiber, current, element)
		created.return_ = returnFiber
		return created
	end

	local function updatePortal(returnFiber: Fiber, current: Fiber | nil, portal: ReactPortal, lanes: Lanes): Fiber
		-- FIXME: type narrowing.
		if
			current == nil
			or (current :: Fiber).tag ~= HostPortal
			or (current :: Fiber).stateNode.containerInfo ~= portal.containerInfo
			or (current :: Fiber).stateNode.implementation ~= portal.implementation
		then
			-- Insert
			local created = createFiberFromPortal(portal, returnFiber.mode, lanes)
			created.return_ = returnFiber
			return created
		else
			-- Update
			local existing = useFiber(current :: Fiber, portal.children or {})
			existing.return_ = returnFiber
			return existing
		end
	end

	local function updateFragment(
		returnFiber: Fiber,
		current: Fiber | nil,
		-- TODO: figure out how we should define our Iterable type
		--   fragment: Iterable<*>,
		fragment: any,
		lanes: Lanes,
		key: nil | string
	): Fiber
		if current == nil or (current :: Fiber).tag ~= Fragment then
			-- Insert
			local created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key)
			created.return_ = returnFiber
			return created
		else
			-- Update
			local existing = useFiber(current :: Fiber, fragment)
			existing.return_ = returnFiber
			return existing
		end
	end

	-- deviation: Roact stable keys - Support Roact's implementation of
	-- stable keys, wherein the key used in the `children` table is used as if it
	-- were a `key` prop. Child order doesn't matter in Roblox, so a vast majority
	-- of existing Roact code used table keys in this way.
	local function assignStableKey(tableKey: any?, newChild: Object): ()
		-- If there's no assigned key in the element, and the table key is valid,
		-- assign it as the element's key.
		-- If the key is a table, convert it to a string.

		-- TODO: Investigate if this is safe; maybe we need to shallow-copy
		-- the object if we have a new key, to preserve immutability, but that cost
		-- may be severe
		if newChild.key == nil then
			-- performance? only call typeof once, and only if first condition is true
			local typeOfTableKey = type(tableKey)
			if typeOfTableKey == "string" or typeOfTableKey == "number" then
				newChild.key = tableKey
			elseif typeOfTableKey == "table" then
				newChild.key = tostring(tableKey)
			end
		end
	end

	local function createChild(
		returnFiber: Fiber,
		newChild: any,
		lanes: Lanes,
		-- deviation: children table key for compat with Roact's stable keys
		tableKey: any?
	): Fiber | nil
		-- performance: early exit for nil newChild since no actions will be taken
		if newChild == nil then
			return nil
		end

		-- performance: avoid repeated calls to typeof, since Luau doesn't optimize
		local typeOfNewChild = type(newChild)

		-- performance: hoist more common ROblox case (non-string/number) first to reduce cmp in hot path
		if typeOfNewChild == "table" then
			-- deviation: Roact stable keys - forward children table key to
			-- child if applicable
			assignStableKey(tableKey, newChild)
			-- performance: avoid repeated indexing to $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				local created = createFiberFromElement(newChild, returnFiber.mode, lanes)
				created.ref = coerceRef(returnFiber, nil, newChild)
				created.return_ = returnFiber
				return created
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				local created = createFiberFromPortal(newChild, returnFiber.mode, lanes)
				created.return_ = returnFiber
				return created
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- deviation: Roact stable keys - Since the table key was
					-- already applied to `newChild` above, we don't need to pass it along
					return createChild(returnFiber, init(payload), lanes)
				end
			end

			-- deviation peformance: this is the equiv of checking for a table, and we already know typeof(newChild) is a table in this branch
			-- if isArray(newChild) or getIteratorFn(newChild) then
			local created = createFiberFromFragment(newChild, returnFiber.mode, lanes, nil)
			created.return_ = returnFiber
			return created

			-- performance deviation: unreachable with the above table check
			-- throwOnInvalidObjectType(returnFiber, newChild)
		end

		if typeOfNewChild == "string" or typeOfNewChild == "number" then
			-- Text nodes don't have keys. If the previous node is implicitly keyed
			-- we can continue to replace it without aborting even if it is not a text
			-- node.
			local created = createFiberFromText(tostring(newChild), returnFiber.mode, lanes)
			created.return_ = returnFiber
			return created
		end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end

		return nil
	end

	local function updateSlot(
		returnFiber: Fiber,
		oldFiber: Fiber | nil,
		newChild: any,
		lanes: Lanes,
		-- deviation: children table key for compat with Roact's stable keys
		tableKey: any?
	): Fiber | nil
		-- performance: early exit for nil newChild since no actions will be taken
		if newChild == nil then
			return nil
		end

		-- Update the fiber if the keys match, otherwise return nil.

		local key = if oldFiber ~= nil then oldFiber.key else nil
		-- performance: avoid repeated calls to typeof since Luau doesn't cache
		local typeOfNewChild = type(newChild)

		if typeOfNewChild == "table" then
			-- deviation: Roact stable keys - forward children table key to
			-- child if applicable
			assignStableKey(tableKey, newChild)
			-- performance: avoid repeated indexing to $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				if newChild.key == key then
					if newChild.type == REACT_FRAGMENT_TYPE then
						return updateFragment(returnFiber, oldFiber, newChild.props.children, lanes, key :: string?)
					end
					return updateElement(returnFiber, oldFiber, newChild, lanes)
				else
					return nil
				end
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				if newChild.key == key then
					return updatePortal(returnFiber, oldFiber, newChild, lanes)
				else
					return nil
				end
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- deviation: Roact stable keys - Since the table key was
					-- already applied to `newChild` above, we don't need to pass it along
					return updateSlot(returnFiber, oldFiber, init(payload), lanes)
				end
			end

			-- deviation peformance: this is the equiv of checking for a table, and we already know typeof(newChild) is a table in this branch
			-- if isArray(newChild) or getIteratorFn(newChild) then
			if key ~= nil then
				return nil
			end

			return updateFragment(returnFiber, oldFiber, newChild, lanes)

			-- performance deviation: unreachable with the above table check
			-- throwOnInvalidObjectType(returnFiber, newChild)
		end

		-- performance: do this compare last to save 2 string cmp in typical Roblox hot path
		if typeOfNewChild == "string" or typeOfNewChild == "number" then
			-- Text nodes don't have keys. If the previous node is implicitly keyed
			-- we can continue to replace it without aborting even if it is not a text
			-- node.
			if key ~= nil then
				return nil
			end
			return updateTextNode(returnFiber, oldFiber, tostring(newChild), lanes)
		end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end

		return nil
	end

	local function updateFromMap(
		existingChildren: Map<string | number, Fiber>,
		returnFiber: Fiber,
		newIdx: number,
		newChild: any,
		lanes: Lanes,
		-- deviation: children table key for compat with Roact's stable keys
		tableKey: any?
	): Fiber | nil
		-- performance: early exit for nil newChild since no actions will be taken
		if newChild == nil then
			return nil
		end

		-- performance: avoid repeated calls to typeof since Luau doesn't cache
		local typeOfNewChild = type(newChild)

		if typeOfNewChild == "table" then
			-- deviation: Roact stable keys - forward children table key to
			-- child if applicable
			assignStableKey(tableKey, newChild)
			local existingChildrenKey
			-- performance: avoid repeated indexing to $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				if newChild.key == nil then
					existingChildrenKey = newIdx
				else
					existingChildrenKey = newChild.key
				end
				local matchedFiber = existingChildren[existingChildrenKey]
				if newChild.type == REACT_FRAGMENT_TYPE then
					return updateFragment(returnFiber, matchedFiber, newChild.props.children, lanes, newChild.key)
				end
				return updateElement(returnFiber, matchedFiber, newChild, lanes)
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				if newChild.key == nil then
					existingChildrenKey = newIdx
				else
					existingChildrenKey = newChild.key
				end
				local matchedFiber = existingChildren[existingChildrenKey]
				return updatePortal(returnFiber, matchedFiber, newChild, lanes)
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- deviation: Roact stable keys - Since the table key was
					-- already applied to `newChild` above, we don't need to pass it along
					return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes)
				end
			end

			-- deviation peformance: this is the equiv of checking for a table, and we already know typeof(newChild) is a table in this branch
			-- if isArray(newChild) or getIteratorFn(newChild) then
			local matchedFiber = existingChildren[newIdx]
			return updateFragment(returnFiber, matchedFiber, newChild, lanes)

			-- performance deviation: unreachable with the above table check
			-- throwOnInvalidObjectType(returnFiber, newChild)
		end

		-- performance: do this compare last, as Roblox won't really support text nodes directly
		if typeOfNewChild == "string" or typeOfNewChild == "number" then
			-- Text nodes don't have keys, so we neither have to check the old nor
			-- new node for the key. If both are text nodes, they match.
			local matchedFiber = existingChildren[newIdx] or nil
			return updateTextNode(returnFiber, matchedFiber, tostring(newChild), lanes)
		end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end

		return nil
	end

	--[[
	Warns if there is a duplicate or missing key
  ]]
	local function warnOnInvalidKey(child: any, knownKeys: Set<string> | nil, returnFiber: Fiber): Set<string> | nil
		if __DEV__ then
			if child == nil or type(child) ~= "table" then
				return knownKeys
			end
			-- performance: avoid repeated indexing to $$typeof
			local childTypeof = child["$$typeof"]
			if childTypeof == REACT_ELEMENT_TYPE or childTypeof == REACT_PORTAL_TYPE then
				warnForMissingKey(child, returnFiber)
				local key = child.key
				if type(key) ~= "string" then
					-- break
				elseif knownKeys == nil then
					knownKeys = {};
					(knownKeys :: Set<string>)[key] = true
				elseif not (knownKeys :: Set<string>)[key] then
					(knownKeys :: Set<string>)[key] = true
				else
					console.error(
						"Encountered two children with the same key, `%s`. "
							.. "Keys should be unique so that components maintain their identity "
							.. "across updates. Non-unique keys may cause children to be "
							.. "duplicated and/or omitted — the behavior is unsupported and "
							.. "could change in a future version.",
						key
					)
				end
			elseif childTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = child._payload
					local init = child._init
					warnOnInvalidKey(init(payload), knownKeys, returnFiber)
				end
			end
		end
		return knownKeys
	end

	local function reconcileChildrenArray(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		newChildren: Array<any>,
		lanes: Lanes
	): Fiber | nil
		-- This algorithm can't optimize by searching from both ends since we
		-- don't have backpointers on fibers. I'm trying to see how far we can get
		-- with that model. If it ends up not being worth the tradeoffs, we can
		-- add it later.

		-- Even with a two ended optimization, we'd want to optimize for the case
		-- where there are few changes and brute force the comparison instead of
		-- going for the Map. It'd like to explore hitting that path first in
		-- forward-only mode and only go for the Map once we notice that we need
		-- lots of look ahead. This doesn't handle reversal as well as two ended
		-- search but that's unusual. Besides, for the two ended optimization to
		-- work on Iterables, we'd need to copy the whole set.

		-- In this first iteration, we'll just live with hitting the bad case
		-- (adding everything to a Map) in for every insert/move.

		-- If you change this code, also update reconcileChildrenIterator() which
		-- uses the same algorithm.

		if __DEV__ then
			-- First, validate keys.
			local knownKeys = nil
			for i, child in newChildren do
				knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber)
			end
		end

		local resultingFirstChild: Fiber | nil = nil
		local previousNewFiber: Fiber | nil = nil

		local oldFiber: Fiber | nil = currentFirstChild
		local lastPlacedIndex = 1
		local newIdx = 1
		local nextOldFiber: Fiber | nil = nil
		-- performance: don't re-evaluate length of newChildren on each iteration through the loop
		local newChildrenCount = #newChildren
		-- deviation: use while loop in place of modified for loop
		while oldFiber ~= nil and newIdx <= newChildrenCount do
			if oldFiber.index > newIdx then
				nextOldFiber = oldFiber
				oldFiber = nil
			else
				nextOldFiber = oldFiber.sibling
			end
			--[[
				ROBLOX DEVIATION: We pass newIdx to createChild to ensure that children are
				assigned a key, assuming the child is not an array itself. We only need to
				pass newIdx if the child is actually a React element. If the child is a
				string or number, a key is never assigned, so we do not pass newIdx as a key.
			]]
			local newFiber
			-- performance: avoid repeated indexing of newChildren to newIdx
			local newChildNewIdx = newChildren[newIdx]
			if newChildNewIdx ~= nil and type(newChildNewIdx) == "table" and newChildNewIdx["$$typeof"] ~= nil then
				newFiber = updateSlot(returnFiber, oldFiber, newChildNewIdx, lanes, newIdx)
			else
				newFiber = updateSlot(returnFiber, oldFiber, newChildNewIdx, lanes)
			end
			if newFiber == nil then
				-- TODO: This breaks on empty slots like nil children. That's
				-- unfortunate because it triggers the slow path all the time. We need
				-- a better way to communicate whether this was a miss or nil,
				-- boolean, undefined, etc.
				if oldFiber == nil then
					oldFiber = nextOldFiber
				end
				break
			end
			if shouldTrackSideEffects then
				-- FIXME Luau: needs type states to understand the continue above
				if oldFiber and (newFiber :: Fiber).alternate == nil then
					-- We matched the slot, but we didn't reuse the existing fiber, so we
					-- need to delete the existing child.
					-- FIXME Luau: needs type states to understand the break above
					deleteChild(returnFiber, oldFiber :: Fiber)
				end
			end
			lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
			if previousNewFiber == nil then
				-- TODO: Move out of the loop. This only happens for the first run.
				resultingFirstChild = newFiber
			else
				-- TODO: Defer siblings if we're not at the right index for this slot.
				-- I.e. if we had nil values before, then we want to defer this
				-- for each nil value. However, we also don't want to call updateSlot
				-- with the previous one.
				(previousNewFiber :: Fiber).sibling = newFiber
			end
			previousNewFiber = newFiber
			oldFiber = nextOldFiber
			-- deviation: increment manually since we're not using a modified for loop
			newIdx += 1
		end

		if newIdx > newChildrenCount then
			-- We've reached the end of the new children. We can delete the rest.
			deleteRemainingChildren(returnFiber, oldFiber)
			return resultingFirstChild
		end

		if oldFiber == nil then
			-- If we don't have any more existing children we can choose a fast path
			-- since the rest will all be insertions.
			-- deviation: use while loop in place of modified for loop
			while newIdx <= newChildrenCount do
				--[[
					ROBLOX DEVIATION: We pass newIdx to createChild to ensure that children are
					assigned a key, assuming the child is not an array itself. We only need to
					pass newIdx if the child is actually a React element. If the child is a
					string or number, a key is never assigned, so we do not pass newIdx as a key.
				]]
				local newFiber
				-- performance: avoid repeated indexing of newChildren to newIdx
				local newChildNewIdx = newChildren[newIdx]
				if newChildNewIdx ~= nil and type(newChildNewIdx) == "table" and newChildNewIdx["$$typeof"] ~= nil then
					newFiber = createChild(returnFiber, newChildNewIdx, lanes, newIdx)
				else
					newFiber = createChild(returnFiber, newChildNewIdx, lanes)
				end
				if newFiber == nil then
					-- deviation: increment manually since we're not using a modified for loop
					newIdx += 1
					continue
				end
				-- FIXME Luau: needs type state to understand the continue above
				lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					-- TODO: Move out of the loop. This only happens for the first run.
					resultingFirstChild = newFiber
				else
					(previousNewFiber :: Fiber).sibling = newFiber
				end
				previousNewFiber = newFiber
				-- deviation: increment manually since we're not using a modified for loop
				newIdx += 1
			end
			return resultingFirstChild
		end

		-- Add all children to a key map for quick lookups.
		-- FIXME Luau: need type state to understand the if/return above
		local existingChildren = mapRemainingChildren(returnFiber, oldFiber :: Fiber)

		-- Keep scanning and use the map to restore deleted items as moves.
		-- deviation: use while loop in place of modified for loop
		while newIdx <= newChildrenCount do
			local newFiber = updateFromMap(
				existingChildren,
				returnFiber,
				newIdx,
				newChildren[newIdx],
				lanes,
				-- deviation: pass newIdx to be used as the key of the element
				newIdx
			)
			if newFiber ~= nil then
				if shouldTrackSideEffects then
					if newFiber.alternate ~= nil then
						-- The new fiber is a work in progress, but if there exists a
						-- current, that means that we reused the fiber. We need to delete
						-- it from the child list so that we don't add it to the deletion
						-- list.
						existingChildren[if newFiber.key == nil then newIdx else newFiber.key] = nil
					end
				end
				lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					resultingFirstChild = newFiber
				else
					(previousNewFiber :: Fiber).sibling = newFiber
				end
				previousNewFiber = newFiber
			end
			-- deviation: increment manually since we're not using a modified for loop
			newIdx += 1
		end

		if shouldTrackSideEffects then
			-- Any existing children that weren't consumed above were deleted. We need
			-- to add them to the deletion list.
			for _, child in existingChildren do
				deleteChild(returnFiber, child)
			end
		end

		return resultingFirstChild
	end

	-- TODO: LUAFDN-254
	local function reconcileChildrenIterator(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		-- TODO: figure out our Iterable<> interface
		--   newChildrenIterable: Iterable<*>,
		newChildrenIterable: any,
		lanes: Lanes,
		-- performance? pass in iteratorFn to avoid two calls to getIteratorFn
		iteratorFn: (...any) -> any
	): Fiber | nil
		-- This is the same implementation as reconcileChildrenArray(),
		-- but using the iterator instead.

		-- local iteratorFn = getIteratorFn(newChildrenIterable)
		-- performance? eliminate 'nice to have' strcmp in hot path
		-- invariant(
		-- 	typeof(iteratorFn) == "function",
		-- 	"An object is not an iterable. This error is likely caused by a bug in "
		-- 		.. "React. Please file an issue."
		-- )

		if __DEV__ then
			-- We don't support rendering Generators because it's a mutation.
			-- See https://github.com/facebook/react/issues/12995
			-- deviation: Lua doesn't have built-in generators
			-- if
			--   typeof(Symbol) == 'function' and
			--   -- $FlowFixMe Flow doesn't know about toStringTag
			--   newChildrenIterable[Symbol.toStringTag] == 'Generator'
			-- then
			--   if not didWarnAboutGenerators then
			--     console.error(
			--       'Using Generators as children is unsupported and will likely yield ' ..
			--         'unexpected results because enumerating a generator mutates it. ' ..
			--         'You may convert it to an array with `Array.from()` or the ' ..
			--         '`[...spread]` operator before rendering. Keep in mind ' ..
			--         'you might need to polyfill these features for older browsers.'
			--     )
			--   end
			--   didWarnAboutGenerators = true
			-- end

			-- Warn about using Maps as children
			if newChildrenIterable.entries == iteratorFn then
				if not didWarnAboutMaps then
					console.error(
						"Using Maps as children is not supported. " .. "Use an array of keyed ReactElements instead."
					)
				end
				didWarnAboutMaps = true
			end

			-- First, validate keys.
			-- We'll get a different iterator later for the main pass.
			local newChildren = iteratorFn(newChildrenIterable)
			if newChildren then
				local knownKeys = nil
				local step = newChildren.next()
				while not step.done do
					step = newChildren.next()
					local child = step.value
					knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber)
				end
			end
		end

		local newChildren = iteratorFn(newChildrenIterable)
		-- performance? eliminate 'nice to have' cmp in hot path
		-- invariant(newChildren ~= nil, "An iterable object provided no iterator.")

		local resultingFirstChild: Fiber | nil = nil
		local previousNewFiber: Fiber = nil

		local oldFiber = currentFirstChild
		local lastPlacedIndex = 1
		local newIdx = 1
		local nextOldFiber: Fiber | nil = nil

		local step = newChildren.next()
		while oldFiber ~= nil and not step.done do
			if oldFiber.index > newIdx then
				nextOldFiber = oldFiber
				oldFiber = nil
			else
				nextOldFiber = oldFiber.sibling
			end
			local newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes, step.key)
			if newFiber == nil then
				-- TODO: This breaks on empty slots like nil children. That's
				-- unfortunate because it triggers the slow path all the time. We need
				-- a better way to communicate whether this was a miss or nil,
				-- boolean, undefined, etc.
				if oldFiber == nil then
					oldFiber = nextOldFiber
				end
				break
			end
			if shouldTrackSideEffects then
				-- FIXME Luau: need type states to understand the break above
				if oldFiber and (newFiber :: Fiber).alternate == nil then
					-- We matched the slot, but we didn't reuse the existing fiber, so we
					-- need to delete the existing child.
					deleteChild(returnFiber, oldFiber)
				end
			end
			lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
			if previousNewFiber == nil then
				-- TODO: Move out of the loop. This only happens for the first run.
				resultingFirstChild = newFiber
			else
				-- TODO: Defer siblings if we're not at the right index for this slot.
				-- I.e. if we had nil values before, then we want to defer this
				-- for each nil value. However, we also don't want to call updateSlot
				-- with the previous one.
				previousNewFiber.sibling = newFiber :: Fiber
			end
			previousNewFiber = newFiber :: Fiber
			oldFiber = nextOldFiber

			newIdx += 1
			step = newChildren.next()
		end

		if step.done then
			-- We've reached the end of the new children. We can delete the rest.
			deleteRemainingChildren(returnFiber, oldFiber)
			return resultingFirstChild
		end

		if oldFiber == nil then
			-- If we don't have any more existing children we can choose a fast path
			-- since the rest will all be insertions.
			while not step.done do
				local newFiber = createChild(returnFiber, step.value, lanes, step.key)
				if newFiber == nil then
					newIdx += 1
					step = newChildren.next()
					continue
				end
				-- FIXME Luau: need type states to understand the continue above
				lastPlacedIndex = placeChild(newFiber :: Fiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					-- TODO: Move out of the loop. This only happens for the first run.
					resultingFirstChild = newFiber
				else
					previousNewFiber.sibling = newFiber
				end
				previousNewFiber = newFiber :: Fiber

				newIdx += 1
				step = newChildren.next()
			end
			return resultingFirstChild
		end

		-- Add all children to a key map for quick lookups.
		-- performance? defer initialization into the loop. extra cmp per loop iter, but avoid call if no loop iter
		local existingChildren

		-- Keep scanning and use the map to restore deleted items as moves.
		while not step.done do
			if not existingChildren then
				-- FIXME LUau: need type states to understand the guard+return above
				existingChildren = mapRemainingChildren(returnFiber, oldFiber :: Fiber)
			end
			local newFiber = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes, step.key)
			if newFiber ~= nil then
				if shouldTrackSideEffects then
					if newFiber.alternate ~= nil then
						-- The new fiber is a work in progress, but if there exists a
						-- current, that means that we reused the fiber. We need to delete
						-- it from the child list so that we don't add it to the deletion
						-- list.
						if newFiber.key == nil then
							existingChildren[newIdx] = nil
						else
							existingChildren[newFiber.key] = nil
						end
					end
				end
				lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx)
				if previousNewFiber == nil then
					resultingFirstChild = newFiber
				else
					previousNewFiber.sibling = newFiber
				end
				previousNewFiber = newFiber
			end

			newIdx += 1
			step = newChildren.next()
		end

		if shouldTrackSideEffects then
			-- Any existing children that weren't consumed above were deleted. We need
			-- to add them to the deletion list.
			for _, child in existingChildren do
				deleteChild(returnFiber, child)
			end
		end

		return resultingFirstChild
	end

	local function reconcileSingleTextNode(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		textContent: string,
		lanes: Lanes
	): Fiber
		-- There's no need to check for keys on text nodes since we don't have a
		-- way to define them.
		-- FIXME: Luau narrowing issue
		if currentFirstChild ~= nil and (currentFirstChild :: Fiber).tag == HostText then
			-- We already have an existing node so let's just update it and delete
			-- the rest.
			deleteRemainingChildren(returnFiber, (currentFirstChild :: Fiber).sibling)
			local existing = useFiber(currentFirstChild :: Fiber, textContent)
			existing.return_ = returnFiber
			return existing
		end
		-- The existing first child is not a text node so we need to create one
		-- and delete the existing ones.
		deleteRemainingChildren(returnFiber, currentFirstChild)
		local created = createFiberFromText(textContent, returnFiber.mode, lanes)
		created.return_ = returnFiber
		return created
	end

	local function reconcileSingleElement(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		element: ReactElement,
		lanes: Lanes
	): Fiber
		local key = element.key
		local child = currentFirstChild
		while child ~= nil do
			-- TODO: If key == nil and child.key == nil, then this only applies to
			-- the first item in the list.
			if child.key == key then
				if child.tag == Fragment then
					if element.type == REACT_FRAGMENT_TYPE then
						deleteRemainingChildren(returnFiber, child.sibling)
						local existing = useFiber(child, element.props.children)
						existing.return_ = returnFiber
						if __DEV__ then
							existing._debugSource = element._source
							existing._debugOwner = element._owner
						end
						return existing
					end
					-- performance: avoid always-false cmp in hot path
					-- elseif child.tag == Block then
					-- 	unimplemented("reconcileSingleElement: Block")
					-- if (enableBlocksAPI) {
					--   let type = element.type;
					--   if (type.$$typeof === REACT_LAZY_TYPE) {
					--     type = resolveLazyType(type);
					--   }
					--   if (type.$$typeof === REACT_BLOCK_TYPE) {
					--     // The new Block might not be initialized yet. We need to initialize
					--     // it in case initializing it turns out it would match.
					--     if (
					--       ((type: any): BlockComponent<any, any>)._render ===
					--       (child.type: BlockComponent<any, any>)._render
					--     ) {
					--       deleteRemainingChildren(returnFiber, child.sibling);
					--       const existing = useFiber(child, element.props);
					--       existing.type = type;
					--       existing.return = returnFiber;
					--       if (__DEV__) {
					--         existing._debugSource = element._source;
					--         existing._debugOwner = element._owner;
					--       }
					--       return existing;
					--     }
					--   }
					-- }
					-- // We intentionally fallthrough here if enableBlocksAPI is not on.
					-- // eslint-disable-next-lined no-fallthrough
				else
					if
						child.elementType == element.type
						-- performance: avoid always-false cmp, hot reloading isn't enabled in Roblox yet
						-- Keep this check inline so it only runs on the false path:
						-- or (
						-- 	__DEV__
						-- 	and isCompatibleFamilyForHotReloading(child, element)
						-- )
					then
						deleteRemainingChildren(returnFiber, child.sibling)
						local existing = useFiber(child, element.props)
						existing.ref = coerceRef(returnFiber, child, element)
						existing.return_ = returnFiber
						if __DEV__ then
							existing._debugSource = element._source
							existing._debugOwner = element._owner
						end
						return existing
					end
				end
				-- Didn't match.
				deleteRemainingChildren(returnFiber, child)
				break
			else
				deleteChild(returnFiber, child)
			end
			child = child.sibling
		end

		if element.type == REACT_FRAGMENT_TYPE then
			local created = createFiberFromFragment(
				element.props.children,
				returnFiber.mode,
				lanes,
				-- FIXME Luau: needs normalization: TypeError: Type '(number | string)?' could not be converted into 'string?'
				element.key :: string
			)
			created.return_ = returnFiber
			return created
		else
			local created = createFiberFromElement(element, returnFiber.mode, lanes)
			created.ref = coerceRef(returnFiber, currentFirstChild, element)
			created.return_ = returnFiber
			return created
		end
	end

	local function reconcileSinglePortal(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		portal: ReactPortal,
		lanes: Lanes
	): Fiber
		local key = portal.key
		local child = currentFirstChild
		while child ~= nil do
			-- TODO: If key == nil and child.key == nil, then this only applies to
			-- the first item in the list.
			if child.key == key then
				if
					child.tag == HostPortal
					and child.stateNode.containerInfo == portal.containerInfo
					and child.stateNode.implementation == portal.implementation
				then
					deleteRemainingChildren(returnFiber, child.sibling)
					local existing = useFiber(child, portal.children or {})
					existing.return_ = returnFiber
					return existing
				else
					deleteRemainingChildren(returnFiber, child)
					break
				end
			else
				deleteChild(returnFiber, child)
			end
			child = child.sibling
		end

		local created = createFiberFromPortal(portal, returnFiber.mode, lanes)
		created.return_ = returnFiber
		return created
	end

	-- This API will tag the children with the side-effect of the reconciliation
	-- itself. They will be added to the side-effect list as we pass through the
	-- children and the parent.
	local function reconcileChildFibers(
		returnFiber: Fiber,
		currentFirstChild: Fiber | nil,
		newChild: any,
		lanes: Lanes
	): Fiber | nil
		-- This function is not recursive.
		-- If the top level item is an array, we treat it as a set of children,
		-- not as a fragment. Nested arrays on the other hand will be treated as
		-- fragment nodes. Recursion happens at the normal flow.

		-- performance: avoid repeated calls to typeof since Luau doesn't cache
		local typeOfNewChild = type(newChild)

		-- Handle top level unkeyed fragments as if they were arrays.
		-- This leads to an ambiguity between <>{[...]}</> and <>...</>.
		-- We treat the ambiguous cases above the same.
		local isUnkeyedTopLevelFragment = newChild ~= nil
			and typeOfNewChild == "table"
			and newChild.type == REACT_FRAGMENT_TYPE
			and newChild.key == nil
		if isUnkeyedTopLevelFragment then
			newChild = newChild.props.children
			typeOfNewChild = type(newChild)
		end
		local newChildIsArray = isArray(newChild)

		-- Handle object types
		-- deviation: upstream checks for `object`, but we need to manually exclude array
		local isObject = newChild ~= nil and typeOfNewChild == "table" and not newChildIsArray

		if isObject then
			-- performance: avoid repeated indexing of $$typeof
			local newChildTypeof = newChild["$$typeof"]
			if newChildTypeof == REACT_ELEMENT_TYPE then
				return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes))
			elseif newChildTypeof == REACT_PORTAL_TYPE then
				return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes))
			elseif newChildTypeof == REACT_LAZY_TYPE then
				if enableLazyElements then
					local payload = newChild._payload
					local init = newChild._init
					-- TODO: This function is supposed to be non-recursive.
					return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes)
				end
			end
		-- performance: make these next blocks `elseif`, as they're mutually exclusive to `isObject` above
		elseif newChildIsArray then
			return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes)
		elseif typeOfNewChild == "string" or typeOfNewChild == "number" then
			return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, tostring(newChild), lanes))
		end

		-- performance? only call getIteratorFn once, pass in the value
		local newChildIteratorFn = getIteratorFn(newChild)
		if newChildIteratorFn then
			return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes, newChildIteratorFn)
		end

		-- performance? eliminate a cmp in hot path for something unimplemented anyway
		-- if isObject then
		-- 	unimplemented("throwOnInvalidObjectType")
		-- 	-- throwOnInvalidObjectType(returnFiber, newChild)
		-- end

		if __DEV__ then
			if typeOfNewChild == "function" then
				warnOnFunctionType(returnFiber)
			end
		end
		if newChild == nil and not isUnkeyedTopLevelFragment then
			-- deviation: need a flag here to simulate switch/case fallthrough + break
			local shouldFallThrough = false
			-- If the new child is undefined, and the return fiber is a composite
			-- component, throw an error. If Fiber return types are disabled,
			-- we already threw above.
			-- deviation: With coercion of no returns to `nil`, it
			-- if returnFiber.tag == ClassComponent then
			--   if __DEV__ then
			-- isn't necessary to special case this scenario
			-- local instance = returnFiber.stateNode
			-- if instance.render._isMockFunction then
			--   -- We allow auto-mocks to proceed as if they're returning nil.
			--   shouldFallThrough = true
			-- end
			--   end
			-- end
			-- Intentionally fall through to the next case, which handles both
			-- functions and classes
			-- eslint-disable-next-lined no-fallthrough
			if
				shouldFallThrough
				and (
					returnFiber.tag == ClassComponent
					or returnFiber.tag == FunctionComponent
					or returnFiber.tag == ForwardRef
					or returnFiber.tag == SimpleMemoComponent
				)
			then
				invariant(
					false,
					"%s(...): Nothing was returned from render. This usually means a "
						.. "return statement is missing. Or, to render nothing, "
						.. "return nil.",
					getComponentName(returnFiber.type) or "Component"
				)
			end
		end

		-- Remaining cases are all treated as empty.
		return deleteRemainingChildren(returnFiber, currentFirstChild)
	end

	return reconcileChildFibers
end

exports.reconcileChildFibers = ChildReconciler(true)
exports.mountChildFibers = ChildReconciler(false)

exports.cloneChildFibers = function(current: Fiber | nil, workInProgress: Fiber)
	-- deviation: This message isn't tested upstream, remove for hot path optimization
	-- invariant(
	-- 	current == nil or workInProgress.child == (current :: Fiber).child,
	-- 	"Resuming work not yet implemented."
	-- )

	if workInProgress.child == nil then
		return
	end

	local currentChild = workInProgress.child :: Fiber
	local newChild = createWorkInProgress(currentChild, currentChild.pendingProps)
	workInProgress.child = newChild

	newChild.return_ = workInProgress
	while currentChild.sibling ~= nil do
		currentChild = currentChild.sibling
		newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps)
		-- FIXME Luau: luau doesn't track/narrow the direct assignment on the line above
		newChild = newChild.sibling :: Fiber
		newChild.return_ = workInProgress
	end
	newChild.sibling = nil
end

-- Reset a workInProgress child set to prepare it for a second pass.
exports.resetChildFibers = function(workInProgress: Fiber, lanes: Lanes): ()
	local child = workInProgress.child
	while child ~= nil do
		resetWorkInProgress(child, lanes)
		child = child.sibling
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006101</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX397DD3986F9B4083A70ED10593C7D8CF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactCurrentFiber</string>
								<string name="ScriptGuid">{1E415D8E-E5CF-427D-8FE8-CD6F45284D32}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/b0cb137bcbd3a11d8eff3c2229cd6b8379d29785/packages/react-reconciler/src/ReactCurrentFiber.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactFiberComponentStack = require(script.Parent.ReactFiberComponentStack)
local getStackByFiberInDevAndProd = ReactFiberComponentStack.getStackByFiberInDevAndProd
local getComponentName = require(Packages.Shared).getComponentName

local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame

-- deviation: Pre-declare type of exports, including values we'll initialize
type Exports = {
	current: Fiber | nil,
	isRendering: boolean,
	-- remaining functions declare their own types
	[string]: any,
}

local exports: Exports = {
	current = nil,
	isRendering = false,
}

exports.getCurrentFiberOwnerNameInDevOrNull = function(): string?
	if __DEV__ then
		if exports.current == nil then
			return nil
		end
		-- FIXME Luau: Luau doesn't understand guard above
		local owner = (exports.current :: Fiber)._debugOwner
		if owner then
			return getComponentName(owner.type)
		end
	end
	return nil
end

local function getCurrentFiberStackInDev(): string
	if __DEV__ then
		if exports.current == nil then
			return ""
		end
		-- Safe because if current fiber exists, we are reconciling,
		-- and it is guaranteed to be the work-in-progress version.
		-- FIXME Luau: Luau doesn't understand guard above
		return getStackByFiberInDevAndProd(exports.current :: Fiber)
	end
	return ""
end

exports.resetCurrentFiber = function(): ()
	if __DEV__ then
		-- FIXME Luau: Expected type table, got 'ReactDebugCurrentFrame | { setExtraStackFrame: () -> () }' instead
		(ReactDebugCurrentFrame :: any).getCurrentStack = nil
		exports.current = nil
		exports.isRendering = false
	end
end

exports.setCurrentFiber = function(fiber: Fiber): ()
	if __DEV__ then
		-- FIXME Luau: Expected type table, got 'ReactDebugCurrentFrame | { setExtraStackFrame: () -> () }' instead
		(ReactDebugCurrentFrame :: any).getCurrentStack = getCurrentFiberStackInDev
		exports.current = fiber
		exports.isRendering = false
	end
end

exports.setIsRendering = function(rendering: boolean): ()
	if __DEV__ then
		exports.isRendering = rendering
	end
end

exports.getIsRendering = function(): boolean
	if __DEV__ then
		return exports.isRendering
	end
	return false
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006102</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX904EF399307849108064F589FEC81950">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiber.new</string>
								<string name="ScriptGuid">{D3E41666-DD16-4C48-B1B4-787234B15CB9}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiber.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local __DEV__ = _G.__DEV__
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Array = LuauPolyfill.Array
local inspect = LuauPolyfill.util.inspect

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
-- deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type ReactElement = ReactTypes.ReactElement<any, any>
type ReactFragment = ReactTypes.ReactFragment
type ReactPortal = ReactTypes.ReactPortal
type ReactFundamentalComponent<T, U> = ReactTypes.ReactFundamentalComponent<T, U>
type ReactScope = ReactTypes.ReactScope
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
export type Fiber = ReactInternalTypes.Fiber

-- deviation: Allow number keys for sparse arrays
type RoactStableKey = ReactInternalTypes.RoactStableKey
local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag
local ReactWorkTags = require(script.Parent.ReactWorkTags)
type WorkTag = ReactWorkTags.WorkTag
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
type TypeOfMode = ReactTypeOfMode.TypeOfMode
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenProps = ReactFiberOffscreenComponent.OffscreenProps

local invariant = require(Packages.Shared).invariant
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local Placement = ReactFiberFlags.Placement
local StaticMask = ReactFiberFlags.StaticMask
local ConcurrentRoot = ReactRootTags.ConcurrentRoot
local BlockingRoot = ReactRootTags.BlockingRoot
local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local Mode = ReactWorkTags.Mode
local ContextProvider = ReactWorkTags.ContextProvider
local ContextConsumer = ReactWorkTags.ContextConsumer
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local DehydratedFragment = ReactWorkTags.DehydratedFragment
local FunctionComponent = ReactWorkTags.FunctionComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LazyComponent = ReactWorkTags.LazyComponent
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local getComponentName = require(Packages.Shared).getComponentName

local ReactFiberDevToolsHook = require(script.Parent["ReactFiberDevToolsHook.new"])
local isDevToolsPresent = ReactFiberDevToolsHook.isDevToolsPresent
local ReactFiberHotReloading = require(script.Parent["ReactFiberHotReloading.new"])
local resolveClassForHotReloading = ReactFiberHotReloading.resolveClassForHotReloading
local resolveFunctionForHotReloading = ReactFiberHotReloading.resolveFunctionForHotReloading
local resolveForwardRefForHotReloading = ReactFiberHotReloading.resolveForwardRefForHotReloading
local NoLanes = ReactFiberLane.NoLanes
local NoMode = ReactTypeOfMode.NoMode
local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local DebugTracingMode = ReactTypeOfMode.DebugTracingMode
local ProfileMode = ReactTypeOfMode.ProfileMode
local StrictMode = ReactTypeOfMode.StrictMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local REACT_DEBUG_TRACING_MODE_TYPE = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
-- local REACT_FUNDAMENTAL_TYPE = ReactSymbols.REACT_FUNDAMENTAL_TYPE
-- local REACT_SCOPE_TYPE = ReactSymbols.REACT_SCOPE_TYPE
local REACT_OFFSCREEN_TYPE = ReactSymbols.REACT_OFFSCREEN_TYPE
local REACT_LEGACY_HIDDEN_TYPE = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE

-- deviation: We probably don't have to worry about this scenario, since we use
-- simple tables as maps

-- local hasBadMapPolyfill

-- if __DEV__ then
-- 	hasBadMapPolyfill = false
-- 	try {
-- 		local nonExtensibleObject = Object.preventExtensions({})
-- 		--[[ eslint-disable no-new ]]
-- 		new Map([[nonExtensibleObject, nil]])
-- 		new Set([nonExtensibleObject])
-- 		--[[ eslint-enable no-new ]]
-- 	} catch (e)
-- 		-- TODO: Consider warning about bad polyfills
-- 		hasBadMapPolyfill = true
-- 	end
-- end

local createFiberFromScope, createFiberFromProfiler, createFiberFromFragment, createFiberFromFundamental, createFiberFromSuspense, createFiberFromOffscreen, createFiberFromLegacyHidden, createFiberFromSuspenseList

local debugCounter = 1

-- deviation START: inline this into its only caller to save hot path performance
-- function FiberNode(
-- 	tag: WorkTag,
-- 	pendingProps: any,
-- 	key: RoactStableKey?,
-- 	mode: TypeOfMode
-- ): Fiber
-- 	return {} :: any
-- end
-- deviation END

-- This is a constructor function, rather than a POJO constructor, still
-- please ensure we do the following:
-- 1) Nobody should add any instance methods on this. Instance methods can be
--    more difficult to predict when they get optimized and they are almost
--    never inlined properly in static compilers.
-- 2) Nobody should rely on `instanceof Fiber` for type testing. We should
--    always know when it is a fiber.
-- 3) We might want to experiment with using numeric keys since they are easier
--    to optimize in a non-JIT environment.
-- 4) We can easily go from a constructor to a createFiber object literal if that
--    is faster.
-- 5) It should be easy to port this to a C struct and keep a C implementation
--    compatible.
-- deviation START: add elementType, type, and lanes arguments so the table is created in a one-shot to avoid rehashing
local function createFiber(
	tag: WorkTag,
	pendingProps: any,
	key: RoactStableKey?,
	mode: TypeOfMode,
	elementType: any?,
	type_: any?,
	stateNode: any?,
	lanes: Lanes?
): Fiber
	-- $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
	-- deviation START: inline FiberNode(), do the table as a one-shot and avoid initializing nil fields for hot-path performance
	local node: Fiber = {
		-- Instance
		tag = tag,
		key = key,
		elementType = elementType,
		type = type_,
		stateNode = stateNode,

		-- Fiber
		-- node.return_ = nil
		-- node.child = nil
		-- node.sibling = nil
		index = 1,

		-- node.ref = nil

		pendingProps = pendingProps,
		-- memoizedProps = nil
		-- updateQueue = nil
		-- memoizedState = nil
		-- dependencies = nil

		mode = mode,

		-- Effects
		flags = NoFlags,
		subtreeFlags = NoFlags,
		-- deletions = nil

		lanes = if lanes then lanes else NoLanes,
		childLanes = NoLanes,

		-- alternate = nil
	} :: any

	if enableProfilerTimer then
		-- deviation: Unlikely that we have this same performance problem
		--[[
			-- NOTE: The following is done to avoid a v8 performance cliff.
			--
			-- Initializing the fields below to smis and later updating them with
			-- double values will cause Fibers to end up having separate shapes.
			-- This behavior/bug has something to do with Object.preventExtension().
			-- Fortunately this only impacts DEV builds.
			-- Unfortunately it makes React unusably slow for some applications.
			-- To work around this, initialize the fields below with doubles.
			--
			-- Learn more about this here:
			-- https://github.com/facebook/react/issues/14365
			-- https://bugs.chromium.org/p/v8/issues/detail?id=8538
			node.actualDuration = Number.NaN
			node.actualStartTime = Number.NaN
			node.selfBaseDuration = Number.NaN
			node.treeBaseDuration = Number.NaN

			-- It's okay to replace the initial doubles with smis after initialization.
			-- This won't trigger the performance cliff mentioned above,
			-- and it simplifies other profiler code (including DevTools).
		]]
		node.actualDuration = 0
		node.actualStartTime = -1
		node.selfBaseDuration = 0
		node.treeBaseDuration = 0
	end

	if __DEV__ then
		-- This isn't directly used but is handy for debugging internals:
		node._debugID = debugCounter
		debugCounter += 1
		node._debugSource = nil
		node._debugOwner = nil
		node._debugNeedsRemount = false
		node._debugHookTypes = nil
		-- deviation: We can just make sure this is always valid
		-- if not hasBadMapPolyfill and typeof(Object.preventExtensions) == "function"

		-- deviation: FIXME - we can't actually distinguish between 'nil' and
		-- absent, so if we do this here, we won't be able to initialize fields
		-- that start out as 'nil'
		-- Object.preventExtensions(node)

		-- end
	end
	return node
	-- deviation END
end

-- deviation START: we inline all uses of this function for performance in hot path
function _shouldConstruct(Component)
	-- deviation: With Lua metatables, members of the "prototype" can be
	-- accessed directly. so we don't need to check for a prototype separately
	return type(Component) ~= "function" and not not Component.isReactComponent
end
-- deviation END

local function isSimpleFunctionComponent(type_: any)
	-- deviation START: inline shouldConstruct logic for hot path performance
	return type(type_) == "function"
	-- deviation: function components don't support this anyway
	-- type.defaultProps == undefined
	-- deviation END: inline shouldConstruct logic for hot path performance
end

local function resolveLazyComponentTag(Component: any): WorkTag
	local typeofComponent = typeof(Component)
	if typeofComponent == "function" then
		return FunctionComponent
	end

	if typeofComponent == "table" then
		if Component.isReactComponent then
			return ClassComponent
		end
		local __typeof = Component["$$typeof"]
		if __typeof == REACT_FORWARD_REF_TYPE then
			return ForwardRef
		end
		if __typeof == REACT_MEMO_TYPE then
			return MemoComponent
		end
	end

	return IndeterminateComponent
end

-- This is used to create an alternate fiber to do work on.
local function createWorkInProgress(current: Fiber, pendingProps: any): Fiber
	-- FIXME Luau: Luau doesn't understand if nil then create pattern
	local workInProgress = current.alternate :: Fiber
	if workInProgress == nil then
		-- We use a double buffering pooling technique because we know that we'll
		-- only ever need at most two versions of a tree. We pool the "other" unused
		-- node that we're free to reuse. This is lazily created to avoid allocating
		-- extra objects for things that are never updated. It also allow us to
		-- reclaim the extra memory if needed.
		workInProgress = createFiber(
			current.tag,
			pendingProps,
			current.key,
			current.mode,
			current.elementType,
			current.type,
			current.stateNode
		)

		if __DEV__ then
			-- DEV-only fields
			workInProgress._debugID = current._debugID
			workInProgress._debugSource = current._debugSource
			workInProgress._debugOwner = current._debugOwner
			workInProgress._debugHookTypes = current._debugHookTypes
		end

		workInProgress.alternate = current
		current.alternate = workInProgress
	else
		workInProgress.pendingProps = pendingProps
		-- Needed because Blocks store data on type.
		workInProgress.type = current.type

		-- We already have an alternate.
		-- Reset the effect tag.
		workInProgress.flags = NoFlags

		-- The current effects are no longer valid
		workInProgress.subtreeFlags = NoFlags
		workInProgress.deletions = nil

		if enableProfilerTimer then
			-- We intentionally reset, rather than copy, actualDuration & actualStartTime.
			-- This prevents time from endlessly accumulating in new commits.
			-- This has the downside of resetting values for different priority renders,
			-- But works for yielding (the common case) and should support resuming.
			workInProgress.actualDuration = 0
			workInProgress.actualStartTime = -1
		end
	end

	-- Reset all effects except static ones.
	-- Static effects are not specific to a render.
	workInProgress.flags = bit32.band(current.flags, StaticMask)
	workInProgress.childLanes = current.childLanes
	workInProgress.lanes = current.lanes

	workInProgress.child = current.child
	workInProgress.memoizedProps = current.memoizedProps
	workInProgress.memoizedState = current.memoizedState
	workInProgress.updateQueue = current.updateQueue

	-- Clone the dependencies object. This is mutated during the render phase, so
	-- it cannot be shared with the current fiber.
	local currentDependencies = current.dependencies
	if currentDependencies == nil then
		workInProgress.dependencies = nil
	else
		workInProgress.dependencies = {
			lanes = currentDependencies.lanes,
			firstContext = currentDependencies.firstContext,
		}
	end

	-- These will be overridden during the parent's reconciliation
	workInProgress.sibling = current.sibling
	workInProgress.index = current.index
	workInProgress.ref = current.ref

	if enableProfilerTimer then
		workInProgress.selfBaseDuration = current.selfBaseDuration
		workInProgress.treeBaseDuration = current.treeBaseDuration
	end

	if __DEV__ then
		workInProgress._debugNeedsRemount = current._debugNeedsRemount
		if
			workInProgress.tag == IndeterminateComponent
			or workInProgress.tag == FunctionComponent
			or workInProgress.tag == SimpleMemoComponent
		then
			workInProgress.type = resolveFunctionForHotReloading(current.type)
		elseif workInProgress.tag == ClassComponent then
			workInProgress.type = resolveClassForHotReloading(current.type)
		elseif workInProgress.tag == ForwardRef then
			workInProgress.type = resolveForwardRefForHotReloading(current.type)
		end
	end

	return workInProgress
end

-- Used to reuse a Fiber for a second pass.
local function resetWorkInProgress(workInProgress: Fiber, renderLanes: Lanes)
	-- This resets the Fiber to what createFiber or createWorkInProgress would
	-- have set the values to before during the first pass. Ideally this wouldn't
	-- be necessary but unfortunately many code paths reads from the workInProgress
	-- when they should be reading from current and writing to workInProgress.

	-- We assume pendingProps, index, key, ref, return are still untouched to
	-- avoid doing another reconciliation.

	-- Reset the effect tag but keep any Placement tags, since that's something
	-- that child fiber is setting, not the reconciliation.
	workInProgress.flags = bit32.band(workInProgress.flags, bit32.bor(StaticMask, Placement))

	-- The effects are no longer valid

	local current = workInProgress.alternate
	if current == nil then
		-- Reset to createFiber's initial values.
		workInProgress.childLanes = NoLanes
		workInProgress.lanes = renderLanes

		workInProgress.child = nil
		workInProgress.subtreeFlags = NoFlags
		workInProgress.memoizedProps = nil
		workInProgress.memoizedState = nil
		workInProgress.updateQueue = nil

		workInProgress.dependencies = nil

		workInProgress.stateNode = nil

		if enableProfilerTimer then
			-- NOTE: We don't reset the actualTime counts. It's useful to accumulate
			-- actual time across multiple render passes.
			workInProgress.selfBaseDuration = 0
			workInProgress.treeBaseDuration = 0
		end
	else
		-- Reset to the cloned values that createWorkInProgress would've.
		workInProgress.childLanes = current.childLanes
		workInProgress.lanes = current.lanes

		workInProgress.child = current.child
		workInProgress.subtreeFlags = current.subtreeFlags
		workInProgress.deletions = nil
		workInProgress.memoizedProps = current.memoizedProps
		workInProgress.memoizedState = current.memoizedState
		workInProgress.updateQueue = current.updateQueue
		-- Needed because Blocks store data on type.
		workInProgress.type = current.type

		-- Clone the dependencies object. This is mutated during the render phase, so
		-- it cannot be shared with the current fiber.
		local currentDependencies = current.dependencies
		if currentDependencies == nil then
			workInProgress.dependencies = nil
		else
			workInProgress.dependencies = {
				lanes = currentDependencies.lanes,
				firstContext = currentDependencies.firstContext,
			}
		end

		if enableProfilerTimer then
			-- NOTE: We don't reset the actualTime counts. It's useful to accumulate
			-- actual time across multiple render passes.
			workInProgress.selfBaseDuration = current.selfBaseDuration
			workInProgress.treeBaseDuration = current.treeBaseDuration
		end
	end

	return workInProgress
end

local function createHostRootFiber(tag: RootTag): Fiber
	local mode
	if tag == ConcurrentRoot then
		mode = bit32.bor(ConcurrentMode, BlockingMode, StrictMode)
	elseif tag == BlockingRoot then
		mode = bit32.bor(BlockingMode, StrictMode)
	else
		mode = NoMode
	end

	-- deviation: We use a function for isDevtoolsPresent to handle the hook being changed at runtime
	if enableProfilerTimer and isDevToolsPresent() then
		-- Always collect profile timings when DevTools are present.
		-- This enables DevTools to start capturing timing at any point–
		-- Without some nodes in the tree having empty base times.
		mode = bit32.bor(mode, ProfileMode)
	end

	return createFiber(HostRoot, nil, nil, mode)
end

local function createFiberFromTypeAndProps(
	type_: any, -- React$ElementType
	key: string?,
	pendingProps: any,
	owner: nil | Fiber,
	mode: TypeOfMode,
	lanes: Lanes
): Fiber
	local fiberTag = IndeterminateComponent
	-- The resolved type is set if we know what the final type will be. I.e. it's not lazy.
	-- deviation: FIXME: Account for deviated class v. function component type logic
	local resolvedType = type_
	local typeOfType_ = type(type_)
	-- deviation: since our class components aren't functions, we have to look
	-- for them more explicitly (inlines logic from `shouldConstruct`)
	if typeOfType_ == "function" then
		if __DEV__ then
			resolvedType = resolveFunctionForHotReloading(resolvedType)
		end
	elseif typeOfType_ == "table" and not not type_.isReactComponent then
		fiberTag = ClassComponent
		if __DEV__ then
			resolvedType = resolveClassForHotReloading(resolvedType)
		end
	elseif typeOfType_ == "string" then
		fiberTag = HostComponent
	else
		if type_ == REACT_FRAGMENT_TYPE then
			return createFiberFromFragment(pendingProps.children, mode, lanes, key)
		elseif type_ == REACT_DEBUG_TRACING_MODE_TYPE then
			fiberTag = Mode
			mode = bit32.bor(mode, DebugTracingMode)
		elseif type_ == REACT_STRICT_MODE_TYPE then
			fiberTag = Mode
			mode = bit32.bor(mode, StrictMode)
		elseif type_ == REACT_PROFILER_TYPE then
			return createFiberFromProfiler(pendingProps, mode, lanes, key)
		elseif type_ == REACT_SUSPENSE_TYPE then
			return createFiberFromSuspense(pendingProps, mode, lanes, key)
			-- elseif type_ == REACT_SUSPENSE_LIST_TYPE then
			-- 	return createFiberFromSuspenseList(pendingProps, mode, lanes, key)
		elseif type_ == REACT_OFFSCREEN_TYPE then
			return createFiberFromOffscreen(pendingProps, mode, lanes, key)
		elseif type_ == REACT_LEGACY_HIDDEN_TYPE then
			return createFiberFromLegacyHidden(pendingProps, mode, lanes, key)
			-- elseif type_ == REACT_SCOPE_TYPE then
			-- 	if enableScopeAPI then
			-- 		return createFiberFromScope(type_, pendingProps, mode, lanes, key)
			-- 	end
		else
			local shouldBreak = false
			local type_typeof
			if typeOfType_ == "table" then
				type_typeof = type_["$$typeof"]
				if type_typeof == REACT_PROVIDER_TYPE then
					fiberTag = ContextProvider
					shouldBreak = true
				elseif type_typeof == REACT_CONTEXT_TYPE then
					-- This is a consumer
					fiberTag = ContextConsumer
					shouldBreak = true
				elseif type_typeof == REACT_FORWARD_REF_TYPE then
					fiberTag = ForwardRef
					if __DEV__ then
						resolvedType = resolveForwardRefForHotReloading(resolvedType)
					end
					shouldBreak = true
				elseif type_typeof == REACT_MEMO_TYPE then
					fiberTag = MemoComponent
					shouldBreak = true
				elseif type_typeof == REACT_LAZY_TYPE then
					fiberTag = LazyComponent
					resolvedType = nil
					shouldBreak = true
					-- elseif type_typeof == REACT_FUNDAMENTAL_TYPE then
					-- 	if enableFundamentalAPI then
					-- 		return createFiberFromFundamental(
					-- 			type_,
					-- 			pendingProps,
					-- 			mode,
					-- 			lanes,
					-- 			key
					-- 		)
					-- 	end
				end
			end
			if not shouldBreak then
				local info = ""
				if __DEV__ then
					if type_ == nil or (typeOfType_ == "table" and #Object.keys(type_) == 0) then
						info ..= " You likely forgot to export your component from the file " .. "it's defined in, or you might have mixed up default and " .. "named imports."
					elseif type_ ~= nil and typeOfType_ == "table" then
						-- deviation: print the table/string in readable form to give a clue, if no other info was gathered
						info ..= "\n" .. inspect(type_)
					end
					local ownerName
					if owner then
						ownerName = getComponentName(owner.type)
					end
					if ownerName ~= nil and ownerName ~= "" then
						info ..= "\n\nCheck the render method of `" .. ownerName .. "`."
					elseif owner then
						-- deviation: print the raw table in readable
						-- form to give a clue, if no other info was gathered
						info ..= "\n" .. inspect(owner)
					end
				end

				-- deviation: make output logic consistent across ReactFiber, ElementValidator, Memo, Context, and Lazy
				local typeString
				if type_ == nil then
					typeString = "nil"
				elseif Array.isArray(type_) then
					typeString = "array"
				elseif typeOfType_ == "table" and type_typeof == REACT_ELEMENT_TYPE then
					typeString = string.format("<%s />", getComponentName(type_.type) or "Unknown")
					info = " Did you accidentally export a JSX literal or Element instead of a component?"
				else
					typeString = typeOfType_
				end

				invariant(
					false,
					"Element type is invalid: expected a string (for built-in "
						.. "components) or a class/function (for composite components) "
						.. "but got: %s.%s",
					typeString,
					info
				)
			end
		end
	end

	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(fiberTag, pendingProps, key, mode, type_, resolvedType, nil, lanes)

	-- fiber.elementType = type_
	-- fiber.type = resolvedType
	-- fiber.lanes = lanes
	-- deviation END

	if __DEV__ then
		fiber._debugOwner = owner
	end

	return fiber
end

local function createFiberFromElement(element: ReactElement, mode: TypeOfMode, lanes: Lanes): Fiber
	local owner = nil
	if __DEV__ then
		owner = element._owner
	end
	local type = element.type
	local key = element.key
	local pendingProps = element.props
	local fiber = createFiberFromTypeAndProps(
		type,
		-- FIXME: according to upstream types, key can only be string?, but RoactStableKey deviation also says number
		key :: string,
		pendingProps,
		owner,
		mode,
		lanes
	)
	if __DEV__ then
		fiber._debugSource = element._source
		fiber._debugOwner = element._owner
	end
	return fiber
end

function createFiberFromFragment(elements: ReactFragment, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(Fragment, elements, key, mode, nil, nil, nil, lanes)
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

function createFiberFromFundamental(
	fundamentalComponent: ReactFundamentalComponent<any, any>,
	pendingProps: any,
	mode: TypeOfMode,
	lanes: Lanes,
	key: string?
): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		FundamentalComponent,
		pendingProps,
		key,
		mode,
		fundamentalComponent,
		fundamentalComponent,
		nil,
		lanes
	)
	-- fiber.elementType = fundamentalComponent
	-- fiber.type = fundamentalComponent
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

function createFiberFromScope(scope: ReactScope, pendingProps: any, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(ScopeComponent, pendingProps, key, mode, scope, scope, nil, lanes)
	-- fiber.type = scope
	-- fiber.elementType = scope
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

function createFiberFromProfiler(pendingProps: any, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	if __DEV__ then
		if typeof(pendingProps.id) ~= "string" then
			console.error('Profiler must specify an "id" as a prop')
		end
	end

	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		Profiler,
		pendingProps,
		key,
		bit32.bor(mode, ProfileMode),
		REACT_PROFILER_TYPE,
		REACT_PROFILER_TYPE,
		if enableProfilerTimer
			then {
				effectDuration = 0,
				passiveEffectDuration = 0,
			}
			else nil,
		lanes
	)
	-- TODO: The Profiler fiber shouldn't have a type. It has a tag.
	-- fiber.elementType = REACT_PROFILER_TYPE
	-- fiber.type = REACT_PROFILER_TYPE
	-- fiber.lanes = lanes
	-- deviation END

	-- if enableProfilerTimer then
	-- 	fiber.stateNode = {
	-- 		effectDuration = 0,
	-- 		passiveEffectDuration = 0,
	-- 	}
	-- end

	return fiber
end

function createFiberFromSuspense(pendingProps: any, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber =
		createFiber(SuspenseComponent, pendingProps, key, mode, REACT_SUSPENSE_TYPE, REACT_SUSPENSE_TYPE, nil, lanes)

	-- TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- instead.
	-- fiber.type = REACT_SUSPENSE_TYPE
	-- fiber.elementType = REACT_SUSPENSE_TYPE

	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

function createFiberFromSuspenseList(pendingProps: any, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		SuspenseListComponent,
		pendingProps,
		key,
		mode,
		REACT_SUSPENSE_LIST_TYPE,
		if __DEV__ then REACT_SUSPENSE_LIST_TYPE else nil,
		nil,
		lanes
	)
	-- if __DEV__ then
	-- 	-- TODO: The SuspenseListComponent fiber shouldn't have a type. It has a tag.
	-- 	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- 	-- instead.
	-- 	fiber.type = REACT_SUSPENSE_LIST_TYPE
	-- end
	-- fiber.elementType = REACT_SUSPENSE_LIST_TYPE
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

function createFiberFromOffscreen(pendingProps: OffscreenProps, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		OffscreenComponent,
		pendingProps,
		key,
		mode,
		REACT_OFFSCREEN_TYPE,
		if __DEV__ then REACT_OFFSCREEN_TYPE else nil,
		nil,
		lanes
	)
	-- TODO: The OffscreenComponent fiber shouldn't have a type. It has a tag.
	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- instead.
	-- if __DEV__ then
	-- 	fiber.type = REACT_OFFSCREEN_TYPE
	-- end
	-- fiber.elementType = REACT_OFFSCREEN_TYPE
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

function createFiberFromLegacyHidden(pendingProps: OffscreenProps, mode: TypeOfMode, lanes: Lanes, key: string?): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(
		LegacyHiddenComponent,
		pendingProps,
		key,
		mode,
		REACT_LEGACY_HIDDEN_TYPE,
		if __DEV__ then REACT_LEGACY_HIDDEN_TYPE else nil,
		nil,
		lanes
	)
	-- TODO: The LegacyHidden fiber shouldn't have a type. It has a tag.
	-- This needs to be fixed in getComponentName so that it relies on the tag
	-- instead.
	-- if __DEV__ then
	-- 	fiber.type = REACT_LEGACY_HIDDEN_TYPE
	-- end
	-- fiber.elementType = REACT_LEGACY_HIDDEN_TYPE
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

local function createFiberFromText(content: string, mode: TypeOfMode, lanes: Lanes): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(HostText, content, nil, mode, nil, nil, nil, lanes)
	-- fiber.lanes = lanes
	-- deviation END
	return fiber
end

local function createFiberFromHostInstanceForDeletion(): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(HostComponent, nil, nil, NoMode, "DELETED", "DELETED")
	-- TODO: These should not need a type.
	-- fiber.elementType = "DELETED"
	-- fiber.type = "DELETED"
	-- deviation END
	return fiber
end

local function createFiberFromDehydratedFragment(dehydratedNode: SuspenseInstance): Fiber
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(DehydratedFragment, nil, nil, NoMode, nil, nil, dehydratedNode)
	-- fiber.stateNode = dehydratedNode
	-- deviation END
	return fiber
end

local function createFiberFromPortal(portal: ReactPortal, mode: TypeOfMode, lanes: Lanes): Fiber
	local pendingProps = if portal.children ~= nil then portal.children else {}
	-- deviation START: we pass in all needed values so the table creation+field assignment is a one-shot
	local fiber = createFiber(HostPortal, pendingProps, portal.key, mode, nil, nil, {
		containerInfo = portal.containerInfo,
		pendingChildren = nil, -- Used by persistent updates
		implementation = portal.implementation,
	}, lanes)
	-- fiber.lanes = lanes
	-- fiber.stateNode = {
	-- 	containerInfo = portal.containerInfo,
	-- 	pendingChildren = nil, -- Used by persistent updates
	-- 	implementation = portal.implementation,
	-- }
	-- deviation END
	return fiber
end

-- Used for stashing WIP properties to replay failed work in DEV.
-- FIXME: `target: Fiber | nil` - Narrowing doesn't work even with nil check
local function assignFiberPropertiesInDEV(target: Fiber, source: Fiber): Fiber
	if target == nil then
		-- This Fiber's initial properties will always be overwritten.
		-- We only use a Fiber to ensure the same hidden class so DEV isn't slow.
		target = createFiber(IndeterminateComponent, nil, nil, NoMode)
	end

	-- This is intentionally written as a list of all properties.
	-- We tried to use Object.assign() instead but this is called in
	-- the hottest path, and Object.assign() was too slow:
	-- https://github.com/facebook/react/issues/12502
	-- This code is DEV-only so size is not a concern.

	target.tag = source.tag
	target.key = source.key
	target.elementType = source.elementType
	target.type = source.type
	target.stateNode = source.stateNode
	target.return_ = source.return_
	target.child = source.child
	target.sibling = source.sibling
	target.index = source.index
	target.ref = source.ref
	target.pendingProps = source.pendingProps
	target.memoizedProps = source.memoizedProps
	target.updateQueue = source.updateQueue
	target.memoizedState = source.memoizedState
	target.dependencies = source.dependencies
	target.mode = source.mode
	target.flags = source.flags
	target.subtreeFlags = source.subtreeFlags
	target.deletions = source.deletions
	target.lanes = source.lanes
	target.childLanes = source.childLanes
	target.alternate = source.alternate
	if enableProfilerTimer then
		target.actualDuration = source.actualDuration
		target.actualStartTime = source.actualStartTime
		target.selfBaseDuration = source.selfBaseDuration
		target.treeBaseDuration = source.treeBaseDuration
	end
	target._debugID = source._debugID
	target._debugSource = source._debugSource
	target._debugOwner = source._debugOwner
	target._debugNeedsRemount = source._debugNeedsRemount
	target._debugHookTypes = source._debugHookTypes
	return target
end

-- deviation: more convenient to export entire interface at the end
return {
	isSimpleFunctionComponent = isSimpleFunctionComponent,
	resolveLazyComponentTag = resolveLazyComponentTag,
	createWorkInProgress = createWorkInProgress,
	resetWorkInProgress = resetWorkInProgress,
	createHostRootFiber = createHostRootFiber,
	createFiberFromTypeAndProps = createFiberFromTypeAndProps,
	createFiberFromElement = createFiberFromElement,
	createFiberFromFragment = createFiberFromFragment,
	createFiberFromFundamental = createFiberFromFundamental,
	createFiberFromSuspense = createFiberFromSuspense,
	createFiberFromSuspenseList = createFiberFromSuspenseList,
	createFiberFromOffscreen = createFiberFromOffscreen,
	createFiberFromLegacyHidden = createFiberFromLegacyHidden,
	createFiberFromText = createFiberFromText,
	createFiberFromHostInstanceForDeletion = createFiberFromHostInstanceForDeletion,
	createFiberFromDehydratedFragment = createFiberFromDehydratedFragment,
	createFiberFromPortal = createFiberFromPortal,
	assignFiberPropertiesInDEV = assignFiberPropertiesInDEV,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006103</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEA39669A0CE84882A430E7528D30A944">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberBeginWork.new</string>
								<string name="ScriptGuid">{FE5C5B99-9AAF-4C90-8E3E-CDE3234E45CA}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/1faf9e3dd5d6492f3607d5c721055819e4106bc6/packages/react-reconciler/src/ReactFiberBeginWork.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
-- TODO remove this when CLI-38793 lands
--!nolint LocalShadow
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local __DEV__ = _G.__DEV__ :: boolean
local __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ = _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ :: boolean
local __COMPAT_WARNINGS__ = _G.__COMPAT_WARNINGS__ :: boolean

local Packages = script.Parent.Parent
-- NOTE: use patched console from Shared
local Shared = require(Packages.Shared)
local console = Shared.console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local inspect = LuauPolyfill.util.inspect

local ReactTypes = require(Packages.Shared)
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type ReactContext<T> = ReactTypes.ReactContext<T>
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>

local React = require(Packages.React)
type LazyComponentType<T, P> = React.LazyComponent<T, P>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
-- type Lane = ReactFiberLane.Lane;
-- local type {MutableSource} = require(Packages.Shared.ReactTypes)

local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState
type SuspenseListRenderState = ReactFiberSuspenseComponent.SuspenseListRenderState
type SuspenseListTailMode = ReactFiberSuspenseComponent.SuspenseListTailMode
local ReactFiberSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"])
type SuspenseContext = ReactFiberSuspenseContext.SuspenseContext

local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenProps = ReactFiberOffscreenComponent.OffscreenProps
type OffscreenState = ReactFiberOffscreenComponent.OffscreenState

local checkPropTypes = require(Packages.Shared).checkPropTypes

local ReactWorkTags = require(script.Parent.ReactWorkTags)
-- local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local Mode = ReactWorkTags.Mode
local ContextProvider = ReactWorkTags.ContextProvider
local ContextConsumer = ReactWorkTags.ContextConsumer
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LazyComponent = ReactWorkTags.LazyComponent
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
-- local FundamentalComponent = ReactWorkTags.FundamentalComponent
-- local ScopeComponent = ReactWorkTags.ScopeComponent
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local StaticMask = ReactFiberFlags.StaticMask
local PerformedWork = ReactFiberFlags.PerformedWork
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
local ContentReset = ReactFiberFlags.ContentReset
local DidCapture = ReactFiberFlags.DidCapture
-- local Update = ReactFiberFlags.Update
local Ref = ReactFiberFlags.Ref
local Deletion = ReactFiberFlags.Deletion
local ForceUpdateForLegacySuspense = ReactFiberFlags.ForceUpdateForLegacySuspense
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local debugRenderPhaseSideEffectsForStrictMode = ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode
local disableLegacyContext = ReactFeatureFlags.disableLegacyContext
local disableModulePatternComponents = ReactFeatureFlags.disableModulePatternComponents
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
local warnAboutDefaultPropsOnFunctionComponents = ReactFeatureFlags.warnAboutDefaultPropsOnFunctionComponents
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local shallowEqual = require(Packages.Shared).shallowEqual
local getComponentName = require(Packages.Shared).getComponentName
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local _getIteratorFn = ReactSymbols.getIteratorFn
local ReactStrictModeWarnings = require(script.Parent["ReactStrictModeWarnings.new"])
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
local getCurrentFiberOwnerNameInDevOrNull = ReactCurrentFiber.getCurrentFiberOwnerNameInDevOrNull
local setIsRendering = ReactCurrentFiber.setIsRendering
local ReactFiberHotReloadingModule = require(script.Parent["ReactFiberHotReloading.new"])
local resolveFunctionForHotReloading = ReactFiberHotReloadingModule.resolveFunctionForHotReloading
local resolveForwardRefForHotReloading = ReactFiberHotReloadingModule.resolveForwardRefForHotReloading
local resolveClassForHotReloading = ReactFiberHotReloadingModule.resolveClassForHotReloading

local ReactChildFiber = require(script.Parent["ReactChildFiber.new"]) :: any
local mountChildFibers = ReactChildFiber.mountChildFibers
local reconcileChildFibers = ReactChildFiber.reconcileChildFibers
local cloneChildFibers = ReactChildFiber.cloneChildFibers
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
local processUpdateQueue = ReactUpdateQueue.processUpdateQueue
local cloneUpdateQueue = ReactUpdateQueue.cloneUpdateQueue
local initializeUpdateQueue = ReactUpdateQueue.initializeUpdateQueue
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local NoMode = ReactTypeOfMode.NoMode
local ProfileMode = ReactTypeOfMode.ProfileMode
local StrictMode = ReactTypeOfMode.StrictMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local shouldSetTextContent = ReactFiberHostConfig.shouldSetTextContent
local isSuspenseInstancePending = ReactFiberHostConfig.isSuspenseInstancePending
local isSuspenseInstanceFallback = ReactFiberHostConfig.isSuspenseInstanceFallback
local registerSuspenseInstanceRetry = ReactFiberHostConfig.registerSuspenseInstanceRetry
local supportsHydration = ReactFiberHostConfig.supportsHydration
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance

local ReactFiberHostContext = require(script.Parent["ReactFiberHostContext.new"])
local pushHostContext = ReactFiberHostContext.pushHostContext
local pushHostContainer = ReactFiberHostContext.pushHostContainer
local suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor
local hasSuspenseContext = ReactFiberSuspenseContext.hasSuspenseContext
local ForceSuspenseFallback = ReactFiberSuspenseContext.ForceSuspenseFallback
local addSubtreeSuspenseContext = ReactFiberSuspenseContext.addSubtreeSuspenseContext
local InvisibleParentSuspenseContext = ReactFiberSuspenseContext.InvisibleParentSuspenseContext
local pushSuspenseContext = ReactFiberSuspenseContext.pushSuspenseContext
-- local setShallowSuspenseContext = ReactFiberSuspenseContext.setShallowSuspenseContext
local setDefaultShallowSuspenseContext = ReactFiberSuspenseContext.setDefaultShallowSuspenseContext
-- local {findFirstSuspended} = require(script.Parent.ReactFiberSuspenseComponent.new)
-- local {
--   ,
local ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"])
local propagateContextChange = ReactFiberNewContext.propagateContextChange
local readContext = ReactFiberNewContext.readContext
local calculateChangedBits = ReactFiberNewContext.calculateChangedBits
-- local scheduleWorkOnParentPath = ReactFiberNewContext.scheduleWorkOnParentPath
local prepareToReadContext = ReactFiberNewContext.prepareToReadContext
local pushProvider = ReactFiberNewContext.pushProvider

-- deviation: Lazy init all methods from ReactFiberHooks
local lazyRefs = {
	renderWithHooksRef = nil :: any,
	bailoutHooksRef = nil :: any,
	shouldSuspendRef = nil :: any,
}

local function shouldSuspend(fiber: Fiber): boolean
	if not lazyRefs.shouldSuspendRef then
		lazyRefs.shouldSuspendRef = require(script.Parent.ReactFiberReconciler).shouldSuspend
	end
	return lazyRefs.shouldSuspendRef(fiber)
end

-- deviation: collective lazy init methods from ReactFiberHooks
local function initReactFiberHooks()
	local ReactFiberHooks = require(script.Parent["ReactFiberHooks.new"])
	lazyRefs.renderWithHooksRef = ReactFiberHooks.renderWithHooks
	lazyRefs.bailoutHooksRef = ReactFiberHooks.bailoutHooks
end

-- deviation: Lazy init renderWithHooks from ReactFiberHooks
local function renderWithHooks(...)
	if not lazyRefs.renderWithHooksRef then
		initReactFiberHooks()
	end
	return lazyRefs.renderWithHooksRef(...)
end

-- deviation: Lazy init bailoutHooks from ReactFiberHooks
local function bailoutHooks(...)
	if not lazyRefs.bailoutHooksRef then
		initReactFiberHooks()
	end
	return lazyRefs.bailoutHooksRef(...)
end

local stopProfilerTimerIfRunning = require(script.Parent["ReactProfilerTimer.new"]).stopProfilerTimerIfRunning
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local getMaskedContext = ReactFiberContext.getMaskedContext
local getUnmaskedContext = ReactFiberContext.getUnmaskedContext
local hasLegacyContextChanged = ReactFiberContext.hasContextChanged
local pushLegacyContextProvider = ReactFiberContext.pushContextProvider
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local pushTopLevelContextObject = ReactFiberContext.pushTopLevelContextObject
local invalidateContextProvider = ReactFiberContext.invalidateContextProvider

local ReactFiberHydrationContext = require(script.Parent["ReactFiberHydrationContext.new"])
local resetHydrationState = ReactFiberHydrationContext.resetHydrationState
local enterHydrationState = ReactFiberHydrationContext.enterHydrationState
local reenterHydrationStateFromDehydratedSuspenseInstance =
	ReactFiberHydrationContext.reenterHydrationStateFromDehydratedSuspenseInstance
local tryToClaimNextHydratableInstance = ReactFiberHydrationContext.tryToClaimNextHydratableInstance
local warnIfHydrating = ReactFiberHydrationContext.warnIfHydrating
local ReactFiberClassComponent = require(script.Parent["ReactFiberClassComponent.new"]) :: any
local adoptClassInstance = ReactFiberClassComponent.adoptClassInstance
local applyDerivedStateFromProps = ReactFiberClassComponent.applyDerivedStateFromProps
local constructClassInstance = ReactFiberClassComponent.constructClassInstance
local mountClassInstance = ReactFiberClassComponent.mountClassInstance
local resumeMountClassInstance = ReactFiberClassComponent.resumeMountClassInstance
local updateClassInstance = ReactFiberClassComponent.updateClassInstance

local resolveDefaultProps = require(script.Parent["ReactFiberLazyComponent.new"]).resolveDefaultProps
local ReactFiber = require(script.Parent["ReactFiber.new"])
local resolveLazyComponentTag = ReactFiber.resolveLazyComponentTag
local createFiberFromFragment = ReactFiber.createFiberFromFragment
local createFiberFromOffscreen = ReactFiber.createFiberFromOffscreen

local createFiberFromTypeAndProps = ReactFiber.createFiberFromTypeAndProps
local isSimpleFunctionComponent = ReactFiber.isSimpleFunctionComponent
local createWorkInProgress = ReactFiber.createWorkInProgress
local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
local pushRenderLanes = ReactFiberWorkLoop.pushRenderLanes
local markSpawnedWork = ReactFiberWorkLoop.markSpawnedWork
local retryDehydratedSuspenseBoundary = ReactFiberWorkLoop.retryDehydratedSuspenseBoundary
local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local renderDidSuspendDelayIfPossible = ReactFiberWorkLoop.renderDidSuspendDelayIfPossible
local getWorkInProgressRoot = ReactFiberWorkLoop.getWorkInProgressRoot
local getExecutionContext = ReactFiberWorkLoop.getExecutionContext
local RetryAfterError = ReactFiberWorkLoop.RetryAfterError
local NoContext = ReactFiberWorkLoop.NoContext

local Schedule_tracing_wrap
local setWorkInProgressVersion = require(script.Parent["ReactMutableSource.new"]).setWorkInProgressVersion
local markSkippedUpdateLanes = require(script.Parent.ReactFiberWorkInProgress).markSkippedUpdateLanes
local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner

local exports: { [string]: any } = {}

-- deviation: Pre-declare functions
local bailoutOnAlreadyFinishedWork, updateFunctionComponent

local didReceiveUpdate: boolean = false

-- deviation: put didWarns in table to reduce number of local variables
local DidWarn = {
	didWarnAboutBadClass = {} :: { [string]: boolean },
	didWarnAboutModulePatternComponent = {} :: { [string]: boolean },
	didWarnAboutContextTypeOnFunctionComponent = {} :: { [string]: boolean },
	didWarnAboutGetDerivedStateOnFunctionComponent = {} :: { [string]: boolean },
	didWarnAboutFunctionRefs = {} :: { [string]: boolean },
	didWarnAboutDefaultPropsOnFunctionComponent = {} :: { [string]: boolean },
}
-- export local didWarnAboutReassigningProps
-- local didWarnAboutRevealOrder
-- local didWarnAboutTailOptions
local updateSimpleMemoComponent

if __DEV__ then
	DidWarn.didWarnAboutBadClass = {}
	DidWarn.didWarnAboutModulePatternComponent = {}
	DidWarn.didWarnAboutContextTypeOnFunctionComponent = {}
	DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent = {}
	DidWarn.didWarnAboutFunctionRefs = {}
	exports.didWarnAboutReassigningProps = false
	--   didWarnAboutRevealOrder = {}
	--   didWarnAboutTailOptions = {}
	DidWarn.didWarnAboutDefaultPropsOnFunctionComponent = {}
end

local function reconcileChildren(current: Fiber | nil, workInProgress: Fiber, nextChildren: any, renderLanes: Lanes)
	if current == nil then
		-- If this is a fresh new component that hasn't been rendered yet, we
		-- won't update its child set by applying minimal side-effects. Instead,
		-- we will add them all to the child before it gets rendered. That means
		-- we can optimize this reconciliation pass by not tracking side-effects.
		workInProgress.child = mountChildFibers(workInProgress, nil, nextChildren, renderLanes)
	else
		-- If the current child is the same as the work in progress, it means that
		-- we haven't yet started any work on these children. Therefore, we use
		-- the clone algorithm to create a copy of all the current children.

		-- If we had any progressed work already, that is invalid at this point so
		-- let's throw it out.
		workInProgress.child = reconcileChildFibers(workInProgress, (current :: Fiber).child, nextChildren, renderLanes)
	end
end

local function forceUnmountCurrentAndReconcile(
	current: Fiber,
	workInProgress: Fiber,
	nextChildren: any,
	renderLanes: Lanes
)
	-- This function is fork of reconcileChildren. It's used in cases where we
	-- want to reconcile without matching against the existing set. This has the
	-- effect of all current children being unmounted; even if the type and key
	-- are the same, the old child is unmounted and a new child is created.
	--
	-- To do this, we're going to go through the reconcile algorithm twice. In
	-- the first pass, we schedule a deletion for all the current children by
	-- passing nil.
	workInProgress.child = reconcileChildFibers(workInProgress, current.child, nil, renderLanes)
	-- In the second pass, we mount the new children. The trick here is that we
	-- pass nil in place of where we usually pass the current child set. This has
	-- the effect of remounting all children regardless of whether their
	-- identities match.
	workInProgress.child = reconcileChildFibers(workInProgress, nil, nextChildren, renderLanes)
end

local function updateForwardRef(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	renderLanes: Lanes
)
	-- TODO: current can be non-null here even if the component
	-- hasn't yet mounted. This happens after the first render suspends.
	-- We'll need to figure out if this is fine or can cause issues.

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if workInProgress.type ~= workInProgress.elementType then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			-- deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes = Component.propTypes
			local validateProps = Component.validateProps
			if innerPropTypes or validateProps then
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(Component)
				)
			end
		end
	end

	local render = Component.render
	local ref = workInProgress.ref

	-- The rest is a fork of updateFunctionComponent
	local nextChildren
	prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)
	if __DEV__ then
		ReactCurrentOwner.current = workInProgress
		setIsRendering(true)
		nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes)
		if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			disableLogs()
			local ok, result =
				xpcall(renderWithHooks, describeError, current, workInProgress, render, nextProps, ref, renderLanes)
			if ok then
				nextChildren = result
			end
			-- finally
			reenableLogs()

			if not ok then
				error(result)
			end
		end
		setIsRendering(false)
	else
		nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes)
	end

	if current ~= nil and not didReceiveUpdate then
		bailoutHooks(current, workInProgress, renderLanes)
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

local function updateMemoComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	updateLanes: Lanes,
	renderLanes: Lanes
): nil | Fiber
	if current == nil then
		local type_ = Component.type
		if
			isSimpleFunctionComponent(type_)
			and Component.compare == nil
			-- SimpleMemoComponent codepath doesn't resolve outer props either.
			and Component.defaultProps == nil
		then
			local resolvedType = type_
			if __DEV__ then
				resolvedType = resolveFunctionForHotReloading(type_)
			end
			-- If this is a plain function component without default props,
			-- and with only the default shallow comparison, we upgrade it
			-- to a SimpleMemoComponent to allow fast path updates.
			workInProgress.tag = SimpleMemoComponent
			workInProgress.type = resolvedType
			if __DEV__ then
				validateFunctionComponentInDev(workInProgress, type_)
			end
			return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, updateLanes, renderLanes)
		end
		if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
			-- deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes
			local validateProps
			-- deviation: avoid accessing propTypes on a function, Lua doesn't support fields on functions
			if type(type_) == "table" then
				innerPropTypes = type_.propTypes
				validateProps = type_.validateProps
			end

			if innerPropTypes or validateProps then
				-- Inner memo component props aren't currently validated in createElement.
				-- We could move it there, but we'd still need this for lazy code path.
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(type_)
				)
			end
		end
		local child = createFiberFromTypeAndProps(
			Component.type,
			nil,
			nextProps,
			workInProgress,
			workInProgress.mode,
			renderLanes
		)
		child.ref = workInProgress.ref
		child.return_ = workInProgress
		workInProgress.child = child
		return child
	end
	-- TODO Deviation: remove redefinition + typecast when this lands: CLI-38793
	-- NOTE: the if clause above returns early if current is nil
	local current = current :: Fiber
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local type_ = Component.type
		-- deviation: adds support for legacy Roact's validateProps()
		local innerPropTypes
		local validateProps
		-- deviation: only check for propTypes on class components, Lua doesn't support fields on functions
		if type(type_) == "table" then
			innerPropTypes = type_.propTypes
			validateProps = type_.validateProps
		end

		if innerPropTypes or validateProps then
			-- Inner memo component props aren't currently validated in createElement.
			-- We could move it there, but we'd still need this for lazy code path.
			checkPropTypes(
				innerPropTypes,
				validateProps,
				nextProps, -- Resolved props
				"prop",
				getComponentName(type_)
			)
		end
	end
	local currentChild = (current.child :: any) :: Fiber -- This is always exactly one child
	if not ReactFiberLane.includesSomeLane(updateLanes, renderLanes) then
		-- This will be the props with resolved defaultProps,
		-- unlike current.memoizedProps which will be the unresolved ones.
		local prevProps = currentChild.memoizedProps
		-- Default to shallow comparison
		local compare = Component.compare
		if compare == nil then
			compare = shallowEqual
		end
		if compare(prevProps, nextProps) and current.ref == workInProgress.ref then
			return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		end
	end
	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	local newChild = createWorkInProgress(currentChild, nextProps)
	newChild.ref = workInProgress.ref
	newChild.return_ = workInProgress
	workInProgress.child = newChild
	return newChild
end

function updateSimpleMemoComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	updateLanes: Lanes,
	renderLanes: Lanes
): nil | Fiber
	-- TODO: current can be non-null here even if the component
	-- hasn't yet mounted. This happens when the inner render suspends.
	-- We'll need to figure out if this is fine or can cause issues.

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if workInProgress.type ~= workInProgress.elementType then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			local outerMemoType = workInProgress.elementType
			if outerMemoType["$$typeof"] == REACT_LAZY_TYPE then
				-- We warn when you define propTypes on lazy()
				-- so let's just skip over it to find memo() outer wrapper.
				-- Inner props for memo are validated later.
				local lazyComponent: LazyComponentType<any, any> = outerMemoType
				local payload = lazyComponent._payload
				local init = lazyComponent._init
				local ok, result = xpcall(init, describeError, payload)
				if ok then
					outerMemoType = result
				else
					outerMemoType = nil
				end
				-- Inner propTypes will be validated in the function component path.
				-- deviation: adds support for legacy Roact's validateProps()
				local outerPropTypes
				local validateProps
				-- deviation: avoid accessing propTypes on a function, Lua doesn't support fields on functions
				if outerMemoType ~= nil and type(outerMemoType) == "table" then
					outerPropTypes = (outerMemoType :: any).propTypes
					-- deviation: support legacy Roact's equivalent of propTypes
					validateProps = (outerMemoType :: any).validateProps
				end

				if outerPropTypes or validateProps then
					checkPropTypes(
						outerPropTypes,
						validateProps,
						nextProps, -- Resolved (SimpleMemoComponent has no defaultProps)
						"prop",
						getComponentName(outerMemoType)
					)
				end
			end
		end
	end
	if current ~= nil then
		-- TODO Deviation: remove redefinition + typecast when this lands: CLI-38793
		-- This unfortunately breaks if current gets reassigned somewhere in this if clause
		local current = current :: Fiber
		local prevProps = current.memoizedProps
		-- deviation: replacing ternary operator
		local preventBailout = true
		if __DEV__ then
			preventBailout = workInProgress.type == current.type
		end
		if
			shallowEqual(prevProps, nextProps)
			and current.ref == workInProgress.ref
			-- Prevent bailout if the implementation changed due to hot reload.
			and preventBailout
		then
			didReceiveUpdate = false
			if not ReactFiberLane.includesSomeLane(renderLanes, updateLanes) then
				-- The pending lanes were cleared at the beginning of beginWork. We're
				-- about to bail out, but there might be other lanes that weren't
				-- included in the current render. Usually, the priority level of the
				-- remaining updates is accumlated during the evaluation of the
				-- component (i.e. when processing the update queue). But since since
				-- we're bailing out early *without* evaluating the component, we need
				-- to account for it here, too. Reset to the value of the current fiber.
				-- NOTE: This only applies to SimpleMemoComponent, not MemoComponent,
				-- because a MemoComponent fiber does not have hooks or an update queue
				-- rather, it wraps around an inner component, which may or may not
				-- contains hooks.
				-- TODO: Move the reset at in beginWork out of the common path so that
				-- this is no longer necessary.
				workInProgress.lanes = current.lanes
				return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
			elseif bit32.band(current.flags, ForceUpdateForLegacySuspense) ~= NoFlags then
				-- This is a special case that only exists for legacy mode.
				-- See https://github.com/facebook/react/pull/19216.
				didReceiveUpdate = true
			end
		end
	end
	return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes)
end

local function updateOffscreenComponent(current: Fiber?, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
	local nextProps: OffscreenProps = workInProgress.pendingProps
	local nextChildren = nextProps.children

	local prevState: OffscreenState?
	if current ~= nil then
		-- FIXME: remove :: recast once Luau understands if-statement nil checks
		prevState = (current :: Fiber).memoizedState
	end

	if nextProps.mode == "hidden" or nextProps.mode == "unstable-defer-without-hiding" then
		if bit32.band(workInProgress.mode, ConcurrentMode) == NoMode then
			-- In legacy sync mode, don't defer the subtree. Render it now.
			-- TODO: Figure out what we should do in Blocking mode.
			local nextState: OffscreenState = {
				baseLanes = ReactFiberLane.NoLanes,
			}
			workInProgress.memoizedState = nextState
			pushRenderLanes(workInProgress, renderLanes)
		-- TODO: recast ReactFiberLane.OffscreenLane to type Lane
		elseif not ReactFiberLane.includesSomeLane(renderLanes, ReactFiberLane.OffscreenLane) then
			local nextBaseLanes
			if prevState ~= nil then
				-- FIXME: remove :: recast once Luau understands if-statement nil check
				local prevBaseLanes = (prevState :: OffscreenState).baseLanes
				nextBaseLanes = ReactFiberLane.mergeLanes(prevBaseLanes, renderLanes)
			else
				nextBaseLanes = renderLanes
			end

			-- Schedule this fiber to re-render at offscreen priority. Then bailout.
			if enableSchedulerTracing then
				markSpawnedWork(ReactFiberLane.OffscreenLane)
			end

			-- deviation: unchain multiple assignment into two discrete assignments.
			workInProgress.childLanes = ReactFiberLane.laneToLanes(ReactFiberLane.OffscreenLane)
			workInProgress.lanes = workInProgress.childLanes

			local nextState: OffscreenState = {
				baseLanes = nextBaseLanes,
			}
			workInProgress.memoizedState = nextState
			-- We're about to bail out, but we need to push this to the stack anyway
			-- to avoid a push/pop misalignment.
			pushRenderLanes(workInProgress, nextBaseLanes)
			return nil
		else
			-- Rendering at offscreen, so we can clear the base lanes.
			local nextState: OffscreenState = {
				baseLanes = ReactFiberLane.NoLanes,
			}
			workInProgress.memoizedState = nextState
			-- Push the lanes that were skipped when we bailed out.
			local subtreeRenderLanes = renderLanes

			-- deviation: ternary converted to if statement
			if prevState ~= nil then
				-- FIXME: remove :: recast once Luau understands if-statement nil check
				subtreeRenderLanes = (prevState :: OffscreenState).baseLanes
			end

			pushRenderLanes(workInProgress, subtreeRenderLanes)
		end
	else
		local subtreeRenderLanes
		if prevState ~= nil then
			-- FIXME: remove :: recast once Luau understands if-statement nil check
			subtreeRenderLanes = ReactFiberLane.mergeLanes((prevState :: OffscreenState).baseLanes, renderLanes)
			-- Since we're not hidden anymore, reset the state
			workInProgress.memoizedState = nil
		else
			-- We weren't previously hidden, and we still aren't, so there's nothing
			-- special to do. Need to push to the stack regardless, though, to avoid
			-- a push/pop misalignment.
			subtreeRenderLanes = renderLanes
		end
		pushRenderLanes(workInProgress, subtreeRenderLanes)
	end

	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

-- NOTE: These happen to have identical begin phases, for now. We shouldn't hold
-- ourselves to this constraint, though. If the behavior diverges, we should
-- fork the function.
local updateLegacyHiddenComponent = updateOffscreenComponent

function updateFragment(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	local nextChildren = workInProgress.pendingProps
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

function updateMode(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	local nextChildren = workInProgress.pendingProps.children
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

function updateProfiler(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	if enableProfilerTimer then
		-- Reset effect durations for the next eventual effect phase.
		-- These are reset during render to allow the DevTools commit hook a chance to read them,
		local stateNode = workInProgress.stateNode
		stateNode.effectDuration = 0
		stateNode.passiveEffectDuration = 0
	end
	local nextProps = workInProgress.pendingProps
	local nextChildren = nextProps.children
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

local function markRef(current: Fiber | nil, workInProgress: Fiber)
	local ref = workInProgress.ref
	if (current == nil and ref ~= nil) or (current ~= nil and (current :: Fiber).ref ~= ref) then
		-- Schedule a Ref effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Ref)
	end
end

function updateFunctionComponent(current, workInProgress, Component, nextProps: any, renderLanes)
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		-- deviation: function components can't have props in Lua
		if type(Component) ~= "function" and (workInProgress.type ~= workInProgress.elementType) then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			-- deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes
			local validateProps
			-- deviation: Roact won't support propTypes on functional components
			if type(Component) == "table" then
				innerPropTypes = (Component :: any).propTypes
				validateProps = (Component :: any).validateProps
			end

			if innerPropTypes or validateProps then
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(Component)
				)
			end
		end
	end

	local context
	if not disableLegacyContext then
		local unmaskedContext = getUnmaskedContext(workInProgress, Component, true)
		context = getMaskedContext(workInProgress, unmaskedContext)
	end

	local nextChildren
	prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)
	if __DEV__ then
		ReactCurrentOwner.current = workInProgress
		setIsRendering(true)
		nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes)
		if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			disableLogs()
			local ok, result = xpcall(
				renderWithHooks,
				describeError,
				current,
				workInProgress,
				Component,
				nextProps,
				context,
				renderLanes
			)
			-- finally
			reenableLogs()
			if ok then
				nextChildren = result
			else
				error(result)
			end
		end
		setIsRendering(false)
	else
		nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes)
	end

	if current ~= nil and not didReceiveUpdate then
		bailoutHooks(current, workInProgress, renderLanes)
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

-- function updateBlock<Props, Data>(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   block: BlockComponent<Props, Data>,
--   nextProps: any,
--   renderLanes: Lanes,
-- )
--   -- TODO: current can be non-null here even if the component
--   -- hasn't yet mounted. This happens after the first render suspends.
--   -- We'll need to figure out if this is fine or can cause issues.

--   local render = block._render
--   local data = block._data

--   -- The rest is a fork of updateFunctionComponent
--   local nextChildren
--   prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)
--   if  __DEV__ then
--     ReactCurrentOwner.current = workInProgress
--     setIsRendering(true)
--     nextChildren = renderWithHooks(
--       current,
--       workInProgress,
--       render,
--       nextProps,
--       data,
--       renderLanes,
--     )
--     if
--       debugRenderPhaseSideEffectsForStrictMode and
--       workInProgress.mode & StrictMode
--     )
--       disableLogs()
--       try {
--         nextChildren = renderWithHooks(
--           current,
--           workInProgress,
--           render,
--           nextProps,
--           data,
--           renderLanes,
--         )
--       } finally {
--         reenableLogs()
--       end
--     end
--     setIsRendering(false)
--   else
--     nextChildren = renderWithHooks(
--       current,
--       workInProgress,
--       render,
--       nextProps,
--       data,
--       renderLanes,
--     )
--   end

--   if current ~= nil and !didReceiveUpdate)
--     bailoutHooks(current, workInProgress, renderLanes)
--     return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
--   end

--   -- React DevTools reads this flag.
--   workInProgress.flags |= PerformedWork
--   reconcileChildren(current, workInProgress, nextChildren, renderLanes)
--   return workInProgress.child
-- end

-- FIXME: type refinement
-- local function updateClassComponent(
--   current: Fiber | nil,
--   ...
-- )
local function updateClassComponent(
	current: any,
	workInProgress: Fiber,
	Component: any,
	nextProps: any,
	renderLanes: Lanes
)
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if workInProgress.type ~= workInProgress.elementType then
			-- Lazy component props can't be validated in createElement
			-- because they're only guaranteed to be resolved here.
			-- deviation: adds support for legacy Roact's validateProps()
			local innerPropTypes = Component.propTypes
			local validateProps = Component.validateProps
			if innerPropTypes or validateProps then
				checkPropTypes(
					innerPropTypes,
					validateProps,
					nextProps, -- Resolved props
					"prop",
					getComponentName(Component)
				)
			end
		end
	end

	-- Push context providers early to prevent context stack mismatches.
	-- During mounting we don't know the child context yet as the instance doesn't exist.
	-- We will invalidate the child context in finishClassComponent() right after rendering.
	local hasContext
	if isLegacyContextProvider(Component) then
		hasContext = true
		pushLegacyContextProvider(workInProgress)
	else
		hasContext = false
	end
	-- deviation: pass in function to break cyclic require dependency
	prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)

	local instance = workInProgress.stateNode
	local shouldUpdate
	if instance == nil then
		if current ~= nil then
			-- A class component without an instance only mounts if it suspended
			-- inside a non-concurrent tree, in an inconsistent state. We want to
			-- treat it like a new mount, even though an empty version of it already
			-- committed. Disconnect the alternate pointers.
			current.alternate = nil
			workInProgress.alternate = nil
			-- Since this is conceptually a new fiber, schedule a Placement effect
			workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
		end
		-- In the initial pass we might need to construct the instance.
		constructClassInstance(workInProgress, Component, nextProps)
		mountClassInstance(workInProgress, Component, nextProps, renderLanes)
		shouldUpdate = true
	elseif current == nil then
		-- In a resume, we'll already have an instance we can reuse.
		shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes)
	else
		shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes)
	end
	local nextUnitOfWork =
		finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes)
	if __DEV__ then
		local inst = workInProgress.stateNode
		if shouldUpdate and inst.props ~= nextProps then
			if not exports.didWarnAboutReassigningProps then
				console.error(
					"It looks like %s is reassigning its own `this.props` while rendering. "
						.. "This is not supported and can lead to confusing bugs.",
					getComponentName(workInProgress.type) or "a component"
				)
			end
			exports.didWarnAboutReassigningProps = true
		end
	end
	return nextUnitOfWork
end

function finishClassComponent(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: any,
	shouldUpdate: boolean,
	hasContext: boolean,
	renderLanes: Lanes
)
	-- Refs should update even if shouldComponentUpdate returns false
	markRef(current, workInProgress)

	local didCaptureError = bit32.band(workInProgress.flags, DidCapture) ~= NoFlags

	if not shouldUpdate and not didCaptureError then
		-- Context providers should defer to sCU for rendering
		if hasContext then
			invalidateContextProvider(workInProgress, Component, false)
		end

		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end

	local instance = workInProgress.stateNode

	-- Rerender
	ReactCurrentOwner.current = workInProgress
	local nextChildren
	if
		didCaptureError
		and (Component.getDerivedStateFromError == nil or type(Component.getDerivedStateFromError) ~= "function")
	then
		-- If we captured an error, but getDerivedStateFromError is not defined,
		-- unmount all the children. componentDidCatch will schedule an update to
		-- re-render a fallback. This is temporary until we migrate everyone to
		-- the new API.
		-- TODO: Warn in a future release.
		nextChildren = nil

		if enableProfilerTimer then
			stopProfilerTimerIfRunning(workInProgress)
		end
	else
		if __DEV__ then
			setIsRendering(true)
			-- deviation: Call with ':' instead of '.' so that render can access self
			nextChildren = instance:render()
			if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
				disableLogs()
				-- deviation: Pass instance so that render can access self
				local ok, result = xpcall(instance.render, describeError, instance)
				-- finally
				reenableLogs()
				if not ok then
					error(result)
				end
			end
			setIsRendering(false)
		else
			-- deviation: Call with ':' instead of '.' so that render can access self
			nextChildren = instance:render()
		end
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	if current ~= nil and didCaptureError then
		-- If we're recovering from an error, reconcile without reusing any of
		-- the existing children. Conceptually, the normal children and the children
		-- that are shown on error are two different sets, so we shouldn't reuse
		-- normal children even if their identities match.
		forceUnmountCurrentAndReconcile(current :: Fiber, workInProgress, nextChildren, renderLanes)
	else
		reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	end

	-- Memoize state using the values we just used to render.
	-- TODO: Restructure so we never read values from the instance.
	workInProgress.memoizedState = instance.state

	-- The context might have changed so we need to recalculate it.
	if hasContext then
		invalidateContextProvider(workInProgress, Component, true)
	end

	return workInProgress.child
end

local function pushHostRootContext(workInProgress)
	-- FIXME (roblox): type refinement '(workInProgress.stateNode: FiberRoot)'
	local root = workInProgress.stateNode
	if root.pendingContext then
		pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext ~= root.context)
	elseif root.context then
		-- Should always be set
		pushTopLevelContextObject(workInProgress, root.context, false)
	end
	pushHostContainer(workInProgress, root.containerInfo)
end

local function updateHostRoot(current, workInProgress, renderLanes)
	pushHostRootContext(workInProgress)
	local updateQueue = workInProgress.updateQueue
	invariant(
		current ~= nil and updateQueue ~= nil,
		"If the root does not have an updateQueue, we should have already "
			.. "bailed out. This error is likely caused by a bug in React. Please "
			.. "file an issue."
	)
	local nextProps = workInProgress.pendingProps
	local prevState = workInProgress.memoizedState
	local prevChildren
	if prevState ~= nil then
		prevChildren = prevState.element
	end
	cloneUpdateQueue(current, workInProgress)
	processUpdateQueue(workInProgress, nextProps, nil, renderLanes)
	local nextState = workInProgress.memoizedState
	-- Caution: React DevTools currently depends on this property
	-- being called "element".
	local nextChildren = nextState.element
	if nextChildren == prevChildren then
		resetHydrationState()
		return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
	end
	local root: FiberRoot = workInProgress.stateNode
	if root.hydrate and enterHydrationState(workInProgress) then
		-- If we don't have any current children this might be the first pass.
		-- We always try to hydrate. If this isn't a hydration pass there won't
		-- be any children to hydrate which is effectively the same thing as
		-- not hydrating.

		if supportsHydration then
			local mutableSourceEagerHydrationData = root.mutableSourceEagerHydrationData
			if mutableSourceEagerHydrationData ~= nil then
				for i = 1, #mutableSourceEagerHydrationData, 2 do
					-- FIXME (roblox): type refinement
					-- local mutableSource = ((mutableSourceEagerHydrationData[
					--   i
					-- ]: any): MutableSource<any>)
					local mutableSource = mutableSourceEagerHydrationData[i]
					local version = mutableSourceEagerHydrationData[i + 1]
					setWorkInProgressVersion(mutableSource, version)
				end
			end
		end

		local child = mountChildFibers(workInProgress, nil, nextChildren, renderLanes)
		workInProgress.child = child

		local node = child
		while node do
			-- Mark each child as hydrating. This is a fast path to know whether this
			-- tree is part of a hydrating tree. This is used to determine if a child
			-- node has fully mounted yet, and for scheduling event replaying.
			-- Conceptually this is similar to Placement in that a new subtree is
			-- inserted into the React tree here. It just happens to not need DOM
			-- mutations because it already exists.
			node.flags = bit32.bor(bit32.band(node.flags, bit32.bnot(Placement)), Hydrating)
			node = node.sibling
		end
	else
		-- Otherwise reset hydration state in case we aborted and resumed another
		-- root.
		reconcileChildren(current, workInProgress, nextChildren, renderLanes)
		resetHydrationState()
	end
	return workInProgress.child
end

-- FIXME (roblox): type refinement
-- local function updateHostComponent(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   renderLanes: Lanes
-- )
local function updateHostComponent(current: any, workInProgress: Fiber, renderLanes: Lanes)
	pushHostContext(workInProgress)

	if current == nil then
		tryToClaimNextHydratableInstance(workInProgress)
	end

	local type_ = workInProgress.type
	local nextProps = workInProgress.pendingProps
	local prevProps
	if current ~= nil then
		prevProps = current.memoizedProps
	end

	local nextChildren = nextProps.children
	local isDirectTextChild = shouldSetTextContent(type_, nextProps)

	if isDirectTextChild then
		-- We special case a direct text child of a host node. This is a common
		-- case. We won't handle it as a reified child. We will instead handle
		-- this in the host environment that also has access to this prop. That
		-- avoids allocating another HostText fiber and traversing it.
		nextChildren = nil
	elseif prevProps ~= nil and shouldSetTextContent(type_, prevProps) then
		-- If we're switching from a direct text child to a normal child, or to
		-- empty, we need to schedule the text content to be reset.
		workInProgress.flags = bit32.bor(workInProgress.flags, ContentReset)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)

	markRef(current, workInProgress)
	reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	return workInProgress.child
end

local function updateHostText(current, workInProgress)
	if current == nil then
		tryToClaimNextHydratableInstance(workInProgress)
	end
	-- Nothing to do here. This is terminal. We'll do the completion step
	-- immediately after.
	return nil
end

local function mountLazyComponent(_current, workInProgress, elementType, updateLanes, renderLanes)
	if _current ~= nil then
		-- A lazy component only mounts if it suspended inside a non-
		-- concurrent tree, in an inconsistent state. We want to treat it like
		-- a new mount, even though an empty version of it already committed.
		-- Disconnect the alternate pointers.
		_current.alternate = nil
		workInProgress.alternate = nil
		-- Since this is conceptually a new fiber, schedule a Placement effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
	end

	local props = workInProgress.pendingProps
	local lazyComponent: LazyComponentType<any, any> = elementType
	local payload = lazyComponent._payload
	local init = lazyComponent._init
	local Component = init(payload)
	-- Store the unwrapped component in the type.
	workInProgress.type = Component
	workInProgress.tag = resolveLazyComponentTag(Component)
	local resolvedTag = workInProgress.tag
	local resolvedProps = resolveDefaultProps(Component, props)
	local child
	if resolvedTag == FunctionComponent then
		if __DEV__ then
			validateFunctionComponentInDev(workInProgress, Component)
			Component = resolveFunctionForHotReloading(Component)
			workInProgress.type = Component
		end
		child = updateFunctionComponent(nil, workInProgress, Component, resolvedProps, renderLanes)
		return child
	elseif resolvedTag == ClassComponent then
		if __DEV__ then
			Component = resolveClassForHotReloading(Component)
			workInProgress.type = Component
		end
		child = updateClassComponent(nil, workInProgress, Component, resolvedProps, renderLanes)
		return child
	elseif resolvedTag == ForwardRef then
		if __DEV__ then
			Component = resolveForwardRefForHotReloading(Component)
			workInProgress.type = Component
		end
		child = updateForwardRef(nil, workInProgress, Component, resolvedProps, renderLanes)
		return child
	elseif resolvedTag == MemoComponent then
		if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
			if workInProgress.type ~= workInProgress.elementType then
				-- deviation: adds support for legacy Roact's validateProps()
				local outerPropTypes = Component.propTypes
				local validateProps = Component.validateProps
				if outerPropTypes or validateProps then
					checkPropTypes(
						outerPropTypes,
						validateProps,
						resolvedProps, -- Resolved for outer only
						"prop",
						getComponentName(Component)
					)
				end
			end
		end
		child = updateMemoComponent(
			nil,
			workInProgress,
			Component,
			resolveDefaultProps(Component.type, resolvedProps), -- The inner type can have defaults too
			updateLanes,
			renderLanes
		)
		return child
		-- elseif resolvedTag == Block then
		--   unimplemented("Blocks API")
		--   if enableBlocksAPI then
		--     -- TODO: Resolve for Hot Reloading.
		--     child = updateBlock(
		--       nil,
		--       workInProgress,
		--       Component,
		--       props,
		--       renderLanes,
		--     )
		--     return child
		--   end
		--   -- deviation: break
	end
	local hint = ""
	if __DEV__ then
		if Component ~= nil and type(Component) == "table" and Component["$$typeof"] == REACT_LAZY_TYPE then
			hint = " Did you wrap a component in React.lazy() more than once?"
		elseif type(Component) == "table" and Component["$$typeof"] == nil then
			hint = "\n" .. inspect(Component)
		end
	end
	-- This message intentionally doesn't mention ForwardRef or MemoComponent
	-- because the fact that it's a separate type of work is an
	-- implementation detail.
	invariant(
		false,
		"Element type is invalid. Received a promise that resolves to: %s. "
			.. "Lazy element type must resolve to a class or function.%s",
		tostring(Component),
		hint
	)
	-- deviation: add nil to satisfy Luau, which doesn't doesn't bubble up the unconditional error() inside invariant
	return nil
end

function mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes)
	if _current ~= nil then
		-- An incomplete component only mounts if it suspended inside a non-
		-- concurrent tree, in an inconsistent state. We want to treat it like
		-- a new mount, even though an empty version of it already committed.
		-- Disconnect the alternate pointers.
		_current.alternate = nil
		workInProgress.alternate = nil
		-- Since this is conceptually a new fiber, schedule a Placement effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
	end

	-- Promote the fiber to a class and try rendering again.
	workInProgress.tag = ClassComponent

	-- The rest of this function is a fork of `updateClassComponent`

	-- Push context providers early to prevent context stack mismatches.
	-- During mounting we don't know the child context yet as the instance doesn't exist.
	-- We will invalidate the child context in finishClassComponent() right after rendering.
	local hasContext
	if isLegacyContextProvider(Component) then
		hasContext = true
		pushLegacyContextProvider(workInProgress)
	else
		hasContext = false
	end
	prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)

	constructClassInstance(workInProgress, Component, nextProps)
	mountClassInstance(workInProgress, Component, nextProps, renderLanes)

	return finishClassComponent(nil, workInProgress, Component, true, hasContext, renderLanes)
end

local function mountIndeterminateComponent(current, workInProgress, Component, renderLanes)
	if current ~= nil then
		-- An indeterminate component only mounts if it suspended inside a non-
		-- concurrent tree, in an inconsistent state. We want to treat it like
		-- a new mount, even though an empty version of it already committed.
		-- Disconnect the alternate pointers.
		current.alternate = nil
		workInProgress.alternate = nil
		-- Since this is conceptually a new fiber, schedule a Placement effect
		workInProgress.flags = bit32.bor(workInProgress.flags, Placement)
	end

	local props = workInProgress.pendingProps
	local context
	if not disableLegacyContext then
		local unmaskedContext = getUnmaskedContext(workInProgress, Component, false)
		context = getMaskedContext(workInProgress, unmaskedContext)
	end

	prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)
	local value

	if __DEV__ then
		if
			-- deviation: Instead of checking for the prototype, see if Component is a
			-- table with a render function
			type(Component) == "table" and type(Component.render) == "function"
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutBadClass[componentName] then
				console.error(
					"The <%s /> component appears to have a render method, but doesn't extend React.Component. "
						.. "This is likely to cause errors. Change %s to extend React.Component instead.",
					componentName,
					componentName
				)
				DidWarn.didWarnAboutBadClass[componentName] = true
			end
		end

		if bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress)
		end

		setIsRendering(true)
		ReactCurrentOwner.current = workInProgress
		value = renderWithHooks(nil, workInProgress, Component, props, context, renderLanes)
		setIsRendering(false)
	else
		value = renderWithHooks(nil, workInProgress, Component, props, context, renderLanes)
	end
	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	-- deviation START: cache type(value)
	local typeofValue = type(value)
	-- deviation END

	if __DEV__ then
		-- Support for module components is deprecated and is removed behind a flag.
		-- Whether or not it would crash later, we want to show a good message in DEV first.
		if
			value ~= nil
			and typeofValue == "table"
			and type(value.render) == "function"
			and value["$$typeof"] == nil
		then
			local componentName = getComponentName(Component) or "Unknown"
			if not DidWarn.didWarnAboutModulePatternComponent[componentName] then
				console.error(
					"The <%s /> component appears to be a function component that returns a class instance. "
						.. "Change %s to a class that extends React.Component instead. ",
					-- deviation: Don't print JS-specific remediation advice
					-- "If you can't use a class try assigning the prototype on the function as a workaround. " ..
					-- "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " ..
					-- "cannot be called with `new` by React.",
					componentName,
					componentName
					-- componentName
				)
				DidWarn.didWarnAboutModulePatternComponent[componentName] = true
			end
		end
	end

	if
		-- Run these checks in production only if the flag is off.
		-- Eventually we'll delete this branch altogether.
		not disableModulePatternComponents
		and value ~= nil
		and typeofValue == "table"
		and type(value.render) == "function"
		and value["$$typeof"] == nil
	then
		if __DEV__ then
			local componentName = getComponentName(Component) or "Unknown"
			if not DidWarn.didWarnAboutModulePatternComponent[componentName] then
				console.error(
					"The <%s /> component appears to be a function component that returns a class instance. "
						.. "Change %s to a class that extends React.Component instead. "
						-- deviation: Don't print JS-specific remediation advice
						-- "If you can't use a class try assigning the prototype on the function as a workaround. " ..
						-- "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " ..
						-- "cannot be called with `new` by React.",
						.. componentName,
					componentName
					-- componentName
				)
				DidWarn.didWarnAboutModulePatternComponent[componentName] = true
			end
		end

		-- Proceed under the assumption that this is a class instance
		workInProgress.tag = ClassComponent

		-- Throw out any hooks that were used.
		workInProgress.memoizedState = nil
		workInProgress.updateQueue = nil

		-- Push context providers early to prevent context stack mismatches.
		-- During mounting we don't know the child context yet as the instance doesn't exist.
		-- We will invalidate the child context in finishClassComponent() right after rendering.
		local hasContext = false
		if isLegacyContextProvider(Component) then
			hasContext = true
			pushLegacyContextProvider(workInProgress)
		else
			hasContext = false
		end

		-- deviation: Lua doesn't need to coerce `T | null | undefined` to `T | null`
		workInProgress.memoizedState = value.state

		initializeUpdateQueue(workInProgress)

		-- deviation: don't access field on function
		local getDerivedStateFromProps
		if type(Component) ~= "function" then
			getDerivedStateFromProps = (Component :: React_Component<any, any>).getDerivedStateFromProps
		end
		if getDerivedStateFromProps ~= nil and type(getDerivedStateFromProps) == "function" then
			applyDerivedStateFromProps(workInProgress, Component, getDerivedStateFromProps, props)
		end

		adoptClassInstance(workInProgress, value)
		mountClassInstance(workInProgress, Component, props, renderLanes)
		return finishClassComponent(nil, workInProgress, Component, true, hasContext, renderLanes)
	else
		-- Proceed under the assumption that this is a function component
		workInProgress.tag = FunctionComponent
		if __DEV__ then
			if disableLegacyContext and Component.contextTypes then
				console.error(
					"%s uses the legacy contextTypes API which is no longer supported. "
						.. "Use React.createContext() with React.useContext() instead.",
					getComponentName(Component) or "Unknown"
				)
			end

			if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
				disableLogs()
				local ok, result =
					xpcall(renderWithHooks, describeError, nil, workInProgress, Component, props, context, renderLanes)
				-- finally
				reenableLogs()
				if ok then
					value = result
				else
					error(result)
				end
			end
		end
		reconcileChildren(nil, workInProgress, value, renderLanes)
		if __DEV__ then
			validateFunctionComponentInDev(workInProgress, Component)
		end
		return workInProgress.child
	end
end

function validateFunctionComponentInDev(workInProgress: Fiber, Component: any)
	if __DEV__ then
		-- deviation: Lua doesn't allow fields on functions, so this never happens
		-- if Component then
		--   if Component.childContextTypes then
		--     console.error(
		--       '%s(...): childContextTypes cannot be defined on a function component.',
		--       Component.displayName or Component.name or 'Component'
		--     )
		--   end
		-- end
		if workInProgress.ref ~= nil then
			local info = ""
			local ownerName = getCurrentFiberOwnerNameInDevOrNull()
			if ownerName then
				info ..= "\n\nCheck the render method of `" .. ownerName .. "`."
			end

			local warningKey = ownerName or workInProgress._debugID or ""
			local debugSource = workInProgress._debugSource
			if debugSource then
				warningKey = debugSource.fileName .. ":" .. debugSource.lineNumber
			end
			if not DidWarn.didWarnAboutFunctionRefs[warningKey] then
				DidWarn.didWarnAboutFunctionRefs[warningKey] = true
				console.error(
					"Function components cannot be given refs. "
						.. "Attempts to access this ref will fail. "
						.. "Did you mean to use React.forwardRef()?%s",
					info
				)
			end
		end

		if
			warnAboutDefaultPropsOnFunctionComponents
			-- deviation: functions can't have fields in Lua
			and type(Component) ~= "function"
			and Component.defaultProps ~= nil
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutDefaultPropsOnFunctionComponent[componentName] then
				console.error(
					"%s: Support for defaultProps will be removed from function components "
						-- deviation: Don't print JS-specific remediation advice
						.. "in a future major release.", -- Use JavaScript default parameters instead.',
					componentName
				)
				DidWarn.didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true
			end
		end

		-- deviation: Lua functions can't have fields
		if
			type(Component) ~= "function"
			and Component.getDerivedStateFromProps ~= nil
			and type(Component.getDerivedStateFromProps) == "function"
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent[componentName] then
				console.error("%s: Function components do not support getDerivedStateFromProps.", componentName)
				DidWarn.didWarnAboutGetDerivedStateOnFunctionComponent[componentName] = true
			end
		end

		-- deviation: Lua functions can't have fields
		if
			type(Component) ~= "function"
			and Component.contextType ~= nil
			and type(Component.contextType) == "table"
		then
			local componentName = getComponentName(Component) or "Unknown"

			if not DidWarn.didWarnAboutContextTypeOnFunctionComponent[componentName] then
				console.error("%s: Function components do not support contextType.", componentName)
				DidWarn.didWarnAboutContextTypeOnFunctionComponent[componentName] = true
			end
		end
	end
end

local SUSPENDED_MARKER: SuspenseState = {
	dehydrated = nil,
	retryLane = ReactFiberLane.NoLane,
}

local function mountSuspenseOffscreenState(renderLanes: Lanes): OffscreenState
	return {
		baseLanes = renderLanes,
	}
end

local function updateSuspenseOffscreenState(prevOffscreenState: OffscreenState, renderLanes: Lanes): OffscreenState
	return {
		baseLanes = ReactFiberLane.mergeLanes(prevOffscreenState.baseLanes, renderLanes),
	}
end

-- TODO: Probably should inline this back
local function shouldRemainOnFallback(
	suspenseContext: SuspenseContext,
	current: nil | Fiber,
	workInProgress: Fiber,
	renderLanes: Lanes
)
	-- If we're already showing a fallback, there are cases where we need to
	-- remain on that fallback regardless of whether the content has resolved.
	-- For example, SuspenseList coordinates when nested content appears.
	if current ~= nil then
		local suspenseState: SuspenseState = (current :: Fiber).memoizedState
		if suspenseState == nil then
			-- Currently showing content. Don't hide it, even if ForceSuspenseFallack
			-- is true. More precise name might be "ForceRemainSuspenseFallback".
			-- NOTE: This is a factoring smell. Can't remain on a fallback if there's
			-- no fallback to remain on.
			return false
		end
	end

	-- Not currently showing content. Consult the Suspense context.
	return hasSuspenseContext(suspenseContext, ForceSuspenseFallback)
end

local function getRemainingWorkInPrimaryTree(current: Fiber, renderLanes)
	-- TODO: Should not remove render lanes that were pinged during this render
	return ReactFiberLane.removeLanes(current.childLanes, renderLanes)
end

-- deviation: predeclare these methods to resolve method declaration ordering
local updateSuspensePrimaryChildren
local mountDehydratedSuspenseComponent
local mountSuspensePrimaryChildren
local updateSuspenseFallbackChildren
local updateDehydratedSuspenseComponent

local function updateSuspenseComponent(current, workInProgress, renderLanes)
	local nextProps = workInProgress.pendingProps

	-- This is used by DevTools to force a boundary to suspend.
	if __DEV__ then
		if shouldSuspend(workInProgress) then
			workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
		end
	end

	local suspenseContext: SuspenseContext = suspenseStackCursor.current

	local showFallback = false
	local didSuspend = bit32.band(workInProgress.flags, DidCapture) ~= NoFlags

	if didSuspend or shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) then
		-- Something in this boundary's subtree already suspended. Switch to
		-- rendering the fallback children.
		showFallback = true
		workInProgress.flags = bit32.band(workInProgress.flags, bit32.bnot(DidCapture))
	else
		-- Attempting the main content
		if current == nil or current.memoizedState ~= nil then
			-- This is a new mount or this boundary is already showing a fallback state.
			-- Mark this subtree context as having at least one invisible parent that could
			-- handle the fallback state.
			-- Boundaries without fallbacks or should be avoided are not considered since
			-- they cannot handle preferred fallback states.
			if nextProps.fallback ~= nil and nextProps.unstable_avoidThisFallback ~= true then
				suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext)
			end
		end
	end

	suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)

	pushSuspenseContext(workInProgress, suspenseContext)

	-- OK, the next part is confusing. We're about to reconcile the Suspense
	-- boundary's children. This involves some custom reconcilation logic. Two
	-- main reasons this is so complicated.
	--
	-- First, Legacy Mode has different semantics for backwards compatibility. The
	-- primary tree will commit in an inconsistent state, so when we do the
	-- second pass to render the fallback, we do some exceedingly, uh, clever
	-- hacks to make that not totally break. Like transferring effects and
	-- deletions from hidden tree. In Concurrent Mode, it's much simpler,
	-- because we bailout on the primary tree completely and leave it in its old
	-- state, no effects. Same as what we do for Offscreen (except that
	-- Offscreen doesn't have the first render pass).
	--
	-- Second is hydration. During hydration, the Suspense fiber has a slightly
	-- different layout, where the child points to a dehydrated fragment, which
	-- contains the DOM rendered by the server.
	--
	-- Third, even if you set all that aside, Suspense is like error boundaries in
	-- that we first we try to render one tree, and if that fails, we render again
	-- and switch to a different tree. Like a try/catch block. So we have to track
	-- which branch we're currently rendering. Ideally we would model this using
	-- a stack.
	if current == nil then
		-- Initial mount
		-- If we're currently hydrating, try to hydrate this boundary.
		-- But only if this has a fallback.
		if nextProps.fallback ~= nil then
			tryToClaimNextHydratableInstance(workInProgress)
			-- This could've been a dehydrated suspense component.
			if enableSuspenseServerRenderer then
				local suspenseState: nil | SuspenseState = workInProgress.memoizedState
				if suspenseState ~= nil then
					local dehydrated = (suspenseState :: SuspenseState).dehydrated
					if dehydrated ~= nil then
						return mountDehydratedSuspenseComponent(workInProgress, dehydrated, renderLanes)
					end
				end
			end
		end

		local nextPrimaryChildren = nextProps.children
		local nextFallbackChildren = nextProps.fallback
		if showFallback then
			local fallbackFragment =
				mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes)
			local primaryChildFragment: Fiber = workInProgress.child :: any
			primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
			workInProgress.memoizedState = SUSPENDED_MARKER
			return fallbackFragment
		elseif nextProps.unstable_expectedLoadTime ~= nil and type(nextProps.unstable_expectedLoadTime) == "number" then
			-- This is a CPU-bound tree. Skip this tree and show a placeholder to
			-- unblock the surrounding content. Then immediately retry after the
			-- initial commit.
			local fallbackFragment =
				mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes)
			local primaryChildFragment: Fiber = workInProgress.child :: any
			primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
			workInProgress.memoizedState = SUSPENDED_MARKER

			-- Since nothing actually suspended, there will nothing to ping this to
			-- get it started back up to attempt the next item. While in terms of
			-- priority this work has the same priority as this current render, it's
			-- not part of the same transition once the transition has committed. If
			-- it's sync, we still want to yield so that it can be painted.
			-- Conceptually, this is really the same as pinging. We can use any
			-- RetryLane even if it's the one currently rendering since we're leaving
			-- it behind on this node.
			workInProgress.lanes = ReactFiberLane.SomeRetryLane
			if enableSchedulerTracing then
				markSpawnedWork(ReactFiberLane.SomeRetryLane)
			end
			return fallbackFragment
		else
			return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren, renderLanes)
		end
	else
		-- This is an update.

		-- If the current fiber has a SuspenseState, that means it's already showing
		-- a fallback.
		local prevState: nil | SuspenseState = current.memoizedState
		if prevState ~= nil then
			-- The current tree is already showing a fallback

			-- Special path for hydration
			if enableSuspenseServerRenderer then
				-- FIXME: remove :: when Luau understands ~= nil
				local dehydrated = (prevState :: SuspenseState).dehydrated

				if dehydrated ~= nil then
					if not didSuspend then
						return updateDehydratedSuspenseComponent(
							current,
							workInProgress,
							dehydrated,
							prevState,
							renderLanes
						)
					elseif workInProgress.memoizedState ~= nil then
						-- Something suspended and we should still be in dehydrated mode.
						-- Leave the existing child in place.
						workInProgress.child = current.child
						-- The dehydrated completion pass expects this flag to be there
						-- but the normal suspense pass doesn't.
						workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
						return nil
					else
						-- Suspended but we should no longer be in dehydrated mode.
						-- Therefore we now have to render the fallback.
						local nextPrimaryChildren = nextProps.children
						local nextFallbackChildren = nextProps.fallback
						local fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(
							current,
							workInProgress,
							nextPrimaryChildren,
							nextFallbackChildren,
							renderLanes
						)
						local primaryChildFragment: Fiber = workInProgress.child :: any
						primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
						workInProgress.memoizedState = SUSPENDED_MARKER
						return fallbackChildFragment
					end
				end
			end

			if showFallback then
				local nextFallbackChildren = nextProps.fallback
				local nextPrimaryChildren = nextProps.children
				local fallbackChildFragment = updateSuspenseFallbackChildren(
					current,
					workInProgress,
					nextPrimaryChildren,
					nextFallbackChildren,
					renderLanes
				)
				local primaryChildFragment: Fiber = workInProgress.child :: any
				local prevOffscreenState: OffscreenState | nil = (current.child :: any).memoizedState

				-- deviation: if/else in place of ternary
				if prevOffscreenState == nil then
					primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
				else
					-- FIXME: remove :: when Luau understands ~= nil
					primaryChildFragment.memoizedState =
						updateSuspenseOffscreenState(prevOffscreenState :: OffscreenState, renderLanes)
				end

				primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes)
				workInProgress.memoizedState = SUSPENDED_MARKER
				return fallbackChildFragment
			else
				local nextPrimaryChildren = nextProps.children
				local primaryChildFragment =
					updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes)
				workInProgress.memoizedState = nil
				return primaryChildFragment
			end
		else
			-- The current tree is not already showing a fallback.
			if showFallback then
				-- Timed out.
				local nextFallbackChildren = nextProps.fallback
				local nextPrimaryChildren = nextProps.children
				local fallbackChildFragment = updateSuspenseFallbackChildren(
					current,
					workInProgress,
					nextPrimaryChildren,
					nextFallbackChildren,
					renderLanes
				)
				local primaryChildFragment: Fiber = workInProgress.child :: any
				local prevOffscreenState: OffscreenState | nil = (current.child :: any).memoizedState

				-- deviation: if/else in place of ternary
				if prevOffscreenState == nil then
					primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes)
				else
					-- FIXME: remove :: once Luau understands nil check
					primaryChildFragment.memoizedState =
						updateSuspenseOffscreenState(prevOffscreenState :: OffscreenState, renderLanes)
				end

				primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes)
				-- Skip the primary children, and continue working on the
				-- fallback children.
				workInProgress.memoizedState = SUSPENDED_MARKER
				return fallbackChildFragment
			else
				-- Still haven't timed out. Continue rendering the children, like we
				-- normally do.
				local nextPrimaryChildren = nextProps.children
				local primaryChildFragment =
					updateSuspensePrimaryChildren(current, workInProgress, nextPrimaryChildren, renderLanes)
				workInProgress.memoizedState = nil
				return primaryChildFragment
			end
		end
	end
end

function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes)
	local mode = workInProgress.mode
	local primaryChildProps: OffscreenProps = {
		mode = "visible",
		children = primaryChildren,
	}
	local primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, renderLanes, nil)
	primaryChildFragment.return_ = workInProgress
	workInProgress.child = primaryChildFragment
	return primaryChildFragment
end

function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes)
	local mode = workInProgress.mode
	local progressedPrimaryFragment: Fiber | nil = workInProgress.child

	local primaryChildProps: OffscreenProps = {
		mode = "hidden",
		children = primaryChildren,
	}

	local primaryChildFragment
	local fallbackChildFragment
	if bit32.band(mode, BlockingMode) == NoMode and progressedPrimaryFragment ~= nil then
		-- In legacy mode, we commit the primary tree as if it successfully
		-- completed, even though it's in an inconsistent state.
		primaryChildFragment = progressedPrimaryFragment
		primaryChildFragment.childLanes = ReactFiberLane.NoLanes
		primaryChildFragment.pendingProps = primaryChildProps

		if enableProfilerTimer and bit32.band(workInProgress.mode, ProfileMode) ~= 0 then
			-- Reset the durations from the first pass so they aren't included in the
			-- final amounts. This seems counterintuitive, since we're intentionally
			-- not measuring part of the render phase, but this makes it match what we
			-- do in Concurrent Mode.
			primaryChildFragment.actualDuration = 0
			primaryChildFragment.actualStartTime = -1
			primaryChildFragment.selfBaseDuration = 0
			primaryChildFragment.treeBaseDuration = 0
		end

		fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
	else
		primaryChildFragment = createFiberFromOffscreen(primaryChildProps, mode, ReactFiberLane.NoLanes, nil)
		fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
	end

	primaryChildFragment.return_ = workInProgress
	fallbackChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = fallbackChildFragment
	workInProgress.child = primaryChildFragment
	return fallbackChildFragment
end

local function createWorkInProgressOffscreenFiber(current: Fiber, offscreenProps: OffscreenProps)
	-- The props argument to `createWorkInProgress` is `any` typed, so we use this
	-- wrapper function to constrain it.
	return createWorkInProgress(current, offscreenProps)
end

function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes)
	local currentPrimaryChildFragment: Fiber = current.child :: any
	local currentFallbackChildFragment: Fiber | nil = currentPrimaryChildFragment.sibling

	local primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
		mode = "visible",
		children = primaryChildren,
	})
	if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
		primaryChildFragment.lanes = renderLanes
	end
	primaryChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = nil
	if currentFallbackChildFragment ~= nil then
		-- Delete the fallback child fragment
		local deletions = workInProgress.deletions
		if deletions == nil then
			workInProgress.deletions = { currentFallbackChildFragment }
			-- TODO (effects) Rename this to better reflect its new usage (e.g. ChildDeletions)
			workInProgress.flags = bit32.bor(workInProgress.flags, Deletion)
		else
			table.insert(deletions, currentFallbackChildFragment)
		end
	end

	workInProgress.child = primaryChildFragment
	return primaryChildFragment
end

function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes)
	local mode = workInProgress.mode
	local currentPrimaryChildFragment: Fiber = current.child :: any
	local currentFallbackChildFragment: Fiber | nil = currentPrimaryChildFragment.sibling

	local primaryChildProps: OffscreenProps = {
		mode = "hidden",
		children = primaryChildren,
	}

	local primaryChildFragment
	if
		-- In legacy mode, we commit the primary tree as if it successfully
		-- completed, even though it's in an inconsistent state.
		bit32.band(mode, BlockingMode) == NoMode
		-- Make sure we're on the second pass, i.e. the primary child fragment was
		-- already cloned. In legacy mode, the only case where this isn't true is
		-- when DevTools forces us to display a fallback; we skip the first render
		-- pass entirely and go straight to rendering the fallback. (In Concurrent
		-- Mode, SuspenseList can also trigger this scenario, but this is a legacy-
		-- only codepath.)
		and workInProgress.child ~= currentPrimaryChildFragment
	then
		local progressedPrimaryFragment: Fiber = workInProgress.child
		primaryChildFragment = progressedPrimaryFragment
		primaryChildFragment.childLanes = ReactFiberLane.NoLanes
		primaryChildFragment.pendingProps = primaryChildProps

		if enableProfilerTimer and bit32.band(workInProgress.mode, ProfileMode) ~= 0 then
			-- Reset the durations from the first pass so they aren't included in the
			-- final amounts. This seems counterintuitive, since we're intentionally
			-- not measuring part of the render phase, but this makes it match what we
			-- do in Concurrent Mode.
			primaryChildFragment.actualDuration = 0
			primaryChildFragment.actualStartTime = -1
			primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration
			primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration
		end

		-- The fallback fiber was added as a deletion effect during the first pass.
		-- However, since we're going to remain on the fallback, we no longer want
		-- to delete it.
		workInProgress.deletions = nil
	else
		primaryChildFragment = createWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps)

		-- Since we're reusing a current tree, we need to reuse the flags, too.
		-- (We don't do this in legacy mode, because in legacy mode we don't re-use
		-- the current tree; see previous branch.)
		primaryChildFragment.subtreeFlags = bit32.band(currentPrimaryChildFragment.subtreeFlags, StaticMask)
	end
	local fallbackChildFragment
	if currentFallbackChildFragment ~= nil then
		fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren)
	else
		fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
		-- Needs a placement effect because the parent (the Suspense boundary) already
		-- mounted but this is a new fiber.
		fallbackChildFragment.flags = bit32.bor(fallbackChildFragment.flags, Placement)
	end

	fallbackChildFragment.return_ = workInProgress
	primaryChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = fallbackChildFragment
	workInProgress.child = primaryChildFragment

	return fallbackChildFragment
end

local function retrySuspenseComponentWithoutHydrating(current: Fiber, workInProgress: Fiber, renderLanes: Lanes)
	-- This will add the old fiber to the deletion list
	reconcileChildFibers(workInProgress, current.child, nil, renderLanes)

	-- We're now not suspended nor dehydrated.
	local nextProps = workInProgress.pendingProps
	local primaryChildren = nextProps.children
	local primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes)
	-- Needs a placement effect because the parent (the Suspense boundary) already
	-- mounted but this is a new fiber.
	primaryChildFragment.flags = bit32.bor(primaryChildFragment.flags, Placement)
	workInProgress.memoizedState = nil

	return primaryChildFragment
end

function mountSuspenseFallbackAfterRetryWithoutHydrating(
	current,
	workInProgress,
	primaryChildren,
	fallbackChildren,
	renderLanes
)
	local mode = workInProgress.mode
	local primaryChildFragment = createFiberFromOffscreen(primaryChildren, mode, ReactFiberLane.NoLanes, nil)
	local fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, nil)
	-- Needs a placement effect because the parent (the Suspense
	-- boundary) already mounted but this is a new fiber.
	fallbackChildFragment.flags = bit32.bor(fallbackChildFragment.flags, Placement)

	primaryChildFragment.return_ = workInProgress
	fallbackChildFragment.return_ = workInProgress
	primaryChildFragment.sibling = fallbackChildFragment
	workInProgress.child = primaryChildFragment

	if bit32.band(workInProgress.mode, BlockingMode) ~= NoMode then
		-- We will have dropped the effect list which contains the
		-- deletion. We need to reconcile to delete the current child.
		reconcileChildFibers(workInProgress, current.child, nil, renderLanes)
	end

	return fallbackChildFragment
end

function mountDehydratedSuspenseComponent(
	workInProgress: Fiber,
	suspenseInstance: SuspenseInstance,
	renderLanes: Lanes
): nil | Fiber
	-- During the first pass, we'll bail out and not drill into the children.
	-- Instead, we'll leave the content in place and try to hydrate it later.
	if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
		if __DEV__ then
			console.error(
				"Cannot hydrate Suspense in legacy mode. Switch from"
					.. "ReactDOM.hydrate(element, container) to "
					.. "ReactDOM.createBlockingRoot(container, { hydrate: true })"
					.. ".render(element) or remove the Suspense components"
					.. "the server rendered components."
			)
		end
		workInProgress.lanes = ReactFiberLane.laneToLanes(ReactFiberLane.SyncLane)
	elseif isSuspenseInstanceFallback(suspenseInstance) then
		-- This is a client-only boundary. Since we won't get any content from the server
		-- for this, we need to schedule that at a higher priority based on when it would
		-- have timed out. In theory we could render it in this pass but it would have the
		-- wrong priority associated with it and will prevent hydration of parent path.
		-- Instead, we'll leave work left on it to render it in a separate commit.

		-- TODO This time should be the time at which the server rendered response that is
		-- a parent to this boundary was displayed. However, since we currently don't have
		-- a protocol to transfer that time, we'll just estimate it by using the current
		-- time. This will mean that Suspense timeouts are slightly shifted to later than
		-- they should be.
		-- Schedule a normal pri update to render this content.
		if enableSchedulerTracing then
			markSpawnedWork(ReactFiberLane.DefaultHydrationLane)
		end
		workInProgress.lanes = ReactFiberLane.laneToLanes(ReactFiberLane.DefaultHydrationLane)
	else
		-- We'll continue hydrating the rest at offscreen priority since we'll already
		-- be showing the right content coming from the server, it is no rush.
		workInProgress.lanes = ReactFiberLane.laneToLanes(ReactFiberLane.OffscreenLane)
		if enableSchedulerTracing then
			markSpawnedWork(ReactFiberLane.OffscreenLane)
		end
	end
	return nil
end

function updateDehydratedSuspenseComponent(
	current: Fiber,
	workInProgress: Fiber,
	suspenseInstance: SuspenseInstance,
	suspenseState: SuspenseState,
	renderLanes: Lanes
): nil | Fiber
	-- We should never be hydrating at this point because it is the first pass,
	-- but after we've already committed once.
	warnIfHydrating()

	if bit32.band(getExecutionContext(), RetryAfterError) ~= NoContext then
		return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)
	end

	if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
		return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)
	end

	if isSuspenseInstanceFallback(suspenseInstance) then
		-- This boundary is in a permanent fallback state. In this case, we'll never
		-- get an update and we'll never be able to hydrate the final content. Let's just try the
		-- client side render instead.
		return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)
	end
	-- We use lanes to indicate that a child might depend on context, so if
	-- any context has changed, we need to treat is as if the input might have changed.
	local hasContextChanged = ReactFiberLane.includesSomeLane(renderLanes, current.childLanes)
	if didReceiveUpdate or hasContextChanged then
		-- This boundary has changed since the first render. This means that we are now unable to
		-- hydrate it. We might still be able to hydrate it using a higher priority lane.
		local root = getWorkInProgressRoot()
		if root ~= nil then
			local attemptHydrationAtLane = ReactFiberLane.getBumpedLaneForHydration(root, renderLanes)
			if
				attemptHydrationAtLane ~= ReactFiberLane.NoLane
				and attemptHydrationAtLane ~= suspenseState.retryLane
			then
				-- Intentionally mutating since this render will get interrupted. This
				-- is one of the very rare times where we mutate the current tree
				-- during the render phase.
				suspenseState.retryLane = attemptHydrationAtLane
				-- TODO: Ideally this would inherit the event time of the current render
				local eventTime = ReactFiberLane.NoTimestamp
				scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime)
			else
				-- We have already tried to ping at a higher priority than we're rendering with
				-- so if we got here, we must have failed to hydrate at those levels. We must
				-- now give up. Instead, we're going to delete the whole subtree and instead inject
				-- a new real Suspense boundary to take its place, which may render content
				-- or fallback. This might suspend for a while and if it does we might still have
				-- an opportunity to hydrate before this pass commits.
			end
		end

		-- If we have scheduled higher pri work above, this will probably just abort the render
		-- since we now have higher priority work, but in case it doesn't, we need to prepare to
		-- render something, if we time out. Even if that requires us to delete everything and
		-- skip hydration.
		-- Delay having to do this as long as the suspense timeout allows us.
		renderDidSuspendDelayIfPossible()
		return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes)
	elseif isSuspenseInstancePending(suspenseInstance) then
		-- This component is still pending more data from the server, so we can't hydrate its
		-- content. We treat it as if this component suspended itself. It might seem as if
		-- we could just try to render it client-side instead. However, this will perform a
		-- lot of unnecessary work and is unlikely to complete since it often will suspend
		-- on missing data anyway. Additionally, the server might be able to render more
		-- than we can on the client yet. In that case we'd end up with more fallback states
		-- on the client than if we just leave it alone. If the server times out or errors
		-- these should update this boundary to the permanent Fallback state instead.
		-- Mark it as having captured (i.e. suspended).
		workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
		-- Leave the child in place. I.e. the dehydrated fragment.
		workInProgress.child = current.child

		-- Register a callback to retry this boundary once the server has sent the result.
		-- deviation: wrapper function in place of bind
		local retry = function()
			return retryDehydratedSuspenseBoundary(current)
		end

		if enableSchedulerTracing then
			if Schedule_tracing_wrap == nil then
				Schedule_tracing_wrap = require(Packages.Scheduler).tracing.unstable_wrap
			end
			retry = Schedule_tracing_wrap(retry)
		end

		registerSuspenseInstanceRetry(suspenseInstance, retry)
		return nil
	else
		-- This is the first attempt.
		reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance)
		local nextProps = workInProgress.pendingProps
		local primaryChildren = nextProps.children
		local primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes)
		-- Mark the children as hydrating. This is a fast path to know whether this
		-- tree is part of a hydrating tree. This is used to determine if a child
		-- node has fully mounted yet, and for scheduling event replaying.
		-- Conceptually this is similar to Placement in that a new subtree is
		-- inserted into the React tree here. It just happens to not need DOM
		-- mutations because it already exists.
		primaryChildFragment.flags = bit32.bor(primaryChildFragment.flags, Hydrating)
		return primaryChildFragment
	end
end

-- function scheduleWorkOnFiber(fiber: Fiber, renderLanes: Lanes)
--   fiber.lanes = ReactFiberLane.mergeLanes(fiber.lanes, renderLanes)
--   local alternate = fiber.alternate
--   if alternate ~= nil)
--     alternate.lanes = ReactFiberLane.mergeLanes(alternate.lanes, renderLanes)
--   end
--   scheduleWorkOnParentPath(fiber.return, renderLanes)
-- end

-- function propagateSuspenseContextChange(
--   workInProgress: Fiber,
--   firstChild: nil | Fiber,
--   renderLanes: Lanes,
-- ): void {
--   -- Mark any Suspense boundaries with fallbacks as having work to do.
--   -- If they were previously forced into fallbacks, they may now be able
--   -- to unblock.
--   local node = firstChild
--   while (node ~= nil)
--     if node.tag == SuspenseComponent)
--       local state: SuspenseState | nil = node.memoizedState
--       if state ~= nil)
--         scheduleWorkOnFiber(node, renderLanes)
--       end
--     } elseif node.tag == SuspenseListComponent)
--       -- If the tail is hidden there might not be an Suspense boundaries
--       -- to schedule work on. In this case we have to schedule it on the
--       -- list itself.
--       -- We don't have to traverse to the children of the list since
--       -- the list will propagate the change when it rerenders.
--       scheduleWorkOnFiber(node, renderLanes)
--     } elseif node.child ~= nil)
--       node.child.return = node
--       node = node.child
--       continue
--     end
--     if node == workInProgress)
--       return
--     end
--     while (node.sibling == nil)
--       if node.return == nil or node.return == workInProgress)
--         return
--       end
--       node = node.return
--     end
--     node.sibling.return = node.return
--     node = node.sibling
--   end
-- end

-- function findLastContentRow(firstChild: nil | Fiber): nil | Fiber {
--   -- This is going to find the last row among these children that is already
--   -- showing content on the screen, as opposed to being in fallback state or
--   -- new. If a row has multiple Suspense boundaries, any of them being in the
--   -- fallback state, counts as the whole row being in a fallback state.
--   -- Note that the "rows" will be workInProgress, but any nested children
--   -- will still be current since we haven't rendered them yet. The mounted
--   -- order may not be the same as the new order. We use the new order.
--   local row = firstChild
--   local lastContentRow: nil | Fiber = nil
--   while (row ~= nil)
--     local currentRow = row.alternate
--     -- New rows can't be content rows.
--     if currentRow ~= nil and findFirstSuspended(currentRow) == nil)
--       lastContentRow = row
--     end
--     row = row.sibling
--   end
--   return lastContentRow
-- end

-- type SuspenseListRevealOrder = 'forwards' | 'backwards' | 'together' | void

-- function validateRevealOrder(revealOrder: SuspenseListRevealOrder)
--   if  __DEV__ then
--     if
--       revealOrder ~= undefined and
--       revealOrder ~= 'forwards' and
--       revealOrder ~= 'backwards' and
--       revealOrder ~= 'together' and
--       !didWarnAboutRevealOrder[revealOrder]
--     )
--       didWarnAboutRevealOrder[revealOrder] = true
--       if typeof revealOrder == 'string')
--         switch (revealOrder.toLowerCase())
--           case 'together':
--           case 'forwards':
--           case 'backwards': {
--             console.error(
--               '"%s" is not a valid value for revealOrder on <SuspenseList />. ' +
--                 'Use lowercase "%s" instead.',
--               revealOrder,
--               revealOrder.toLowerCase(),
--             )
--             break
--           end
--           case 'forward':
--           case 'backward': {
--             console.error(
--               '"%s" is not a valid value for revealOrder on <SuspenseList />. ' +
--                 'React uses the -s suffix in the spelling. Use "%ss" instead.',
--               revealOrder,
--               revealOrder.toLowerCase(),
--             )
--             break
--           end
--           default:
--             console.error(
--               '"%s" is not a supported revealOrder on <SuspenseList />. ' +
--                 'Did you mean "together", "forwards" or "backwards"?',
--               revealOrder,
--             )
--             break
--         end
--       else
--         console.error(
--           '%s is not a supported value for revealOrder on <SuspenseList />. ' +
--             'Did you mean "together", "forwards" or "backwards"?',
--           revealOrder,
--         )
--       end
--     end
--   end
-- end

-- function validateTailOptions(
--   tailMode: SuspenseListTailMode,
--   revealOrder: SuspenseListRevealOrder,
-- )
--   if  __DEV__ then
--     if tailMode ~= undefined and !didWarnAboutTailOptions[tailMode])
--       if tailMode ~= 'collapsed' and tailMode ~= 'hidden')
--         didWarnAboutTailOptions[tailMode] = true
--         console.error(
--           '"%s" is not a supported value for tail on <SuspenseList />. ' +
--             'Did you mean "collapsed" or "hidden"?',
--           tailMode,
--         )
--       } elseif revealOrder ~= 'forwards' and revealOrder ~= 'backwards')
--         didWarnAboutTailOptions[tailMode] = true
--         console.error(
--           '<SuspenseList tail="%s" /> is only valid if revealOrder is ' +
--             '"forwards" or "backwards". ' +
--             'Did you mean to specify revealOrder="forwards"?',
--           tailMode,
--         )
--       end
--     end
--   end
-- end

-- function validateSuspenseListNestedChild(childSlot: mixed, index: number)
--   if  __DEV__ then
--     local isArray = Array.isArray(childSlot)
--     local isIterable =
--       !isArray and typeof getIteratorFn(childSlot) == 'function'
--     if isArray or isIterable)
--       local type = isArray ? 'array' : 'iterable'
--       console.error(
--         'A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' +
--           'an additional SuspenseList to configure its revealOrder: ' +
--           '<SuspenseList revealOrder=...> ... ' +
--           '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' +
--           '</SuspenseList>',
--         type,
--         index,
--         type,
--       )
--       return false
--     end
--   end
--   return true
-- end

-- function validateSuspenseListChildren(
--   children: mixed,
--   revealOrder: SuspenseListRevealOrder,
-- )
--   if  __DEV__ then
--     if
--       (revealOrder == 'forwards' or revealOrder == 'backwards') and
--       children ~= undefined and
--       children ~= nil and
--       children ~= false
--     )
--       if Array.isArray(children))
--         for (local i = 0; i < children.length; i++)
--           if not validateSuspenseListNestedChild(children[i], i))
--             return
--           end
--         end
--       else
--         local iteratorFn = getIteratorFn(children)
--         if typeof iteratorFn == 'function')
--           local childrenIterator = iteratorFn.call(children)
--           if childrenIterator)
--             local step = childrenIterator.next()
--             local i = 0
--             for (; !step.done; step = childrenIterator.next())
--               if not validateSuspenseListNestedChild(step.value, i))
--                 return
--               end
--               i++
--             end
--           end
--         else
--           console.error(
--             'A single row was passed to a <SuspenseList revealOrder="%s" />. ' +
--               'This is not useful since it needs multiple rows. ' +
--               'Did you mean to pass multiple children or an array?',
--             revealOrder,
--           )
--         end
--       end
--     end
--   end
-- end

-- function initSuspenseListRenderState(
--   workInProgress: Fiber,
--   isBackwards: boolean,
--   tail: nil | Fiber,
--   lastContentRow: nil | Fiber,
--   tailMode: SuspenseListTailMode,
-- ): void {
--   local renderState: nil | SuspenseListRenderState =
--     workInProgress.memoizedState
--   if renderState == nil)
--     workInProgress.memoizedState = ({
--       isBackwards: isBackwards,
--       rendering: nil,
--       renderingStartTime: 0,
--       last: lastContentRow,
--       tail: tail,
--       tailMode: tailMode,
--     }: SuspenseListRenderState)
--   else
--     -- We can reuse the existing object from previous renders.
--     renderState.isBackwards = isBackwards
--     renderState.rendering = nil
--     renderState.renderingStartTime = 0
--     renderState.last = lastContentRow
--     renderState.tail = tail
--     renderState.tailMode = tailMode
--   end
-- end

-- -- This can end up rendering this component multiple passes.
-- -- The first pass splits the children fibers into two sets. A head and tail.
-- -- We first render the head. If anything is in fallback state, we do another
-- -- pass through beginWork to rerender all children (including the tail) with
-- -- the force suspend context. If the first render didn't have anything in
-- -- in fallback state. Then we render each row in the tail one-by-one.
-- -- That happens in the completeWork phase without going back to beginWork.
-- function updateSuspenseListComponent(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   renderLanes: Lanes,
-- )
--   local nextProps = workInProgress.pendingProps
--   local revealOrder: SuspenseListRevealOrder = nextProps.revealOrder
--   local tailMode: SuspenseListTailMode = nextProps.tail
--   local newChildren = nextProps.children

--   validateRevealOrder(revealOrder)
--   validateTailOptions(tailMode, revealOrder)
--   validateSuspenseListChildren(newChildren, revealOrder)

--   reconcileChildren(current, workInProgress, newChildren, renderLanes)

--   local suspenseContext: SuspenseContext = suspenseStackCursor.current

--   local shouldForceFallback = hasSuspenseContext(
--     suspenseContext,
--     (ForceSuspenseFallback: SuspenseContext),
--   )
--   if shouldForceFallback)
--     suspenseContext = setShallowSuspenseContext(
--       suspenseContext,
--       ForceSuspenseFallback,
--     )
--     workInProgress.flags |= DidCapture
--   else
--     local didSuspendBefore =
--       current ~= nil and (current.flags & DidCapture) ~= NoFlags
--     if didSuspendBefore)
--       -- If we previously forced a fallback, we need to schedule work
--       -- on any nested boundaries to local them know to try to render
--       -- again. This is the same as context updating.
--       propagateSuspenseContextChange(
--         workInProgress,
--         workInProgress.child,
--         renderLanes,
--       )
--     end
--     suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
--   end
--   pushSuspenseContext(workInProgress, suspenseContext)

--   if (workInProgress.mode & BlockingMode) == NoMode)
--     -- In legacy mode, SuspenseList doesn't work so we just
--     -- use make it a noop by treating it as the default revealOrder.
--     workInProgress.memoizedState = nil
--   else
--     switch (revealOrder)
--       case 'forwards': {
--         local lastContentRow = findLastContentRow(workInProgress.child)
--         local tail
--         if lastContentRow == nil)
--           -- The whole list is part of the tail.
--           -- TODO: We could fast path by just rendering the tail now.
--           tail = workInProgress.child
--           workInProgress.child = nil
--         else
--           -- Disconnect the tail rows after the content row.
--           -- We're going to render them separately later.
--           tail = lastContentRow.sibling
--           lastContentRow.sibling = nil
--         end
--         initSuspenseListRenderState(
--           workInProgress,
--           false, -- isBackwards
--           tail,
--           lastContentRow,
--           tailMode,
--         )
--         break
--       end
--       case 'backwards': {
--         -- We're going to find the first row that has existing content.
--         -- At the same time we're going to reverse the list of everything
--         -- we pass in the meantime. That's going to be our tail in reverse
--         -- order.
--         local tail = nil
--         local row = workInProgress.child
--         workInProgress.child = nil
--         while (row ~= nil)
--           local currentRow = row.alternate
--           -- New rows can't be content rows.
--           if currentRow ~= nil and findFirstSuspended(currentRow) == nil)
--             -- This is the beginning of the main content.
--             workInProgress.child = row
--             break
--           end
--           local nextRow = row.sibling
--           row.sibling = tail
--           tail = row
--           row = nextRow
--         end
--         -- TODO: If workInProgress.child is nil, we can continue on the tail immediately.
--         initSuspenseListRenderState(
--           workInProgress,
--           true, -- isBackwards
--           tail,
--           nil, -- last
--           tailMode,
--         )
--         break
--       end
--       case 'together': {
--         initSuspenseListRenderState(
--           workInProgress,
--           false, -- isBackwards
--           nil, -- tail
--           nil, -- last
--           undefined,
--         )
--         break
--       end
--       default: {
--         -- The default reveal order is the same as not having
--         -- a boundary.
--         workInProgress.memoizedState = nil
--       end
--     end
--   end
--   return workInProgress.child
-- end

function updatePortalComponent(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo)
	local nextChildren = workInProgress.pendingProps
	if current == nil then
		-- Portals are special because we don't append the children during mount
		-- but at commit. Therefore we need to track insertions which the normal
		-- flow doesn't do during mount. This doesn't happen at the root because
		-- the root always starts with a "current" with a nil child.
		-- TODO: Consider unifying this with how the root works.
		workInProgress.child = reconcileChildFibers(workInProgress, nil, nextChildren, renderLanes)
	else
		reconcileChildren(current, workInProgress, nextChildren, renderLanes)
	end
	return workInProgress.child
end

local hasWarnedAboutUsingNoValuePropOnContextProvider = false

local function updateContextProvider(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	local providerType: ReactProviderType<any> = workInProgress.type
	local context: ReactContext<any> = providerType._context

	local newProps = workInProgress.pendingProps
	local oldProps = workInProgress.memoizedProps

	local newValue = newProps.value

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		if Array.indexOf(Object.keys(newProps), "value") < 1 then
			if not hasWarnedAboutUsingNoValuePropOnContextProvider then
				hasWarnedAboutUsingNoValuePropOnContextProvider = true
				console.error(
					"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
				)
			end
		end
		-- deviation: adds support for legacy Roact's validateProps()
		local providerPropTypes = workInProgress.type.propTypes
		local validateProps = workInProgress.type.validateProps

		if providerPropTypes or validateProps then
			checkPropTypes(providerPropTypes, validateProps, newProps, "prop", "Context.Provider")
		end
	end

	pushProvider(workInProgress, newValue)

	if oldProps ~= nil then
		local oldValue = oldProps.value
		local changedBits = calculateChangedBits(context, newValue, oldValue)
		if changedBits == 0 then
			-- No change. Bailout early if children are the same.
			if oldProps.children == newProps.children and not hasLegacyContextChanged() then
				return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
			end
		else
			-- The context value changed. Search for matching consumers and schedule
			-- them to update.
			propagateContextChange(workInProgress, context, changedBits, renderLanes)
		end
	end

	local newChildren = newProps.children
	reconcileChildren(current, workInProgress, newChildren, renderLanes)
	return workInProgress.child
end

-- deviation: combine two warning flags to dodge the registers limit
local hasWarnedAbout = {
	usingContextAsConsumer = false,
	usingLegacyConsumer = false,
}

function updateContextConsumer(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes)
	local context: ReactContext<any> = workInProgress.type
	-- The logic below for Context differs depending on PROD or DEV mode. In
	-- DEV mode, we create a separate object for Context.Consumer that acts
	-- like a proxy to Context. This proxy object adds unnecessary code in PROD
	-- so we use the old behaviour (Context.Consumer references Context) to
	-- reduce size and overhead. The separate object references context via
	-- a property called "_context", which also gives us the ability to check
	-- in DEV mode if this property exists or not and warn if it does not.
	if __DEV__ then
		if (context :: any)._context == nil then
			-- This may be because it's a Context (rather than a Consumer).
			-- Or it may be because it's older React where they're the same thing.
			-- We only want to warn if we're sure it's a new React.
			if context ~= context.Consumer then
				if not hasWarnedAbout.usingContextAsConsumer then
					hasWarnedAbout.usingContextAsConsumer = true
					console.error(
						"Rendering <Context> directly is not supported and will be removed in "
							.. "a future major release. Did you mean to render <Context.Consumer> instead?"
					)
				end
			end
		else
			context = (context :: any)._context
		end
	end
	local newProps = workInProgress.pendingProps

	-- deviation: compatibility for old Roact's context consumer API
	local render
	if newProps.render then
		if __DEV__ and __COMPAT_WARNINGS__ then
			if not hasWarnedAbout.usingLegacyConsumer then
				hasWarnedAbout.usingLegacyConsumer = true
				console.warn(
					"Your Context.Consumer component is using legacy Roact syntax, which won't be supported in future versions of Roact. \n"
						.. "Please provide no props and supply the 'render' function as a child (the 3rd argument of createElement). For example: \n"
						.. "       createElement(ContextConsumer, {render = function(...) end})\n"
						.. "becomes:\n"
						.. "       createElement(ContextConsumer, nil, function(...) end)\n"
						.. "For more info, reference the React documentation here: \n"
						.. "https://reactjs.org/docs/context.html#contextconsumer"
				)
			end
		end
		render = newProps.render
	else
		render = newProps.children
	end

	if __DEV__ then
		if type(render) ~= "function" then
			console.error(
				"A context consumer was rendered with multiple children, or a child "
					.. "that isn't a function. A context consumer expects a single child "
					.. "that is a function. If you did pass a function, make sure there "
					.. "is no trailing or leading whitespace around it."
			)
		end
	end

	prepareToReadContext(workInProgress, renderLanes, exports.markWorkInProgressReceivedUpdate)
	local newValue = readContext(context, newProps.unstable_observedBits)
	local newChildren
	if __DEV__ then
		ReactCurrentOwner.current = workInProgress
		setIsRendering(true)
		newChildren = render(newValue)
		setIsRendering(false)
	else
		newChildren = render(newValue)
	end

	-- React DevTools reads this flag.
	workInProgress.flags = bit32.bor(workInProgress.flags, PerformedWork)
	reconcileChildren(current, workInProgress, newChildren, renderLanes)
	return workInProgress.child
end

-- TODO: fundamental component is removed in React 18, clean up all traces when we upgrade
-- function updateFundamentalComponent(current, workInProgress, renderLanes)
--   local fundamentalImpl = workInProgress.type.impl
--   if fundamentalImpl.reconcileChildren == false then
--     return nil
--   end
--   local nextProps = workInProgress.pendingProps
--   local nextChildren = nextProps.children

--   reconcileChildren(current, workInProgress, nextChildren, renderLanes)
--   return workInProgress.child
-- end

-- TODO: scope component is disabled in our FeatureFlags, uncomment when we enable it
-- function updateScopeComponent(current, workInProgress, renderLanes)
--   local nextProps = workInProgress.pendingProps
--   local nextChildren = nextProps.children

--   reconcileChildren(current, workInProgress, nextChildren, renderLanes)
--   return workInProgress.child
-- end

exports.markWorkInProgressReceivedUpdate = function()
	didReceiveUpdate = true
end

function bailoutOnAlreadyFinishedWork(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
	if current then
		-- Reuse previous dependencies
		workInProgress.dependencies = current.dependencies
	end

	if enableProfilerTimer then
		-- Don't update "base" render times for bailouts.
		stopProfilerTimerIfRunning(workInProgress)
	end

	markSkippedUpdateLanes(workInProgress.lanes)

	-- Check if the children have any pending work.
	if not ReactFiberLane.includesSomeLane(renderLanes, workInProgress.childLanes) then
		-- The children don't have any work either. We can skip them.
		-- TODO: Once we add back resuming, we should check if the children are
		-- a work-in-progress set. If so, we need to transfer their effects.
		return nil
	else
		-- This fiber doesn't have work, but its subtree does. Clone the child
		-- fibers and continue.
		cloneChildFibers(current, workInProgress)
		return workInProgress.child
	end
end

function remountFiber(current: Fiber, oldWorkInProgress: Fiber, newWorkInProgress: Fiber): Fiber | nil
	if __DEV__ then
		local returnFiber = oldWorkInProgress.return_
		if returnFiber == nil then
			error("Cannot swap the root fiber.")
		end
		-- FIXME Luau: remove this assert when Luau type states understands the above guard
		assert(returnFiber ~= nil, "returnFiber was nil in remountFiber")

		-- Disconnect from the old current.
		-- It will get deleted.
		current.alternate = nil
		oldWorkInProgress.alternate = nil

		-- Connect to the new tree.
		newWorkInProgress.index = oldWorkInProgress.index
		newWorkInProgress.sibling = oldWorkInProgress.sibling
		newWorkInProgress.return_ = oldWorkInProgress.return_
		newWorkInProgress.ref = oldWorkInProgress.ref

		-- Replace the child/sibling pointers above it.
		if oldWorkInProgress == returnFiber.child then
			returnFiber.child = newWorkInProgress
		else
			local prevSibling = returnFiber.child
			if prevSibling == nil then
				error("Expected parent to have a child.")
			end
			-- FIXME Luau: remove this assert when Luau type states understands the above guard
			assert(prevSibling ~= nil, "prevSibling was nil in remountFiber")

			while prevSibling.sibling ~= oldWorkInProgress do
				prevSibling = prevSibling.sibling
				if prevSibling == nil then
					error("Expected to find the previous sibling.")
				end
			end
			prevSibling.sibling = newWorkInProgress
		end

		-- Delete the old fiber and place the new one.
		-- Since the old fiber is disconnected, we have to schedule it manually.
		local deletions = returnFiber.deletions
		if deletions == nil then
			returnFiber.deletions = { current }
			-- TODO (effects) Rename this to better reflect its new usage (e.g. ChildDeletions)
			returnFiber.flags = bit32.bor(returnFiber.flags, Deletion)
		else
			table.insert(deletions, current)
		end

		newWorkInProgress.flags = bit32.bor(newWorkInProgress.flags, Placement)

		-- Restart work from the new fiber.
		return newWorkInProgress
	else
		error("Did not expect this call in production. " .. "This is a bug in React. Please file an issue.")
	end
end

-- FIXME (roblox): restore types when refinement is better:
-- current: Fiber | nil,
local function beginWork(current: any, workInProgress: Fiber, renderLanes: Lanes): Fiber?
	local updateLanes = workInProgress.lanes

	if __DEV__ then
		if workInProgress._debugNeedsRemount and current ~= nil then
			-- This will restart the begin phase with a new fiber.
			return remountFiber(
				current,
				workInProgress,
				createFiberFromTypeAndProps(
					workInProgress.type,
					-- FIXME: we widen this to be number|string for Roact compatibility
					workInProgress.key :: string?,
					workInProgress.pendingProps,
					workInProgress._debugOwner or nil,
					workInProgress.mode,
					workInProgress.lanes
				)
			)
		end
	end

	if current ~= nil then
		local oldProps = current.memoizedProps
		local newProps = workInProgress.pendingProps

		if
			oldProps ~= newProps
			or hasLegacyContextChanged()
			-- Force a re-render if the implementation changed due to hot reload:
			or if __DEV__ then workInProgress.type ~= current.type else false
		then
			-- If props or context changed, mark the fiber as having performed work.
			-- This may be unset if the props are determined to be equal later (memo).
			didReceiveUpdate = true
		elseif not ReactFiberLane.includesSomeLane(renderLanes, updateLanes) then
			didReceiveUpdate = false
			-- This fiber does not have any pending work. Bailout without entering
			-- the begin phase. There's still some bookkeeping we that needs to be done
			-- in this optimized path, mostly pushing stuff onto the stack.
			if workInProgress.tag == HostRoot then
				pushHostRootContext(workInProgress)
				resetHydrationState()
			elseif workInProgress.tag == HostComponent then
				pushHostContext(workInProgress)
			elseif workInProgress.tag == ClassComponent then
				local Component = workInProgress.type
				if isLegacyContextProvider(Component) then
					pushLegacyContextProvider(workInProgress)
				end
			elseif workInProgress.tag == HostPortal then
				pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo)
			elseif workInProgress.tag == ContextProvider then
				local newValue = workInProgress.memoizedProps.value
				pushProvider(workInProgress, newValue)
			elseif workInProgress.tag == Profiler then
				if enableProfilerTimer then
					-- Reset effect durations for the next eventual effect phase.
					-- These are reset during render to allow the DevTools commit hook a chance to read them,
					local stateNode = workInProgress.stateNode
					stateNode.effectDuration = 0
					stateNode.passiveEffectDuration = 0
				end
			elseif workInProgress.tag == SuspenseComponent then
				local state: SuspenseState | nil = workInProgress.memoizedState
				if state ~= nil then
					if enableSuspenseServerRenderer then
						if (state :: SuspenseState).dehydrated ~= nil then
							pushSuspenseContext(
								workInProgress,
								setDefaultShallowSuspenseContext(suspenseStackCursor.current)
							)
							-- We know that this component will suspend again because if it has
							-- been unsuspended it has committed as a resolved Suspense component.
							-- If it needs to be retried, it should have work scheduled on it.
							workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
							-- We should never render the children of a dehydrated boundary until we
							-- upgrade it. We return nil instead of bailoutOnAlreadyFinishedWork.
							return nil
						end
					end

					-- If this boundary is currently timed out, we need to decide
					-- whether to retry the primary children, or to skip over it and
					-- go straight to the fallback. Check the priority of the primary
					-- child fragment.
					local primaryChildFragment: Fiber = workInProgress.child :: any
					local primaryChildLanes = primaryChildFragment.childLanes
					if ReactFiberLane.includesSomeLane(renderLanes, primaryChildLanes) then
						-- The primary children have pending work. Use the normal path
						-- to attempt to render the primary children again.
						return updateSuspenseComponent(current, workInProgress, renderLanes)
					else
						-- The primary child fragment does not have pending work marked
						-- on it
						pushSuspenseContext(
							workInProgress,
							setDefaultShallowSuspenseContext(suspenseStackCursor.current)
						)
						-- The primary children do not have pending work with sufficient
						-- priority. Bailout.
						local child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
						if child ~= nil then
							-- The fallback children have pending work. Skip over the
							-- primary children and work on the fallback.
							return child.sibling
						else
							return nil
						end
					end
				else
					pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current))
				end
			elseif workInProgress.tag == SuspenseListComponent then
				unimplemented("beginWork: SuspenseListComponent")
			-- local didSuspendBefore = bit32.band(current.flags, DidCapture) ~= NoFlags

			-- local hasChildWork = ReactFiberLane.includesSomeLane(
			--   renderLanes,
			--   workInProgress.childLanes
			-- )

			-- if didSuspendBefore then
			--   if hasChildWork then
			--     -- If something was in fallback state last time, and we have all the
			--     -- same children then we're still in progressive loading state.
			--     -- Something might get unblocked by state updates or retries in the
			--     -- tree which will affect the tail. So we need to use the normal
			--     -- path to compute the correct tail.
			--     return updateSuspenseListComponent(
			--       current,
			--       workInProgress,
			--       renderLanes
			--     )
			--   end
			--   -- If none of the children had any work, that means that none of
			--   -- them got retried so they'll still be blocked in the same way
			--   -- as before. We can fast bail out.
			--   workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
			-- end

			-- -- If nothing suspended before and we're rendering the same children,
			-- -- then the tail doesn't matter. Anything new that suspends will work
			-- -- in the "together" mode, so we can continue from the state we had.
			-- local renderState = workInProgress.memoizedState
			-- if renderState ~= nil then
			--   -- Reset to the "together" mode in case we've started a different
			--   -- update in the past but didn't complete it.
			--   renderState.rendering = nil
			--   renderState.tail = nil
			-- end
			-- pushSuspenseContext(workInProgress, suspenseStackCursor.current)

			-- if not hasChildWork then
			--   -- If none of the children had any work, that means that none of
			--   -- them got retried so they'll still be blocked in the same way
			--   -- as before. We can fast bail out.
			--   return nil
			-- end
			elseif workInProgress.tag == OffscreenComponent or workInProgress.tag == LegacyHiddenComponent then
				-- Need to check if the tree still needs to be deferred. This is
				-- almost identical to the logic used in the normal update path,
				-- so we'll just enter that. The only difference is we'll bail out
				-- at the next level instead of this one, because the child props
				-- have not changed. Which is fine.
				-- TODO: Probably should refactor `beginWork` to split the bailout
				-- path from the normal path. I'm tempted to do a labeled break here
				-- but I won't :)
				workInProgress.lanes = ReactFiberLane.NoLanes
				return updateOffscreenComponent(current, workInProgress, renderLanes)
			end
			return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)
		else
			if bit32.band(current.flags, ForceUpdateForLegacySuspense) ~= NoFlags then
				-- This is a special case that only exists for legacy mode.
				-- See https://github.com/facebook/react/pull/19216.
				didReceiveUpdate = true
			else
				-- An update was scheduled on this fiber, but there are no new props
				-- nor legacy context. Set this to false. If an update queue or context
				-- consumer produces a changed value, it will set this to true. Otherwise,
				-- the component will assume the children have not changed and bail out.
				didReceiveUpdate = false
			end
		end
	else
		didReceiveUpdate = false
	end

	-- Before entering the begin phase, clear pending update priority.
	-- TODO: This assumes that we're about to evaluate the component and process
	-- the update queue. However, there's an exception: SimpleMemoComponent
	-- sometimes bails out later in the begin phase. This indicates that we should
	-- move this assignment out of the common path and into each branch.
	workInProgress.lanes = ReactFiberLane.NoLanes

	if workInProgress.tag == ReactWorkTags.IndeterminateComponent then
		return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes)
	elseif workInProgress.tag == LazyComponent then
		local elementType = workInProgress.elementType
		return mountLazyComponent(current, workInProgress, elementType, updateLanes, renderLanes)
	elseif workInProgress.tag == FunctionComponent then
		local Component = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps
		if workInProgress.elementType == Component then
			resolvedProps = unresolvedProps
		else
			resolvedProps = resolveDefaultProps(Component, unresolvedProps)
		end
		return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes)
	elseif workInProgress.tag == ClassComponent then
		local Component = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps = workInProgress.elementType == Component and unresolvedProps
			or resolveDefaultProps(Component, unresolvedProps)
		return updateClassComponent(current, workInProgress, Component, resolvedProps, renderLanes)
	elseif workInProgress.tag == HostRoot then
		return updateHostRoot(current, workInProgress, renderLanes)
	elseif workInProgress.tag == HostComponent then
		return updateHostComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == HostText then
		return updateHostText(current, workInProgress)
	elseif workInProgress.tag == SuspenseComponent then
		return updateSuspenseComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == HostPortal then
		return updatePortalComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == ForwardRef then
		local type = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps = unresolvedProps
		if workInProgress.elementType ~= type then
			resolvedProps = resolveDefaultProps(type, unresolvedProps)
		end
		return updateForwardRef(current, workInProgress, type, resolvedProps, renderLanes)
	elseif workInProgress.tag == Fragment then
		return updateFragment(current, workInProgress, renderLanes)
	elseif workInProgress.tag == Mode then
		return updateMode(current, workInProgress, renderLanes)
	elseif workInProgress.tag == Profiler then
		return updateProfiler(current, workInProgress, renderLanes)
	elseif workInProgress.tag == ContextProvider then
		return updateContextProvider(current, workInProgress, renderLanes)
	elseif workInProgress.tag == ContextConsumer then
		return updateContextConsumer(current, workInProgress, renderLanes)
	elseif workInProgress.tag == MemoComponent then
		local type_ = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		-- Resolve outer props first, then resolve inner props.
		local resolvedProps = resolveDefaultProps(type_, unresolvedProps)
		if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
			if workInProgress.type ~= workInProgress.elementType then
				-- deviation: adds support for legacy Roact's validateProps()
				local outerPropTypes
				local validateProps
				-- deviation: only get propTypes from class components, Lua doesn't support fields on functions
				if type(type_) == "table" then
					outerPropTypes = type_.propTypes
					validateProps = type_.validateProps
				end
				if outerPropTypes or validateProps then
					checkPropTypes(
						outerPropTypes,
						validateProps,
						resolvedProps, -- Resolved for outer only
						"prop",
						getComponentName(type_)
					)
				end
			end
		end
		resolvedProps = resolveDefaultProps(type_.type, resolvedProps)
		return updateMemoComponent(current, workInProgress, type_, resolvedProps, updateLanes, renderLanes)
	elseif workInProgress.tag == SimpleMemoComponent then
		return updateSimpleMemoComponent(
			current,
			workInProgress,
			workInProgress.type,
			workInProgress.pendingProps,
			updateLanes,
			renderLanes
		)
	elseif workInProgress.tag == IncompleteClassComponent then
		local Component = workInProgress.type
		local unresolvedProps = workInProgress.pendingProps
		local resolvedProps = workInProgress.elementType == Component and unresolvedProps
			or resolveDefaultProps(Component, unresolvedProps)
		return mountIncompleteClassComponent(current, workInProgress, Component, resolvedProps, renderLanes)
	-- elseif workInProgress.tag == SuspenseListComponent then
	--   unimplemented("beginWork: SuspenseListComponent")
	-- return updateSuspenseListComponent(current, workInProgress, renderLanes)
	-- elseif workInProgress.tag == FundamentalComponent then
	--   if enableFundamentalAPI then
	--     return updateFundamentalComponent(current, workInProgress, renderLanes)
	--   end
	-- elseif workInProgress.tag == ScopeComponent then
	--   if enableScopeAPI then
	--     return updateScopeComponent(current, workInProgress, renderLanes)
	--   end
	elseif workInProgress.tag == OffscreenComponent then
		return updateOffscreenComponent(current, workInProgress, renderLanes)
	elseif workInProgress.tag == LegacyHiddenComponent then
		return updateLegacyHiddenComponent(current, workInProgress, renderLanes)
	end
	invariant(
		false,
		"Unknown unit of work tag (%s). This error is likely caused by a bug in " .. "React. Please file an issue.",
		tostring(workInProgress.tag)
	)
	return nil
end
exports.beginWork = beginWork

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006104</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX049D32DB93AE42EB88FDC28FC7447E86">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberClassComponent.new</string>
								<string name="ScriptGuid">{C4E5C208-D4BB-47F9-9DC1-FA8DCEC56D92}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/c63741fb3daef6c1e8746cbe7d7b07ecb281a9fd/packages/react-reconciler/src/ReactFiberClassComponent.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
type UpdateQueue<State> = ReactInternalTypes.UpdateQueue<State>

local ReactTypes = require(Packages.Shared)
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>

local React = require(Packages.React)

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Update = ReactFiberFlags.Update
local Snapshot = ReactFiberFlags.Snapshot
local MountLayoutDev = ReactFiberFlags.MountLayoutDev

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local debugRenderPhaseSideEffectsForStrictMode = ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode
local disableLegacyContext = ReactFeatureFlags.disableLegacyContext
local enableDebugTracing = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local warnAboutDeprecatedLifecycles = ReactFeatureFlags.warnAboutDeprecatedLifecycles
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects

local ReactStrictModeWarnings = require(script.Parent["ReactStrictModeWarnings.new"])
local isMounted = require(script.Parent.ReactFiberTreeReflection).isMounted
local ReactInstanceMap = require(Packages.Shared).ReactInstanceMap
local getInstance = ReactInstanceMap.get
local setInstance = ReactInstanceMap.set
local shallowEqual = require(Packages.Shared).shallowEqual
local getComponentName = require(Packages.Shared).getComponentName
local UninitializedState = require(Packages.Shared).UninitializedState
local describeError = require(Packages.Shared).describeError
-- local invariant = require(Packages.Shared).invariant
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE

local resolveDefaultProps = require(script.Parent["ReactFiberLazyComponent.new"]).resolveDefaultProps
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local DebugTracingMode = ReactTypeOfMode.DebugTracingMode
local StrictMode = ReactTypeOfMode.StrictMode

local enqueueUpdate = ReactUpdateQueue.enqueueUpdate
local processUpdateQueue = ReactUpdateQueue.processUpdateQueue
local checkHasForceUpdateAfterProcessing = ReactUpdateQueue.checkHasForceUpdateAfterProcessing
local resetHasForceUpdateBeforeProcessing = ReactUpdateQueue.resetHasForceUpdateBeforeProcessing
local createUpdate = ReactUpdateQueue.createUpdate
local ReplaceState = ReactUpdateQueue.ReplaceState
local ForceUpdate = ReactUpdateQueue.ForceUpdate
local initializeUpdateQueue = ReactUpdateQueue.initializeUpdateQueue
local cloneUpdateQueue = ReactUpdateQueue.cloneUpdateQueue
local NoLanes = ReactFiberLane.NoLanes

local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local cacheContext = ReactFiberContext.cacheContext
local getMaskedContext = ReactFiberContext.getMaskedContext
local getUnmaskedContext = ReactFiberContext.getUnmaskedContext
local hasContextChanged = ReactFiberContext.hasContextChanged
local emptyContextObject = ReactFiberContext.emptyContextObject

local ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"])
local readContext = ReactFiberNewContext.readContext

-- local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
-- local requestEventTime = ReactFiberWorkLoop.requestEventTime
-- local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
-- local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local DebugTracing = require(script.Parent.DebugTracing)
local logForceUpdateScheduled = DebugTracing.logForceUpdateScheduled
local logStateUpdateScheduled = DebugTracing.logStateUpdateScheduled

local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local SchedulingProfiler = require(script.Parent.SchedulingProfiler)
local markForceUpdateScheduled = SchedulingProfiler.markForceUpdateScheduled
local markStateUpdateScheduled = SchedulingProfiler.markStateUpdateScheduled

local fakeInternalInstance = {}
-- TODO: If this is being localized, it might be for a hot path; that's
-- concerning, since our version of `isArray` is much more complex
-- local isArray = Array.isArray

-- React.Component uses a shared frozen object by default.
-- We'll use it to determine whether we need to initialize legacy refs.
-- deviation: Uses __refs instead of refs to avoid conflicts
-- local emptyRefsObject = React.Component:extend("").refs
local emptyRefsObject = React.Component:extend("").__refs

local didWarnAboutStateAssignmentForComponent
local didWarnAboutUninitializedState
local didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate
local didWarnAboutLegacyLifecyclesAndDerivedState
local _didWarnAboutUndefinedDerivedState
local warnOnUndefinedDerivedState
local warnOnInvalidCallback
local didWarnAboutDirectlyAssigningPropsToState
local didWarnAboutContextTypeAndContextTypes
local didWarnAboutInvalidateContextType

if __DEV__ then
	didWarnAboutStateAssignmentForComponent = {}
	didWarnAboutUninitializedState = {}
	didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = {}
	didWarnAboutLegacyLifecyclesAndDerivedState = {}
	didWarnAboutDirectlyAssigningPropsToState = {}
	_didWarnAboutUndefinedDerivedState = {}
	didWarnAboutContextTypeAndContextTypes = {}
	didWarnAboutInvalidateContextType = {}

	local didWarnOnInvalidCallback = {}

	function warnOnInvalidCallback(callback: any, callerName: string)
		if callback == nil or type(callback) == "function" then
			return
		end
		local key = callerName .. "_" .. tostring(callback)
		if not didWarnOnInvalidCallback[key] then
			didWarnOnInvalidCallback[key] = true
			console.error(
				"%s(...): Expected the last optional `callback` argument to be a " .. "function. Instead received: %s.",
				callerName,
				tostring(callback)
			)
		end
	end

	function warnOnUndefinedDerivedState(type_, partialState)
		-- deviation: `nil` is a valid return for getDerivedStateFromProps, but
		-- `undefined` is not possible for us to return; we could try to detect
		-- returning zero values, but that's likely not possible without tracking it
		-- differently at the original callsite (e.g. the value we save to
		-- `partialState` would still be nil)

		-- if partialState == nil then
		--   local componentName = getComponentName(type_) or "Component"
		--   if not didWarnAboutUndefinedDerivedState[componentName] then
		--     didWarnAboutUndefinedDerivedState[componentName] = true
		--     console.error(
		--       "%s.getDerivedStateFromProps(): A valid state object (or nil) must be returned. " ..
		--         "You have returned undefined.",
		--       componentName
		--     )
		--   end
		-- end
	end

	--   -- FIXME: I'm not sure this applies, need to revisit it
	--   -- -- This is so gross but it's at least non-critical and can be removed if
	--   -- -- it causes problems. This is meant to give a nicer error message for
	--   -- -- ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
	--   -- -- ...)) which otherwise throws a "_processChildContext is not a function"
	--   -- -- exception.
	--   -- Object.defineProperty(fakeInternalInstance, '_processChildContext', {
	--   --   enumerable: false,
	--   --   value: function()
	--   --     invariant(
	--   --       false,
	--   --       '_processChildContext is not available in React 16+. This likely ' +
	--   --         'means you have multiple copies of React and are attempting to nest ' +
	--   --         'a React 15 tree inside a React 16 tree using ' +
	--   --         "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
	--   --         'to make sure you have only one copy of React (and ideally, switch ' +
	--   --         'to ReactDOM.createPortal).',
	--   --     )
	--   --   },
	--   -- })
	--   Object.freeze(fakeInternalInstance)
end

local function applyDerivedStateFromProps<Props, State>(
	workInProgress: Fiber,
	ctor: React_Component<Props, State>,
	getDerivedStateFromProps: (Props, State) -> State?,
	nextProps: Props
)
	local prevState = workInProgress.memoizedState

	if __DEV__ then
		if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			disableLogs()
			-- Invoke the function an extra time to help detect side-effects.
			local ok, result = xpcall(getDerivedStateFromProps, describeError, nextProps, prevState)

			reenableLogs()

			if not ok then
				error(result)
			end
		end
	end

	local partialState = getDerivedStateFromProps(nextProps, prevState)

	if __DEV__ then
		warnOnUndefinedDerivedState(ctor, partialState)
	end
	-- Merge the partial state and the previous state.
	local memoizedState = if partialState == nil then prevState else Object.assign({}, prevState, partialState)
	workInProgress.memoizedState = memoizedState

	-- Once the update queue is empty, persist the derived state onto the
	-- base state.
	if workInProgress.lanes == NoLanes then
		-- Queue is always non-null for classes
		local updateQueue: UpdateQueue<any> = workInProgress.updateQueue
		updateQueue.baseState = memoizedState
	end
end

-- deviation: lazy initialize this to avoid cycles
local classComponentUpdater = nil
local function initializeClassComponentUpdater()
	local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
	local requestEventTime = ReactFiberWorkLoop.requestEventTime
	local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
	local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber

	classComponentUpdater = {
		isMounted = isMounted,
		enqueueSetState = function(inst, payload, callback: (() -> ...any)?)
			local fiber = getInstance(inst)
			local eventTime = requestEventTime()
			local lane = requestUpdateLane(fiber)

			local update = createUpdate(eventTime, lane, payload, callback)
			-- update.payload = payload
			if callback ~= nil then
				if __DEV__ then
					warnOnInvalidCallback(callback, "setState")
				end
				-- update.callback = callback
			end

			enqueueUpdate(fiber, update)
			scheduleUpdateOnFiber(fiber, lane, eventTime)

			if __DEV__ then
				if enableDebugTracing then
					if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
						local name = getComponentName(fiber.type) or "Unknown"
						logStateUpdateScheduled(name, lane, payload)
					end
				end
			end

			if enableSchedulingProfiler then
				markStateUpdateScheduled(fiber, lane)
			end
		end,
		enqueueReplaceState = function(inst, payload, callback)
			local fiber = getInstance(inst)
			local eventTime = requestEventTime()
			local lane = requestUpdateLane(fiber)

			local update = createUpdate(eventTime, lane, payload, callback)
			update.tag = ReplaceState
			-- update.payload = payload

			if callback ~= nil then
				if __DEV__ then
					warnOnInvalidCallback(callback, "replaceState")
				end
				-- update.callback = callback
			end

			enqueueUpdate(fiber, update)
			scheduleUpdateOnFiber(fiber, lane, eventTime)

			if __DEV__ then
				if enableDebugTracing then
					if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
						local name = getComponentName(fiber.type) or "Unknown"
						logStateUpdateScheduled(name, lane, payload)
					end
				end
			end

			if enableSchedulingProfiler then
				markStateUpdateScheduled(fiber, lane)
			end
		end,
		enqueueForceUpdate = function(inst, callback)
			local fiber = getInstance(inst)
			local eventTime = requestEventTime()
			local lane = requestUpdateLane(fiber)

			local update = createUpdate(eventTime, lane, nil, callback)
			update.tag = ForceUpdate

			if callback ~= nil then
				if __DEV__ then
					warnOnInvalidCallback(callback, "forceUpdate")
				end
				-- update.callback = callback
			end

			enqueueUpdate(fiber, update)
			scheduleUpdateOnFiber(fiber, lane, eventTime)

			if __DEV__ then
				if enableDebugTracing then
					if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
						local name = getComponentName(fiber.type) or "Unknown"
						logForceUpdateScheduled(name, lane)
					end
				end
			end

			if enableSchedulingProfiler then
				markForceUpdateScheduled(fiber, lane)
			end
		end,
	}
end

local function getClassComponentUpdater()
	if classComponentUpdater == nil then
		initializeClassComponentUpdater()
	end
	return classComponentUpdater
end

function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext)
	local instance = workInProgress.stateNode
	if instance.shouldComponentUpdate ~= nil and type(instance.shouldComponentUpdate) == "function" then
		if __DEV__ then
			if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
				disableLogs()
				-- deviation: Pass instance so that the method receives self
				-- Invoke the function an extra time to help detect side-effects.
				local ok, result =
					xpcall(instance.shouldComponentUpdate, describeError, instance, newProps, newState, nextContext)
				-- finally
				reenableLogs()
				if not ok then
					error(result)
				end
			end
		end
		-- deviation: Call with ":" so that the method receives self
		local shouldUpdate = instance:shouldComponentUpdate(newProps, newState, nextContext)

		if __DEV__ then
			if shouldUpdate == nil then
				console.error(
					"%s.shouldComponentUpdate(): Returned nil instead of a "
						.. "boolean value. Make sure to return true or false.",
					getComponentName(ctor) or "Component"
				)
			end
		end

		return shouldUpdate
	end

	-- deviation: for us, the isPureReactComponent flag will be visible as a
	-- direct member of the 'ctor', which in reality is the component definition
	if type(ctor) == "table" and ctor.isPureReactComponent then
		return (not shallowEqual(oldProps, newProps) or not shallowEqual(oldState, newState))
	end

	return true
end

local function checkClassInstance(workInProgress: Fiber, ctor: any, newProps: any)
	local instance = workInProgress.stateNode
	if __DEV__ then
		local name = getComponentName(ctor) or "Component"
		local renderPresent = instance.render

		if not renderPresent then
			-- deviation: for us, the render function will be visible as a direct
			-- member of the 'ctor', which in reality is the component definition
			if type(ctor.render) == "function" then
				console.error(
					"%s(...): No `render` method found on the returned component "
						.. "instance: did you accidentally return an object from the constructor?",
					name
				)
			else
				console.error(
					"%s(...): No `render` method found on the returned component "
						.. "instance: you may have forgotten to define `render`.",
					name
				)
			end
		end

		if instance.getInitialState and not instance.getInitialState.isReactClassApproved and not instance.state then
			console.error(
				"getInitialState was defined on %s, a plain JavaScript class. "
					.. "This is only supported for classes created using React.createClass. "
					.. "Did you mean to define a state property instead?",
				name
			)
		end
		if instance.getDefaultProps and not instance.getDefaultProps.isReactClassApproved then
			console.error(
				"getDefaultProps was defined on %s, a plain JavaScript class. "
					.. "This is only supported for classes created using React.createClass. "
					.. "Use a static property to define defaultProps instead.",
				name
			)
		end
		-- TODO? the original check causes false positives, this adjustment should live up to the intention
		if instance.propTypes and not ctor.propTypes then
			console.error(
				"propTypes was defined as an instance property on %s. Use a static "
					.. "property to define propTypes instead.",
				name
			)
		end
		-- TODO? the original check causes false positives, this adjustment should live up to the intention
		if instance.contextType and not ctor.contextType then
			console.error(
				"contextType was defined as an instance property on %s. Use a static "
					.. "property to define contextType instead.",
				name
			)
		end

		if disableLegacyContext then
			if ctor.childContextTypes then
				console.error(
					"%s uses the legacy childContextTypes API which is no longer supported. "
						.. "Use React.createContext() instead.",
					name
				)
			end
			if ctor.contextTypes then
				console.error(
					"%s uses the legacy contextTypes API which is no longer supported. "
						.. "Use React.createContext() with static contextType instead.",
					name
				)
			end
		else
			-- TODO? the original check causes false positives, this adjustment should live up to the intention
			if instance.contextTypes and not ctor.contextTypes then
				console.error(
					"contextTypes was defined as an instance property on %s. Use a static "
						.. "property to define contextTypes instead.",
					name
				)
			end

			-- deviation: don't access fields on a function
			if
				type(ctor) == "table"
				and ctor.contextType
				and ctor.contextTypes
				and not didWarnAboutContextTypeAndContextTypes[ctor]
			then
				didWarnAboutContextTypeAndContextTypes[ctor] = true
				console.error(
					"%s declares both contextTypes and contextType static properties. "
						.. "The legacy contextTypes property will be ignored.",
					name
				)
			end
		end

		if type(instance.componentShouldUpdate) == "function" then
			console.error(
				"%s has a method called "
					.. "componentShouldUpdate(). Did you mean shouldComponentUpdate()? "
					.. "The name is phrased as a question because the function is "
					.. "expected to return a value.",
				name
			)
		end
		-- deviation: don't access fields on a function
		if type(ctor) == "table" and ctor.isPureReactComponent and instance.shouldComponentUpdate ~= nil then
			console.error(
				"%s has a method called shouldComponentUpdate(). "
					.. "shouldComponentUpdate should not be used when extending React.PureComponent. "
					.. "Please extend React.Component if shouldComponentUpdate is used.",
				getComponentName(ctor) or "A pure component"
			)
		end
		if type(instance.componentDidUnmount) == "function" then
			console.error(
				"%s has a method called "
					.. "componentDidUnmount(). But there is no such lifecycle method. "
					.. "Did you mean componentWillUnmount()?",
				name
			)
		end
		if type(instance.componentDidReceiveProps) == "function" then
			console.error(
				"%s has a method called "
					.. "componentDidReceiveProps(). But there is no such lifecycle method. "
					.. "If you meant to update the state in response to changing props, "
					.. "use componentWillReceiveProps(). If you meant to fetch data or "
					.. "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
				name
			)
		end
		if type(instance.componentWillRecieveProps) == "function" then
			console.error(
				"%s has a method called " .. "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
				name
			)
		end
		if type(instance.UNSAFE_componentWillRecieveProps) == "function" then
			console.error(
				"%s has a method called "
					.. "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
				name
			)
		end
		local hasMutatedProps = instance.props ~= newProps
		if instance.props ~= nil and hasMutatedProps then
			console.error(
				"%s(...): When calling super() in `%s`, make sure to pass "
					.. "up the same props that your component's constructor was passed.",
				name,
				name
			)
		end
		if rawget(instance, "defaultProps") then
			console.error(
				"Setting defaultProps as an instance property on %s is not supported and will be ignored."
					.. " Instead, define defaultProps as a static property on %s.",
				name,
				name
			)
		end

		if
			type(instance.getSnapshotBeforeUpdate) == "function"
			and type(instance.componentDidUpdate) ~= "function"
			and not didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate[ctor]
		then
			didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate[ctor] = true
			console.error(
				"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). "
					.. "This component defines getSnapshotBeforeUpdate() only.",
				getComponentName(ctor)
			)
		end

		-- TODO: get function arity to see if it takes >0 arguments. if it takes 1, assume it's self, and warn
		-- if type(instance.getDerivedStateFromProps) == "function" then
		--   console.error(
		--     "%s: getDerivedStateFromProps() is defined as an instance method " ..
		--       "and will be ignored. Instead, declare it as a static method.",
		--     name
		--   )
		-- end
		-- if type(instance.getDerivedStateFromError) == "function" then
		--   console.error(
		--     "%s: getDerivedStateFromError() is defined as an instance method " ..
		--       "and will be ignored. Instead, declare it as a static method.",
		--     name
		--   )
		-- end
		-- if type(ctor.getSnapshotBeforeUpdate) == "function" then
		--   console.error(
		--     "%s: getSnapshotBeforeUpdate() is defined as a static method " ..
		--       "and will be ignored. Instead, declare it as an instance method.",
		--     name
		--   )
		-- end
		local state = instance.state
		-- deviation: It's not useful for us to try to distinguish an array from an
		-- object in this case
		-- if state and (type(state) ~= "table" or Array.isArray(state)) then
		if state ~= nil and type(state) ~= "table" then
			console.error("%s.state: must be set to an object or nil", name)
		end
		-- deviation: don't access fields on a function
		if
			type(ctor) == "table"
			and type(instance.getChildContext) == "function"
			and type(ctor.childContextTypes) ~= "table"
		then
			console.error(
				"%s.getChildContext(): childContextTypes must be defined in order to " .. "use getChildContext().",
				name
			)
		end
	end
end

local function adoptClassInstance(workInProgress: Fiber, instance: any)
	-- performance? it looks like this lazy init is a perf problem in tab switching hot path
	instance.__updater = getClassComponentUpdater()
	workInProgress.stateNode = instance
	-- The instance needs access to the fiber so that it can schedule updates
	setInstance(instance, workInProgress)
	if __DEV__ then
		instance._reactInternalInstance = fakeInternalInstance
	end
end

local function constructClassInstance(workInProgress: Fiber, ctor: any, props: any): any
	local isLegacyContextConsumer = false
	local unmaskedContext = emptyContextObject
	local context = emptyContextObject
	local contextType = ctor.contextType

	if __DEV__ then
		-- deviation: `ctor` is actually a table, in our case; use normal indexing
		if ctor["contextType"] ~= nil then
			-- TODO: Double-check this boolean for accuracy
			local isValid =
				-- Allow nil for conditional declaration
				contextType == nil or (contextType["$$typeof"] == REACT_CONTEXT_TYPE and contextType._context == nil) -- Not a <Context.Consumer>

			if not isValid and not didWarnAboutInvalidateContextType[ctor] then
				didWarnAboutInvalidateContextType[ctor] = true

				local addendum = ""
				if contextType == nil then
					addendum =
						-- deviation: s/undefined/nil
						" However, it is set to nil. " .. "This can be caused by a typo or by mixing up named and default imports. " .. "This can also happen due to a circular dependency, so " .. "try moving the createContext() call to a separate file."
				elseif type(contextType) ~= "table" then
					addendum = " However, it is set to a " .. type(contextType) .. "."
				elseif contextType["$$typeof"] == REACT_PROVIDER_TYPE then
					addendum = " Did you accidentally pass the Context.Provider instead?"
				elseif contextType._context ~= nil then
					-- <Context.Consumer>
					addendum = " Did you accidentally pass the Context.Consumer instead?"
				else
					addendum ..= " However, it is set to an object with keys {"
					for key, _ in contextType do
						addendum ..= key .. ", "
					end
					addendum ..= "}."
				end
				console.error(
					"%s defines an invalid contextType. "
						.. "contextType should point to the Context object returned by React.createContext().%s",
					getComponentName(ctor) or "Component",
					addendum
				)
			end
		end
	end

	-- performance: check for nil first to avoid typeof when possible
	if contextType ~= nil and type(contextType) == "table" then
		context = readContext(contextType)
	elseif not disableLegacyContext then
		unmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		local contextTypes = ctor.contextTypes
		isLegacyContextConsumer = contextTypes ~= nil
		context = isLegacyContextConsumer and getMaskedContext(workInProgress, unmaskedContext) or emptyContextObject
	end

	-- Instantiate twice to help detect side-effects.
	if __DEV__ then
		if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			disableLogs()
			-- deviation: ctor will actually refer to a class component, we use the
			-- `__ctor` function that it exposes
			local ok, result = xpcall(ctor.__ctor, describeError, props, context) -- eslint-disable-line no-new
			-- finally
			reenableLogs()

			if not ok then
				error(result)
			end
		end
	end

	-- deviation: ctor will actually refer to a class component, we use the
	-- `__ctor` function that it exposes
	local instance = ctor.__ctor(props, context)
	-- deviation: no need to worry about undefined
	-- local state = (workInProgress.memoizedState =
	--   instance.state ~= nil and instance.state ~= undefined
	--     ? instance.state
	--     : nil)
	workInProgress.memoizedState = instance.state
	local state = workInProgress.memoizedState
	adoptClassInstance(workInProgress, instance)

	if __DEV__ then
		-- deviation: Instead of checking if state is nil, we check if it is our
		-- UninitializedState singleton.
		if type(ctor.getDerivedStateFromProps) == "function" and state == UninitializedState then
			local componentName = getComponentName(ctor) or "Component"
			if not didWarnAboutUninitializedState[componentName] then
				didWarnAboutUninitializedState[componentName] = true
				-- deviation: message adjusted for accuracy with Lua "class" components
				console.error(
					"`%s` uses `getDerivedStateFromProps` but its initial state has not been initialized. "
						.. "This is not recommended. Instead, define the initial state by "
						.. "passing an object to `self:setState` in the `init` method of `%s`. "
						.. "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
					componentName,
					-- deviation: no need to worry about undefined
					-- instance.state == nil and 'nil' or 'undefined',
					componentName
				)
			end
		end

		-- If new component APIs are defined, "unsafe" lifecycles won't be called.
		-- Warn about these lifecycles if they are present.
		-- Don't warn about react-lifecycles-compat polyfilled methods though.
		if
			type(ctor.getDerivedStateFromProps) == "function"
			or type(instance.getSnapshotBeforeUpdate) == "function"
		then
			local foundWillMountName = nil
			local foundWillReceivePropsName = nil
			local foundWillUpdateName = nil
			if
				-- FIXME: This won't work! Lua functions can't have properties
				type(instance.componentWillMount) == "function" -- and
				-- instance.componentWillMount.__suppressDeprecationWarning ~= true
			then
				foundWillMountName = "componentWillMount"
			elseif type(instance.UNSAFE_componentWillMount) == "function" then
				foundWillMountName = "UNSAFE_componentWillMount"
			end
			if
				-- FIXME: This won't work! Lua functions can't have properties
				type(instance.componentWillReceiveProps) == "function" -- and
				-- instance.componentWillReceiveProps.__suppressDeprecationWarning ~= true
			then
				foundWillReceivePropsName = "componentWillReceiveProps"
			elseif type(instance.UNSAFE_componentWillReceiveProps) == "function" then
				foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"
			end
			if
				-- FIXME: This won't work! Lua functions can't have properties
				type(instance.componentWillUpdate) == "function" -- and
				-- instance.componentWillUpdate.__suppressDeprecationWarning ~= true
			then
				foundWillUpdateName = "componentWillUpdate"
			elseif type(instance.UNSAFE_componentWillUpdate) == "function" then
				foundWillUpdateName = "UNSAFE_componentWillUpdate"
			end
			if foundWillMountName ~= nil or foundWillReceivePropsName ~= nil or foundWillUpdateName ~= nil then
				local componentName = getComponentName(ctor) or "Component"
				local newApiName
				if type(ctor.getDerivedStateFromProps) == "function" then
					newApiName = "getDerivedStateFromProps()"
				else
					newApiName = "getSnapshotBeforeUpdate()"
				end

				local willMountName
				if foundWillMountName ~= nil then
					willMountName = ("\n  " .. tostring(foundWillMountName))
				else
					willMountName = ""
				end

				local willReceievePropsName
				if foundWillReceivePropsName ~= nil then
					willReceievePropsName = ("\n  " .. tostring(foundWillReceivePropsName))
				else
					willReceievePropsName = ""
				end

				local willUpdateName
				if foundWillUpdateName ~= nil then
					willUpdateName = "\n  " .. tostring(foundWillUpdateName)
				else
					willUpdateName = ""
				end

				if not didWarnAboutLegacyLifecyclesAndDerivedState[componentName] then
					didWarnAboutLegacyLifecyclesAndDerivedState[componentName] = true
					console.error(
						"Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n"
							.. "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n"
							.. "The above lifecycles should be removed. Learn more about this warning here:\n"
							.. "https://reactjs.org/link/unsafe-component-lifecycles",
						componentName,
						newApiName,
						willMountName,
						willReceievePropsName,
						willUpdateName
					)
				end
			end
		end
	end

	-- Cache unmasked context so we can avoid recreating masked context unless necessary.
	-- ReactFiberContext usually updates this cache but can't for newly-created instances.
	if isLegacyContextConsumer then
		cacheContext(workInProgress, unmaskedContext, context)
	end

	return instance
end

local function callComponentWillMount(workInProgress, instance)
	local oldState = instance.state

	if instance.componentWillMount ~= nil and type(instance.componentWillMount) == "function" then
		-- deviation: Call with ":" so that the method receives self
		instance:componentWillMount()
	end
	-- TODO: Should we really run both of these?
	if instance.UNSAFE_componentWillMount ~= nil and type(instance.UNSAFE_componentWillMount) == "function" then
		-- deviation: Call with ":" so that the method receives self
		instance:UNSAFE_componentWillMount()
	end

	if oldState ~= instance.state then
		if __DEV__ then
			console.error(
				"%s.componentWillMount(): Assigning directly to this.state is "
					.. "deprecated (except inside a component's "
					.. "constructor). Use setState instead.",
				getComponentName(workInProgress.type) or "Component"
			)
		end
		getClassComponentUpdater().enqueueReplaceState(instance, instance.state)
	end
end

function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext)
	local oldState = instance.state
	if instance.componentWillReceiveProps ~= nil and type(instance.componentWillReceiveProps) == "function" then
		-- deviation: Call with ":" so that the method receives self
		instance:componentWillReceiveProps(newProps, nextContext)
	end
	if
		instance.UNSAFE_componentWillReceiveProps ~= nil
		and type(instance.UNSAFE_componentWillReceiveProps) == "function"
	then
		-- deviation: Call with ":" so that the method receives self
		instance:UNSAFE_componentWillReceiveProps(newProps, nextContext)
	end

	if instance.state ~= oldState then
		if __DEV__ then
			local componentName = getComponentName(workInProgress.type) or "Component"
			if not didWarnAboutStateAssignmentForComponent[componentName] then
				didWarnAboutStateAssignmentForComponent[componentName] = true
				console.error(
					"%s.componentWillReceiveProps(): Assigning directly to "
						.. "this.state is deprecated (except inside a component's "
						.. "constructor). Use setState instead.",
					componentName
				)
			end
		end
		getClassComponentUpdater().enqueueReplaceState(instance, instance.state)
	end
end

-- Invokes the mount life-cycles on a previously never rendered instance.
local function mountClassInstance(workInProgress: Fiber, ctor: any, newProps: any, renderLanes: Lanes)
	if __DEV__ then
		checkClassInstance(workInProgress, ctor, newProps)
	end

	local instance = workInProgress.stateNode
	instance.props = newProps
	instance.state = workInProgress.memoizedState
	-- deviation: Uses __refs instead of refs to avoid conflicts
	-- instance.refs = emptyRefsObject
	instance.__refs = emptyRefsObject

	initializeUpdateQueue(workInProgress)

	-- deviation: don't access field on a function
	local contextType
	if type(ctor) == "table" then
		contextType = ctor.contextType
	end
	-- deviation: nil check first so we don't call typeof() unnecessarily
	if contextType ~= nil and type(contextType) == "table" then
		instance.context = readContext(contextType)
	elseif disableLegacyContext then
		instance.context = emptyContextObject
	else
		local unmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		instance.context = getMaskedContext(workInProgress, unmaskedContext)
	end

	if __DEV__ then
		if instance.state == newProps then
			local componentName = getComponentName(ctor) or "Component"
			if not didWarnAboutDirectlyAssigningPropsToState[componentName] then
				didWarnAboutDirectlyAssigningPropsToState[componentName] = true
				console.error(
					"%s: It is not recommended to assign props directly to state "
						.. "because updates to props won't be reflected in state. "
						.. "In most cases, it is better to use props directly.",
					componentName
				)
			end
		end

		if bit32.band(workInProgress.mode, StrictMode) ~= 0 then
			ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance)
		end

		if warnAboutDeprecatedLifecycles then
			ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance)
		end
	end

	processUpdateQueue(workInProgress, newProps, instance, renderLanes)
	instance.state = workInProgress.memoizedState

	-- deviation START: don't access field on a function, cache typeofCtor
	local typeofCtor = type(ctor)
	local getDerivedStateFromProps
	if type(ctor) == "table" then
		getDerivedStateFromProps = ctor.getDerivedStateFromProps
	end
	if getDerivedStateFromProps ~= nil and type(getDerivedStateFromProps) == "function" then
		applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps)
		instance.state = workInProgress.memoizedState
	end

	-- In order to support react-lifecycles-compat polyfilled components,
	-- Unsafe lifecycles should not be invoked for components using the new APIs.
	-- deviation: don't access fields on a function
	if
		typeofCtor == "table"
		and type(ctor.getDerivedStateFromProps) ~= "function"
		and type(instance.getSnapshotBeforeUpdate) ~= "function"
		and (type(instance.UNSAFE_componentWillMount) == "function" or type(instance.componentWillMount) == "function")
	then
		callComponentWillMount(workInProgress, instance)
		-- If we had additional state updates during this life-cycle, let's
		-- process them now.
		processUpdateQueue(workInProgress, newProps, instance, renderLanes)
		instance.state = workInProgress.memoizedState
	end

	if type(instance.componentDidMount) == "function" then
		if __DEV__ and enableDoubleInvokingEffects then
			workInProgress.flags = bit32.bor(workInProgress.flags, bit32.bor(MountLayoutDev, Update))
		else
			workInProgress.flags = bit32.bor(workInProgress.flags, Update)
		end
	end
end

function resumeMountClassInstance(workInProgress: Fiber, ctor: any, newProps: any, renderLanes: Lanes): boolean
	local instance = workInProgress.stateNode

	local oldProps = workInProgress.memoizedProps
	instance.props = oldProps

	local oldContext = instance.context
	local contextType = ctor.contextType
	local nextContext = emptyContextObject

	-- performance: check for nil first to avoid typeof when possible
	if contextType ~= nil and type(contextType) == "table" then
		nextContext = readContext(contextType)
	elseif not disableLegacyContext then
		local nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext)
	end

	local getDerivedStateFromProps = ctor.getDerivedStateFromProps
	local hasNewLifecycles = type(getDerivedStateFromProps) == "function"
		or type(instance.getSnapshotBeforeUpdate) == "function"

	-- NOTE: During these life-cycles, instance.props/instance.state are what
	-- ever the previously attempted to render - not the "current". However,
	-- during componentDidUpdate we pass the "current" props.

	-- In order to support react-lifecycles-compat polyfilled components,
	-- Unsafe lifecycles should not be invoked for components using the new APIs.
	if
		not hasNewLifecycles
		and (
			type(instance.UNSAFE_componentWillReceiveProps) == "function"
			or type(instance.componentWillReceiveProps) == "function"
		)
	then
		if oldProps ~= newProps or oldContext ~= nextContext then
			callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext)
		end
	end

	resetHasForceUpdateBeforeProcessing()

	local oldState = workInProgress.memoizedState
	instance.state = oldState
	local newState = oldState
	processUpdateQueue(workInProgress, newProps, instance, renderLanes)
	newState = workInProgress.memoizedState
	if
		oldProps == newProps
		and oldState == newState
		and not hasContextChanged()
		and not checkHasForceUpdateAfterProcessing()
	then
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if type(instance.componentDidMount) == "function" then
			if __DEV__ and enableDoubleInvokingEffects then
				workInProgress.flags = bit32.bor(workInProgress.flags, MountLayoutDev, Update)
			else
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		return false
	end

	if getDerivedStateFromProps ~= nil and type(getDerivedStateFromProps) == "function" then
		applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps)
		newState = workInProgress.memoizedState
	end

	local shouldUpdate = checkHasForceUpdateAfterProcessing()
		or checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext)

	if shouldUpdate then
		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			not hasNewLifecycles
			and (
				type(instance.UNSAFE_componentWillMount) == "function"
				or type(instance.componentWillMount) == "function"
			)
		then
			if type(instance.componentWillMount) == "function" then
				instance:componentWillMount()
			end
			if type(instance.UNSAFE_componentWillMount) == "function" then
				instance:UNSAFE_componentWillMount()
			end
		end
		if type(instance.componentDidMount) == "function" then
			if __DEV__ and enableDoubleInvokingEffects then
				workInProgress.flags = bit32.bor(workInProgress.flags, MountLayoutDev, Update)
			else
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
	else
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if type(instance.componentDidMount) == "function" then
			if __DEV__ and enableDoubleInvokingEffects then
				workInProgress.flags = bit32.bor(workInProgress.flags, MountLayoutDev, Update)
			else
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end

		-- If shouldComponentUpdate returned false, we should still update the
		-- memoized state to indicate that this work can be reused.
		workInProgress.memoizedProps = newProps
		workInProgress.memoizedState = newState
	end

	-- Update the existing instance's state, props, and context pointers even
	-- if shouldComponentUpdate returns false.
	instance.props = newProps
	instance.state = newState
	instance.context = nextContext

	return shouldUpdate
end

-- Invokes the update life-cycles and returns false if it shouldn't rerender.
local function updateClassInstance(
	current: Fiber,
	workInProgress: Fiber,
	ctor: any,
	newProps: any,
	renderLanes: Lanes
): boolean
	local instance = workInProgress.stateNode

	cloneUpdateQueue(current, workInProgress)

	local unresolvedOldProps = workInProgress.memoizedProps
	local oldProps = if workInProgress.type == workInProgress.elementType
		then unresolvedOldProps
		else resolveDefaultProps(workInProgress.type, unresolvedOldProps)
	instance.props = oldProps
	local unresolvedNewProps = workInProgress.pendingProps

	local oldContext = instance.context
	local contextType
	local getDerivedStateFromProps
	-- deviation: don't access fields on a function
	if type(ctor) == "table" then
		contextType = ctor.contextType
		getDerivedStateFromProps = ctor.getDerivedStateFromProps
	end
	local nextContext = emptyContextObject
	if type(contextType) == "table" then
		nextContext = readContext(contextType)
	elseif not disableLegacyContext then
		local nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true)
		nextContext = getMaskedContext(workInProgress, nextUnmaskedContext)
	end

	local hasNewLifecycles = (getDerivedStateFromProps ~= nil and type(getDerivedStateFromProps) == "function")
		or (instance.getSnapshotBeforeUpdate ~= nil and type(instance.getSnapshotBeforeUpdate) == "function")

	-- NOTE: During these life-cycles, instance.props/instance.state are what
	-- ever the previously attempted to render - not the "current". However,
	-- during componentDidUpdate we pass the "current" props.

	-- In order to support react-lifecycles-compat polyfilled components,
	-- Unsafe lifecycles should not be invoked for components using the new APIs.
	if
		not hasNewLifecycles
		and (
			(
				instance.UNSAFE_componentWillReceiveProps ~= nil
				and type(instance.UNSAFE_componentWillReceiveProps) == "function"
			)
			or (instance.componentWillReceiveProps ~= nil and type(instance.componentWillReceiveProps) == "function")
		)
	then
		if unresolvedOldProps ~= unresolvedNewProps or oldContext ~= nextContext then
			callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext)
		end
	end

	resetHasForceUpdateBeforeProcessing()

	local oldState = workInProgress.memoizedState
	instance.state = oldState
	local newState = instance.state
	processUpdateQueue(workInProgress, newProps, instance, renderLanes)
	newState = workInProgress.memoizedState

	if
		unresolvedOldProps == unresolvedNewProps
		and oldState == newState
		and not hasContextChanged()
		and not checkHasForceUpdateAfterProcessing()
	then
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if instance.componentDidUpdate ~= nil and type(instance.componentDidUpdate) == "function" then
			if unresolvedOldProps ~= current.memoizedProps or oldState ~= current.memoizedState then
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if instance.getSnapshotBeforeUpdate ~= nil and type(instance.getSnapshotBeforeUpdate) == "function" then
			if unresolvedOldProps ~= current.memoizedProps or oldState ~= current.memoizedState then
				workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
			end
		end
		return false
	end

	if getDerivedStateFromProps ~= nil and type(getDerivedStateFromProps) == "function" then
		applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps)
		newState = workInProgress.memoizedState
	end

	local shouldUpdate = checkHasForceUpdateAfterProcessing()
		or checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext)

	if shouldUpdate then
		-- In order to support react-lifecycles-compat polyfilled components,
		-- Unsafe lifecycles should not be invoked for components using the new APIs.
		if
			not hasNewLifecycles
			and (
				(instance.UNSAFE_componentWillUpdate ~= nil and type(instance.UNSAFE_componentWillUpdate) == "function")
				or (instance.componentWillUpdate ~= nil and type(instance.componentWillUpdate) == "function")
			)
		then
			if instance.componentWillUpdate ~= nil and type(instance.componentWillUpdate) == "function" then
				-- deviation: Call with ":" so that the method receives self
				instance:componentWillUpdate(newProps, newState, nextContext)
			end
			if
				instance.UNSAFE_componentWillUpdate ~= nil
				and type(instance.UNSAFE_componentWillUpdate) == "function"
			then
				-- deviation: Call with ":" so that the method receives self
				instance:UNSAFE_componentWillUpdate(newProps, newState, nextContext)
			end
		end
		if instance.componentDidUpdate ~= nil and type(instance.componentDidUpdate) == "function" then
			workInProgress.flags = bit32.bor(workInProgress.flags, Update)
		end
		if instance.getSnapshotBeforeUpdate ~= nil and type(instance.getSnapshotBeforeUpdate) == "function" then
			workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
		end
	else
		-- If an update was already in progress, we should schedule an Update
		-- effect even though we're bailing out, so that cWU/cDU are called.
		if instance.componentDidUpdate ~= nil and type(instance.componentDidUpdate) == "function" then
			if unresolvedOldProps ~= current.memoizedProps or oldState ~= current.memoizedState then
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if instance.getSnapshotBeforeUpdate ~= nil and type(instance.getSnapshotBeforeUpdate) == "function" then
			if unresolvedOldProps ~= current.memoizedProps or oldState ~= current.memoizedState then
				workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
			end
		end

		-- If shouldComponentUpdate returned false, we should still update the
		-- memoized props/state to indicate that this work can be reused.
		workInProgress.memoizedProps = newProps
		workInProgress.memoizedState = newState
	end

	-- Update the existing instance's state, props, and context pointers even
	-- if shouldComponentUpdate returns false.
	instance.props = newProps
	instance.state = newState
	instance.context = nextContext

	return shouldUpdate
end

return {
	adoptClassInstance = adoptClassInstance,
	constructClassInstance = constructClassInstance,
	mountClassInstance = mountClassInstance,
	resumeMountClassInstance = resumeMountClassInstance,
	updateClassInstance = updateClassInstance,

	applyDerivedStateFromProps = applyDerivedStateFromProps,
	-- deviation: this should be safe to export, since it gets assigned only once
	emptyRefsObject = emptyRefsObject,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006105</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA678003598534AA3A66F3237A9B82F7B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberCommitWork.new</string>
								<string name="ScriptGuid">{5E9312C4-E4F9-447E-92A2-7F6AA9D61D5B}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/7f08e908b10a58cda902611378ec053003d371ed/packages/react-reconciler/src/ReactFiberCommitWork.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local __DEV__ = _G.__DEV__ :: boolean
local __YOLO__ = _G.__YOLO__ :: boolean
-- deviation: keep track of the pcall run depth and stop wrapping pcalls after we hit MAX_RUN_DEPTH.
-- NOTE: if this number is raised to 195, the test in RoactRecursiveLayoutPcallDepth will fail
local runDepth = 0
local MAX_RUN_DEPTH = 20

local function isCallable(value)
	if typeof(value) == "function" then
		return true
	end
	if typeof(value) == "table" then
		local mt = getmetatable(value)
		if mt and rawget(mt, "__call") then
			return true
		end
		if value._isMockFunction then
			return true
		end
	end
	return false
end

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local Set = LuauPolyfill.Set
type Array<T> = { [number]: T }

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type Container = ReactFiberHostConfig.Container
type TextInstance = ReactFiberHostConfig.TextInstance
-- deviation START: we have to inline, because type imports don't work across dynamic requires like HostConfig
-- local type {
--   SuspenseInstance,
--   ChildSet,
--   UpdatePayload,
type UpdatePayload = Array<any>
-- } = require(script.Parent.ReactFiberHostConfig)
-- deviation END
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local ReactUpdateQueueModule = require(script.Parent["ReactUpdateQueue.new"])
type UpdateQueue<T> = ReactInternalTypes.UpdateQueue<T>

-- local ReactFiberHooks = require(script.Parent["ReactFiberHooks.new"])
-- type FunctionComponentUpdateQueue = ReactFiberHooks.FunctionComponentUpdateQueue
-- deviation: inline the typedef here to avoid circular dependency
type Effect = {
	tag: HookFlags,
	create: () -> (() -> ())?,
	destroy: (() -> ())?,
	deps: Array<any>?,
	next: Effect,
}
type FunctionComponentUpdateQueue = {
	lastEffect: Effect?,
}

local ReactTypes = require(Packages.Shared)
type Wakeable = ReactTypes.Wakeable

type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenState = ReactFiberOffscreenComponent.OffscreenState
local ReactHookEffectTags = require(script.Parent.ReactHookEffectTags)
type HookFlags = ReactHookEffectTags.HookFlags

-- deviation: import tracing as a top-level export to avoid direct file access
local Schedule_tracing_wrap = require(Packages.Scheduler).tracing.unstable_wrap
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
local enableProfilerCommitHooks = ReactFeatureFlags.enableProfilerCommitHooks
-- local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
local enableSuspenseCallback = ReactFeatureFlags.enableSuspenseCallback
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local FunctionComponent = ReactWorkTags.FunctionComponent
local ForwardRef = ReactWorkTags.ForwardRef
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local DehydratedFragment = ReactWorkTags.DehydratedFragment
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local Block = ReactWorkTags.Block
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local ReactErrorUtils = require(Packages.Shared).ReactErrorUtils
local invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback
local hasCaughtError = ReactErrorUtils.hasCaughtError
local clearCaughtError = ReactErrorUtils.clearCaughtError
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local ContentReset = ReactFiberFlags.ContentReset
local Placement = ReactFiberFlags.Placement
local Snapshot = ReactFiberFlags.Snapshot
local Update = ReactFiberFlags.Update
local Callback = ReactFiberFlags.Callback
local LayoutMask = ReactFiberFlags.LayoutMask
local PassiveMask = ReactFiberFlags.PassiveMask
local Ref = ReactFiberFlags.Ref
local getComponentName = require(Packages.Shared).getComponentName
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
--  ROBLOX deviation: this property would be captured as values instead of bound
local currentDebugFiberInDEV = ReactCurrentFiber.current
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local onCommitUnmount = require(script.Parent["ReactFiberDevToolsHook.new"]).onCommitUnmount
local resolveDefaultProps = require(script.Parent["ReactFiberLazyComponent.new"]).resolveDefaultProps
local ReactProfilerTimer = require(script.Parent["ReactProfilerTimer.new"])
local startLayoutEffectTimer = ReactProfilerTimer.startLayoutEffectTimer
local recordPassiveEffectDuration = ReactProfilerTimer.recordPassiveEffectDuration
local recordLayoutEffectDuration = ReactProfilerTimer.recordLayoutEffectDuration
local startPassiveEffectTimer = ReactProfilerTimer.startPassiveEffectTimer
local getCommitTime = ReactProfilerTimer.getCommitTime
local ProfileMode = require(script.Parent.ReactTypeOfMode).ProfileMode
local commitUpdateQueue = ReactUpdateQueueModule.commitUpdateQueue
local getPublicInstance = ReactFiberHostConfig.getPublicInstance
local supportsMutation = ReactFiberHostConfig.supportsMutation
local supportsPersistence = ReactFiberHostConfig.supportsPersistence
local supportsHydration = ReactFiberHostConfig.supportsHydration
local commitMount = ReactFiberHostConfig.commitMount
local commitUpdate = ReactFiberHostConfig.commitUpdate
local resetTextContent = ReactFiberHostConfig.resetTextContent
local commitTextUpdate = ReactFiberHostConfig.commitTextUpdate
local appendChild = ReactFiberHostConfig.appendChild
local appendChildToContainer = ReactFiberHostConfig.appendChildToContainer
local insertBefore = ReactFiberHostConfig.insertBefore
local insertInContainerBefore = ReactFiberHostConfig.insertInContainerBefore
local removeChild = ReactFiberHostConfig.removeChild
local removeChildFromContainer = ReactFiberHostConfig.removeChildFromContainer
-- local clearSuspenseBoundary = ReactFiberHostConfig.clearSuspenseBoundary
-- local clearSuspenseBoundaryFromContainer = ReactFiberHostConfig.clearSuspenseBoundaryFromContainer
-- local replaceContainerChildren = ReactFiberHostConfig.replaceContainerChildren
-- local createContainerChildSet = ReactFiberHostConfig.createContainerChildSet
local hideInstance = ReactFiberHostConfig.hideInstance
local hideTextInstance = ReactFiberHostConfig.hideTextInstance
local unhideInstance = ReactFiberHostConfig.unhideInstance
local unhideTextInstance = ReactFiberHostConfig.unhideTextInstance
-- local unmountFundamentalComponent = ReactFiberHostConfig.unmountFundamentalComponent
-- local updateFundamentalComponent = ReactFiberHostConfig.updateFundamentalComponent
-- local commitHydratedContainer = ReactFiberHostConfig.commitHydratedContainer
local commitHydratedSuspenseInstance = ReactFiberHostConfig.commitHydratedSuspenseInstance
local clearContainer = ReactFiberHostConfig.clearContainer
-- local prepareScopeUpdate = ReactFiberHostConfig.prepareScopeUpdate

-- deviation: Lazy init to avoid circular dependencies
local ReactFiberWorkLoop

local function resolveRetryWakeable(boundaryFiber: Fiber, wakeable: Wakeable): ()
	if not ReactFiberWorkLoop then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
	end
	ReactFiberWorkLoop.resolveRetryWakeable(boundaryFiber, wakeable)
end

local function markCommitTimeOfFallback(): ()
	if not ReactFiberWorkLoop then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
	end
	ReactFiberWorkLoop.markCommitTimeOfFallback()
end

-- deviation: stub to allow dependency injection that breaks circular dependency
local function schedulePassiveEffectCallback(): ()
	console.warn("ReactFiberCommitWork: schedulePassiveEffectCallback causes a dependency cycle\n" .. debug.traceback())
end

-- deviation: stub to allow dependency injection that breaks circular dependency
local function captureCommitPhaseError(rootFiber: Fiber, sourceFiber: Fiber | nil, error_: any?): ()
	console.warn("ReactFiberCommitWork: captureCommitPhaseError causes a dependency cycle")
	error(error_)
end

local NoHookEffect = ReactHookEffectTags.NoFlags
local HookHasEffect = ReactHookEffectTags.HasEffect
local HookLayout = ReactHookEffectTags.Layout
local HookPassive = ReactHookEffectTags.Passive

-- deviation: lazy init to break cyclic dependency
local didWarnAboutReassigningPropsRef
local didWarnAboutReassigningProps = function()
	if not didWarnAboutReassigningPropsRef then
		didWarnAboutReassigningPropsRef = require(script.Parent["ReactFiberBeginWork.new"]).didWarnAboutReassigningProps
	end
	return didWarnAboutReassigningPropsRef
end

-- deviation: Common types
type Set<T> = { [T]: boolean }

-- deviation: pre-declare functions when necessary
local isHostParent, getHostSibling, insertOrAppendPlacementNode, insertOrAppendPlacementNodeIntoContainer, commitLayoutEffectsForHostRoot, commitLayoutEffectsForHostComponent, commitLayoutEffectsForClassComponent, unmountHostComponents, commitNestedUnmounts, commitUnmount

-- Used to avoid traversing the return path to find the nearest Profiler ancestor during commit.
local nearestProfilerOnStack: Fiber | nil = nil

-- deviation: Not possible to return `undefined` in lua
-- local didWarnAboutUndefinedSnapshotBeforeUpdate: Set<any>? = nil
-- if __DEV__ then
--   didWarnAboutUndefinedSnapshotBeforeUpdate = {}
-- end

-- local PossiblyWeakSet = typeof WeakSet == 'function' ? WeakSet : Set

local function callComponentWillUnmountWithTimer(current, instance)
	instance.props = current.memoizedProps
	instance.state = current.memoizedState
	if enableProfilerTimer and enableProfilerCommitHooks and bit32.band(current.mode, ProfileMode) ~= 0 then
		-- performance? we could hoist start...Timer() out and eliminate the anon function, but then the timer would incldue the pcall overhead
		local ok, exception = xpcall(function()
			startLayoutEffectTimer()
			-- deviation: Call with ":" so that the method receives self
			instance:componentWillUnmount()
		end, describeError)

		recordLayoutEffectDuration(current)

		if not ok then
			error(exception)
		end
	else
		-- deviation: Call with ":" so that the method receives self
		instance:componentWillUnmount()
	end
end

-- Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current: Fiber, instance: any, nearestMountedAncestor): ()
	-- performance: eliminate the __DEV__ and invokeGuardedCallback, like React 18 has done
	local ok, error_ = xpcall(callComponentWillUnmountWithTimer, describeError, current, instance)

	if not ok then
		captureCommitPhaseError(current, nearestMountedAncestor, error_)
	end
end

local function safelyDetachRef(current: Fiber, nearestMountedAncestor: Fiber): ()
	local ref = current.ref
	if ref ~= nil then
		if typeof(ref) == "function" then
			-- performance: eliminate the __DEV__ and invokeGuardedCallback, like React 18 has done
			local ok, error_ = xpcall(ref, describeError)
			if not ok then
				captureCommitPhaseError(current, nearestMountedAncestor, error_)
			end
		else
			-- FIXME Luau: next line gets Expected type table, got 'RefObject | {| [string]: any, _stringRef: string? |}' instead
			ref.current = nil
		end
	end
end

local function safelyCallDestroy(current: Fiber, nearestMountedAncestor: Fiber | nil, destroy: () -> ()): ()
	-- performance: eliminate the __DEV__ and invokeGuardedCallback, like React 18 has done
	local ok, error_ = xpcall(destroy, describeError)
	if not ok then
		captureCommitPhaseError(current, nearestMountedAncestor, error_)
	end
end

local function commitBeforeMutationLifeCycles(current: Fiber | nil, finishedWork: Fiber): ()
	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		return
	elseif finishedWork.tag == ClassComponent then
		if bit32.band(finishedWork.flags, Snapshot) ~= 0 then
			if current ~= nil then
				local prevProps = (current :: Fiber).memoizedProps
				local prevState = (current :: Fiber).memoizedState
				local instance = finishedWork.stateNode
				-- We could update instance props and state here,
				-- but instead we rely on them being set during last render.
				-- TODO: revisit this when we implement resuming.
				if __DEV__ then
					if finishedWork.type == finishedWork.elementType and not didWarnAboutReassigningProps then
						if instance.props ~= finishedWork.memoizedProps then
							console.error(
								"Expected %s props to match memoized props before "
									.. "getSnapshotBeforeUpdate. "
									.. "This might either be because of a bug in React, or because "
									.. "a component reassigns its own `this.props`. "
									.. "Please file an issue.",
								getComponentName(finishedWork.type) or "instance"
							)
						end
						if instance.state ~= finishedWork.memoizedState then
							console.error(
								"Expected %s state to match memoized state before "
									.. "getSnapshotBeforeUpdate. "
									.. "This might either be because of a bug in React, or because "
									.. "a component reassigns its own `this.state`. "
									.. "Please file an issue.",
								getComponentName(finishedWork.type) or "instance"
							)
						end
					end
				end
				-- deviation: Call with ':' instead of '.' so that self is available
				local snapshot = instance:getSnapshotBeforeUpdate(
					finishedWork.elementType == finishedWork.type and prevProps
						or resolveDefaultProps(finishedWork.type, prevProps),
					prevState
				)
				if __DEV__ then
					-- deviation: not possible to return `undefined` in Lua
					-- local didWarnSet = ((didWarnAboutUndefinedSnapshotBeforeUpdate: any): Set<mixed>)
					-- if snapshot == nil and not didWarnSet[finishedWork.type] then
					--   didWarnSet[finishedWork.type] = true
					--   console.error(
					--     "%s.getSnapshotBeforeUpdate(): A snapshot value (or nil) " ..
					--       "must be returned. You have returned undefined.",
					--     getComponentName(finishedWork.type)
					--   )
					-- end
				end
				instance.__reactInternalSnapshotBeforeUpdate = snapshot
			end
		end
		return
	elseif finishedWork.tag == HostRoot then
		if supportsMutation then
			if bit32.band(finishedWork.flags, Snapshot) ~= 0 then
				local root = finishedWork.stateNode
				clearContainer(root.containerInfo)
			end
		end
		return
	elseif
		finishedWork.tag == HostComponent
		or finishedWork.tag == HostText
		or finishedWork.tag == HostPortal
		or finishedWork.tag == IncompleteClassComponent
	then
		-- Nothing to do for these component types
		return
	end
	invariant(
		false,
		"This unit of work tag should not have side-effects. This error is "
			.. "likely caused by a bug in React. Please file an issue."
	)
end

local function commitHookEffectListUnmount(flags: HookFlags, finishedWork: Fiber, nearestMountedAncestor: Fiber?)
	local updateQueue: FunctionComponentUpdateQueue | nil = finishedWork.updateQueue
	local lastEffect
	if updateQueue ~= nil then
		lastEffect = (updateQueue :: FunctionComponentUpdateQueue).lastEffect
	end

	if lastEffect ~= nil then
		local firstEffect = lastEffect.next
		local effect = firstEffect
		repeat
			if bit32.band(effect.tag, flags) == flags then
				-- Unmount
				local destroy = effect.destroy
				effect.destroy = nil
				if destroy ~= nil then
					safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy)
				end
			end
			effect = effect.next
		until effect == firstEffect
	end
end

local function commitHookEffectListMount(flags: HookFlags, finishedWork: Fiber)
	local updateQueue: FunctionComponentUpdateQueue | nil = finishedWork.updateQueue :: any
	local lastEffect = if updateQueue ~= nil then updateQueue.lastEffect else nil
	if lastEffect ~= nil then
		local firstEffect = lastEffect.next
		local effect = firstEffect
		repeat
			if bit32.band(effect.tag, flags) == flags then
				-- Mount
				local create = effect.create
				effect.destroy = create()

				if __DEV__ then
					local destroy = effect.destroy
					if destroy ~= nil and typeof(destroy) ~= "function" then
						local addendum
						if destroy == nil then
							addendum = " You returned nil. If your effect does not require clean "
								.. "up, return nil (or nothing)."
						elseif typeof(destroy.andThen) == "function" then
							addendum =
								-- FIXME: write a real program that does the equivalent and update this example, LUAFDN-754
								"\n\nIt looks like you wrote useEffect(Promise.new(function() --[[...]] end) or returned a Promise. " .. "Instead, write the async function inside your effect " .. "and call it immediately:\n\n" .. "useEffect(function()\n" .. "  function fetchData()\n" .. "    -- You can await here\n" .. "    local response = MyAPI.getData(someId):await()\n" .. "    -- ...\n" .. "  end\n" .. "  fetchData()\n" .. "end, {someId}) -- Or {} if effect doesn't need props or state\n\n" .. "Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching"
						else
							addendum = " You returned: " .. destroy
						end
						console.error(
							"An effect function must not return anything besides a function, "
								.. "which is used for clean-up.%s",
							addendum
						)
					end
				end
			end
			effect = effect.next
		until effect == firstEffect
	end
end

function commitProfilerPassiveEffect(finishedRoot: FiberRoot, finishedWork: Fiber): ()
	if enableProfilerTimer and enableProfilerCommitHooks then
		if finishedWork.tag == Profiler then
			local passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration
			local id, onPostCommit = finishedWork.memoizedProps.id, finishedWork.memoizedProps.onPostCommit

			-- This value will still reflect the previous commit phase.
			-- It does not get reset until the start of the next commit phase.
			local commitTime = getCommitTime()

			if typeof(onPostCommit) == "function" then
				if enableSchedulerTracing then
					onPostCommit(
						id,
						if finishedWork.alternate == nil then "mount" else "update",
						passiveEffectDuration,
						commitTime,
						finishedRoot.memoizedInteractions
					)
				else
					onPostCommit(
						id,
						if finishedWork.alternate == nil then "mount" else "update",
						passiveEffectDuration,
						commitTime
					)
				end
			end
		end
	end
end

local function recursivelyCommitLayoutEffects(
	finishedWork: Fiber,
	finishedRoot: FiberRoot,
	-- deviation: pass in these functions to avoid dependency cycle
	_captureCommitPhaseError: (
		sourceFiber: Fiber,
		nearestMountedAncestor: Fiber?,
		error: any
	) -> (),
	_schedulePassiveEffectCallback: () -> ()
)
	if _captureCommitPhaseError ~= nil then
		captureCommitPhaseError = _captureCommitPhaseError
	end
	if _schedulePassiveEffectCallback ~= nil then
		schedulePassiveEffectCallback = _schedulePassiveEffectCallback
	end
	local flags = finishedWork.flags
	local tag = finishedWork.tag
	if tag == Profiler then
		local prevProfilerOnStack = nil
		if enableProfilerTimer and enableProfilerCommitHooks then
			prevProfilerOnStack = nearestProfilerOnStack
			nearestProfilerOnStack = finishedWork
		end

		local child = finishedWork.child
		while child ~= nil do
			local primarySubtreeFlags = bit32.band(finishedWork.subtreeFlags, LayoutMask)
			if primarySubtreeFlags ~= NoFlags then
				if __DEV__ then
					local prevCurrentFiberInDEV = currentDebugFiberInDEV
					setCurrentDebugFiberInDEV(child)
					invokeGuardedCallback(
						nil,
						recursivelyCommitLayoutEffects,
						nil,
						child,
						finishedRoot,
						-- deviation: pass in these functions to avoid dependency cycle
						captureCommitPhaseError,
						schedulePassiveEffectCallback
					)
					if hasCaughtError() then
						local error_ = clearCaughtError()
						captureCommitPhaseError(child, finishedWork, error_)
					end
					if prevCurrentFiberInDEV ~= nil then
						setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
					else
						resetCurrentDebugFiberInDEV()
					end
				else
					local ok, error_ = xpcall(
						-- deviation: pass in captureCommitPhaseError function to avoid dependency cycle
						recursivelyCommitLayoutEffects,
						describeError,
						child,
						finishedRoot,
						captureCommitPhaseError,
						schedulePassiveEffectCallback
					)
					if not ok then
						captureCommitPhaseError(child, finishedWork, error_)
					end
				end
			end
			child = child.sibling
		end

		local primaryFlags = bit32.band(flags, bit32.bor(Update, Callback))
		if primaryFlags ~= NoFlags then
			if enableProfilerTimer then
				if __DEV__ then
					local prevCurrentFiberInDEV = currentDebugFiberInDEV
					setCurrentDebugFiberInDEV(finishedWork)
					invokeGuardedCallback(nil, commitLayoutEffectsForProfiler, nil, finishedWork, finishedRoot)
					if hasCaughtError() then
						local error_ = clearCaughtError()
						captureCommitPhaseError(finishedWork, finishedWork.return_, error_)
					end
					if prevCurrentFiberInDEV ~= nil then
						setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
					else
						resetCurrentDebugFiberInDEV()
					end
				else
					-- TODO? pass in captureCommitPhaseError?
					local ok, error_ = xpcall(commitLayoutEffectsForProfiler, describeError, finishedWork, finishedRoot)
					if not ok then
						captureCommitPhaseError(finishedWork, finishedWork.return_, error_)
					end
				end
			end
		end

		if enableProfilerTimer and enableProfilerCommitHooks then
			-- Propagate layout effect durations to the next nearest Profiler ancestor.
			-- Do not reset these values until the next render so DevTools has a chance to read them first.
			if prevProfilerOnStack ~= nil then
				prevProfilerOnStack.stateNode.effectDuration += finishedWork.stateNode.effectDuration
			end

			nearestProfilerOnStack = prevProfilerOnStack
		end
	-- elseif tag == Offscreen then
	-- TODO: Fast path to invoke all nested layout effects when Offscren goes from hidden to visible.
	else
		local child = finishedWork.child
		while child ~= nil do
			local primarySubtreeFlags = bit32.band(finishedWork.subtreeFlags, LayoutMask)
			if primarySubtreeFlags ~= NoFlags then
				if __DEV__ then
					local prevCurrentFiberInDEV = ReactCurrentFiber.current
					setCurrentDebugFiberInDEV(child)
					--[[
              ROBLOX DEVIATION: In DEV, After MAX_RUN_DEPTH pcalls, do not wrap recursive calls in pcall. Otherwise,
              we hit the stack limit and get a stack overflow error.
            ]]
					if runDepth < MAX_RUN_DEPTH then
						runDepth += 1
						invokeGuardedCallback(
							nil,
							recursivelyCommitLayoutEffects,
							nil,
							child,
							finishedRoot,
							-- deviation: pass in this function to avoid dependency cycle
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)
						runDepth -= 1

						if hasCaughtError() then
							local error_ = clearCaughtError()
							captureCommitPhaseError(child, finishedWork, error_)
						end
					else
						recursivelyCommitLayoutEffects(
							child,
							finishedRoot,
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)
					end
					if prevCurrentFiberInDEV ~= nil then
						setCurrentDebugFiberInDEV(prevCurrentFiberInDEV)
					else
						resetCurrentDebugFiberInDEV()
					end
				else
					-- deviation: YOLO flag for disabling pcall
					local ok, error_
					if not __YOLO__ and runDepth < MAX_RUN_DEPTH then
						--[[
              ROBLOX DEVIATION: After MAX_RUN_DEPTH pcalls, do not wrap recursive calls in pcall. Otherwise, we hit the
              stack limit and get a stack overflow error.
            ]]
						runDepth += 1

						ok, error_ = xpcall(
							-- deviation: pass in this function to avoid dependency cycle
							recursivelyCommitLayoutEffects,
							describeError,
							child,
							finishedRoot,
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)

						runDepth -= 1
					else
						ok = true
						recursivelyCommitLayoutEffects(
							child,
							finishedRoot,
							captureCommitPhaseError,
							schedulePassiveEffectCallback
						)
					end

					if not ok then
						captureCommitPhaseError(child, finishedWork, error_)
					end
				end
			end
			child = child.sibling
		end

		local primaryFlags = bit32.band(flags, bit32.bor(Update, Callback))
		if primaryFlags ~= NoFlags then
			if tag == FunctionComponent or tag == ForwardRef or tag == SimpleMemoComponent or tag == Block then
				if
					enableProfilerTimer
					and enableProfilerCommitHooks
					and bit32.band(finishedWork.mode, ProfileMode) ~= 0
				then
					-- try
					local ok, error_ = xpcall(function()
						startLayoutEffectTimer()
						commitHookEffectListMount(bit32.bor(HookLayout, HookHasEffect), finishedWork)
					end, describeError)
					-- finally
					recordLayoutEffectDuration(finishedWork)
					if not ok then
						error(error_)
					end
				else
					commitHookEffectListMount(bit32.bor(HookLayout, HookHasEffect), finishedWork)
				end

				if bit32.band(finishedWork.subtreeFlags, PassiveMask) ~= NoFlags then
					schedulePassiveEffectCallback()
				end
			elseif tag == ClassComponent then
				-- NOTE: Layout effect durations are measured within this function.
				commitLayoutEffectsForClassComponent(finishedWork)
			elseif tag == HostRoot then
				commitLayoutEffectsForHostRoot(finishedWork)
			elseif tag == HostComponent then
				commitLayoutEffectsForHostComponent(finishedWork)
			elseif tag == SuspenseComponent then
				commitSuspenseHydrationCallbacks(finishedRoot, finishedWork)
			elseif
				tag == FundamentalComponent
				or tag == HostPortal
				or tag == HostText
				or tag == IncompleteClassComponent
				or tag == LegacyHiddenComponent
				or tag == OffscreenComponent
				or tag == ScopeComponent
				or tag == SuspenseListComponent
			then
			-- break
			else
				invariant(
					false,
					"This unit of work tag should not have side-effects. This error is "
						.. "likely caused by a bug in React. Please file an issue."
				)
			end
		end

		-- performance: avoid cmp on always-false value
		-- if enableScopeAPI then
		--   -- TODO: This is a temporary solution that allowed us to transition away from React Flare on www.
		--   if bit32.band(flags, Ref) ~= 0 and tag ~= ScopeComponent then
		--     commitAttachRef(finishedWork)
		--   end
		-- else
		if bit32.band(flags, Ref) ~= 0 then
			commitAttachRef(finishedWork)
		end
		-- end
	end
end

function commitLayoutEffectsForProfiler(finishedWork: Fiber, finishedRoot: FiberRoot)
	if enableProfilerTimer then
		local flags = finishedWork.flags
		local current = finishedWork.alternate

		local onCommit, onRender = finishedWork.memoizedProps.onCommit, finishedWork.memoizedProps.onRender
		local effectDuration = finishedWork.stateNode.effectDuration

		local commitTime = getCommitTime()

		local OnRenderFlag = Update
		local OnCommitFlag = Callback

		if
			bit32.band(flags, OnRenderFlag) ~= NoFlags
			-- deviation: our mocked functions are tables with __call, since they have fields
			and isCallable(onRender)
		then
			if enableSchedulerTracing then
				onRender(
					finishedWork.memoizedProps.id,
					if current == nil then "mount" else "update",
					finishedWork.actualDuration,
					finishedWork.treeBaseDuration,
					finishedWork.actualStartTime,
					commitTime,
					finishedRoot.memoizedInteractions
				)
			else
				onRender(
					finishedWork.memoizedProps.id,
					if current == nil then "mount" else "update",
					finishedWork.actualDuration,
					finishedWork.treeBaseDuration,
					finishedWork.actualStartTime,
					commitTime
				)
			end
		end

		if enableProfilerCommitHooks then
			if
				bit32.band(flags, OnCommitFlag) ~= NoFlags
				-- deviation: our mocked functions are tables with __call, since they have fields
				and isCallable(onCommit)
			then
				if enableSchedulerTracing then
					onCommit(
						finishedWork.memoizedProps.id,
						if current == nil then "mount" else "update",
						effectDuration,
						commitTime,
						finishedRoot.memoizedInteractions
					)
				else
					onCommit(
						finishedWork.memoizedProps.id,
						if current == nil then "mount" else "update",
						effectDuration,
						commitTime
					)
				end
			end
		end
	end
end

function commitLayoutEffectsForClassComponent(finishedWork: Fiber)
	local instance = finishedWork.stateNode
	local current = finishedWork.alternate
	if bit32.band(finishedWork.flags, Update) ~= 0 then
		if current == nil then
			-- We could update instance props and state here,
			-- but instead we rely on them being set during last render.
			-- TODO: revisit this when we implement resuming.
			if __DEV__ then
				if finishedWork.type == finishedWork.elementType and not didWarnAboutReassigningProps then
					if instance.props ~= finishedWork.memoizedProps then
						console.error(
							"Expected %s props to match memoized props before "
								.. "componentDidMount. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.props`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
					if instance.state ~= finishedWork.memoizedState then
						console.error(
							"Expected %s state to match memoized state before "
								.. "componentDidMount. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.state`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
				end
			end
			if
				enableProfilerTimer
				and enableProfilerCommitHooks
				and bit32.band(finishedWork.mode, ProfileMode) ~= 0
			then
				local ok, result = xpcall(function()
					startLayoutEffectTimer()
					-- deviation: Call with ":" so that the method receives self
					instance:componentDidMount()
				end, describeError)
				-- finally
				recordLayoutEffectDuration(finishedWork)
				if not ok then
					error(result)
				end
			else
				-- deviation: Call with ":" so that the method receives self
				instance:componentDidMount()
			end
		else
			local prevProps = finishedWork.elementType == finishedWork.type and current.memoizedProps
				or resolveDefaultProps(finishedWork.type, current.memoizedProps)
			local prevState = current.memoizedState
			-- We could update instance props and state here,
			-- but instead we rely on them being set during last render.
			-- TODO: revisit this when we implement resuming.
			if __DEV__ then
				if finishedWork.type == finishedWork.elementType and not didWarnAboutReassigningProps then
					if instance.props ~= finishedWork.memoizedProps then
						console.error(
							"Expected %s props to match memoized props before "
								.. "componentDidUpdate. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.props`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
					if instance.state ~= finishedWork.memoizedState then
						console.error(
							"Expected %s state to match memoized state before "
								.. "componentDidUpdate. "
								.. "This might either be because of a bug in React, or because "
								.. "a component reassigns its own `this.state`. "
								.. "Please file an issue.",
							getComponentName(finishedWork.type) or "instance"
						)
					end
				end
			end
			if
				enableProfilerTimer
				and enableProfilerCommitHooks
				and bit32.band(finishedWork.mode, ProfileMode) ~= 0
			then
				local ok, result = xpcall(function()
					startLayoutEffectTimer()
					-- deviation: Call with ":" so that the method receives self
					instance:componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate)
				end, describeError)
				-- finally
				recordLayoutEffectDuration(finishedWork)
				if not ok then
					error(result)
				end
			else
				-- deviation: Call with ":" so that the method receives self
				instance:componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate)
			end
		end
	end

	-- TODO: I think this is now always non-null by the time it reaches the
	-- commit phase. Consider removing the type check.
	local updateQueue: UpdateQueue<any> | nil = finishedWork.updateQueue
	if updateQueue ~= nil then
		if __DEV__ then
			if finishedWork.type == finishedWork.elementType and not didWarnAboutReassigningProps then
				if instance.props ~= finishedWork.memoizedProps then
					console.error(
						"Expected %s props to match memoized props before "
							.. "processing the update queue. "
							.. "This might either be because of a bug in React, or because "
							.. "a component reassigns its own `this.props`. "
							.. "Please file an issue.",
						getComponentName(finishedWork.type) or "instance"
					)
				end
				if instance.state ~= finishedWork.memoizedState then
					console.error(
						"Expected %s state to match memoized state before "
							.. "processing the update queue. "
							.. "This might either be because of a bug in React, or because "
							.. "a component reassigns its own `this.state`. "
							.. "Please file an issue.",
						getComponentName(finishedWork.type) or "instance"
					)
				end
			end
		end
		-- We could update instance props and state here,
		-- but instead we rely on them being set during last render.
		-- TODO: revisit this when we implement resuming.
		commitUpdateQueue(finishedWork, updateQueue, instance)
	end
end

function commitLayoutEffectsForHostRoot(finishedWork: Fiber)
	-- TODO: I think this is now always non-null by the time it reaches the
	-- commit phase. Consider removing the type check.
	local updateQueue: UpdateQueue<any> | nil = finishedWork.updateQueue
	if updateQueue ~= nil then
		local instance = nil
		if finishedWork.child ~= nil then
			-- TODO: localize child, workaround Luau type refinement shortcomings
			local child = finishedWork.child
			if child.tag == HostComponent then
				instance = getPublicInstance(child.stateNode)
			elseif child.tag == ClassComponent then
				instance = child.stateNode
			end
		end
		commitUpdateQueue(finishedWork, updateQueue, instance)
	end
end

function commitLayoutEffectsForHostComponent(finishedWork: Fiber)
	local instance: Instance = finishedWork.stateNode
	local current = finishedWork.alternate

	-- Renderers may schedule work to be done after host components are mounted
	-- (eg DOM renderer may schedule auto-focus for inputs and form controls).
	-- These effects should only be committed when components are first mounted,
	-- aka when there is no current/alternate.
	if current == nil and bit32.band(finishedWork.flags, Update) ~= 0 then
		local type = finishedWork.type
		local props = finishedWork.memoizedProps
		commitMount(instance, type, props, finishedWork)
	end
end

local function hideOrUnhideAllChildren(finishedWork, isHidden)
	if supportsMutation then
		-- We only have the top Fiber that was inserted but we need to recurse down its
		-- children to find all the terminal nodes.
		local node: Fiber = finishedWork
		while true do
			if node.tag == HostComponent then
				local instance = node.stateNode
				if isHidden then
					hideInstance(instance)
				else
					unhideInstance(node.stateNode, node.memoizedProps)
				end
			elseif node.tag == HostText then
				local instance = node.stateNode
				if isHidden then
					hideTextInstance(instance)
				else
					unhideTextInstance(instance, node.memoizedProps)
				end
			elseif
				(node.tag == OffscreenComponent or node.tag == LegacyHiddenComponent)
				and (node.memoizedState :: OffscreenState) ~= nil
				and node ~= finishedWork
			then
			-- Found a nested Offscreen component that is hidden. Don't search
			-- any deeper. This tree should remain hidden.
			elseif node.child ~= nil then
				-- FIXME: type casts to silence analyze, Luau doesn't understand nil check
				(node.child :: Fiber).return_ = node
				node = node.child :: Fiber
				continue
			end
			if node == finishedWork then
				return
			end
			while node.sibling == nil do
				if node.return_ == nil or node.return_ == finishedWork then
					return
				end
				node = node.return_ :: Fiber -- TODO: Luau narrowing doesn't understand this loop until nil pattern
			end
			-- FIXME: cast to any to silence analyze
			(node.sibling :: Fiber).return_ = node.return_
			-- FIXME: recast to silence analyze while Luau doesn't understand nil check
			node = node.sibling :: Fiber
		end
	end
end

function commitAttachRef(finishedWork: Fiber)
	local ref = finishedWork.ref
	if ref ~= nil then
		local instance = finishedWork.stateNode
		local instanceToUse
		if finishedWork.tag == HostComponent then
			instanceToUse = getPublicInstance(instance)
		else
			instanceToUse = instance
		end
		-- Moved outside to ensure DCE works with this flag
		-- performance: avoid cmp on always-false value
		-- if enableScopeAPI and finishedWork.tag == ScopeComponent then
		--   instanceToUse = instance
		-- end
		if typeof(ref) == "function" then
			ref(instanceToUse)
		else
			if __DEV__ then
				-- FIXME: We won't be able to recognize a ref object by checking
				-- for the existence of the `current` key, since it won't be initialized
				-- at this point. We might consider using a symbol to uniquely identify
				-- ref objects, or relying more heavily on Luau types
				-- if not ref.current then
				if typeof(ref) ~= "table" then
					console.error(
						"Unexpected ref object provided for %s. "
							.. "Use either a ref-setter function or React.createRef().",
						getComponentName(finishedWork.type) or "instance"
					)
					return
				end
			end

			ref.current = instanceToUse
		end
	end
end

function commitDetachRef(current: Fiber)
	local currentRef = current.ref
	if currentRef ~= nil then
		if typeof(currentRef) == "function" then
			currentRef(nil)
		else
			currentRef.current = nil
		end
	end
end

-- User-originating errors (lifecycles and refs) should not interrupt
-- deletion, so don't local them throw. Host-originating errors should
-- interrupt deletion, so it's okay
function commitUnmount(
	finishedRoot: FiberRoot,
	current: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
): ()
	onCommitUnmount(current)

	if
		current.tag == FunctionComponent
		or current.tag == ForwardRef
		or current.tag == MemoComponent
		or current.tag == SimpleMemoComponent
		or current.tag == Block
	then
		local updateQueue: FunctionComponentUpdateQueue | nil = current.updateQueue
		if updateQueue ~= nil then
			local lastEffect = (updateQueue :: FunctionComponentUpdateQueue).lastEffect
			if lastEffect ~= nil then
				local firstEffect = lastEffect.next

				local effect = firstEffect
				repeat
					if effect.destroy ~= nil then
						if bit32.band(effect.tag, HookLayout) ~= NoHookEffect then
							if
								enableProfilerTimer
								and enableProfilerCommitHooks
								and bit32.band(current.mode, ProfileMode) ~= 0
							then
								startLayoutEffectTimer()
								safelyCallDestroy(current, nearestMountedAncestor, effect.destroy)
								recordLayoutEffectDuration(current)
							else
								safelyCallDestroy(current, nearestMountedAncestor, effect.destroy)
							end
						end
					end
					effect = effect.next
				until effect == firstEffect
			end
		end
		return
	elseif current.tag == ClassComponent then
		safelyDetachRef(current, nearestMountedAncestor)
		local instance = current.stateNode
		if typeof(instance.componentWillUnmount) == "function" then
			safelyCallComponentWillUnmount(current, instance, nearestMountedAncestor)
		end
		return
	elseif current.tag == HostComponent then
		safelyDetachRef(current, nearestMountedAncestor)
		return
	elseif current.tag == HostPortal then
		-- TODO: this is recursive.
		-- We are also not using this parent because
		-- the portal will get pushed immediately.
		if supportsMutation then
			unmountHostComponents(finishedRoot, current, nearestMountedAncestor, renderPriorityLevel)
		elseif supportsPersistence then
			unimplemented("emptyPortalContainer")
			-- emptyPortalContainer(current)
		end
		return
		-- elseif current.tag == FundamentalComponent then
		--   unimplemented("commitUnmount - FundamentalComponent")
		-- if enableFundamentalAPI then
		--   local fundamentalInstance = current.stateNode
		--   if fundamentalInstance ~= nil then
		--     unmountFundamentalComponent(fundamentalInstance)
		--     current.stateNode = nil
		--   end
		-- end
		-- return
		-- elseif current.tag == DehydratedFragment then
		--   unimplemented("commitUnmount - DehydratedFragment")
		-- if enableSuspenseCallback then
		--   local hydrationCallbacks = finishedRoot.hydrationCallbacks
		--   if hydrationCallbacks ~= nil then
		--     local onDeleted = hydrationCallbacks.onDeleted
		--     if onDeleted then
		--       onDeleted((current.stateNode: SuspenseInstance))
		--     end
		--   end
		-- end
		-- return
		-- elseif current.tag == ScopeComponent then
		--   if enableScopeAPI then
		--     safelyDetachRef(current, nearestMountedAncestor)
		--   end
		--   return
	end
end

function commitNestedUnmounts(
	finishedRoot: FiberRoot,
	root: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
)
	-- While we're inside a removed host node we don't want to call
	-- removeChild on the inner nodes because they're removed by the top
	-- call anyway. We also want to call componentWillUnmount on all
	-- composites before this host node is removed from the tree. Therefore
	-- we do an inner loop while we're still inside the host node.
	local node: Fiber = root
	while true do
		commitUnmount(finishedRoot, node, nearestMountedAncestor, renderPriorityLevel)
		-- Visit children because they may contain more composite or host nodes.
		-- Skip portals because commitUnmount() currently visits them recursively.
		if
			node.child ~= nil
			-- If we use mutation we drill down into portals using commitUnmount above.
			-- If we don't use mutation we drill down into portals here instead.
			and (not supportsMutation or node.tag ~= HostPortal)
		then
			(node.child :: Fiber).return_ = node
			node = node.child :: Fiber
			continue
		end
		if node == root then
			return
		end
		while node.sibling == nil do
			if node.return_ == nil or node.return_ == root then
				return
			end
			node = node.return_ :: Fiber -- TODO: Luau narrowing doesn't understand this loop until nil pattern
		end
		(node.sibling :: Fiber).return_ = node.return_
		node = node.sibling :: Fiber
	end
end

local function detachFiberMutation(fiber: Fiber)
	-- Cut off the return pointer to disconnect it from the tree.
	-- This enables us to detect and warn against state updates on an unmounted component.
	-- It also prevents events from bubbling from within disconnected components.
	--
	-- Ideally, we should also clear the child pointer of the parent alternate to local this
	-- get GC:ed but we don't know which for sure which parent is the current
	-- one so we'll settle for GC:ing the subtree of this child.
	-- This child itself will be GC:ed when the parent updates the next time.
	--
	-- Note that we can't clear child or sibling pointers yet.
	-- They're needed for passive effects and for findDOMNode.
	-- We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).
	local alternate = fiber.alternate
	if alternate ~= nil then
		alternate.return_ = nil
		fiber.alternate = nil
	end
	fiber.return_ = nil
end

-- function emptyPortalContainer(current: Fiber)
--   if !supportsPersistence)
--     return
--   end

--   local portal: {
--     containerInfo: Container,
--     pendingChildren: ChildSet,
--     ...
--   } = current.stateNode
--   local {containerInfo} = portal
--   local emptyChildSet = createContainerChildSet(containerInfo)
--   replaceContainerChildren(containerInfo, emptyChildSet)
-- end

-- function commitContainer(finishedWork: Fiber)
--   if !supportsPersistence)
--     return
--   end

--   switch (finishedWork.tag)
--     case ClassComponent:
--     case HostComponent:
--     case HostText:
--     case FundamentalComponent: {
--       return
--     end
--     case HostRoot:
--     case HostPortal: {
--       local portalOrRoot: {
--         containerInfo: Container,
--         pendingChildren: ChildSet,
--         ...
--       } = finishedWork.stateNode
--       local {containerInfo, pendingChildren} = portalOrRoot
--       replaceContainerChildren(containerInfo, pendingChildren)
--       return
--     end
--   end
--   invariant(
--     false,
--     'This unit of work tag should not have side-effects. This error is ' +
--       'likely caused by a bug in React. Please file an issue.',
--   )
-- end

local function getHostParentFiber(fiber: Fiber): Fiber
	local parent = fiber.return_
	while parent ~= nil do
		if isHostParent(parent) then
			return parent
		end
		parent = parent.return_
	end
	-- deviation START: use React 18 approach, which Luau understands better than invariant
	error(
		Error.new(
			"Expected to find a host parent. This error is likely caused by a bug " .. "in React. Please file an issue."
		)
	)
	-- deviation END
end

function isHostParent(fiber: Fiber): boolean
	return fiber.tag == HostComponent or fiber.tag == HostRoot or fiber.tag == HostPortal
end

function getHostSibling(fiber: Fiber): Instance?
	-- We're going to search forward into the tree until we find a sibling host
	-- node. Unfortunately, if multiple insertions are done in a row we have to
	-- search past them. This leads to exponential search for the next sibling.
	-- TODO: Find a more efficient way to do this.
	local node: Fiber = fiber
	while true do
		-- deviation: we can't `continue` with labels in luau, so some variable
		-- juggling is used instead
		local continueOuter = false
		-- If we didn't find anything, let's try the next sibling.
		while node.sibling == nil do
			if node.return_ == nil or isHostParent(node.return_) then
				-- If we pop out of the root or hit the parent the fiber we are the
				-- last sibling.
				return nil
			end
			node = node.return_ :: Fiber -- TODO: Luau narrowing doesn't understand this loop until nil pattern
		end
		(node.sibling :: Fiber).return_ = node.return_ :: Fiber
		node = node.sibling :: Fiber
		while node.tag ~= HostComponent and node.tag ~= HostText and node.tag ~= DehydratedFragment do
			-- If it is not host node and, we might have a host node inside it.
			-- Try to search down until we find one.
			if bit32.band(node.flags, Placement) ~= 0 then
				-- If we don't have a child, try the siblings instead.
				continueOuter = true
				break
			end
			-- If we don't have a child, try the siblings instead.
			-- We also skip portals because they are not part of this host tree.
			if node.child == nil or node.tag == HostPortal then
				continueOuter = true
				break
			else
				(node.child :: Fiber).return_ = node
				node = node.child :: Fiber
			end
		end
		if continueOuter then
			continue
		end
		-- Check if this host node is stable or about to be placed.
		if bit32.band(node.flags, Placement) == 0 then
			-- Found it!
			return node.stateNode
		end
	end
end

local function commitPlacement(finishedWork: Fiber)
	if not supportsMutation then
		return
	end

	-- Recursively insert all host nodes into the parent.
	local parentFiber = getHostParentFiber(finishedWork)

	-- NOTE: these two variables *must* always be updated together.
	local parent
	local isContainer
	local parentStateNode = parentFiber.stateNode
	if parentFiber.tag == HostComponent then
		parent = parentStateNode
		isContainer = false
	elseif parentFiber.tag == HostRoot then
		parent = parentStateNode.containerInfo
		isContainer = true
	elseif parentFiber.tag == HostPortal then
		parent = parentStateNode.containerInfo
		isContainer = true
	-- elseif parentFiber.tag == FundamentalComponent then
	--   if enableFundamentalAPI then
	--     parent = parentStateNode.instance
	--     isContainer = false
	--   end
	else
		-- eslint-disable-next-line-no-fallthrough
		invariant(
			false,
			"Invalid host parent fiber. This error is likely caused by a bug " .. "in React. Please file an issue."
		)
	end
	if bit32.band(parentFiber.flags, ContentReset) ~= 0 then
		-- Reset the text content of the parent before doing any insertions
		resetTextContent(parent)
		-- Clear ContentReset from the effect tag
		parentFiber.flags = bit32.band(parentFiber.flags, bit32.bnot(ContentReset))
	end

	local before = getHostSibling(finishedWork)
	-- We only have the top Fiber that was inserted but we need to recurse down its
	-- children to find all the terminal nodes.
	if isContainer then
		insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent)
	else
		insertOrAppendPlacementNode(finishedWork, before, parent)
	end
end

function insertOrAppendPlacementNodeIntoContainer(node: Fiber, before: Instance?, parent: Container)
	local tag = node.tag
	local isHost = tag == HostComponent or tag == HostText
	-- performance: avoid always-false compare for Roblox renderer in hot path
	if isHost then -- or (enableFundamentalAPI and tag == FundamentalComponent) then
		local stateNode = node.stateNode
		if before then
			insertInContainerBefore(parent, stateNode, before)
		else
			appendChildToContainer(parent, stateNode)
		end
	elseif tag == HostPortal then
	-- If the insertion itself is a portal, then we don't want to traverse
	-- down its children. Instead, we'll get insertions from each child in
	-- the portal directly.
	else
		local child = node.child
		if child ~= nil then
			insertOrAppendPlacementNodeIntoContainer(child, before, parent)
			local sibling = child.sibling
			while sibling ~= nil do
				insertOrAppendPlacementNodeIntoContainer(sibling, before, parent)
				sibling = sibling.sibling
			end
		end
	end
end

function insertOrAppendPlacementNode(node: Fiber, before: Instance?, parent: Instance): ()
	local tag = node.tag
	local isHost = tag == HostComponent or tag == HostText
	-- performance: avoid always-false compare for Roblox renderer in hot path
	if isHost then -- or (enableFundamentalAPI and tag == FundamentalComponent) then
		local stateNode = node.stateNode
		if before then
			insertBefore(parent, stateNode, before)
		else
			appendChild(parent, stateNode)
		end
	elseif tag == HostPortal then
	-- If the insertion itself is a portal, then we don't want to traverse
	-- down its children. Instead, we'll get insertions from each child in
	-- the portal directly.
	else
		local child = node.child
		if child ~= nil then
			insertOrAppendPlacementNode(child, before, parent)
			local sibling = child.sibling
			while sibling ~= nil do
				insertOrAppendPlacementNode(sibling, before, parent)
				sibling = sibling.sibling
			end
		end
	end
end

function unmountHostComponents(
	finishedRoot: FiberRoot,
	current: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
): ()
	-- We only have the top Fiber that was deleted but we need to recurse down its
	-- children to find all the terminal nodes.
	local node: Fiber = current

	-- Each iteration, currentParent is populated with node's host parent if not
	-- currentParentIsValid.
	local currentParentIsValid = false

	-- NOTE: these two variables *must* always be updated together.
	local currentParent
	local currentParentIsContainer

	while true do
		if not currentParentIsValid then
			-- FIXME Luau: Luau doesn't understand the nil guard at the top of the loop
			local parent = node.return_ :: Fiber
			while true do
				-- deviation START: use React 18 approach so Luau understands control flow better
				if parent == nil then
					error(
						Error.new(
							"Expected to find a host parent. This error is likely caused by "
								.. "a bug in React. Please file an issue."
						)
					)
				end
				-- deviation END
				local parentStateNode = parent.stateNode
				if parent.tag == HostComponent then
					currentParent = parentStateNode
					currentParentIsContainer = false
					break
				elseif parent.tag == HostRoot then
					currentParent = parentStateNode.containerInfo
					currentParentIsContainer = true
					break
				elseif parent.tag == HostPortal then
					currentParent = parentStateNode.containerInfo
					currentParentIsContainer = true
					break
					-- performance: eliminate always-false compare for Roblox in hot path
					-- elseif parent.tag == FundamentalComponent then
					--   if enableFundamentalAPI then
					--     currentParent = parentStateNode.instance
					--     currentParentIsContainer = false
					--   end
				end
				-- FIXME Luau: Luau doesn't understand the nil guard at the top of the loop
				parent = parent.return_ :: Fiber
			end
			currentParentIsValid = true
		end

		if node.tag == HostComponent or node.tag == HostText then
			commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor, renderPriorityLevel)
			-- After all the children have unmounted, it is now safe to remove the
			-- node from the tree.
			if currentParentIsContainer then
				-- removeChildFromContainer(
				--   ((currentParent: any): Container),
				--   (fundamentalNode: Instance),
				-- )
				-- FIXME: type coercion
				removeChildFromContainer(currentParent, node.stateNode)
			else
				-- removeChild(
				--   ((currentParent: any): Instance),
				--   (fundamentalNode: Instance),
				-- )
				-- FIXME: type coercion
				removeChild(currentParent, node.stateNode)
			end
		-- Don't visit children because we already visited them.
		-- performance? fundamentalAPI  and suspenseServerRender are always false for Roblox. avoid unnecessary cmp in hot path
		-- elseif enableFundamentalAPI and node.tag == FundamentalComponent then
		--   local fundamentalNode = node.stateNode.instance
		--   commitNestedUnmounts(
		--     finishedRoot,
		--     node,
		--     nearestMountedAncestor,
		--     renderPriorityLevel
		--   )
		--   -- After all the children have unmounted, it is now safe to remove the
		--   -- node from the tree.
		--   if currentParentIsContainer then
		--     -- removeChildFromContainer(
		--     --   ((currentParent: any): Container),
		--     --   (fundamentalNode: Instance),
		--     -- )
		--     -- FIXME: type coercion
		--     removeChildFromContainer(currentParent, fundamentalNode)
		--   else
		--     -- removeChild(
		--     --   ((currentParent: any): Instance),
		--     --   (fundamentalNode: Instance),
		--     -- )
		--     -- FIXME: type coercion
		--     removeChild(currentParent, fundamentalNode)
		--   end
		-- elseif
		--   enableSuspenseServerRenderer and
		--   node.tag == DehydratedFragment
		-- then
		--   unimplemented("clearSuspenseBoundary")
		--   -- if enableSuspenseCallback then
		--   --   local hydrationCallbacks = finishedRoot.hydrationCallbacks
		--   --   if hydrationCallbacks ~= nil)
		--   --     local onDeleted = hydrationCallbacks.onDeleted
		--   --     if onDeleted)
		--   --       onDeleted((node.stateNode: SuspenseInstance))
		--   --     end
		--   --   end
		--   -- end

		--   -- -- Delete the dehydrated suspense boundary and all of its content.
		--   -- if currentParentIsContainer)
		--   --   clearSuspenseBoundaryFromContainer(
		--   --     ((currentParent: any): Container),
		--   --     (node.stateNode: SuspenseInstance),
		--   --   )
		--   -- } else {
		--   --   clearSuspenseBoundary(
		--   --     ((currentParent: any): Instance),
		--   --     (node.stateNode: SuspenseInstance),
		--   --   )
		--   -- end
		elseif node.tag == HostPortal then
			if node.child ~= nil then
				-- When we go into a portal, it becomes the parent to remove from.
				-- We will reassign it back when we pop the portal on the way up.
				currentParent = node.stateNode.containerInfo
				currentParentIsContainer = true
				-- Visit children because portals might contain host components.
				node.child.return_ = node
				node = node.child
				continue
			end
		else
			commitUnmount(finishedRoot, node, nearestMountedAncestor, renderPriorityLevel)
			-- Visit children because we may find more host components below.
			if node.child ~= nil then
				node.child.return_ = node
				node = node.child
				continue
			end
		end
		if node == current then
			return
		end
		while node.sibling == nil do
			if node.return_ == nil or node.return_ == current then
				return
			end
			-- FIXME Luau: Luau doesn't understand narrowing by guard above
			node = node.return_ :: Fiber
			if node.tag == HostPortal then
				-- When we go out of the portal, we need to restore the parent.
				-- Since we don't keep a stack of them, we will search for it.
				currentParentIsValid = false
			end
		end
		-- TODO: flowtype makes an impossible leap here, contribute this annotation upstream
		(node.sibling :: Fiber).return_ = node.return_
		node = node.sibling :: Fiber
	end
end

local function commitDeletion(
	finishedRoot: FiberRoot,
	current: Fiber,
	nearestMountedAncestor: Fiber,
	renderPriorityLevel: ReactPriorityLevel
): ()
	-- performance? supportsMutation always true, eliminate cmp on hot path
	-- if supportsMutation then
	-- Recursively delete all host nodes from the parent.
	-- Detach refs and call componentWillUnmount() on the whole subtree.
	unmountHostComponents(finishedRoot, current, nearestMountedAncestor, renderPriorityLevel)
	-- else
	--   -- Detach refs and call componentWillUnmount() on the whole subtree.
	--   commitNestedUnmounts(
	--     finishedRoot,
	--     current,
	--     nearestMountedAncestor,
	--     renderPriorityLevel
	--   )
	-- end
	local alternate = current.alternate
	detachFiberMutation(current)
	if alternate ~= nil then
		detachFiberMutation(alternate)
	end
end

local function commitWork(current: Fiber | nil, finishedWork: Fiber)
	-- if not supportsMutation then
	--   unimplemented("commitWork: non-mutation branch")
	-- switch (finishedWork.tag)
	--   case FunctionComponent:
	--   case ForwardRef:
	--   case MemoComponent:
	--   case SimpleMemoComponent:
	--   case Block: {
	--     -- Layout effects are destroyed during the mutation phase so that all
	--     -- destroy functions for all fibers are called before any create functions.
	--     -- This prevents sibling component effects from interfering with each other,
	--     -- e.g. a destroy function in one component should never override a ref set
	--     -- by a create function in another component during the same commit.
	--     if
	--       enableProfilerTimer and
	--       enableProfilerCommitHooks and
	--       finishedWork.mode & ProfileMode
	--     )
	--       try {
	--         startLayoutEffectTimer()
	--         commitHookEffectListUnmount(
	--           HookLayout | HookHasEffect,
	--           finishedWork,
	--           finishedWork.return_,
	--         )
	--       } finally {
	--         recordLayoutEffectDuration(finishedWork)
	--       end
	--     } else {
	--       commitHookEffectListUnmount(
	--         HookLayout | HookHasEffect,
	--         finishedWork,
	--         finishedWork.return_,
	--       )
	--     end
	--     return
	--   end
	--   case Profiler: {
	--     return
	--   end
	--   case SuspenseComponent: {
	--     commitSuspenseComponent(finishedWork)
	--     attachSuspenseRetryListeners(finishedWork)
	--     return
	--   end
	--   case SuspenseListComponent: {
	--     attachSuspenseRetryListeners(finishedWork)
	--     return
	--   end
	--   case HostRoot: {
	--     if supportsHydration)
	--       local root: FiberRoot = finishedWork.stateNode
	--       if root.hydrate)
	--         -- We've just hydrated. No need to hydrate again.
	--         root.hydrate = false
	--         commitHydratedContainer(root.containerInfo)
	--       end
	--     end
	--     break
	--   end
	--   case OffscreenComponent:
	--   case LegacyHiddenComponent: {
	--     return
	--   end
	-- end

	-- commitContainer(finishedWork)
	-- return
	-- end

	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == MemoComponent
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		-- Layout effects are destroyed during the mutation phase so that all
		-- destroy functions for all fibers are called before any create functions.
		-- This prevents sibling component effects from interfering with each other,
		-- e.g. a destroy function in one component should never override a ref set
		-- by a create function in another component during the same commit.
		if enableProfilerTimer and enableProfilerCommitHooks and bit32.band(finishedWork.mode, ProfileMode) ~= 0 then
			-- try
			local ok, result = xpcall(function()
				startLayoutEffectTimer()
				commitHookEffectListUnmount(bit32.bor(HookLayout, HookHasEffect), finishedWork, finishedWork.return_)
			end, describeError)
			-- finally
			recordLayoutEffectDuration(finishedWork)
			if not ok then
				error(result)
			end
		else
			commitHookEffectListUnmount(bit32.bor(HookLayout, HookHasEffect), finishedWork, finishedWork.return_)
		end
		return
	elseif finishedWork.tag == ClassComponent then
		return
	elseif finishedWork.tag == HostComponent then
		local instance: Instance = finishedWork.stateNode
		if instance ~= nil then
			-- Commit the work prepared earlier.
			local newProps = finishedWork.memoizedProps
			-- For hydration we reuse the update path but we treat the oldProps
			-- as the newProps. The updatePayload will contain the real change in
			-- this case.
			local oldProps
			if current then
				oldProps = current.memoizedProps
			else
				oldProps = newProps
			end
			local type = finishedWork.type
			-- TODO: Type the updateQueue to be specific to host components.
			local updatePayload: nil | UpdatePayload = finishedWork.updateQueue :: any
			finishedWork.updateQueue = nil
			if updatePayload ~= nil then
				commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork)
			end
		end
		return
	elseif finishedWork.tag == HostText then
		invariant(
			finishedWork.stateNode ~= nil,
			"This should have a text node initialized. This error is likely "
				.. "caused by a bug in React. Please file an issue."
		)
		local textInstance: TextInstance = finishedWork.stateNode
		local newText: string = finishedWork.memoizedProps
		-- For hydration we reuse the update path but we treat the oldProps
		-- as the newProps. The updatePayload will contain the real change in
		-- this case.
		local oldText: string
		if current ~= nil then
			oldText = (current :: Fiber).memoizedProps
			oldText = newText
		end
		commitTextUpdate(textInstance, oldText, newText)
		return
	elseif finishedWork.tag == HostRoot then
		if supportsHydration then
			local root: FiberRoot = finishedWork.stateNode
			if root.hydrate then
				-- We've just hydrated. No need to hydrate again.
				root.hydrate = false
				unimplemented("commitWork: HostRoot: commitHydratedContainer")
				-- commitHydratedContainer(root.containerInfo)
			end
		end
		return
	elseif finishedWork.tag == Profiler then
		return
	elseif finishedWork.tag == SuspenseComponent then
		commitSuspenseComponent(finishedWork)
		attachSuspenseRetryListeners(finishedWork)
		return
	elseif finishedWork.tag == SuspenseListComponent then
		unimplemented("commitWork: SuspenseListComponent")
	-- attachSuspenseRetryListeners(finishedWork)
	-- return
	elseif finishedWork.tag == IncompleteClassComponent then
		return
	-- elseif finishedWork.tag == FundamentalComponent then
	--   unimplemented("commitWork: FundamentalComponent")
	-- if enableFundamentalAPI)
	--   local fundamentalInstance = finishedWork.stateNode
	--   updateFundamentalComponent(fundamentalInstance)
	--   return
	-- end
	-- break
	-- elseif finishedWork.tag == ScopeComponent then
	--   unimplemented("commitWork: ScopeComponent")
	-- if enableScopeAPI)
	--   local scopeInstance = finishedWork.stateNode
	--   prepareScopeUpdate(scopeInstance, finishedWork)
	--   return
	-- end
	-- break
	elseif finishedWork.tag == OffscreenComponent or finishedWork.tag == LegacyHiddenComponent then
		local newState: OffscreenState | nil = finishedWork.memoizedState
		local isHidden = newState ~= nil
		hideOrUnhideAllChildren(finishedWork, isHidden)
		return
	end
	invariant(
		false,
		"This unit of work tag should not have side-effects. This error is "
			.. "likely caused by a bug in React. Please file an issue."
	)
end

function commitSuspenseComponent(finishedWork: Fiber)
	local newState: SuspenseState | nil = finishedWork.memoizedState

	if newState ~= nil then
		markCommitTimeOfFallback()

		if supportsMutation then
			-- Hide the Offscreen component that contains the primary children. TODO:
			-- Ideally, this effect would have been scheduled on the Offscreen fiber
			-- itself. That's how unhiding works: the Offscreen component schedules an
			-- effect on itself. However, in this case, the component didn't complete,
			-- so the fiber was never added to the effect list in the normal path. We
			-- could have appended it to the effect list in the Suspense component's
			-- second pass, but doing it this way is less complicated. This would be
			-- simpler if we got rid of the effect list and traversed the tree, like
			-- we're planning to do.
			local primaryChildParent: Fiber = finishedWork.child :: any
			hideOrUnhideAllChildren(primaryChildParent, true)
		end
	end

	if enableSuspenseCallback and newState ~= nil then
		local suspenseCallback = finishedWork.memoizedProps.suspenseCallback
		if typeof(suspenseCallback) == "function" then
			local wakeables: Set<Wakeable> | nil = finishedWork.updateQueue :: any
			if wakeables ~= nil then
				suspenseCallback(table.clone(wakeables))
			end
		elseif __DEV__ then
			if suspenseCallback ~= nil then
				console.error("Unexpected type for suspenseCallback: %s", tostring(suspenseCallback))
			end
		end
	end
end

function commitSuspenseHydrationCallbacks(finishedRoot: FiberRoot, finishedWork: Fiber)
	if not supportsHydration then
		return
	end
	local newState: SuspenseState | nil = finishedWork.memoizedState
	if newState == nil then
		local current = finishedWork.alternate
		if current ~= nil then
			local prevState: SuspenseState | nil = current.memoizedState
			if prevState ~= nil then
				local suspenseInstance = prevState.dehydrated
				if suspenseInstance ~= nil then
					commitHydratedSuspenseInstance(suspenseInstance)
					if enableSuspenseCallback then
						local hydrationCallbacks = finishedRoot.hydrationCallbacks
						if hydrationCallbacks ~= nil then
							local onHydrated = hydrationCallbacks.onHydrated
							if onHydrated then
								onHydrated(suspenseInstance)
							end
						end
					end
				end
			end
		end
	end
end

function attachSuspenseRetryListeners(finishedWork: Fiber)
	-- If this boundary just timed out, then it will have a set of wakeables.
	-- For each wakeable, attach a listener so that when it resolves, React
	-- attempts to re-render the boundary in the primary (pre-timeout) state.
	local wakeables: Set<Wakeable> | nil = finishedWork.updateQueue :: any
	if wakeables ~= nil then
		finishedWork.updateQueue = nil
		local retryCache = finishedWork.stateNode
		if retryCache == nil then
			finishedWork.stateNode = Set.new()
			retryCache = finishedWork.stateNode
		end
		for wakeable, _ in wakeables :: Set<Wakeable> do
			-- Memoize using the boundary fiber to prevent redundant listeners.
			local retry = function()
				return resolveRetryWakeable(finishedWork, wakeable)
			end

			if not retryCache:has(wakeable) then
				if enableSchedulerTracing then
					if wakeable.__reactDoNotTraceInteractions ~= true then
						retry = Schedule_tracing_wrap(retry)
					end
				end
				retryCache:add(wakeable)
				wakeable:andThen(function()
					return retry()
				end, function()
					return retry()
				end)
			end
		end
	end
end

-- This function detects when a Suspense boundary goes from visible to hidden.
-- It returns false if the boundary is already hidden.
-- TODO: Use an effect tag.
function isSuspenseBoundaryBeingHidden(current: Fiber | nil, finishedWork: Fiber): boolean
	if current ~= nil then
		-- TODO: remove typechecks when narrowing works better
		local oldState: SuspenseState | nil = (current :: Fiber).memoizedState
		if oldState == nil or (oldState :: SuspenseState).dehydrated ~= nil then
			local newState: SuspenseState | nil = finishedWork.memoizedState
			return newState ~= nil and (newState :: SuspenseState).dehydrated == nil
		end
	end
	return false
end

function commitResetTextContent(current: Fiber): ()
	if not supportsMutation then
		return
	end
	resetTextContent(current.stateNode)
end

local function commitPassiveUnmount(finishedWork: Fiber): ()
	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		if enableProfilerTimer and enableProfilerCommitHooks and bit32.band(finishedWork.mode, ProfileMode) ~= 0 then
			startPassiveEffectTimer()
			commitHookEffectListUnmount(bit32.bor(HookPassive, HookHasEffect), finishedWork, finishedWork.return_)
			recordPassiveEffectDuration(finishedWork)
		else
			commitHookEffectListUnmount(bit32.bor(HookPassive, HookHasEffect), finishedWork, finishedWork.return_)
		end
	end
end

local function commitPassiveUnmountInsideDeletedTree(current: Fiber, nearestMountedAncestor: Fiber | nil): ()
	if
		current.tag == FunctionComponent
		or current.tag == ForwardRef
		or current.tag == SimpleMemoComponent
		or current.tag == Block
	then
		if enableProfilerTimer and enableProfilerCommitHooks and bit32.band(current.mode, ProfileMode) ~= 0 then
			startPassiveEffectTimer()
			commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor)
			recordPassiveEffectDuration(current)
		else
			commitHookEffectListUnmount(HookPassive, current, nearestMountedAncestor)
		end
	end
end

local function commitPassiveMount(finishedRoot: FiberRoot, finishedWork: Fiber): ()
	if
		finishedWork.tag == FunctionComponent
		or finishedWork.tag == ForwardRef
		or finishedWork.tag == SimpleMemoComponent
		or finishedWork.tag == Block
	then
		if enableProfilerTimer and enableProfilerCommitHooks and bit32.band(finishedWork.mode, ProfileMode) ~= 0 then
			startPassiveEffectTimer()
			-- try
			local ok, error_ =
				xpcall(commitHookEffectListMount, describeError, bit32.bor(HookPassive, HookHasEffect), finishedWork)
			-- finally
			recordPassiveEffectDuration(finishedWork)
			if not ok then
				error(error_)
			end
		else
			commitHookEffectListMount(bit32.bor(HookPassive, HookHasEffect), finishedWork)
		end
	elseif finishedWork.tag == Profiler then
		commitProfilerPassiveEffect(finishedRoot, finishedWork)
	end
end

function invokeLayoutEffectMountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(nil, commitHookEffectListMount, nil, bit32.bor(HookLayout, HookHasEffect), fiber)
			if hasCaughtError() then
				local mountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, mountError)
			end
			return
		end
	elseif fiber.tag == ClassComponent then
		local instance = fiber.stateNode
		invokeGuardedCallback(nil, instance.componentDidMount, instance)
		if hasCaughtError() then
			local mountError = clearCaughtError()
			captureCommitPhaseError(fiber, fiber.return_, mountError)
		end
		return
	end
end

function invokePassiveEffectMountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(nil, commitHookEffectListMount, nil, bit32.bor(HookPassive, HookHasEffect), fiber)
			if hasCaughtError() then
				local mountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, mountError)
			end
			return
		end
	end
end

function invokeLayoutEffectUnmountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(
				nil,
				commitHookEffectListUnmount,
				nil,
				bit32.bor(HookLayout, HookHasEffect),
				fiber,
				fiber.return_
			)
			if hasCaughtError() then
				local unmountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, unmountError)
			end
			return
		end
	elseif fiber.tag == ClassComponent then
		local instance = fiber.stateNode
		if typeof(instance.componentWillUnmount) == "function" then
			safelyCallComponentWillUnmount(fiber, instance, fiber.return_)
		end
		return
	end
end

function invokePassiveEffectUnmountInDEV(fiber: Fiber): ()
	if __DEV__ and enableDoubleInvokingEffects then
		if
			fiber.tag == FunctionComponent
			or fiber.tag == ForwardRef
			or fiber.tag == SimpleMemoComponent
			or fiber.tag == Block
		then
			invokeGuardedCallback(
				nil,
				commitHookEffectListUnmount,
				nil,
				bit32.bor(HookPassive, HookHasEffect),
				fiber,
				fiber.return_
			)
			if hasCaughtError() then
				local unmountError = clearCaughtError()
				captureCommitPhaseError(fiber, fiber.return_, unmountError)
			end
			return
		end
	end
end

return {
	safelyCallDestroy = safelyCallDestroy,

	commitBeforeMutationLifeCycles = commitBeforeMutationLifeCycles,
	commitResetTextContent = commitResetTextContent,
	commitPlacement = commitPlacement,
	commitDeletion = commitDeletion,
	commitWork = commitWork,
	commitAttachRef = commitAttachRef,
	commitDetachRef = commitDetachRef,
	commitPassiveUnmount = commitPassiveUnmount,
	commitPassiveUnmountInsideDeletedTree = commitPassiveUnmountInsideDeletedTree,
	commitPassiveMount = commitPassiveMount,
	invokeLayoutEffectMountInDEV = invokeLayoutEffectMountInDEV,
	invokeLayoutEffectUnmountInDEV = invokeLayoutEffectUnmountInDEV,
	invokePassiveEffectMountInDEV = invokePassiveEffectMountInDEV,
	invokePassiveEffectUnmountInDEV = invokePassiveEffectUnmountInDEV,
	isSuspenseBoundaryBeingHidden = isSuspenseBoundaryBeingHidden,
	recursivelyCommitLayoutEffects = recursivelyCommitLayoutEffects,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006106</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX63B65A7790054EF1A4B6012AC74AE18B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberCompleteWork.new</string>
								<string name="ScriptGuid">{E98F315D-C562-40E3-8383-9B5C2C2AA43A}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/87c023b1c1b00d6776b7031f6e105913ead355da/packages/react-reconciler/src/ReactFiberCompleteWork.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
local OffscreenLane = ReactFiberLane.OffscreenLane
-- local type {
--   ReactFundamentalComponentInstance,
--   ReactScopeInstance,
-- } = require(Packages.Shared).ReactTypes
-- local type {FiberRoot} = require(script.Parent.ReactInternalTypes)
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type Type = ReactFiberHostConfig.Type
type Props = ReactFiberHostConfig.Props
type Container = ReactFiberHostConfig.Container
type ChildSet = ReactFiberHostConfig.ChildSet
-- local type {
--   SuspenseState,
--   SuspenseListRenderState,
-- } = require(script.Parent.ReactFiberSuspenseComponent.new)
local ReactFiberOffscreenComponent = require(script.Parent.ReactFiberOffscreenComponent)
type OffscreenState = ReactFiberOffscreenComponent.OffscreenState

local ReactMutableSource = require(script.Parent["ReactMutableSource.new"])
local resetMutableSourceWorkInProgressVersions = ReactMutableSource.resetWorkInProgressVersions

-- local {now} = require(script.Parent.SchedulerWithReactIntegration.new)

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local FunctionComponent = ReactWorkTags.FunctionComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostPortal = ReactWorkTags.HostPortal
local ContextProvider = ReactWorkTags.ContextProvider
local ContextConsumer = ReactWorkTags.ContextConsumer
local ForwardRef = ReactWorkTags.ForwardRef
local Fragment = ReactWorkTags.Fragment
local Mode = ReactWorkTags.Mode
local Profiler = ReactWorkTags.Profiler
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local MemoComponent = ReactWorkTags.MemoComponent
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LazyComponent = ReactWorkTags.LazyComponent
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ScopeComponent = ReactWorkTags.ScopeComponent
local Block = ReactWorkTags.Block
local OffscreenComponent = ReactWorkTags.OffscreenComponent
local LegacyHiddenComponent = ReactWorkTags.LegacyHiddenComponent
local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState
type SuspenseListRenderState = ReactFiberSuspenseComponent.SuspenseState

local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local NoMode = ReactTypeOfMode.NoMode
local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local ProfileMode = ReactTypeOfMode.ProfileMode

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Ref = ReactFiberFlags.Ref
local Update = ReactFiberFlags.Update
local Callback = ReactFiberFlags.Callback
local Passive = ReactFiberFlags.Passive
local Deletion = ReactFiberFlags.Deletion
local NoFlags = ReactFiberFlags.NoFlags
local DidCapture = ReactFiberFlags.DidCapture
local Snapshot = ReactFiberFlags.Snapshot
local MutationMask = ReactFiberFlags.MutationMask
local LayoutMask = ReactFiberFlags.LayoutMask
local PassiveMask = ReactFiberFlags.PassiveMask
local StaticMask = ReactFiberFlags.StaticMask
local PerformedWork = ReactFiberFlags.PerformedWork

local invariant = require(Packages.Shared).invariant

local createInstance = ReactFiberHostConfig.createInstance
local createTextInstance = ReactFiberHostConfig.createTextInstance
local appendInitialChild = ReactFiberHostConfig.appendInitialChild
local finalizeInitialChildren = ReactFiberHostConfig.finalizeInitialChildren
local prepareUpdate = ReactFiberHostConfig.prepareUpdate
local supportsMutation = ReactFiberHostConfig.supportsMutation
local supportsPersistence = ReactFiberHostConfig.supportsPersistence
-- local cloneInstance = ReactFiberHostConfig.cloneInstance
-- local cloneHiddenInstance = ReactFiberHostConfig.cloneHiddenInstance
-- local cloneHiddenTextInstance = ReactFiberHostConfig.cloneHiddenTextInstance
local createContainerChildSet = ReactFiberHostConfig.createContainerChildSet
-- local appendChildToContainerChildSet = ReactFiberHostConfig.appendChildToContainerChildSet
local finalizeContainerChildren = ReactFiberHostConfig.finalizeContainerChildren
-- local getFundamentalComponentInstance = ReactFiberHostConfig.getFundamentalComponentInstance
-- local mountFundamentalComponent = ReactFiberHostConfig.mountFundamentalComponent
-- local cloneFundamentalInstance = ReactFiberHostConfig.cloneFundamentalInstance
-- local shouldUpdateFundamentalComponent = ReactFiberHostConfig.shouldUpdateFundamentalComponent
local preparePortalMount = ReactFiberHostConfig.preparePortalMount
-- local prepareScopeUpdate = ReactFiberHostConfig.prepareScopeUpdate
local ReactFiberHostContext = require(script.Parent["ReactFiberHostContext.new"])
local getRootHostContainer = ReactFiberHostContext.getRootHostContainer
local popHostContext = ReactFiberHostContext.popHostContext
local getHostContext = ReactFiberHostContext.getHostContext
local popHostContainer = ReactFiberHostContext.popHostContainer

local ReactFiberSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"])
local popSuspenseContext = ReactFiberSuspenseContext.popSuspenseContext
local suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor
local InvisibleParentSuspenseContext = ReactFiberSuspenseContext.InvisibleParentSuspenseContext
local hasSuspenseContext = ReactFiberSuspenseContext.hasSuspenseContext
type SuspenseContext = ReactFiberSuspenseContext.SuspenseContext
-- local pushSuspenseContext = ReactFiberSuspenseContext.pushSuspenseContext
-- local setShallowSuspenseContext = ReactFiberSuspenseContext.setShallowSuspenseContext
-- local ForceSuspenseFallback = ReactFiberSuspenseContext.ForceSuspenseFallback
-- local setDefaultShallowSuspenseContext = ReactFiberSuspenseContext.setDefaultShallowSuspenseContext

-- local {findFirstSuspended} = require(script.Parent.ReactFiberSuspenseComponent.new)
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local popLegacyContext = ReactFiberContext.popContext
local popTopLevelLegacyContextObject = ReactFiberContext.popTopLevelContextObject
local popProvider = require(script.Parent["ReactFiberNewContext.new"]).popProvider

local ReactFiberHydrationContext = require(script.Parent["ReactFiberHydrationContext.new"])
local prepareToHydrateHostSuspenseInstance = ReactFiberHydrationContext.prepareToHydrateHostSuspenseInstance
local popHydrationState = ReactFiberHydrationContext.popHydrationState
local resetHydrationState = ReactFiberHydrationContext.resetHydrationState
-- local getIsHydrating = ReactFiberHydrationContext.getIsHydrating
local prepareToHydrateHostInstance = ReactFiberHydrationContext.prepareToHydrateHostInstance
local prepareToHydrateHostTextInstance = ReactFiberHydrationContext.prepareToHydrateHostTextInstance
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableSuspenseCallback = ReactFeatureFlags.enableSuspenseCallback
local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer

local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any

local popRenderLanes = ReactFiberWorkLoop.popRenderLanes
-- deviation: this is a live value in WorkLoop's module state, so it must be accessed directly and not 'cached'
-- local subtreeRenderLanes = ReactFiberWorkLoop.subtreeRenderLanes
local markSpawnedWork = ReactFiberWorkLoop.markSpawnedWork
local renderDidSuspend = ReactFiberWorkLoop.renderDidSuspend
local renderDidSuspendDelayIfPossible = ReactFiberWorkLoop.renderDidSuspendDelayIfPossible
-- local renderHasNotSuspendedYet = ReactFiberWorkLoop.renderHasNotSuspendedYet
-- local getRenderTargetTime = ReactFiberWorkLoop.getRenderTargetTime

-- local {createFundamentalStateInstance} = require(script.Parent.ReactFiberFundamental.new)

-- local OffscreenLane = ReactFiberLane.OffscreenLane
-- local SomeRetryLane = ReactFiberLane.SomeRetryLane
local NoLanes = ReactFiberLane.NoLanes
local includesSomeLane = ReactFiberLane.includesSomeLane
local mergeLanes = ReactFiberLane.mergeLanes
-- local {resetChildFibers} = require(script.Parent.ReactChildFiber.new)
-- local {createScopeInstance} = require(script.Parent.ReactFiberScope.new)
local ReactProfilerTimer = require(script.Parent["ReactProfilerTimer.new"])
local transferActualDuration = ReactProfilerTimer.transferActualDuration

local function markUpdate(workInProgress: Fiber)
	-- Tag the fiber with an update effect. This turns a Placement into
	-- a PlacementAndUpdate.
	workInProgress.flags = bit32.bor(workInProgress.flags, Update)
end

local function markRef(workInProgress: Fiber)
	workInProgress.flags = bit32.bor(workInProgress.flags, Ref)
end

-- FIXME: type refinement
-- local function hadNoMutationsEffects(current: nil | Fiber, completedWork: Fiber)
local function hadNoMutationsEffects(current, completedWork: Fiber)
	local didBailout = current ~= nil and current.child == completedWork.child
	if didBailout then
		return true
	end

	local child = completedWork.child
	while child ~= nil do
		if bit32.band(child.flags, MutationMask) ~= NoFlags then
			return false
		end
		if bit32.band(child.subtreeFlags, MutationMask) ~= NoFlags then
			return false
		end
		child = child.sibling
	end
	return true
end

local appendAllChildren
local updateHostContainer
local updateHostComponent
local updateHostText
if supportsMutation then
	-- Mutation mode

	appendAllChildren = function(
		parent: Instance,
		workInProgress: Fiber,
		needsVisibilityToggle: boolean,
		isHidden: boolean
	)
		-- We only have the top Fiber that was created but we need recurse down its
		-- children to find all the terminal nodes.
		local node = workInProgress.child
		while node ~= nil do
			if node.tag == HostComponent or node.tag == HostText then
				appendInitialChild(parent, node.stateNode)
			elseif enableFundamentalAPI and node.tag == FundamentalComponent then
				appendInitialChild(parent, node.stateNode.instance)
			elseif node.tag == HostPortal then
				-- If we have a portal child, then we don't want to traverse
				-- down its children. Instead, we'll get insertions from each child in
				-- the portal directly.
			elseif node.child ~= nil then
				node.child.return_ = node
				node = node.child
				continue
			end
			if node == workInProgress then
				return
			end
			while node.sibling == nil do
				if node.return_ == nil or node.return_ == workInProgress then
					return
				end
				node = node.return_
			end
			-- FIXME Luau: Luau doesn't understand loop predicates above results in node.sibling ~= nil
			(node.sibling :: Fiber).return_ = node.return_
			node = node.sibling
		end
	end

	updateHostContainer = function(current: nil | Fiber, workInProgress: Fiber)
		-- Noop
	end
	function updateHostComponent(
		current: Fiber,
		workInProgress: Fiber,
		type: Type,
		newProps: Props,
		rootContainerInstance: Container
	)
		-- If we have an alternate, that means this is an update and we need to
		-- schedule a side-effect to do the updates.
		local oldProps = current.memoizedProps
		if oldProps == newProps then
			-- In mutation mode, this is sufficient for a bailout because
			-- we won't touch this node even if children changed.
			return
		end

		-- If we get updated because one of our children updated, we don't
		-- have newProps so we'll have to reuse them.
		-- TODO: Split the update API as separate for the props vs. children.
		-- Even better would be if children weren't special cased at all tho.
		local instance: Instance = workInProgress.stateNode
		local currentHostContext = getHostContext()
		-- TODO: Experiencing an error where oldProps is nil. Suggests a host
		-- component is hitting the resume path. Figure out why. Possibly
		-- related to `hidden`.
		local updatePayload =
			prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext)
		-- TODO: Type this specific to this type of component.
		workInProgress.updateQueue = updatePayload
		-- If the update payload indicates that there is a change or if there
		-- is a new ref we mark this as an update. All the work is done in commitWork.
		if updatePayload then
			markUpdate(workInProgress)
		end
	end
	function updateHostText(current: Fiber, workInProgress: Fiber, oldText: string, newText: string)
		-- If the text differs, mark it as an update. All the work in done in commitWork.
		if oldText ~= newText then
			markUpdate(workInProgress)
		end
	end
elseif supportsPersistence then
	-- Persistent host tree mode
	appendAllChildren = function(
		parent: Instance,
		workInProgress: Fiber,
		needsVisibilityToggle: boolean,
		isHidden: boolean
	)
		unimplemented("appendAllChildren")
		--     -- We only have the top Fiber that was created but we need recurse down its
		--     -- children to find all the terminal nodes.
		--     local node = workInProgress.child
		--     while (node ~= nil)
		--       -- eslint-disable-next-line no-labels
		--       branches: if node.tag == HostComponent)
		--         local instance = node.stateNode
		--         if needsVisibilityToggle and isHidden)
		--           -- This child is inside a timed out tree. Hide it.
		--           local props = node.memoizedProps
		--           local type = node.type
		--           instance = cloneHiddenInstance(instance, type, props, node)
		--         end
		--         appendInitialChild(parent, instance)
		--       } else if node.tag == HostText)
		--         local instance = node.stateNode
		--         if needsVisibilityToggle and isHidden)
		--           -- This child is inside a timed out tree. Hide it.
		--           local text = node.memoizedProps
		--           instance = cloneHiddenTextInstance(instance, text, node)
		--         end
		--         appendInitialChild(parent, instance)
		--       } else if enableFundamentalAPI and node.tag == FundamentalComponent)
		--         local instance = node.stateNode.instance
		--         if needsVisibilityToggle and isHidden)
		--           -- This child is inside a timed out tree. Hide it.
		--           local props = node.memoizedProps
		--           local type = node.type
		--           instance = cloneHiddenInstance(instance, type, props, node)
		--         end
		--         appendInitialChild(parent, instance)
		--       } else if node.tag == HostPortal)
		--         -- If we have a portal child, then we don't want to traverse
		--         -- down its children. Instead, we'll get insertions from each child in
		--         -- the portal directly.
		--       } else if node.tag == SuspenseComponent)
		--         if (node.flags & Update) ~= NoFlags)
		--           -- Need to toggle the visibility of the primary children.
		--           local newIsHidden = node.memoizedState ~= nil
		--           if newIsHidden)
		--             local primaryChildParent = node.child
		--             if primaryChildParent ~= nil)
		--               if primaryChildParent.child ~= nil)
		--                 primaryChildParent.child.return = primaryChildParent
		--                 appendAllChildren(
		--                   parent,
		--                   primaryChildParent,
		--                   true,
		--                   newIsHidden,
		--                 )
		--               end
		--               local fallbackChildParent = primaryChildParent.sibling
		--               if fallbackChildParent ~= nil)
		--                 fallbackChildParent.return = node
		--                 node = fallbackChildParent
		--                 continue
		--               end
		--             end
		--           end
		--         end
		--         if node.child ~= nil)
		--           -- Continue traversing like normal
		--           node.child.return = node
		--           node = node.child
		--           continue
		--         end
		--       } else if node.child ~= nil)
		--         node.child.return = node
		--         node = node.child
		--         continue
		--       end
		--       -- $FlowFixMe This is correct but Flow is confused by the labeled break.
		--       node = (node: Fiber)
		--       if node == workInProgress)
		--         return
		--       end
		--       while (node.sibling == nil)
		--         if node.return == nil or node.return == workInProgress)
		--           return
		--         end
		--         node = node.return
		--       end
		--       node.sibling.return = node.return
		--       node = node.sibling
		--     end
	end

	-- An unfortunate fork of appendAllChildren because we have two different parent types.
	local function appendAllChildrenToContainer(
		containerChildSet: ChildSet,
		workInProgress: Fiber,
		needsVisibilityToggle: boolean,
		isHidden: boolean
	)
		unimplemented("appendAllChildrenToContainer")
		-- -- We only have the top Fiber that was created but we need recurse down its
		-- -- children to find all the terminal nodes.
		-- local node = workInProgress.child
		-- while node ~= nil do
		--   -- eslint-disable-next-line no-labels
		--   if node.tag == HostComponent then
		--     local instance = node.stateNode
		--     if needsVisibilityToggle and isHidden then
		--       -- This child is inside a timed out tree. Hide it.
		--       local props = node.memoizedProps
		--       local type = node.type
		--       instance = cloneHiddenInstance(instance, type, props, node)
		--     end
		--     appendChildToContainerChildSet(containerChildSet, instance)
		--   elseif node.tag == HostText then
		--     local instance = node.stateNode
		--     if needsVisibilityToggle and isHidden then
		--       -- This child is inside a timed out tree. Hide it.
		--       local text = node.memoizedProps
		--       instance = cloneHiddenTextInstance(instance, text, node)
		--     end
		--     appendChildToContainerChildSet(containerChildSet, instance)
		--   elseif enableFundamentalAPI and node.tag == FundamentalComponent then
		--     local instance = node.stateNode.instance
		--     if needsVisibilityToggle and isHidden then
		--       -- This child is inside a timed out tree. Hide it.
		--       local props = node.memoizedProps
		--       local type = node.type
		--       instance = cloneHiddenInstance(instance, type, props, node)
		--     end
		--     appendChildToContainerChildSet(containerChildSet, instance)
		--   elseif node.tag == HostPortal then
		--     -- If we have a portal child, then we don't want to traverse
		--     -- down its children. Instead, we'll get insertions from each child in
		--     -- the portal directly.
		--   elseif node.tag == SuspenseComponent then
		--     if bit32.band(node.flags, Update) ~= NoFlags then
		--       -- Need to toggle the visibility of the primary children.
		--       local newIsHidden = node.memoizedState ~= nil
		--       if newIsHidden then
		--         local primaryChildParent = node.child
		--         if primaryChildParent ~= nil then
		--           if primaryChildParent.child ~= nil then
		--             primaryChildParent.child.return_ = primaryChildParent
		--             appendAllChildrenToContainer(
		--               containerChildSet,
		--               primaryChildParent,
		--               true,
		--               newIsHidden
		--             )
		--           end
		--           local fallbackChildParent = primaryChildParent.sibling
		--           if fallbackChildParent ~= nil then
		--             fallbackChildParent.return_ = node
		--             node = fallbackChildParent
		--             continue
		--           end
		--         end
		--       end
		--     end
		--     if node.child ~= nil then
		--       -- Continue traversing like normal
		--       node.child.return_ = node
		--       node = node.child
		--       continue
		--     end
		--   elseif node.child ~= nil then
		--     node.child.return_ = node
		--     node = node.child
		--     continue
		--   end
		--   -- $FlowFixMe This is correct but Flow is confused by the labeled break.
		--   -- node = (node: Fiber)
		--   if node == workInProgress then
		--     return
		--   end
		--   while node.sibling == nil do
		--     if node.return_ == nil or node.return_ == workInProgress then
		--       return
		--     end
		--     node = node.return_
		--   end
		--   node.sibling.return_ = node.return_
		--   node = node.sibling
		-- end
	end

	function updateHostContainer(current: nil | Fiber, workInProgress: Fiber)
		local portalOrRoot: {
			containerInfo: Container,
			pendingChildren: ChildSet,
			-- ...
			[any]: any,
		} =
			workInProgress.stateNode
		local childrenUnchanged = hadNoMutationsEffects(current, workInProgress)
		if childrenUnchanged then
		-- No changes, just reuse the existing instance.
		else
			local container = portalOrRoot.containerInfo
			local newChildSet = createContainerChildSet(container)
			-- If children might have changed, we have to add them all to the set.
			appendAllChildrenToContainer(newChildSet, workInProgress, false, false)
			portalOrRoot.pendingChildren = newChildSet
			-- Schedule an update on the container to swap out the container.
			markUpdate(workInProgress)
			finalizeContainerChildren(container, newChildSet)
		end
	end
--   updateHostComponent = function(
--     current: Fiber,
--     workInProgress: Fiber,
--     type: Type,
--     newProps: Props,
--     rootContainerInstance: Container,
--   )
--     local currentInstance = current.stateNode
--     local oldProps = current.memoizedProps
--     -- If there are no effects associated with this node, then none of our children had any updates.
--     -- This guarantees that we can reuse all of them.
--     local childrenUnchanged = workInProgress.firstEffect == nil
--     if childrenUnchanged and oldProps == newProps)
--       -- No changes, just reuse the existing instance.
--       -- Note that this might release a previous clone.
--       workInProgress.stateNode = currentInstance
--       return
--     end
--     local recyclableInstance: Instance = workInProgress.stateNode
--     local currentHostContext = getHostContext()
--     local updatePayload = nil
--     if oldProps ~= newProps)
--       updatePayload = prepareUpdate(
--         recyclableInstance,
--         type,
--         oldProps,
--         newProps,
--         rootContainerInstance,
--         currentHostContext,
--       )
--     end
--     if childrenUnchanged and updatePayload == nil)
--       -- No changes, just reuse the existing instance.
--       -- Note that this might release a previous clone.
--       workInProgress.stateNode = currentInstance
--       return
--     end
--     local newInstance = cloneInstance(
--       currentInstance,
--       updatePayload,
--       type,
--       oldProps,
--       newProps,
--       workInProgress,
--       childrenUnchanged,
--       recyclableInstance,
--     )
--     if
--       finalizeInitialChildren(
--         newInstance,
--         type,
--         newProps,
--         rootContainerInstance,
--         currentHostContext,
--       )
--     )
--       markUpdate(workInProgress)
--     end
--     workInProgress.stateNode = newInstance
--     if childrenUnchanged)
--       -- If there are no other effects in this tree, we need to flag this node as having one.
--       -- Even though we're not going to use it for anything.
--       -- Otherwise parents won't know that there are new children to propagate upwards.
--       markUpdate(workInProgress)
--     else
--       -- If children might have changed, we have to add them all to the set.
--       appendAllChildren(newInstance, workInProgress, false, false)
--     end
--   end
--   updateHostText = function(
--     current: Fiber,
--     workInProgress: Fiber,
--     oldText: string,
--     newText: string,
--   )
--     if oldText ~= newText)
--       -- If the text content differs, we'll create a new text instance for it.
--       local rootContainerInstance = getRootHostContainer()
--       local currentHostContext = getHostContext()
--       workInProgress.stateNode = createTextInstance(
--         newText,
--         rootContainerInstance,
--         currentHostContext,
--         workInProgress,
--       )
--       -- We'll have to mark it as having an effect, even though we won't use the effect for anything.
--       -- This lets the parents know that at least one of their children has changed.
--       markUpdate(workInProgress)
--     else
--       workInProgress.stateNode = current.stateNode
--     end
--   end
else
	-- No host operations
	updateHostContainer = function(current: nil | Fiber, workInProgress: Fiber)
		-- Noop
	end
	--   updateHostComponent = function(
	--     current: Fiber,
	--     workInProgress: Fiber,
	--     type: Type,
	--     newProps: Props,
	--     rootContainerInstance: Container,
	--   )
	--     -- Noop
	--   end
	--   updateHostText = function(
	--     current: Fiber,
	--     workInProgress: Fiber,
	--     oldText: string,
	--     newText: string,
	--   )
	--     -- Noop
	--   end
	-- end

	-- function cutOffTailIfNeeded(
	--   renderState: SuspenseListRenderState,
	--   hasRenderedATailFallback: boolean,
	-- )
	--   if getIsHydrating())
	--     -- If we're hydrating, we should consume as many items as we can
	--     -- so we don't leave any behind.
	--     return
	--   end
	--   switch (renderState.tailMode)
	--     case 'hidden': {
	--       -- Any insertions at the end of the tail list after this point
	--       -- should be invisible. If there are already mounted boundaries
	--       -- anything before them are not considered for collapsing.
	--       -- Therefore we need to go through the whole tail to find if
	--       -- there are any.
	--       local tailNode = renderState.tail
	--       local lastTailNode = nil
	--       while (tailNode ~= nil)
	--         if tailNode.alternate ~= nil)
	--           lastTailNode = tailNode
	--         end
	--         tailNode = tailNode.sibling
	--       end
	--       -- Next we're simply going to delete all insertions after the
	--       -- last rendered item.
	--       if lastTailNode == nil)
	--         -- All remaining items in the tail are insertions.
	--         renderState.tail = nil
	--       else
	--         -- Detach the insertion after the last node that was already
	--         -- inserted.
	--         lastTailNode.sibling = nil
	--       end
	--       break
	--     end
	--     case 'collapsed': {
	--       -- Any insertions at the end of the tail list after this point
	--       -- should be invisible. If there are already mounted boundaries
	--       -- anything before them are not considered for collapsing.
	--       -- Therefore we need to go through the whole tail to find if
	--       -- there are any.
	--       local tailNode = renderState.tail
	--       local lastTailNode = nil
	--       while (tailNode ~= nil)
	--         if tailNode.alternate ~= nil)
	--           lastTailNode = tailNode
	--         end
	--         tailNode = tailNode.sibling
	--       end
	--       -- Next we're simply going to delete all insertions after the
	--       -- last rendered item.
	--       if lastTailNode == nil)
	--         -- All remaining items in the tail are insertions.
	--         if !hasRenderedATailFallback and renderState.tail ~= nil)
	--           -- We suspended during the head. We want to show at least one
	--           -- row at the tail. So we'll keep on and cut off the rest.
	--           renderState.tail.sibling = nil
	--         else
	--           renderState.tail = nil
	--         end
	--       else
	--         -- Detach the insertion after the last node that was already
	--         -- inserted.
	--         lastTailNode.sibling = nil
	--       end
	--       break
	--     end
	--   end
end

local function bubbleProperties(completedWork: Fiber)
	local didBailout = completedWork.alternate ~= nil
		and (completedWork.alternate :: Fiber).child == completedWork.child

	local newChildLanes = NoLanes
	local subtreeFlags = NoFlags

	if not didBailout then
		-- Bubble up the earliest expiration time.
		if enableProfilerTimer and bit32.band(completedWork.mode, ProfileMode) ~= NoMode then
			-- In profiling mode, resetChildExpirationTime is also used to reset
			-- profiler durations.
			local actualDuration = completedWork.actualDuration
			local treeBaseDuration = completedWork.selfBaseDuration

			local child = completedWork.child
			while child ~= nil do
				newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes))

				subtreeFlags = bit32.bor(subtreeFlags, child.subtreeFlags)
				subtreeFlags = bit32.bor(subtreeFlags, child.flags)

				-- When a fiber is cloned, its actualDuration is reset to 0. This value will
				-- only be updated if work is done on the fiber (i.e. it doesn't bailout).
				-- When work is done, it should bubble to the parent's actualDuration. If
				-- the fiber has not been cloned though, (meaning no work was done), then
				-- this value will reflect the amount of time spent working on a previous
				-- render. In that case it should not bubble. We determine whether it was
				-- cloned by comparing the child pointer.
				actualDuration += child.actualDuration

				treeBaseDuration += child.treeBaseDuration
				child = child.sibling
			end

			completedWork.actualDuration = actualDuration
			completedWork.treeBaseDuration = treeBaseDuration
		else
			local child = completedWork.child
			while child ~= nil do
				-- performance: inline mergeLanes
				-- newChildLanes = mergeLanes(
				--   newChildLanes,
				--   mergeLanes(child.lanes, child.childLanes)
				-- )
				newChildLanes = bit32.bor(newChildLanes, bit32.bor(child.lanes, child.childLanes))

				subtreeFlags = bit32.bor(subtreeFlags, child.subtreeFlags)
				subtreeFlags = bit32.bor(subtreeFlags, child.flags)

				-- NOTE: this was missed in the "new" version of the file in React 17, but is fixed in React 18
				-- Update the return pointer so the tree is consistent. This is a code
				-- smell because it assumes the commit phase is never concurrent with
				-- the render phase. Will address during refactor to alternate model.
				child.return_ = completedWork

				child = child.sibling
			end
		end

		completedWork.subtreeFlags = bit32.bor(completedWork.subtreeFlags, subtreeFlags)
	else
		-- Bubble up the earliest expiration time.
		if enableProfilerTimer and bit32.band(completedWork.mode, ProfileMode) ~= NoMode then
			-- In profiling mode, resetChildExpirationTime is also used to reset
			-- profiler durations.
			local treeBaseDuration = completedWork.selfBaseDuration

			local child = completedWork.child
			while child ~= nil do
				newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes))

				-- "Static" flags share the lifetime of the fiber/hook they belong to,
				-- so we should bubble those up even during a bailout. All the other
				-- flags have a lifetime only of a single render + commit, so we should
				-- ignore them.
				subtreeFlags = bit32.bor(subtreeFlags, bit32.band(child.subtreeFlags, StaticMask))
				subtreeFlags = bit32.bor(subtreeFlags, bit32.band(child.flags, StaticMask))

				treeBaseDuration += child.treeBaseDuration
				child = child.sibling
			end

			completedWork.treeBaseDuration = treeBaseDuration
		else
			local child = completedWork.child
			while child ~= nil do
				-- performance: inline mergeLanes
				-- newChildLanes = mergeLanes(
				--   newChildLanes,
				--   mergeLanes(child.lanes, child.childLanes)
				-- )
				newChildLanes = bit32.bor(newChildLanes, bit32.bor(child.lanes, child.childLanes))

				-- "Static" flags share the lifetime of the fiber/hook they belong to,
				-- so we should bubble those up even during a bailout. All the other
				-- flags have a lifetime only of a single render + commit, so we should
				-- ignore them.
				subtreeFlags = bit32.bor(subtreeFlags, bit32.band(child.subtreeFlags, StaticMask))
				subtreeFlags = bit32.bor(subtreeFlags, bit32.band(child.flags, StaticMask))

				-- NOTE: this was missed in the "new" version of the file in React 17, but is fixed in React 18
				-- Update the return pointer so the tree is consistent. This is a code
				-- smell because it assumes the commit phase is never concurrent with
				-- the render phase. Will address during refactor to alternate model.
				child.return_ = completedWork

				child = child.sibling
			end
		end

		completedWork.subtreeFlags = bit32.bor(completedWork.subtreeFlags, subtreeFlags)
	end

	completedWork.childLanes = newChildLanes

	return didBailout
end

-- FIXME (roblox): type refinement
-- local function completeWork(
--   current: Fiber | nil,
--   workInProgress: Fiber,
--   renderLanes: Lanes
-- ): Fiber | nil
local function completeWork(current, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
	local newProps = workInProgress.pendingProps

	if
		workInProgress.tag == IndeterminateComponent
		or workInProgress.tag == LazyComponent
		or workInProgress.tag == SimpleMemoComponent
		or workInProgress.tag == FunctionComponent
		or workInProgress.tag == ForwardRef
		or workInProgress.tag == Fragment
		or workInProgress.tag == Mode
		or workInProgress.tag == ContextConsumer
		or workInProgress.tag == MemoComponent
	then
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == ClassComponent then
		local Component = workInProgress.type
		if isLegacyContextProvider(Component) then
			popLegacyContext(workInProgress)
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == HostRoot then
		popHostContainer(workInProgress)
		popTopLevelLegacyContextObject(workInProgress)
		resetMutableSourceWorkInProgressVersions()
		-- FIXME: type coercion
		-- local fiberRoot = (workInProgress.stateNode: FiberRoot)
		local fiberRoot = workInProgress.stateNode
		if fiberRoot.pendingContext then
			fiberRoot.context = fiberRoot.pendingContext
			fiberRoot.pendingContext = nil
		end
		if current == nil or current.child == nil then
			-- If we hydrated, pop so that we can delete any remaining children
			-- that weren't hydrated.
			local wasHydrated = popHydrationState(workInProgress)
			if wasHydrated then
				-- If we hydrated, then we'll need to schedule an update for
				-- the commit side-effects on the root.
				markUpdate(workInProgress)
			elseif not fiberRoot.hydrate then
				-- Schedule an effect to clear this container at the start of the next commit.
				-- This handles the case of React rendering into a container with previous children.
				-- It's also safe to do for updates too, because current.child would only be nil
				-- if the previous render was nil (so the the container would already be empty).
				workInProgress.flags = bit32.bor(workInProgress.flags, Snapshot)
			end
		end
		updateHostContainer(current, workInProgress)
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == HostComponent then
		popHostContext(workInProgress)
		local rootContainerInstance = getRootHostContainer()
		local type = workInProgress.type
		if current ~= nil and workInProgress.stateNode ~= nil then
			updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance)

			if current.ref ~= workInProgress.ref then
				markRef(workInProgress)
			end
		else
			if not newProps then
				invariant(
					workInProgress.stateNode ~= nil,
					"We must have new props for new mounts. This error is likely "
						.. "caused by a bug in React. Please file an issue."
				)
				-- This can happen when we abort work.
				bubbleProperties(workInProgress)
				return nil
			end

			local currentHostContext = getHostContext()
			-- TODO: Move createInstance to beginWork and keep it on a context
			-- "stack" as the parent. Then append children as we go in beginWork
			-- or completeWork depending on whether we want to add them top->down or
			-- bottom->up. Top->down is faster in IE11.
			local wasHydrated = popHydrationState(workInProgress)
			if wasHydrated then
				-- TODO: Move this and createInstance step into the beginPhase
				-- to consolidate.
				if prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext) then
					-- If changes to the hydrated node need to be applied at the
					-- commit-phase we mark this as such.
					markUpdate(workInProgress)
				end
			else
				local instance =
					createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress)

				appendAllChildren(instance, workInProgress, false, false)

				workInProgress.stateNode = instance

				-- Certain renderers require commit-time effects for initial mount.
				-- (eg DOM renderer supports auto-focus for certain elements).
				-- Make sure such renderers get scheduled for later work.
				if finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext) then
					markUpdate(workInProgress)
				end
			end

			if workInProgress.ref ~= nil then
				-- If there is a ref on a host node we need to schedule a callback
				markRef(workInProgress)
			end
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == HostText then
		local newText = newProps
		if current and workInProgress.stateNode ~= nil then
			local oldText = current.memoizedProps
			-- If we have an alternate, that means this is an update and we need
			-- to schedule a side-effect to do the updates.
			updateHostText(current, workInProgress, oldText, newText)
		else
			if typeof(newText) ~= "string" then
				invariant(
					workInProgress.stateNode ~= nil,
					"We must have new props for new mounts. This error is likely "
						.. "caused by a bug in React. Please file an issue."
				)
				-- This can happen when we abort work.
			end
			local rootContainerInstance = getRootHostContainer()
			local currentHostContext = getHostContext()
			local wasHydrated = popHydrationState(workInProgress)
			if wasHydrated then
				if prepareToHydrateHostTextInstance(workInProgress) then
					markUpdate(workInProgress)
				end
			else
				workInProgress.stateNode =
					createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress)
			end
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == Profiler then
		local didBailout = bubbleProperties(workInProgress)
		if not didBailout then
			-- Use subtreeFlags to determine which commit callbacks should fire.
			-- TODO: Move this logic to the commit phase, since we already check if
			-- a fiber's subtree contains effects. Refactor the commit phase's
			-- depth-first traversal so that we can put work tag-specific logic
			-- before or after committing a subtree's effects.
			local OnRenderFlag = Update
			local OnCommitFlag = Callback
			local OnPostCommitFlag = Passive
			local subtreeFlags = workInProgress.subtreeFlags
			local flags = workInProgress.flags
			local newFlags = flags

			-- Call onRender any time this fiber or its subtree are worked on.
			if bit32.band(flags, PerformedWork) ~= NoFlags or bit32.band(subtreeFlags, PerformedWork) ~= NoFlags then
				newFlags = bit32.bor(newFlags, OnRenderFlag)
			end

			-- Call onCommit only if the subtree contains layout work, or if it
			-- contains deletions, since those might result in unmount work, which
			-- we include in the same measure.
			-- TODO: Can optimize by using a static flag to track whether a tree
			-- contains layout effects, like we do for passive effects.
			if
				bit32.band(flags, bit32.bor(LayoutMask, Deletion)) ~= NoFlags
				or bit32.band(subtreeFlags, bit32.bor(LayoutMask, Deletion)) ~= NoFlags
			then
				newFlags = bit32.bor(newFlags, OnCommitFlag)
			end

			-- Call onPostCommit only if the subtree contains passive work.
			-- Don't have to check for deletions, because Deletion is already
			-- a passive flag.
			if bit32.band(flags, PassiveMask) ~= NoFlags or bit32.band(subtreeFlags, PassiveMask) ~= NoFlags then
				newFlags = bit32.bor(newFlags, OnPostCommitFlag)
			end
			workInProgress.flags = newFlags
		else
			-- This fiber and its subtree bailed out, so don't fire any callbacks.
		end

		return nil
	elseif workInProgress.tag == SuspenseComponent then
		popSuspenseContext(workInProgress)
		local nextState: nil | SuspenseState = workInProgress.memoizedState

		if enableSuspenseServerRenderer then
			-- FIXME: remove :: recast once Luau understands if statement nil check
			if nextState ~= nil and (nextState :: SuspenseState).dehydrated ~= nil then
				if current == nil then
					local wasHydrated = popHydrationState(workInProgress)
					invariant(
						wasHydrated,
						"A dehydrated suspense component was completed without a hydrated node. "
							.. "This is probably a bug in React."
					)
					prepareToHydrateHostSuspenseInstance(workInProgress)
					if enableSchedulerTracing then
						markSpawnedWork(OffscreenLane)
					end
					bubbleProperties(workInProgress)
					if enableProfilerTimer then
						if bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
							local isTimedOutSuspense = nextState ~= nil
							if isTimedOutSuspense then
								-- Don't count time spent in a timed out Suspense subtree as part of the base duration.
								local primaryChildFragment = workInProgress.child
								if primaryChildFragment ~= nil then
									-- $FlowFixMe Flow doens't support type casting in combiation with the -= operator
									workInProgress.treeBaseDuration = (
										primaryChildFragment.treeBaseDuration :: any
									) :: number
								end
							end
						end
					end
					return nil
				else
					-- We should never have been in a hydration state if we didn't have a current.
					-- However, in some of those paths, we might have reentered a hydration state
					-- and then we might be inside a hydration state. In that case, we'll need to exit out of it.
					resetHydrationState()
					if bit32.band(workInProgress.flags, DidCapture) == NoFlags then
						-- This boundary did not suspend so it's now hydrated and unsuspended.
						workInProgress.memoizedState = nil
					end
					-- If nothing suspended, we need to schedule an effect to mark this boundary
					-- as having hydrated so events know that they're free to be invoked.
					-- It's also a signal to replay events and the suspense callback.
					-- If something suspended, schedule an effect to attach retry listeners.
					-- So we might as well always mark this.
					workInProgress.flags = bit32.bor(workInProgress.flags, Update)
					bubbleProperties(workInProgress)
					if enableProfilerTimer then
						if bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
							local isTimedOutSuspense = nextState ~= nil
							if isTimedOutSuspense then
								-- Don't count time spent in a timed out Suspense subtree as part of the base duration.
								local primaryChildFragment = workInProgress.child
								if primaryChildFragment ~= nil then
									-- $FlowFixMe Flow doens't support type casting in combiation with the -= operator
									-- deviation: remove recast to silence analyze
									workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration
								end
							end
						end
					end
					return nil
				end
			end
		end

		if bit32.band(workInProgress.flags, DidCapture) ~= NoFlags then
			-- Something suspended. Re-render with the fallback children.
			workInProgress.lanes = renderLanes
			-- Do not reset the effect list.
			if enableProfilerTimer and bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
				transferActualDuration(workInProgress)
			end
			-- Don't bubble properties in this case.
			return workInProgress
		end

		local nextDidTimeout = nextState ~= nil
		local prevDidTimeout = false
		if current == nil then
			if workInProgress.memoizedProps.fallback ~= nil then
				popHydrationState(workInProgress)
			end
		else
			local prevState: nil | SuspenseState = current.memoizedState
			prevDidTimeout = prevState ~= nil
		end

		if nextDidTimeout and not prevDidTimeout then
			-- If this subtreee is running in blocking mode we can suspend,
			-- otherwise we won't suspend.
			-- TODO: This will still suspend a synchronous tree if anything
			-- in the concurrent tree already suspended during this render.
			-- This is a known bug.
			if bit32.band(workInProgress.mode, BlockingMode) ~= NoMode then
				-- TODO: Move this back to throwException because this is too late
				-- if this is a large tree which is common for initial loads. We
				-- don't know if we should restart a render or not until we get
				-- this marker, and this is too late.
				-- If this render already had a ping or lower pri updates,
				-- and this is the first time we know we're going to suspend we
				-- should be able to immediately restart from within throwException.
				local hasInvisibleChildContext = current == nil
					and workInProgress.memoizedProps.unstable_avoidThisFallback ~= true
				if
					hasInvisibleChildContext
					or hasSuspenseContext(
						suspenseStackCursor.current,
						InvisibleParentSuspenseContext :: SuspenseContext
					)
				then
					-- If this was in an invisible tree or a new render, then showing
					-- this boundary is ok.
					renderDidSuspend()
				else
					-- Otherwise, we're going to have to hide content so we should
					-- suspend for longer if possible.
					renderDidSuspendDelayIfPossible()
				end
			end
		end

		if supportsPersistence then
			-- TODO: Only schedule updates if not prevDidTimeout.
			if nextDidTimeout then
				-- If this boundary just timed out, schedule an effect to attach a
				-- retry listener to the promise. This flag is also used to hide the
				-- primary children.
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if supportsMutation then
			-- TODO: Only schedule updates if these values are non equal, i.e. it changed.
			if nextDidTimeout or prevDidTimeout then
				-- If this boundary just timed out, schedule an effect to attach a
				-- retry listener to the promise. This flag is also used to hide the
				-- primary children. In mutation mode, we also need the flag to
				-- *unhide* children that were previously hidden, so check if this
				-- is currently timed out, too.
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end
		if
			enableSuspenseCallback
			and workInProgress.updateQueue ~= nil
			and workInProgress.memoizedProps.suspenseCallback ~= nil
		then
			-- Always notify the callback
			workInProgress.flags = bit32.bor(workInProgress.flags, Update)
		end
		bubbleProperties(workInProgress)
		if enableProfilerTimer then
			if bit32.band(workInProgress.mode, ProfileMode) ~= NoMode then
				if nextDidTimeout then
					-- Don't count time spent in a timed out Suspense subtree as part of the base duration.
					local primaryChildFragment = workInProgress.child
					if primaryChildFragment ~= nil then
						-- $FlowFixMe Flow doens't support type casting in combiation with the -= operator
						-- deviation: remove recast to silence analyze
						workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration
					end
				end
			end
		end
		return nil
	elseif workInProgress.tag == HostPortal then
		popHostContainer(workInProgress)
		updateHostContainer(current, workInProgress)
		if current == nil then
			preparePortalMount(workInProgress.stateNode.containerInfo)
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == ContextProvider then
		-- Pop provider fiber
		popProvider(workInProgress)
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == IncompleteClassComponent then
		-- Same as class component case. I put it down here so that the tags are
		-- sequential to ensure this switch is compiled to a jump table.
		local Component = workInProgress.type
		if isLegacyContextProvider(Component) then
			popLegacyContext(workInProgress)
		end
		bubbleProperties(workInProgress)
		return nil
	elseif workInProgress.tag == SuspenseListComponent then
		unimplemented("SuspenseListComponent")
	-- popSuspenseContext(workInProgress)

	-- local renderState: nil | SuspenseListRenderState =
	--   workInProgress.memoizedState

	-- if renderState == nil)
	--   -- We're running in the default, "independent" mode.
	--   -- We don't do anything in this mode.
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end

	-- local didSuspendAlready = (workInProgress.flags & DidCapture) ~= NoFlags

	-- local renderedTail = renderState.rendering
	-- if renderedTail == nil)
	--   -- We just rendered the head.
	--   if !didSuspendAlready)
	--     -- This is the first pass. We need to figure out if anything is still
	--     -- suspended in the rendered set.

	--     -- If new content unsuspended, but there's still some content that
	--     -- didn't. Then we need to do a second pass that forces everything
	--     -- to keep showing their fallbacks.

	--     -- We might be suspended if something in this render pass suspended, or
	--     -- something in the previous committed pass suspended. Otherwise,
	--     -- there's no chance so we can skip the expensive call to
	--     -- findFirstSuspended.
	--     local cannotBeSuspended =
	--       renderHasNotSuspendedYet() and
	--       (current == nil or (current.flags & DidCapture) == NoFlags)
	--     if !cannotBeSuspended)
	--       local row = workInProgress.child
	--       while (row ~= nil)
	--         local suspended = findFirstSuspended(row)
	--         if suspended ~= nil)
	--           didSuspendAlready = true
	--           workInProgress.flags |= DidCapture
	--           cutOffTailIfNeeded(renderState, false)

	--           -- If this is a newly suspended tree, it might not get committed as
	--           -- part of the second pass. In that case nothing will subscribe to
	--           -- its thennables. Instead, we'll transfer its thennables to the
	--           -- SuspenseList so that it can retry if they resolve.
	--           -- There might be multiple of these in the list but since we're
	--           -- going to wait for all of them anyway, it doesn't really matter
	--           -- which ones gets to ping. In theory we could get clever and keep
	--           -- track of how many dependencies remain but it gets tricky because
	--           -- in the meantime, we can add/remove/change items and dependencies.
	--           -- We might bail out of the loop before finding any but that
	--           -- doesn't matter since that means that the other boundaries that
	--           -- we did find already has their listeners attached.
	--           local newThennables = suspended.updateQueue
	--           if newThennables ~= nil)
	--             workInProgress.updateQueue = newThennables
	--             workInProgress.flags |= Update
	--           end

	--           -- Rerender the whole list, but this time, we'll force fallbacks
	--           -- to stay in place.
	--           -- Reset the child fibers to their original state.
	--           workInProgress.subtreeFlags = NoFlags
	--           resetChildFibers(workInProgress, renderLanes)

	--           -- Set up the Suspense Context to force suspense and immediately
	--           -- rerender the children.
	--           pushSuspenseContext(
	--             workInProgress,
	--             setShallowSuspenseContext(
	--               suspenseStackCursor.current,
	--               ForceSuspenseFallback,
	--             ),
	--           )
	--           -- Don't bubble properties in this case.
	--           return workInProgress.child
	--         end
	--         row = row.sibling
	--       end
	--     end

	--     if renderState.tail ~= nil and now() > getRenderTargetTime())
	--       -- We have already passed our CPU deadline but we still have rows
	--       -- left in the tail. We'll just give up further attempts to render
	--       -- the main content and only render fallbacks.
	--       workInProgress.flags |= DidCapture
	--       didSuspendAlready = true

	--       cutOffTailIfNeeded(renderState, false)

	--       -- Since nothing actually suspended, there will nothing to ping this
	--       -- to get it started back up to attempt the next item. While in terms
	--       -- of priority this work has the same priority as this current render,
	--       -- it's not part of the same transition once the transition has
	--       -- committed. If it's sync, we still want to yield so that it can be
	--       -- painted. Conceptually, this is really the same as pinging.
	--       -- We can use any RetryLane even if it's the one currently rendering
	--       -- since we're leaving it behind on this node.
	--       workInProgress.lanes = SomeRetryLane
	--       if enableSchedulerTracing)
	--         markSpawnedWork(SomeRetryLane)
	--       end
	--     end
	--   else
	--     cutOffTailIfNeeded(renderState, false)
	--   end
	--   -- Next we're going to render the tail.
	-- else
	--   -- Append the rendered row to the child list.
	--   if !didSuspendAlready)
	--     local suspended = findFirstSuspended(renderedTail)
	--     if suspended ~= nil)
	--       workInProgress.flags |= DidCapture
	--       didSuspendAlready = true

	--       -- Ensure we transfer the update queue to the parent so that it doesn't
	--       -- get lost if this row ends up dropped during a second pass.
	--       local newThennables = suspended.updateQueue
	--       if newThennables ~= nil)
	--         workInProgress.updateQueue = newThennables
	--         workInProgress.flags |= Update
	--       end

	--       cutOffTailIfNeeded(renderState, true)
	--       -- This might have been modified.
	--       if
	--         renderState.tail == nil and
	--         renderState.tailMode == 'hidden' and
	--         !renderedTail.alternate and
	--         !getIsHydrating() -- We don't cut it if we're hydrating.
	--       )
	--         -- We're done.
	--         bubbleProperties(workInProgress)
	--         return nil
	--       end
	--     } else if
	--       -- The time it took to render last row is greater than the remaining
	--       -- time we have to render. So rendering one more row would likely
	--       -- exceed it.
	--       now() * 2 - renderState.renderingStartTime >
	--         getRenderTargetTime() and
	--       renderLanes ~= OffscreenLane
	--     )
	--       -- We have now passed our CPU deadline and we'll just give up further
	--       -- attempts to render the main content and only render fallbacks.
	--       -- The assumption is that this is usually faster.
	--       workInProgress.flags |= DidCapture
	--       didSuspendAlready = true

	--       cutOffTailIfNeeded(renderState, false)

	--       -- Since nothing actually suspended, there will nothing to ping this
	--       -- to get it started back up to attempt the next item. If we can show
	--       -- them, then they really have the same priority as this render.
	--       -- So we'll pick it back up the very next render pass once we've had
	--       -- an opportunity to yield for paint.
	--       workInProgress.lanes = SomeRetryLane
	--       if enableSchedulerTracing)
	--         markSpawnedWork(SomeRetryLane)
	--       end
	--     end
	--   end
	--   if renderState.isBackwards)
	--     -- The effect list of the backwards tail will have been added
	--     -- to the end. This breaks the guarantee that life-cycles fire in
	--     -- sibling order but that isn't a strong guarantee promised by React.
	--     -- Especially since these might also just pop in during future commits.
	--     -- Append to the beginning of the list.
	--     renderedTail.sibling = workInProgress.child
	--     workInProgress.child = renderedTail
	--   else
	--     local previousSibling = renderState.last
	--     if previousSibling ~= nil)
	--       previousSibling.sibling = renderedTail
	--     else
	--       workInProgress.child = renderedTail
	--     end
	--     renderState.last = renderedTail
	--   end
	-- end

	-- if renderState.tail ~= nil)
	--   -- We still have tail rows to render.
	--   -- Pop a row.
	--   local next = renderState.tail
	--   renderState.rendering = next
	--   renderState.tail = next.sibling
	--   renderState.renderingStartTime = now()
	--   next.sibling = nil

	--   -- Restore the context.
	--   -- TODO: We can probably just avoid popping it instead and only
	--   -- setting it the first time we go from not suspended to suspended.
	--   local suspenseContext = suspenseStackCursor.current
	--   if didSuspendAlready)
	--     suspenseContext = setShallowSuspenseContext(
	--       suspenseContext,
	--       ForceSuspenseFallback,
	--     )
	--   else
	--     suspenseContext = setDefaultShallowSuspenseContext(suspenseContext)
	--   end
	--   pushSuspenseContext(workInProgress, suspenseContext)
	--   -- Do a pass over the next row.
	--   -- Don't bubble properties in this case.
	--   return next
	-- end
	-- bubbleProperties(workInProgress)
	-- return nil
	-- end
	elseif workInProgress.tag == FundamentalComponent then
		unimplemented("FundamentalComponent")
	--   if enableFundamentalAPI)
	--   local fundamentalImpl = workInProgress.type.impl
	--   local fundamentalInstance: ReactFundamentalComponentInstance<
	--     any,
	--     any,
	--   > | nil = workInProgress.stateNode

	--   if fundamentalInstance == nil)
	--     local getInitialState = fundamentalImpl.getInitialState
	--     local fundamentalState
	--     if getInitialState ~= undefined)
	--       fundamentalState = getInitialState(newProps)
	--     end
	--     fundamentalInstance = workInProgress.stateNode = createFundamentalStateInstance(
	--       workInProgress,
	--       newProps,
	--       fundamentalImpl,
	--       fundamentalState or {},
	--     )
	--     local instance = ((getFundamentalComponentInstance(
	--       fundamentalInstance,
	--     ): any): Instance)
	--     fundamentalInstance.instance = instance
	--     if fundamentalImpl.reconcileChildren == false)
	--       bubbleProperties(workInProgress)
	--       return nil
	--     end
	--     appendAllChildren(instance, workInProgress, false, false)
	--     mountFundamentalComponent(fundamentalInstance)
	--   else
	--     -- We fire update in commit phase
	--     local prevProps = fundamentalInstance.props
	--     fundamentalInstance.prevProps = prevProps
	--     fundamentalInstance.props = newProps
	--     fundamentalInstance.currentFiber = workInProgress
	--     if supportsPersistence)
	--       local instance = cloneFundamentalInstance(fundamentalInstance)
	--       fundamentalInstance.instance = instance
	--       appendAllChildren(instance, workInProgress, false, false)
	--     end
	--     local shouldUpdate = shouldUpdateFundamentalComponent(
	--       fundamentalInstance,
	--     )
	--     if shouldUpdate)
	--       markUpdate(workInProgress)
	--     end
	--   end
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end
	elseif workInProgress.tag == ScopeComponent then
		unimplemented("ScopeComponent")
	-- if enableScopeAPI)
	--   if current == nil)
	--     local scopeInstance: ReactScopeInstance = createScopeInstance()
	--     workInProgress.stateNode = scopeInstance
	--     prepareScopeUpdate(scopeInstance, workInProgress)
	--     if workInProgress.ref ~= nil)
	--       markRef(workInProgress)
	--       markUpdate(workInProgress)
	--     end
	--   else
	--     if workInProgress.ref ~= nil)
	--       markUpdate(workInProgress)
	--     end
	--     if current.ref ~= workInProgress.ref)
	--       markRef(workInProgress)
	--     end
	--   end
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end
	elseif workInProgress.tag == Block then
		unimplemented("Block")
	-- if enableBlocksAPI)
	--   bubbleProperties(workInProgress)
	--   return nil
	-- end
	elseif workInProgress.tag == OffscreenComponent or workInProgress.tag == LegacyHiddenComponent then
		popRenderLanes(workInProgress)
		local nextState: OffscreenState | nil = workInProgress.memoizedState
		local nextIsHidden = nextState ~= nil

		if current ~= nil then
			local prevState: OffscreenState | nil = current.memoizedState

			local prevIsHidden = prevState ~= nil
			if prevIsHidden ~= nextIsHidden and newProps.mode ~= "unstable-defer-without-hiding" then
				workInProgress.flags = bit32.bor(workInProgress.flags, Update)
			end
		end

		-- Don't bubble properties for hidden children.
		if
			not nextIsHidden
			or includesSomeLane(ReactFiberWorkLoop.subtreeRenderLanes, OffscreenLane :: Lane)
			or bit32.band(workInProgress.mode, ConcurrentMode) == NoMode
		then
			bubbleProperties(workInProgress)
		end

		return nil
	end
	invariant(
		false,
		"Unknown unit of work tag (%s). This error is likely caused by a bug in " .. "React. Please file an issue.",
		tostring(workInProgress.tag)
	)
	return nil
end

return {
	completeWork = completeWork,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006107</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9B8ADE3D041D45EABC175821DB267AEC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberComponentStack</string>
								<string name="ScriptGuid">{8A3B9F48-0D3D-4897-B1BA-43326596B5A6}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/72d00ab623502983ebd7ac0756cf2787df109811/packages/react-reconciler/src/ReactFiberComponentStack.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Function = (...any) -> ...any
type Error = LuauPolyfill.Error

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local HostComponent = ReactWorkTags.HostComponent
local LazyComponent = ReactWorkTags.LazyComponent
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local FunctionComponent = ReactWorkTags.FunctionComponent
local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
local ForwardRef = ReactWorkTags.ForwardRef
local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local ClassComponent = ReactWorkTags.ClassComponent

local ReactComponentStackFrame = require(Packages.Shared).ReactComponentStackFrame
local describeBuiltInComponentFrame = ReactComponentStackFrame.describeBuiltInComponentFrame
local describeFunctionComponentFrame = ReactComponentStackFrame.describeFunctionComponentFrame
local describeClassComponentFrame = ReactComponentStackFrame.describeClassComponentFrame

local function describeFiber(fiber: Fiber): string
	-- deviation: untangling some nested ternaries to use more idiomatic if/else
	local owner: nil | Function = nil
	if _G.__DEV__ then
		-- FIXME (roblox): Luau's limited narrowing necessitates this local
		local debugOwner = fiber._debugOwner
		if debugOwner then
			owner = debugOwner.type
		end
	end
	local source = nil
	if _G.__DEV__ then
		source = fiber._debugSource
	end
	if fiber.tag == HostComponent then
		return describeBuiltInComponentFrame(fiber.type, source, owner)
	elseif fiber.tag == LazyComponent then
		return describeBuiltInComponentFrame("Lazy", source, owner)
	elseif fiber.tag == SuspenseComponent then
		return describeBuiltInComponentFrame("Suspense", source, owner)
	elseif fiber.tag == SuspenseListComponent then
		return describeBuiltInComponentFrame("SuspenseList", source, owner)
	elseif
		fiber.tag == FunctionComponent
		or fiber.tag == IndeterminateComponent
		or fiber.tag == SimpleMemoComponent
	then
		return describeFunctionComponentFrame(fiber.type, source, owner)
	elseif fiber.tag == ForwardRef then
		return describeFunctionComponentFrame(fiber.type.render, source, owner)
	elseif fiber.tag == ClassComponent then
		return describeClassComponentFrame(fiber.type, source, owner)
	else
		return ""
	end
end

return {
	getStackByFiberInDevAndProd = function(workInProgress: Fiber?): string
		local ok: boolean, result: Error | string = pcall(function()
			local info = ""
			local node = workInProgress
			repeat
				info ..= describeFiber(node :: Fiber)
				node = (node :: Fiber).return_
			until node == nil
			return info
		end)

		if not ok then
			local message = "\nError generating stack: "
			if typeof(result) == "table" and (result :: Error).message and (result :: Error).stack then
				return message .. (result :: Error).message .. "\n" .. tostring((result :: Error).stack)
			end
			return message .. tostring(result)
		end

		return result :: string
	end,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006108</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX087A00804BE34D0A9B6138353BA057E2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberContext.new</string>
								<string name="ScriptGuid">{7CD0B9EC-EA98-4501-8A92-9ADCD85B321A}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/a724a3b578dce77d427bef313102a4d0e978d9b4/packages/react-reconciler/src/ReactFiberContext.new.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local __DEV__ = _G.__DEV__ :: boolean
local __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ = _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ :: boolean

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Error = LuauPolyfill.Error

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>

local isFiberMounted = require(script.Parent.ReactFiberTreeReflection).isFiberMounted
local disableLegacyContext = require(Packages.Shared).ReactFeatureFlags.disableLegacyContext
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local getComponentName = require(Packages.Shared).getComponentName
local checkPropTypes = require(Packages.Shared).checkPropTypes

local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop

local warnedAboutMissingGetChildContext

if __DEV__ then
	warnedAboutMissingGetChildContext = {}
end

local emptyContextObject = {}
if __DEV__ then
	Object.freeze(emptyContextObject)
end

-- deviation: Common types
type Object = { [any]: any }

-- A cursor to the current merged context object on the stack.
local contextStackCursor: StackCursor<Object> = createCursor(emptyContextObject)
-- A cursor to a boolean indicating whether the context has changed.
local didPerformWorkStackCursor: StackCursor<boolean> = createCursor(false)
-- Keep track of the previous context object that was on the stack.
-- We use this to get access to the parent context after we have already
-- pushed the next context provider, and now need to merge their contexts.
local previousContext: Object = emptyContextObject

-- deviation: Pre-declare function
local isContextProvider

-- deviation: FIXME: `Component: Function` - lock down component type def
local function getUnmaskedContext(workInProgress: Fiber, Component: any, didPushOwnContextIfProvider: boolean): Object
	-- performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return emptyContextObject
	-- else
	if didPushOwnContextIfProvider and isContextProvider(Component) then
		-- If the fiber is a context provider itself, when we read its context
		-- we may have already pushed its own child context on the stack. A context
		-- provider should not "see" its own child context. Therefore we read the
		-- previous (parent) context instead for a context provider.
		return previousContext
	end
	return contextStackCursor.current
	-- end
end

local function cacheContext(workInProgress: Fiber, unmaskedContext: Object, maskedContext: Object): ()
	-- performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	local instance = workInProgress.stateNode
	instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext
	instance.__reactInternalMemoizedMaskedChildContext = maskedContext
	-- end
end

local function getMaskedContext(workInProgress: Fiber, unmaskedContext: Object): Object
	-- performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return emptyContextObject
	-- else
	local type_ = workInProgress.type
	-- deviation: For function components, we can't support `contextTypes`;
	-- instead, just return unmaskedContext
	if type(type_) == "function" then
		return unmaskedContext
	end

	local contextTypes = type_.contextTypes
	if not contextTypes then
		return emptyContextObject
	end

	-- Avoid recreating masked context unless unmasked context has changed.
	-- Failing to do this will result in unnecessary calls to componentWillReceiveProps.
	-- This may trigger infinite loops if componentWillReceiveProps calls setState.
	local instance = workInProgress.stateNode
	if instance and instance.__reactInternalMemoizedUnmaskedChildContext == unmaskedContext then
		return instance.__reactInternalMemoizedMaskedChildContext
	end

	local context = {}
	for key, _ in contextTypes do
		context[key] = unmaskedContext[key]
	end

	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local name = getComponentName(type_) or "Unknown"
		-- deviation: nil as second argument for validateProps compatibility
		checkPropTypes(contextTypes, nil, context, "context", name)
	end

	-- Cache unmasked context so we can avoid recreating masked context unless necessary.
	-- Context is created before the class component is instantiated so check for instance.
	if instance then
		cacheContext(workInProgress, unmaskedContext, context)
	end

	return context
	-- end
end

local function hasContextChanged(): boolean
	if disableLegacyContext then
		return false
	else
		return didPerformWorkStackCursor.current
	end
end

-- deviation: `type: Function` - lock down component type def
function isContextProvider(type_): boolean
	-- performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return false
	-- else
	-- deviation: context types only valid for class components
	-- performance: type is already guarded as being a ClassComponent and/or typeof == 'table' in all call sites
	if type(type_) == "function" then
		return false
	end
	local childContextTypes = type_.childContextTypes
	return childContextTypes ~= nil
	-- end
end

local function popContext(fiber: Fiber): ()
	-- performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	pop(didPerformWorkStackCursor, fiber)
	pop(contextStackCursor, fiber)
	-- end
end

local function popTopLevelContextObject(fiber: Fiber): ()
	-- performance: skip always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	pop(didPerformWorkStackCursor, fiber)
	pop(contextStackCursor, fiber)
	-- end
end

local function pushTopLevelContextObject(fiber: Fiber, context: Object, didChange: boolean): ()
	-- performance: disable always-false cmp in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	if contextStackCursor.current ~= emptyContextObject then
		error(
			Error.new(
				"Unexpected context found on stack. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		)
	end

	push(contextStackCursor, context, fiber)
	push(didPerformWorkStackCursor, didChange, fiber)
	-- end
end

local function processChildContext(fiber: Fiber, type_: any, parentContext: Object): Object
	-- performance: eliminate always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return parentContext
	-- else
	local instance = fiber.stateNode
	local childContextTypes = type_.childContextTypes

	-- TODO (bvaughn) Replace this behavior with an invariant() in the future.
	-- It has only been added in Fiber to match the (unintentional) behavior in Stack.
	if instance.getChildContext == nil or type(instance.getChildContext) ~= "function" then
		if __DEV__ then
			local componentName = getComponentName(type_) or "Unknown"

			if not warnedAboutMissingGetChildContext[componentName] then
				warnedAboutMissingGetChildContext[componentName] = true
				console.error(
					"%s.childContextTypes is specified but there is no getChildContext() method "
						.. "on the instance. You can either define getChildContext() on %s or remove "
						.. "childContextTypes from it.",
					componentName,
					componentName
				)
			end
		end
		return parentContext
	end

	local childContext = instance:getChildContext()
	for contextKey, _ in childContext do
		if childContextTypes[contextKey] == nil then
			local name = getComponentName(type_) or "Unknown"
			error(
				Error.new(
					string.format(
						'%s.getChildContext(): key "%s" is not defined in childContextTypes.',
						name,
						contextKey
					)
				)
			)
		end
	end
	if __DEV__ or __DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local name = getComponentName(type_) or "Unknown"
		-- deviation: nil as second argument for validateProps compatibility
		checkPropTypes(childContextTypes, nil, childContext, "child context", name)
	end

	return Object.assign({}, parentContext, childContext)
	-- end
end

local function pushContextProvider(workInProgress: Fiber): boolean
	-- performance: eliminate always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return false
	-- else
	local instance = workInProgress.stateNode
	-- We push the context as early as possible to ensure stack integrity.
	-- If the instance does not exist yet, we will push nil at first,
	-- and replace it on the stack later when invalidating the context.
	local memoizedMergedChildContext = (instance and instance.__reactInternalMemoizedMergedChildContext)
		or emptyContextObject

	-- Remember the parent context so we can merge with it later.
	-- Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
	previousContext = contextStackCursor.current
	push(contextStackCursor, memoizedMergedChildContext, workInProgress)
	push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress)

	return true
	-- end
end

local function invalidateContextProvider(workInProgress: Fiber, type_: any, didChange: boolean): ()
	-- performance: eliminate always-false compare in hot path
	-- if disableLegacyContext then
	-- 	return
	-- else
	local instance = workInProgress.stateNode

	if not instance then
		error(
			Error.new(
				"Expected to have an instance by this point. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		)
	end

	if didChange then
		-- Merge parent and own context.
		-- Skip this if we're not updating due to sCU.
		-- This avoids unnecessarily recomputing memoized values.
		local mergedContext = processChildContext(workInProgress, type_, previousContext)
		instance.__reactInternalMemoizedMergedChildContext = mergedContext

		-- Replace the old (or empty) context with the new one.
		-- It is important to unwind the context in the reverse order.
		pop(didPerformWorkStackCursor, workInProgress)
		pop(contextStackCursor, workInProgress)
		-- Now push the new context and mark that it has changed.
		push(contextStackCursor, mergedContext, workInProgress)
		push(didPerformWorkStackCursor, didChange, workInProgress)
	else
		pop(didPerformWorkStackCursor, workInProgress)
		push(didPerformWorkStackCursor, didChange, workInProgress)
	end
	-- end
end

local function findCurrentUnmaskedContext(fiber: Fiber): Object
	-- performance: eliminate always-false in hot path
	-- if disableLegacyContext then
	-- 	return emptyContextObject
	-- else
	-- Currently this is only used with renderSubtreeIntoContainer; not sure if it
	-- makes sense elsewhere
	if fiber.tag ~= ClassComponent or not isFiberMounted(fiber) then
		error(
			Error.new(
				"Expected subtree parent to be a mounted class component. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
		)
	end

	-- TODO: Luau analyze can't accommodate the 'repeat until (not) nil' pattern
	local node: any = fiber
	repeat
		if node.tag == HostRoot then
			return node.stateNode.context
		elseif node.tag == ClassComponent then
			local Component = node.type
			-- deviation: inline specialized check for isContextProvider since we know it's a class
			if Component.childContextTypes ~= nil then
				return node.stateNode.__reactInternalMemoizedMergedChildContext
			end
		end

		node = node.return_
	until node == nil

	error(
		Error.new(
			"Found unexpected detached subtree parent. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	)
	-- end
end

return {
	emptyContextObject = emptyContextObject,
	getUnmaskedContext = getUnmaskedContext,
	cacheContext = cacheContext,
	getMaskedContext = getMaskedContext,
	hasContextChanged = hasContextChanged,
	popContext = popContext,
	popTopLevelContextObject = popTopLevelContextObject,
	pushTopLevelContextObject = pushTopLevelContextObject,
	processChildContext = processChildContext,
	isContextProvider = isContextProvider,
	pushContextProvider = pushContextProvider,
	invalidateContextProvider = invalidateContextProvider,
	findCurrentUnmaskedContext = findCurrentUnmaskedContext,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006109</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8562ABBE539249EEAE48B02ABD4E0C7E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberDevToolsHook.new</string>
								<string name="ScriptGuid">{C1D9C4F5-2733-4333-BD16-9FB1E2004AFA}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberDevToolsHook.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object
local exports = {}

-- deviation: subset copied here from devtools-shared/backend/types, to have stronger enforcement than 'Object' without circular dep
type DevToolsHook = {
	-- TODO: ideally, ReactRenderer type would be importable from this file so we could use it here
	inject: (Object) -> number | nil,
	supportsFiber: boolean,
	isDisabled: boolean,
	--   ...
}

-- deviation: we use callable tables instead of functions sometimes, so typeof() == "function" isn't enough
local function isCallable(value)
	if typeof(value) == "function" then
		return true
	end
	if typeof(value) == "table" then
		local mt = getmetatable(value)
		if mt and rawget(mt, "__call") then
			return true
		end
		if value._isMockFunction then
			return true
		end
	end
	return false
end

local enableProfilerTimer = require(Packages.Shared).ReactFeatureFlags.enableProfilerTimer

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList

local DidCapture = require(script.Parent.ReactFiberFlags).DidCapture

-- deviation: we'll inject this a different way
-- declare var __REACT_DEVTOOLS_GLOBAL_HOOK__: Object | void

local rendererID = nil
local injectedHook = nil
local hasLoggedError = false

-- deviation: We use a function to handle the hook being changed at runtime
exports.isDevToolsPresent = function()
	return _G.__REACT_DEVTOOLS_GLOBAL_HOOK__ ~= nil
end

exports.injectInternals = function(internals: Object): boolean
	if _G.__REACT_DEVTOOLS_GLOBAL_HOOK__ == nil then
		-- No DevTools
		return false
	end
	local hook: DevToolsHook = _G.__REACT_DEVTOOLS_GLOBAL_HOOK__
	if hook.isDisabled then
		-- This isn't a real property on the hook, but it can be set to opt out
		-- of DevTools integration and associated warnings and logs.
		-- http://github.com/facebook/react/issues/3877
		return true
	end
	if not hook.supportsFiber then
		if _G.__DEV__ then
			console.error(
				"The installed version of React DevTools is too old and will not work "
					.. "with the current version of React. Please update React DevTools. "
					.. "https://reactjs.org/link/react-devtools"
			)
		end
		-- DevTools exists, even though it doesn't support Fiber.
		return true
	end
	local ok, err = pcall(function()
		rendererID = hook.inject(internals)
		-- We have successfully injected, so now it is safe to set up hooks.
		injectedHook = hook
	end)

	if not ok then
		-- Catch all errors because it is unsafe to throw during initialization.
		if _G.__DEV__ then
			console.error("React instrumentation encountered an error: %s.", err)
		end
	end
	-- DevTools exists
	return true
end

exports.onScheduleRoot = function(root: FiberRoot, children: ReactNodeList)
	if _G.__DEV__ then
		if
			injectedHook
			-- deviation: our mocked functions are tables with __call, since they have fields
			and isCallable(injectedHook.onScheduleFiberRoot)
		then
			local ok, err = pcall(injectedHook.onScheduleFiberRoot, rendererID, root, children)

			if not ok then
				if _G.__DEV__ and not hasLoggedError then
					hasLoggedError = true
					console.error("React instrumentation encountered an error: %s", err)
				end
			end
		end
	end
end

exports.onCommitRoot = function(root: FiberRoot, priorityLevel: ReactPriorityLevel)
	if
		injectedHook
		-- deviation: our mocked functions are tables with __call, since they have fields
		and isCallable(injectedHook.onCommitFiberRoot)
	then
		local ok, err = pcall(function()
			local didError = bit32.band(root.current.flags, DidCapture) == DidCapture
			if enableProfilerTimer then
				injectedHook.onCommitFiberRoot(rendererID, root, priorityLevel, didError)
			else
				injectedHook.onCommitFiberRoot(rendererID, root, nil, didError)
			end
		end)
		if not ok then
			if _G.__DEV__ then
				if not hasLoggedError then
					hasLoggedError = true
					console.error("React instrumentation encountered an error: %s", err)
				end
			end
		end
	end
end

exports.onCommitUnmount = function(fiber: Fiber)
	if
		injectedHook
		-- deviation: our mocked functions are tables with __call, since they have fields
		and isCallable(injectedHook.onCommitFiberUnmount)
	then
		local ok, err = pcall(injectedHook.onCommitFiberUnmount, rendererID, fiber)
		if not ok then
			if _G.__DEV__ then
				if not hasLoggedError then
					hasLoggedError = true
					console.error("React instrumentation encountered an error: %s", err)
				end
			end
		end
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000610a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8AC2714F389343AB950286A68618E10D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberErrorDialog</string>
								<string name="ScriptGuid">{86EE0365-A9AF-49FD-8DCC-C6091B486A6D}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiberErrorDialog.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

-- This module is forked in different environments.
-- By default, return `true` to log errors to the console.
-- Forks can return `false` if this isn't desirable.
local exports = {}

exports.showErrorDialog = function(boundary, errorInfo): boolean
	-- TODO: we may replace this with something that sends telemetry LUAFDN-222
	return true
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000610b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC0B085EF1155459292F653F13D7E5E1E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberErrorLogger</string>
								<string name="ScriptGuid">{E9238860-B255-4A1B-B7D8-25C391C33809}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-reconciler/src/ReactFiberErrorLogger.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
local setTimeout = LuauPolyfill.setTimeout

local Shared = require(Packages.Shared)
local console = Shared.console
local errorToString = Shared.errorToString

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactCapturedValue = require(script.Parent.ReactCapturedValue)
type CapturedValue<T> = ReactCapturedValue.CapturedValue<T>

local showErrorDialog = require(script.Parent.ReactFiberErrorDialog).showErrorDialog
local ClassComponent = require(script.Parent.ReactWorkTags).ClassComponent
local getComponentName = require(Packages.Shared).getComponentName

local exports = {}

exports.logCapturedError = function(boundary: Fiber, errorInfo: CapturedValue<any>)
	local ok, e = pcall(function()
		local logError = showErrorDialog(boundary, errorInfo)

		-- Allow injected showErrorDialog() to prevent default console.error logging.
		-- This enables renderers like ReactNative to better manage redbox behavior.
		if logError == false then
			-- FIXME Luau: needs void return Luau bugfix
			return nil
		end

		local error_ = errorInfo.value
		if _G.__DEV__ then
			local source = errorInfo.source
			local stack = errorInfo.stack
			local componentStack = stack or ""
			-- Browsers support silencing uncaught errors by calling
			-- `preventDefault()` in window `error` handler.
			-- We record this information as an expando on the error.
			if error_ ~= nil and error_._suppressLogging then
				if boundary.tag == ClassComponent then
					-- The error is recoverable and was silenced.
					-- Ignore it and don't print the stack addendum.
					-- This is handy for testing error boundaries without noise.
					return
				end
				-- The error is fatal. Since the silencing might have
				-- been accidental, we'll surface it anyway.
				-- However, the browser would have silenced the original error
				-- so we'll print it first, and then print the stack addendum.
				console["error"](error_) -- Don't transform to our wrapper
				-- For a more detailed description of this block, see:
				-- https://github.com/facebook/react/pull/13384
			end

			local componentName
			if source ~= nil then
				componentName = getComponentName(source.type)
			else
				componentName = nil
			end

			local componentNameMessage
			if componentName then
				componentNameMessage = "The above error occurred in the <" .. tostring(componentName) .. "> component:"
			else
				componentNameMessage = "The above error occurred in one of your React components:"
			end

			local errorBoundaryMessage
			local errorBoundaryName = getComponentName(boundary.type)
			if errorBoundaryName then
				errorBoundaryMessage = "React will try to recreate this component tree from scratch "
					.. "using the error boundary you provided, "
					.. errorBoundaryName
					.. "."
			else
				errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\n"
					.. "Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries."
			end
			local combinedMessage = componentNameMessage .. "\n" .. componentStack .. "\n\n" .. errorBoundaryMessage

			-- In development, we provide our own message with just the component stack.
			-- We don't include the original error message and JS stack because the browser
			-- has already printed it. Even if the application swallows the error, it is still
			-- displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
			console["error"](combinedMessage) -- Don't transform to our wrapper
		else
			-- In production, we print the error directly.
			-- This will include the message, the JS stack, and anything the browser wants to show.
			-- We pass the error object instead of custom message so that the browser displays the error natively.
			console["error"](inspect(error_)) -- Don't transform to our wrapper
		end

		-- FIXME Luau: needs void return Luau bugfix
		return nil
	end)

	if not ok then
		warn("failed to error with error: " .. inspect(e))
		-- TODO: we may need to think about this more deeply and do something different
		-- This method must not throw, or React internal state will get messed up.
		-- If console.error is overridden, or logCapturedError() shows a dialog that throws,
		-- we want to report this error outside of the normal stack as a last resort.
		-- https://github.com/facebook/react/issues/13188
		setTimeout(function()
			-- FIXME: the top-level Luau VM handler doesn't deal with non-string errors, so massage it until VM support lands
			error(errorToString(e :: any))
		end)
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000610c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX36342D0C5FE8414ABB98653698F5A64F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberFlags</string>
								<string name="ScriptGuid">{B54C5B65-8565-4FF3-9727-BFD49FD3D791}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/37cb732c59863297e48f69ac1f6e2ba1aa1886f0/packages/react-reconciler/src/ReactFiberFlags.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

export type Flags = number

local exports = {}

-- Don't change these two values. They're used by React Dev Tools.
exports.NoFlags = --[[                      ]]
	0b000000000000000000
exports.PerformedWork = --[[                ]]
	0b000000000000000001

-- You can change the rest (and add more).
exports.Placement = --[[                    ]]
	0b000000000000000010
exports.Update = --[[                       ]]
	0b000000000000000100
exports.PlacementAndUpdate = --[[           ]]
	0b000000000000000110
exports.Deletion = --[[                     ]]
	0b000000000000001000
exports.ContentReset = --[[                 ]]
	0b000000000000010000
exports.Callback = --[[                     ]]
	0b000000000000100000
exports.DidCapture = --[[                   ]]
	0b000000000001000000
exports.Ref = --[[                          ]]
	0b000000000010000000
exports.Snapshot = --[[                     ]]
	0b000000000100000000
exports.Passive = --[[                      ]]
	0b000000001000000000
-- TODO (effects) Remove this bit once the new reconciler is synced to the old.
exports.PassiveUnmountPendingDev = --[[     ]]
	0b000010000000000000
exports.Hydrating = --[[                    ]]
	0b000000010000000000
exports.HydratingAndUpdate = --[[           ]]
	0b000000010000000100

-- Passive & Update & Callback & Ref & Snapshot
exports.LifecycleEffectMask = --[[          ]]
	0b000000001110100100

-- Union of all host effects
exports.HostEffectMask = --[[               ]]
	0b000000011111111111

-- These are not really side effects, but we still reuse this field.
exports.Incomplete = --[[                   ]]
	0b000000100000000000
exports.ShouldCapture = --[[                ]]
	0b000001000000000000
exports.ForceUpdateForLegacySuspense = --[[ ]]
	0b000100000000000000

-- Static tags describe aspects of a fiber that are not specific to a render,
-- e.g. a fiber uses a passive effect (even if there are no updates on this particular render).
-- This enables us to defer more work in the unmount case,
-- since we can defer traversing the tree during layout to look for Passive effects,
-- and instead rely on the static flag as a signal that there may be cleanup work.
exports.PassiveStatic = --[[                ]]
	0b001000000000000000

-- Union of side effect groupings as pertains to subtreeFlags
exports.BeforeMutationMask = --[[           ]]
	0b000000001100001010
exports.MutationMask = --[[                 ]]
	0b000000010010011110
exports.LayoutMask = --[[                   ]]
	0b000000000010100100
exports.PassiveMask = --[[                  ]]
	0b000000001000001000

-- Union of tags that don't get reset on clones.
-- This allows certain concepts to persist without recalculting them,
-- e.g. whether a subtree contains passive effects or portals.
exports.StaticMask = --[[                   ]]
	0b001000000000000000

-- These flags allow us to traverse to fibers that have effects on mount
-- without traversing the entire tree after every commit for
-- double invoking
exports.MountLayoutDev = --[[               ]]
	0b010000000000000000
exports.MountPassiveDev = --[[              ]]
	0b100000000000000000

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000610d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA147F83659904527A98F04915B969C6C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberHooks.new</string>
								<string name="ScriptGuid">{15E977E6-C5ED-4E49-8D9E-FE0B5734CD5F}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/43363e2795393a00fd77312a16d6b80e626c29de/packages/react-reconciler/src/ReactFiberHooks.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. message)
	error("FIXME (roblox): " .. message .. " is unimplemented")
end
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object

-- NOTE: use Bindings to implement useRef
local createRef = require(Packages.React).createRef
local createBinding = require(Packages.React).createBinding

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
type ReactContext<T> = ReactTypes.ReactContext<T>
type ReactBinding<T> = ReactTypes.ReactBinding<T>
type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<Source, Snapshot>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type Dispatcher = ReactInternalTypes.Dispatcher
type HookType = ReactInternalTypes.HookType
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
local ReactHookEffectTags = require(script.Parent.ReactHookEffectTags)
type HookFlags = ReactHookEffectTags.HookFlags
type FiberRoot = ReactInternalTypes.FiberRoot
-- TODO: figure out how to expose types through dynamic exports
-- local type {OpaqueIDType} = require(script.Parent.ReactFiberHostConfig)
type OpaqueIDType = any

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableDebugTracing: boolean? = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler: boolean? = ReactFeatureFlags.enableSchedulingProfiler
local enableNewReconciler: boolean? = ReactFeatureFlags.enableNewReconciler
-- local decoupleUpdatePriorityFromScheduler = ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects

-- local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local DebugTracingMode = require(script.Parent.ReactTypeOfMode).DebugTracingMode
local NoLane = ReactFiberLane.NoLane
local NoLanes = ReactFiberLane.NoLanes
-- local InputContinuousLanePriority = ReactFiberLane.InputContinuousLanePriority
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local mergeLanes = ReactFiberLane.mergeLanes
local removeLanes = ReactFiberLane.removeLanes
local markRootEntangled = ReactFiberLane.markRootEntangled
local markRootMutableRead = ReactFiberLane.markRootMutableRead
-- local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
-- local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority
-- local higherLanePriority = ReactFiberLane.higherLanePriority
-- local DefaultLanePriority = ReactFiberLane.DefaultLanePriority
local ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"])
local readContext = ReactFiberNewContext.readContext
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local UpdateEffect = ReactFiberFlags.Update
local PassiveEffect = ReactFiberFlags.Passive
local PassiveStaticEffect = ReactFiberFlags.PassiveStatic
local MountLayoutDevEffect = ReactFiberFlags.MountLayoutDev
local MountPassiveDevEffect = ReactFiberFlags.MountPassiveDev
local HookHasEffect = ReactHookEffectTags.HasEffect
local HookLayout = ReactHookEffectTags.Layout
local HookPassive = ReactHookEffectTags.Passive
local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
local warnIfNotCurrentlyActingUpdatesInDEV = ReactFiberWorkLoop.warnIfNotCurrentlyActingUpdatesInDEV
local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local warnIfNotScopedWithMatchingAct = ReactFiberWorkLoop.warnIfNotScopedWithMatchingAct
local requestEventTime = ReactFiberWorkLoop.requestEventTime
local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
local markSkippedUpdateLanes = ReactFiberWorkLoop.markSkippedUpdateLanes
local getWorkInProgressRoot = ReactFiberWorkLoop.getWorkInProgressRoot
local warnIfNotCurrentlyActingEffectsInDEV = ReactFiberWorkLoop.warnIfNotCurrentlyActingEffectsInDEV
-- local {
--   getWorkInProgressRoot,
--   requestUpdateLane,
--   requestEventTime,
--   warnIfNotCurrentlyActingEffectsInDEV,
-- } = require(script.Parent.ReactFiberWorkLoop.new)

local invariant = require(Packages.Shared).invariant
local getComponentName = require(Packages.Shared).getComponentName
-- local is = require(Packages.Shared).objectIs
local function is(x: any, y: any)
	return x == y and (x ~= 0 or 1 / x == 1 / y) or x ~= x and y ~= y -- eslint-disable-line no-self-compare
end
local markWorkInProgressReceivedUpdate =
	require(script.Parent["ReactFiberBeginWork.new"]).markWorkInProgressReceivedUpdate :: any
-- local {
--   UserBlockingPriority,
--   NormalPriority,
--   runWithPriority,
--   getCurrentPriorityLevel,
-- } = require(script.Parent.SchedulerWithReactIntegration.new)
local getIsHydrating = require(script.Parent["ReactFiberHydrationContext.new"]).getIsHydrating
-- local {
--   makeClientId,
--   makeClientIdInDEV,
--   makeOpaqueHydratingObject,
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local makeClientId = ReactFiberHostConfig.makeClientId
-- local makeOpaqueHydratingObject = ReactFiberHostConfig.makeOpaqueHydratingObject
-- local makeClientIdInDEV = ReactFiberHostConfig.makeClientIdInDEV

local ReactMutableSource = require(script.Parent["ReactMutableSource.new"])
local warnAboutMultipleRenderersDEV = ReactMutableSource.warnAboutMultipleRenderersDEV
local getWorkInProgressVersion = ReactMutableSource.getWorkInProgressVersion
local setWorkInProgressVersion = ReactMutableSource.setWorkInProgressVersion
local markSourceAsDirty = ReactMutableSource.markSourceAsDirty

-- local getIsRendering = require(script.Parent.ReactCurrentFiber).getIsRendering
local logStateUpdateScheduled = require(script.Parent.DebugTracing).logStateUpdateScheduled
local markStateUpdateScheduled = require(script.Parent.SchedulingProfiler).markStateUpdateScheduled

local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
-- local ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig

-- deviation: common types
type Array<T> = { [number]: T }

type Update<S, A> = {
	lane: Lane,
	action: A,
	eagerReducer: ((S, A) -> S) | nil,
	eagerState: S | nil,
	next: Update<S, A>,
	priority: ReactPriorityLevel?,
}

type UpdateQueue<S, A> = {
	pending: Update<S, A> | nil,
	dispatch: ((A) -> ...any) | nil,
	lastRenderedReducer: ((S, A) -> S) | nil,
	lastRenderedState: S | nil,
}

local didWarnAboutMismatchedHooksForComponent
local _didWarnAboutUseOpaqueIdentifier
if __DEV__ then
	_didWarnAboutUseOpaqueIdentifier = {}
	didWarnAboutMismatchedHooksForComponent = {}
end

export type Hook = {
	memoizedState: any,
	baseState: any,
	baseQueue: Update<any, any> | nil,
	queue: UpdateQueue<any, any> | nil,
	next: Hook?,
}

export type Effect = {
	tag: HookFlags,
	-- TODO: this needs Luau type pack support to express accurately
	create: (() -> (() -> ())) | () -> (),
	destroy: (() -> ())?,
	deps: Array<any> | nil,
	next: Effect,
}

export type FunctionComponentUpdateQueue = {
	lastEffect: Effect?,
}

type BasicStateAction<S> = ((S) -> S) | S

type Dispatch<A> = (A) -> ()

local exports: any = {}

-- These are set right before calling the component.
local renderLanes: Lanes = NoLanes
-- The work-in-progress fiber. I've named it differently to distinguish it from
-- the work-in-progress hook.
local currentlyRenderingFiber: Fiber = nil :: any

-- Hooks are stored as a linked list on the fiber's memoizedState field. The
-- current hook list is the list that belongs to the current fiber. The
-- work-in-progress hook list is a new list that will be added to the
-- work-in-progress fiber.
-- FIXME (roblox): type refinement
-- local currentHook: Hook | nil = nil
local currentHook: any = nil
-- FIXME (roblox): type refinement
-- local workInProgressHook: Hook | nil = nil
local workInProgressHook: any = nil

-- Whether an update was scheduled at any point during the render phase. This
-- does not get reset if we do another render pass; only when we're completely
-- finished evaluating this component. This is an optimization so we know
-- whether we need to clear render phase updates after a throw.
local didScheduleRenderPhaseUpdate: boolean = false
-- Where an update was scheduled only during the current render pass. This
-- gets reset after each attempt.
-- TODO: Maybe there's some way to consolidate this with
-- `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.
local didScheduleRenderPhaseUpdateDuringThisPass: boolean = false

local RE_RENDER_LIMIT = 25

-- In DEV, this is the name of the currently executing primitive hook
local currentHookNameInDev: HookType? = nil

-- In DEV, this list ensures that hooks are called in the same order between renders.
-- The list stores the order of hooks used during the initial render (mount).
-- Subsequent renders (updates) reference this list.
local hookTypesDev: Array<HookType> | nil = nil
local hookTypesUpdateIndexDev: number = 0

-- In DEV, this tracks whether currently rendering component needs to ignore
-- the dependencies for Hooks that need them (e.g. useEffect or useMemo).
-- When true, such Hooks will always be "remounted". Only used during hot reload.
-- performance: eliminate unuseful cmp in hot path, we don't currently support hot reloading
local ignorePreviousDependencies: boolean = false

-- Deviation: move to top so below function can reference
local HooksDispatcherOnMountInDEV: Dispatcher | nil = nil
local HooksDispatcherOnMountWithHookTypesInDEV: Dispatcher | nil = nil
local HooksDispatcherOnUpdateInDEV: Dispatcher | nil = nil
local HooksDispatcherOnRerenderInDEV: Dispatcher | nil = nil
local InvalidNestedHooksDispatcherOnMountInDEV: Dispatcher | nil = nil
local InvalidNestedHooksDispatcherOnUpdateInDEV: Dispatcher | nil = nil
local InvalidNestedHooksDispatcherOnRerenderInDEV: Dispatcher | nil = nil

-- deviation: Used to better compare dependency arrays with gaps
local function getHighestIndex(array: Array<any>)
	local highestIndex = 0
	for k, v in array do
		highestIndex = if k > highestIndex then k else highestIndex
	end
	return highestIndex
end

-- deviation: Used to better detect dependency arrays with gaps, to be
-- used in place of Array.isArray
local function isArrayOrSparseArray(deps: any)
	if type(deps) ~= "table" then
		return false
	end
	for k, _v in deps do
		if type(k) ~= "number" then
			return false
		end
	end
	return true
end

local function mountHookTypesDev()
	if __DEV__ then
		local hookName = (currentHookNameInDev :: any) :: HookType

		if hookTypesDev == nil then
			-- FIXME Luau: needs normalization (I think)
			hookTypesDev = ({ hookName } :: any) :: Array<HookType>
		else
			table.insert(hookTypesDev, hookName)
		end
	end
end

function updateHookTypesDev()
	if __DEV__ then
		-- FIXME Luau: needs normalization (I think) to avoid duplicate type declaration
		local hookName: HookType = (currentHookNameInDev :: any) :: HookType

		if hookTypesDev ~= nil then
			hookTypesUpdateIndexDev += 1
			if hookTypesDev[hookTypesUpdateIndexDev] ~= hookName then
				warnOnHookMismatchInDev(hookName)
			end
		end
	end
end

local function checkDepsAreArrayDev(deps: any)
	if __DEV__ then
		if deps ~= nil and not isArrayOrSparseArray(deps) then
			-- Verify deps, but only on mount to avoid extra checks.
			-- It's unlikely their type would change as usually you define them inline.
			console.error(
				"%s received a final argument that is not an array (instead, received `%s`). When "
					.. "specified, the final argument must be an array.",
				currentHookNameInDev,
				type(deps)
			)
		end
	end
end

function warnOnHookMismatchInDev(currentHookName: HookType)
	if __DEV__ then
		-- deviation: getComponentName will return nil in most Hook cases, use same fallback as elsewhere
		local componentName = getComponentName(currentlyRenderingFiber.type) or "Component"
		if not didWarnAboutMismatchedHooksForComponent[componentName] then
			didWarnAboutMismatchedHooksForComponent[componentName] = true

			if hookTypesDev ~= nil then
				local table_ = ""

				local secondColumnStart = 30

				for i = 1, hookTypesUpdateIndexDev do
					local oldHookName = (hookTypesDev :: any)[i]
					local newHookName
					if i == hookTypesUpdateIndexDev then
						newHookName = currentHookName
					else
						newHookName = oldHookName
					end

					-- NOTE: upstream lets this be void and string concat coerces it to 'undefined'
					local row = tostring(i) .. ". " .. (oldHookName or "undefined")

					-- Extra space so second column lines up
					-- lol @ IE not supporting String#repeat
					while string.len(row) < secondColumnStart do
						row ..= " "
					end

					row ..= newHookName .. "\n"

					table_ ..= row
				end

				console.error(
					"React has detected a change in the order of Hooks called by %s. "
						.. "This will lead to bugs and errors if not fixed. "
						.. "For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n"
						.. "   Previous render            Next render\n"
						.. "   ------------------------------------------------------\n"
						.. "%s"
						.. "   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
					componentName,
					table_
				)
			end
		end
	end
end

local function throwInvalidHookError(): ()
	error(
		Error.new(
			"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
				.. " one of the following reasons:\n"
				.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
				.. "2. You might be breaking the Rules of Hooks\n"
				.. "3. You might have more than one copy of React in the same app\n"
				.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
		)
	)
end

-- FIXME (roblox): type refinement
-- prevDeps: Array<any>?
local function areHookInputsEqual(nextDeps: Array<any>, prevDeps: Array<any>)
	if __DEV__ then
		if ignorePreviousDependencies then
			-- Only true when this component is being hot reloaded.
			return false
		end
	end

	if prevDeps == nil then
		if __DEV__ then
			-- TODO: no unit tests in upstream for this, we should add some
			console.error(
				"%s received a final argument during this render, but not during "
					.. "the previous render. Even though the final argument is optional, "
					.. "its type cannot change between renders.",
				currentHookNameInDev
			)
		end
		return false
	end

	-- deviation START: calculate lengths with iteration instead of # to
	-- accommodate nil values and disable warning for differing lengths
	local nextDepsLength = getHighestIndex(nextDeps)
	local prevDepsLength = getHighestIndex(prevDeps)

	-- NOTE: In upstream, lengths aren't even compared unless dev mode is
	-- enabled because they _always_ indicate a misuse of dependency arrays. In
	-- luau, since trailing `nil`s effectively change the length of the array,
	-- it's possible to trigger this scenario with a valid use of the dependencies
	-- array (e.g. `{1, 2, 3}` -> `{1, 2, nil}`)
	if nextDepsLength ~= prevDepsLength then
		-- TODO: linting like upstream does would make this warning less
		-- necessary, and would help justify our exclusion of the warning.

		-- https://jira.rbx.com/browse/LUAFDN-1175
		-- if __DEV__ then
		--   console.error(
		--     "The final argument passed to %s changed size between renders. The " ..
		--       "order and size of this array must remain constant.\n\n" ..
		--       "Previous: %s\n" ..
		--       "Incoming: %s",
		--     currentHookNameInDev,
		--     inspect(prevDeps),
		--     inspect(nextDeps)
		--   )
		-- end

		-- Short-circuit here since we know that different lengths means a change in
		-- values, even if it's due to trailing nil values
		return false
	end
	-- deviation END

	local minDependencyCount = math.min(prevDepsLength, nextDepsLength)
	for i = 1, minDependencyCount do
		if is(nextDeps[i], prevDeps[i]) then
			continue
		end
		return false
	end
	return true
end

exports.bailoutHooks = function(current: Fiber, workInProgress: Fiber, lanes: Lanes)
	-- performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
	workInProgress.updateQueue = current.updateQueue
	if __DEV__ and enableDoubleInvokingEffects then
		workInProgress.flags = bit32.band(
			workInProgress.flags,
			bit32.bnot(bit32.bor(MountPassiveDevEffect, PassiveEffect, MountLayoutDevEffect, UpdateEffect))
		)
	else
		workInProgress.flags = bit32.band(workInProgress.flags, bit32.bnot(bit32.bor(PassiveEffect, UpdateEffect)))
	end
	current.lanes = removeLanes(current.lanes, lanes)
end

local _isUpdatingOpaqueValueInRenderPhase = false
exports.resetHooksAfterThrow = function(): ()
	-- We can assume the previous dispatcher is always this one, since we set it
	-- at the beginning of the render phase and there's no re-entrancy.
	ReactCurrentDispatcher.current = exports.ContextOnlyDispatcher

	if didScheduleRenderPhaseUpdate then
		-- There were render phase updates. These are only valid for this render
		-- phase, which we are now aborting. Remove the updates from the queues so
		-- they do not persist to the next render. Do not remove updates from hooks
		-- that weren't processed.
		--
		-- Only reset the updates from the queue if it has a clone. If it does
		-- not have a clone, that means it wasn't processed, and the updates were
		-- scheduled before we entered the render phase.
		-- FIXME (roblox): Better type refinement
		-- local hook: Hook | nil = currentlyRenderingFiber.memoizedState
		local hook: any = currentlyRenderingFiber.memoizedState
		while hook ~= nil do
			local queue = hook.queue
			if queue ~= nil then
				queue.pending = nil
			end
			hook = hook.next
		end
		didScheduleRenderPhaseUpdate = false
	end

	renderLanes = NoLanes
	currentlyRenderingFiber = nil :: any

	currentHook = nil
	workInProgressHook = nil

	if __DEV__ then
		hookTypesDev = nil
		hookTypesUpdateIndexDev = 0

		currentHookNameInDev = nil

		_isUpdatingOpaqueValueInRenderPhase = false
	end

	didScheduleRenderPhaseUpdateDuringThisPass = false
end

local function mountWorkInProgressHook(): Hook
	local hook: Hook = {
		memoizedState = nil,

		baseState = nil,
		baseQueue = nil,
		queue = nil,

		next = nil,
	}

	if workInProgressHook == nil then
		-- This is the first hook in the list
		currentlyRenderingFiber.memoizedState = hook
		workInProgressHook = hook
	else
		-- Append to the end of the list
		workInProgressHook.next = hook
		workInProgressHook = hook
	end
	return workInProgressHook
end

local function updateWorkInProgressHook(): Hook
	-- This function is used both for updates and for re-renders triggered by a
	-- render phase update. It assumes there is either a current hook we can
	-- clone, or a work-in-progress hook from a previous render pass that we can
	-- use as a base. When we reach the end of the base list, we must switch to
	-- the dispatcher used for mounts.
	-- FIXME (roblox): type refinement
	-- local nextCurrentHook: Hook?
	local nextCurrentHook
	if currentHook == nil then
		local current = currentlyRenderingFiber.alternate
		if current ~= nil then
			nextCurrentHook = current.memoizedState
		else
			nextCurrentHook = nil
		end
	else
		nextCurrentHook = currentHook.next
	end

	-- FIXME (roblox): type refinement
	-- local nextWorkInProgressHook: Hook?
	local nextWorkInProgressHook: Hook
	if workInProgressHook == nil then
		nextWorkInProgressHook = currentlyRenderingFiber.memoizedState
	else
		nextWorkInProgressHook = workInProgressHook.next
	end

	if nextWorkInProgressHook ~= nil then
		-- There's already a work-in-progress. Reuse it.
		workInProgressHook = nextWorkInProgressHook
		nextWorkInProgressHook = workInProgressHook.next

		currentHook = nextCurrentHook
	else
		-- Clone from the current hook.

		-- performance: use React 18 check to avoid function call overhead
		if nextCurrentHook == nil then
			error(Error.new("Rendered more hooks than during the previous render."))
		end

		currentHook = nextCurrentHook

		local newHook: Hook = {
			memoizedState = currentHook.memoizedState,

			baseState = currentHook.baseState,
			baseQueue = currentHook.baseQueue,
			queue = currentHook.queue,

			next = nil,
		}

		if workInProgressHook == nil then
			-- This is the first hook in the list.
			workInProgressHook = newHook
			currentlyRenderingFiber.memoizedState = newHook
		else
			-- Append to the end of the list.
			workInProgressHook.next = newHook
			workInProgressHook = newHook
		end
	end
	return workInProgressHook
end

-- performance: inlined in hot path
-- local function createFunctionComponentUpdateQueue(): FunctionComponentUpdateQueue
--   return {
--     lastEffect = nil,
--   }
-- end

function basicStateReducer<S>(state: S, action: BasicStateAction<S>): S
	-- $FlowFixMe: Flow doesn't like mixed types
	if type(action) == "function" then
		return action(state)
	else
		return action
	end
end

function mountReducer<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
	local hook = mountWorkInProgressHook()
	local initialState
	if init ~= nil then
		initialState = init(initialArg)
	else
		initialState = (initialArg :: any) :: S
	end
	hook.baseState = initialState
	hook.memoizedState = hook.baseState

	local queue: UpdateQueue<S, A> = {
		pending = nil,
		dispatch = nil,
		lastRenderedReducer = reducer,
		lastRenderedState = initialState :: any,
	}
	hook.queue = queue

	-- deviation: set currentlyRenderingFiber to a local varible so it doesn't change
	-- by call time
	local cRF = currentlyRenderingFiber
	-- FIXME? we pass in action here, but is that what really happens upstream?
	local dispatch: Dispatch<A> = function(action, ...)
		-- FIXME Luau: relies on normalization
		dispatchAction(cRF, queue :: UpdateQueue<any, any>, action, ...)
	end :: any
	queue.dispatch = dispatch :: any
	-- deviation START: Lua version of useState and useReducer return two items, not list like upstream
	return hook.memoizedState, dispatch
	-- deviation END: Lua version of useState and useReducer return two items, not list like upstream
end

function updateReducer<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
	local hook = updateWorkInProgressHook()
	local queue = hook.queue
	-- deviation: change from invariant to avoid funtion call in hot path
	assert(queue ~= nil, "Should have a queue. This is likely a bug in React. Please file an issue.")

	queue.lastRenderedReducer = reducer

	local current: Hook = currentHook

	-- The last rebase update that is NOT part of the base state.
	local baseQueue = current.baseQueue

	-- The last pending update that hasn't been processed yet.
	local pendingQueue = queue.pending
	if pendingQueue ~= nil then
		-- We have new updates that haven't been processed yet.
		-- We'll add them to the base queue.
		if baseQueue ~= nil then
			-- Merge the pending queue and the base queue.
			local baseFirst = baseQueue.next
			local pendingFirst = pendingQueue.next
			baseQueue.next = pendingFirst
			pendingQueue.next = baseFirst
		end
		-- performance: elimiante cmp in hot path
		-- if __DEV__ then
		--   if current.baseQueue ~= baseQueue then
		--     -- Internal invariant that should never happen, but feasibly could in
		--     -- the future if we implement resuming, or some form of that.
		--     console.error(
		--       'Internal error: Expected work-in-progress queue to be a clone. ' ..
		--         'This is a bug in React.'
		--     )
		--   end
		-- end
		baseQueue = pendingQueue
		current.baseQueue = baseQueue
		queue.pending = nil
	end

	if baseQueue ~= nil then
		-- We have a queue to process.
		local first = baseQueue.next
		local newState = current.baseState

		local newBaseState = nil
		local newBaseQueueFirst = nil
		local newBaseQueueLast = nil
		local update = first
		repeat
			local updateLane = update.lane
			-- performance: inline isSubsetOfLanes for hot path
			-- if not isSubsetOfLanes(renderLanes, updateLane) then
			if bit32.band(renderLanes, updateLane) ~= updateLane then
				-- Priority is insufficient. Skip this update. If this is the first
				-- skipped update, the previous update/state is the new base
				-- update/state.
				local clone: Update<S, A> = {
					lane = updateLane,
					action = update.action,
					eagerReducer = update.eagerReducer,
					eagerState = update.eagerState,
					next = nil :: any,
				}
				if newBaseQueueLast == nil then
					newBaseQueueLast = clone
					newBaseQueueFirst = newBaseQueueLast
					newBaseState = newState
				else
					newBaseQueueLast.next = clone
					newBaseQueueLast = newBaseQueueLast.next
				end
				-- Update the remaining priority in the queue.
				-- TODO: Don't need to accumulate this. Instead, we can remove
				-- renderLanes from the original lanes.
				currentlyRenderingFiber.lanes = mergeLanes(currentlyRenderingFiber.lanes, updateLane)
				markSkippedUpdateLanes(updateLane)
			else
				-- This update does have sufficient priority.

				if newBaseQueueLast ~= nil then
					local clone: Update<S, A> = {
						-- This update is going to be committed so we never want uncommit
						-- it. Using NoLane works because 0 is a subset of all bitmasks, so
						-- this will never be skipped by the check above.
						lane = NoLane,
						action = update.action,
						eagerReducer = update.eagerReducer,
						eagerState = update.eagerState,
						next = nil :: any,
					}
					newBaseQueueLast.next = clone
					newBaseQueueLast = newBaseQueueLast.next
				end

				-- Process this update.
				if update.eagerReducer == reducer then
					-- If this update was processed eagerly, and its reducer matches the
					-- current reducer, we can use the eagerly computed state.
					newState = update.eagerState
				else
					local action = update.action
					newState = reducer(newState, action)
				end
			end
			update = update.next
		until update == nil or update == first

		if newBaseQueueLast == nil then
			newBaseState = newState
		else
			newBaseQueueLast.next = newBaseQueueFirst
		end

		-- Mark that the fiber performed work, but only if the new state is
		-- different from the current state.
		if not is(newState, hook.memoizedState) then
			markWorkInProgressReceivedUpdate()
		end

		hook.memoizedState = newState
		hook.baseState = newBaseState
		hook.baseQueue = newBaseQueueLast

		queue.lastRenderedState = newState
	end

	local dispatch: Dispatch<A> = queue.dispatch :: any
	-- deviation: Lua version of useState and useReducer return two items, not list like upstream
	return hook.memoizedState, dispatch
end

function rerenderReducer<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
	local hook = updateWorkInProgressHook()
	local queue = hook.queue
	-- performance: changed from invariant to avoid function call in hot path
	assert(queue ~= nil, "Should have a queue. This is likely a bug in React. Please file an issue.")

	queue.lastRenderedReducer = reducer

	-- This is a re-render. Apply the new render phase updates to the previous
	-- work-in-progress hook.
	local dispatch: Dispatch<A> = queue.dispatch :: Dispatch<A>
	local lastRenderPhaseUpdate = queue.pending
	local newState = hook.memoizedState
	if lastRenderPhaseUpdate ~= nil then
		-- The queue doesn't persist past this render pass.
		queue.pending = nil

		local firstRenderPhaseUpdate = lastRenderPhaseUpdate.next
		local update = firstRenderPhaseUpdate
		repeat
			-- Process this render phase update. We don't have to check the
			-- priority because it will always be the same as the current
			-- render's.
			local action = update.action
			newState = reducer(newState, action)
			update = update.next
		until update == firstRenderPhaseUpdate

		-- Mark that the fiber performed work, but only if the new state is
		-- different from the current state.
		if not is(newState, hook.memoizedState) then
			markWorkInProgressReceivedUpdate()
		end

		hook.memoizedState = newState
		-- Don't persist the state accumulated from the render phase updates to
		-- the base state unless the queue is empty.
		-- TODO: Not sure if this is the desired semantics, but it's what we
		-- do for gDSFP. I can't remember why.
		if hook.baseQueue == nil then
			hook.baseState = newState
		end

		queue.lastRenderedState = newState
	end
	-- deviation: Lua version returns two values instead of an array
	return newState, dispatch
end

type MutableSourceMemoizedState<Source, Snapshot> = {
	refs: {
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		setSnapshot: (Snapshot) -> (),
	},
	source: MutableSource<any>,
	subscribe: MutableSourceSubscribeFn<Source, Snapshot>,
}

function readFromUnsubcribedMutableSource<Source, Snapshot>(
	root: FiberRoot,
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>
): Snapshot
	if __DEV__ then
		warnAboutMultipleRenderersDEV(source)
	end

	local getVersion = source._getVersion
	local version_ = getVersion(source._source)

	-- Is it safe for this component to read from this source during the current render?
	local isSafeToReadFromSource = false

	-- Check the version first.
	-- If this render has already been started with a specific version,
	-- we can use it alone to determine if we can safely read from the source.
	local currentRenderVersion = getWorkInProgressVersion(source)
	if currentRenderVersion ~= nil then
		-- It's safe to read if the store hasn't been mutated since the last time
		-- we read something.
		isSafeToReadFromSource = currentRenderVersion == version_
	else
		-- If there's no version, then this is the first time we've read from the
		-- source during the current render pass, so we need to do a bit more work.
		-- What we need to determine is if there are any hooks that already
		-- subscribed to the source, and if so, whether there are any pending
		-- mutations that haven't been synchronized yet.
		--
		-- If there are no pending mutations, then `root.mutableReadLanes` will be
		-- empty, and we know we can safely read.
		--
		-- If there *are* pending mutations, we may still be able to safely read
		-- if the currently rendering lanes are inclusive of the pending mutation
		-- lanes, since that guarantees that the value we're about to read from
		-- the source is consistent with the values that we read during the most
		-- recent mutation.
		isSafeToReadFromSource = isSubsetOfLanes(renderLanes, root.mutableReadLanes)

		if isSafeToReadFromSource then
			-- If it's safe to read from this source during the current render,
			-- store the version in case other components read from it.
			-- A changed version number will local those components know to throw and restart the render.
			setWorkInProgressVersion(source, version_)
		end
	end

	if isSafeToReadFromSource then
		local snapshot = getSnapshot(source._source)
		if __DEV__ then
			-- deviation: the Snapshot generic isn't constrained upstream, but it as to be for this typeof() to work
			if type(snapshot :: any) == "function" then
				console.error(
					"Mutable source should not return a function as the snapshot value. "
						.. "Functions may close over mutable values and cause tearing."
				)
			end
		end
		return snapshot
	else
		-- This handles the special case of a mutable source being shared between renderers.
		-- In that case, if the source is mutated between the first and second renderer,
		-- The second renderer don't know that it needs to reset the WIP version during unwind,
		-- (because the hook only marks sources as dirty if it's written to their WIP version).
		-- That would cause this tear check to throw again and eventually be visible to the user.
		-- We can avoid this infinite loop by explicitly marking the source as dirty.
		--
		-- This can lead to tearing in the first renderer when it resumes,
		-- but there's nothing we can do about that (short of throwing here and refusing to continue the render).
		markSourceAsDirty(source)

		error(
			Error.new(
				"Cannot read from mutable source during the current render without tearing. This is a bug in React. Please file an issue."
			)
		)
	end
end

function useMutableSource<Source, Snapshot>(
	hook: Hook,
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
	subscribe: MutableSourceSubscribeFn<Source, Snapshot>
): Snapshot
	local root: FiberRoot = getWorkInProgressRoot()
	invariant(root ~= nil, "Expected a work-in-progress root. This is a bug in React. Please file an issue.")

	local getVersion = source._getVersion
	local version_ = getVersion(source._source)

	local dispatcher = ReactCurrentDispatcher.current
	-- deviation: upstream doesn't assert non-nil, but we have to for type soundness
	assert(dispatcher ~= nil, "dispatcher was nil, this is a bug in React")
	-- eslint-disable-next-line prefer-const
	local currentSnapshot, setSnapshot = dispatcher.useState(function()
		return readFromUnsubcribedMutableSource(root, source, getSnapshot)
	end)
	local snapshot = currentSnapshot

	-- Grab a handle to the state hook as well.
	-- We use it to clear the pending update queue if we have a new source.

	-- TODO: recast local stateHook = ((workInProgressHook: any): Hook)
	local stateHook = workInProgressHook

	local memoizedState: MutableSourceMemoizedState<any, any> = hook.memoizedState
	if memoizedState.refs == nil then
		error(tostring(debug.traceback()))
	end
	local refs = memoizedState.refs
	local prevGetSnapshot = refs.getSnapshot
	local prevSource = memoizedState.source
	local prevSubscribe = memoizedState.subscribe

	local fiber = currentlyRenderingFiber

	hook.memoizedState = {
		refs = refs,
		source = source,
		subscribe = subscribe,
	}

	-- Sync the values needed by our subscription handler after each commit.
	dispatcher.useEffect(function()
		refs.getSnapshot = getSnapshot

		-- Normally the dispatch function for a state hook never changes,
		-- but this hook recreates the queue in certain cases  to avoid updates from stale sources.
		-- handleChange() below needs to reference the dispatch function without re-subscribing,
		-- so we use a ref to ensure that it always has the latest version.
		refs.setSnapshot = setSnapshot

		-- Check for a possible change between when we last rendered now.
		local maybeNewVersion = getVersion(source._source)
		if not is(version_, maybeNewVersion) then
			local maybeNewSnapshot = getSnapshot(source._source)
			if __DEV__ then
				-- deviation: the Snapshot generic isn't constrained upstream, but it as to be for this typeof() to work
				if type(maybeNewSnapshot :: any) == "function" then
					console.error(
						"Mutable source should not return a function as the snapshot value. "
							.. "Functions may close over mutable values and cause tearing."
					)
				end
			end

			if not is(snapshot, maybeNewSnapshot) then
				setSnapshot(maybeNewSnapshot)

				local lane = requestUpdateLane(fiber)
				markRootMutableRead(root, lane)
			end
			-- If the source mutated between render and now,
			-- there may be state updates already scheduled from the old source.
			-- Entangle the updates so that they render in the same batch.
			markRootEntangled(root, root.mutableReadLanes)
		end
		-- FIXME Luau: Luau doesn't support mixed arrays
	end, { getSnapshot, source, subscribe } :: Array<any>)

	-- If we got a new source or subscribe function, re-subscribe in a passive effect.
	dispatcher.useEffect(function()
		local handleChange = function()
			local latestGetSnapshot = refs.getSnapshot
			local latestSetSnapshot = refs.setSnapshot

			-- performance? only latestGet..() is throwable. hoist the rest out to eliminate anon func overhead?
			local ok, result = pcall(function()
				latestSetSnapshot(latestGetSnapshot(source._source))

				-- Record a pending mutable source update with the same expiration time.
				local lane = requestUpdateLane(fiber)

				markRootMutableRead(root, lane)
			end)

			if not ok then
				-- A selector might throw after a source mutation.
				-- e.g. it might try to read from a part of the store that no longer exists.
				-- In this case we should still schedule an update with React.
				-- Worst case the selector will throw again and then an error boundary will handle it.
				latestSetSnapshot(function()
					error(result)
				end)
			end
		end

		local unsubscribe = subscribe(source._source, handleChange)
		if __DEV__ then
			if type(unsubscribe) ~= "function" then
				console.error("Mutable source subscribe function must return an unsubscribe function.")
			end
		end

		return unsubscribe
		-- FIXME Luau: Luau doesn't support mixed arrays
	end, { source, subscribe } :: Array<any>)

	-- If any of the inputs to useMutableSource change, reading is potentially unsafe.
	--
	-- If either the source or the subscription have changed we can't can't trust the update queue.
	-- Maybe the source changed in a way that the old subscription ignored but the new one depends on.
	--
	-- If the getSnapshot function changed, we also shouldn't rely on the update queue.
	-- It's possible that the underlying source was mutated between the when the last "change" event fired,
	-- and when the current render (with the new getSnapshot function) is processed.
	--
	-- In both cases, we need to throw away pending updates (since they are no longer relevant)
	-- and treat reading from the source as we do in the mount case.
	if not is(prevGetSnapshot, getSnapshot) or not is(prevSource, source) or not is(prevSubscribe, subscribe) then
		-- Create a new queue and setState method,
		-- So if there are interleaved updates, they get pushed to the older queue.
		-- When this becomes current, the previous queue and dispatch method will be discarded,
		-- including any interleaving updates that occur.
		local newQueue = {
			pending = nil,
			dispatch = nil,
			lastRenderedReducer = basicStateReducer,
			lastRenderedState = snapshot,
		}

		-- deviation: keep local pointer so if global changes we maintain correct reference.
		local cRF = currentlyRenderingFiber

		setSnapshot = function(...)
			dispatchAction(cRF, newQueue, ...)
		end :: any
		newQueue.dispatch = setSnapshot :: any
		stateHook.queue = newQueue
		stateHook.baseQueue = nil
		snapshot = readFromUnsubcribedMutableSource(root, source, getSnapshot)
		stateHook.baseState = snapshot
		stateHook.memoizedState = stateHook.baseState
	end

	return snapshot
end

function mountMutableSource<Source, Snapshot>(
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
	subscribe: MutableSourceSubscribeFn<Source, Snapshot>
): Snapshot
	local hook = mountWorkInProgressHook()
	hook.memoizedState = {
		refs = {
			getSnapshot = getSnapshot,
			setSnapshot = nil,
		},
		source = source,
		subscribe = subscribe,
	}
	return useMutableSource(hook, source, getSnapshot, subscribe)
end

function updateMutableSource<Source, Snapshot>(
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
	subscribe: MutableSourceSubscribeFn<Source, Snapshot>
): Snapshot
	local hook = updateWorkInProgressHook()
	return useMutableSource(hook, source, getSnapshot, subscribe)
end

function mountState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	local hook = mountWorkInProgressHook()
	if type(initialState) == "function" then
		-- $FlowFixMe: Flow doesn't like mixed types
		-- deviation: workaround to silence cli analyze not understanding that we've already verified initialState is a function
		local initialStateAsFunction: () -> S = initialState
		initialState = initialStateAsFunction()
	end
	hook.baseState = initialState
	hook.memoizedState = hook.baseState
	local queue: UpdateQueue<S, BasicStateAction<S>> = {
		pending = nil,
		dispatch = nil,
		lastRenderedReducer = nil, --basicStateReducer,
		lastRenderedState = initialState :: any,
	}
	-- FIXME Luau: work around a toposorting issue in Luau: CLI-48752
	queue.lastRenderedReducer = basicStateReducer
	hook.queue = queue

	-- deviation: set currentlyRenderingFiber to a local varible so it doesn't change by call time
	local cRF = currentlyRenderingFiber
	local dispatch: Dispatch<BasicStateAction<S>> = function(action, ...)
		-- FIXME? we pass in action here, but is that what really happens upstream?
		dispatchAction(cRF, queue :: UpdateQueue<any, any>, action, ...)
	end :: any
	queue.dispatch = dispatch
	-- deviation: Lua version of useState and useReducer return two items, not list like upstream
	return hook.memoizedState, dispatch
end

function updateState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	return updateReducer(basicStateReducer, initialState)
end

function rerenderState<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
	return rerenderReducer(basicStateReducer, initialState)
end

local function pushEffect(tag, create, destroy, deps)
	local effect: Effect = {
		tag = tag,
		create = create,
		destroy = destroy,
		deps = deps,
		-- Circular
		next = nil :: any,
	}
	local componentUpdateQueue: FunctionComponentUpdateQueue = currentlyRenderingFiber.updateQueue :: any
	if componentUpdateQueue == nil then
		-- performance: inline simple function in hot path
		-- componentUpdateQueue = createFunctionComponentUpdateQueue()
		componentUpdateQueue = {
			lastEffect = nil,
		}
		currentlyRenderingFiber.updateQueue = componentUpdateQueue
		effect.next = effect
		componentUpdateQueue.lastEffect = effect
	else
		local lastEffect = componentUpdateQueue.lastEffect
		if lastEffect == nil then
			componentUpdateQueue.lastEffect = effect
			effect.next = effect
		else
			local firstEffect = lastEffect.next
			lastEffect.next = effect
			effect.next = firstEffect
			componentUpdateQueue.lastEffect = effect
		end
	end
	return effect
end

-- deviation: Bindings are a feature unique to Roact
function mountBinding<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
	local hook = mountWorkInProgressHook()
	local value, updateValue = createBinding(initialValue)

	-- FIXME Luau: Luau doesn't allow mixed arrays, forcing us to use any here
	hook.memoizedState = { value :: any, updateValue :: any }
	return value, updateValue
end

-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
function updateBinding<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
	local hook = updateWorkInProgressHook()
	return unpack(hook.memoizedState)
end

-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
function mountRef<T>(initialValue: T): { current: T | nil }
	local hook = mountWorkInProgressHook()
	-- deviation: Implement useRef with bindings
	local ref: any = createRef()
	ref.current = initialValue
	-- if (__DEV__) then
	--   Object.seal(ref)
	-- end
	hook.memoizedState = ref
	return ref :: { current: T | nil }
end

-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
function updateRef<T>(initialValue: T): { current: T | nil }
	local hook = updateWorkInProgressHook()
	return hook.memoizedState
end

local function mountEffectImpl(fiberFlags, hookFlags, create, deps): ()
	local hook = mountWorkInProgressHook()
	-- deviation: no need to account for undefined
	-- local nextDeps = deps == undefined ? nil : deps
	local nextDeps = deps
	currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags, fiberFlags)

	hook.memoizedState = pushEffect(bit32.bor(HookHasEffect, hookFlags), create, nil, nextDeps)
end

-- deviation START: must explicitly mark deps argument as optional/nil-able
function updateEffectImpl(fiberFlags, hookFlags, create, deps: Array<any>?): ()
	-- deviation END
	local hook = updateWorkInProgressHook()
	-- deviation: no need to account for undefined
	-- local nextDeps = deps == undefined ? nil : deps
	local nextDeps = deps
	local destroy

	if currentHook ~= nil then
		local prevEffect = currentHook.memoizedState
		destroy = prevEffect.destroy
		if nextDeps ~= nil then
			local prevDeps = prevEffect.deps
			if areHookInputsEqual(nextDeps, prevDeps) then
				hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps)
				return
			end
		end
	end

	currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags, fiberFlags)

	hook.memoizedState = pushEffect(bit32.bor(HookHasEffect, hookFlags), create, destroy, nextDeps)
end

local function mountEffect(
	-- TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	if __DEV__ then
		-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ as well as jest
		-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
		if type(_G.jest) ~= "nil" or _G.__TESTEZ_RUNNING_TEST__ then
			warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber)
		end
	end

	if __DEV__ and enableDoubleInvokingEffects then
		mountEffectImpl(bit32.bor(MountPassiveDevEffect, PassiveEffect, PassiveStaticEffect), HookPassive, create, deps)
	else
		mountEffectImpl(bit32.bor(PassiveEffect, PassiveStaticEffect), HookPassive, create, deps)
	end
end

local function updateEffect(
	-- TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	if __DEV__ then
		-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ in addition to jest
		-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
		if type(_G.jest) ~= "nil" or _G.__TESTEZ_RUNNING_TEST__ then
			warnIfNotCurrentlyActingEffectsInDEV(currentlyRenderingFiber)
		end
	end
	updateEffectImpl(PassiveEffect, HookPassive, create, deps)
end

local function mountLayoutEffect(
	-- TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	if __DEV__ and enableDoubleInvokingEffects then
		mountEffectImpl(bit32.bor(MountLayoutDevEffect, UpdateEffect), HookLayout, create, deps)
	else
		mountEffectImpl(UpdateEffect, HookLayout, create, deps)
	end
end

local function updateLayoutEffect(
	-- TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any>?
): ()
	updateEffectImpl(UpdateEffect, HookLayout, create, deps)
end

function imperativeHandleEffect<T>(
	create: () -> T,
	ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil
	-- deviation: explicit type annotation needed due to mixed return
): nil | () -> ...any
	if ref ~= nil and type(ref) == "function" then
		local refCallback = ref
		local inst = create()
		refCallback(inst)
		return function()
			return refCallback(nil)
		end
	elseif ref ~= nil then
		local refObject = ref :: any
		-- deviation: can't check for key presence because nil is a legitimate value.
		if __DEV__ then
			-- FIXME: This is a clumsy approximation, since we don't have any
			-- explicit way to know that something is a ref object; instead, we check
			-- that it's an empty object with a metatable, which is what Roact refs
			-- look like since they indirect to bindings via their metatable
			local isRefObject = getmetatable(refObject) ~= nil and #Object.keys(refObject) == 0
			if not isRefObject then
				console.error(
					"Expected useImperativeHandle() first argument to either be a "
						.. "ref callback or React.createRef() object. Instead received: %s.",
					"an object with keys {" .. Array.join(Object.keys(refObject), ", ") .. "}"
				)
			end
		end
		local inst = create()
		refObject.current = inst
		return function()
			refObject.current = nil
		end
	-- deviation: explicit return to silence analyze
	else
		return nil
	end
end

function mountImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	if __DEV__ then
		if type(create) ~= "function" then
			console.error(
				"Expected useImperativeHandle() second argument to be a function "
					.. "that creates a handle. Instead received: %s.",
				-- deviation START: nil instead of null
				if create ~= nil then type(create) else "nil"
				-- deviation END
			)
		end
	end
	-- TODO: If deps are provided, should we skip comparing the ref itself?
	local effectDeps = if deps ~= nil then Array.concat(deps, { ref }) else nil

	if __DEV__ and enableDoubleInvokingEffects then
		return mountEffectImpl(bit32.bor(MountLayoutDevEffect, UpdateEffect), HookLayout, function()
			return imperativeHandleEffect(create, ref)
		end, effectDeps)
	else
		return mountEffectImpl(UpdateEffect, HookLayout, function()
			return imperativeHandleEffect(create, ref)
		end, effectDeps)
	end
end

function updateImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	if __DEV__ then
		if type(create) ~= "function" then
			local errorArg = "nil"
			if create then
				errorArg = type(create)
			end
			console.error(
				"Expected useImperativeHandle() second argument to be a function "
					.. "that creates a handle. Instead received: %s.",
				errorArg
			)
		end
	end

	-- TODO: If deps are provided, should we skip comparing the ref itself?
	-- deviation: ternary turned to explicit if/else
	local effectDeps
	if deps ~= nil then
		effectDeps = table.clone(deps)
		table.insert(effectDeps, ref)
	end

	return updateEffectImpl(UpdateEffect, HookLayout, function()
		return imperativeHandleEffect(create, ref)
	end, effectDeps)
end

function mountDebugValue<T>(value: T, formatterFn: nil | (T) -> any): ()
	-- This hook is normally a no-op.
	-- The react-debug-hooks package injects its own implementation
	-- so that e.g. DevTools can display custom hook values.
end

local updateDebugValue = mountDebugValue

function mountCallback<T>(callback: T, deps: Array<any> | nil): T
	local hook = mountWorkInProgressHook()
	local nextDeps = deps
	-- FIXME Luau: Luau doesn't allow mixed arrays, forcing us to use any here
	hook.memoizedState = { callback :: any, nextDeps :: any }
	return callback
end

function updateCallback<T>(callback: T, deps: Array<any> | nil): T
	local hook = updateWorkInProgressHook()
	local nextDeps = deps
	local prevState = hook.memoizedState
	if prevState ~= nil then
		if nextDeps ~= nil then
			-- TODO: Luau false positive when this is `Array<any>?` (E001) Type 'Array<any>?' could not be converted into 'Array<any>'
			local prevDeps: Array<any> = prevState[2]
			if areHookInputsEqual(nextDeps, prevDeps) then
				return prevState[1]
			end
		end
	end
	-- FIXME Luau: Luau doesn't allow mixed arrays, forcing us to use any here
	hook.memoizedState = { callback :: any, nextDeps :: any }
	return callback
end

-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
function mountMemo<T...>(nextCreate: () -> T..., deps: Array<any> | nil): ...any
	local hook = mountWorkInProgressHook()

	-- deviation: equivilant to upstream ternary logic
	local nextDeps = deps
	-- deviation: Wrap memoized values in a table and unpack to allow for multiple return values
	local nextValue = { nextCreate() }
	hook.memoizedState = { nextValue :: any, nextDeps }
	return unpack(nextValue)
end

-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
function updateMemo<T...>(nextCreate: () -> T..., deps: Array<any> | nil): ...any
	local hook = updateWorkInProgressHook()
	-- deviation: equivilant to upstream ternary logic
	local nextDeps = deps
	local prevState = hook.memoizedState
	if prevState ~= nil then
		-- Assume these are defined. If they're not, areHookInputsEqual will warn.
		if nextDeps ~= nil then
			local prevDeps: Array<any> = prevState[2]
			if areHookInputsEqual(nextDeps, prevDeps) then
				return unpack(prevState[1])
			end
		end
	end
	-- deviation: Wrap memoized values in a table and unpack to allow for multiple return values
	local nextValue = { nextCreate() }
	hook.memoizedState = { nextValue :: any, nextDeps }
	return unpack(nextValue)
end

-- function mountDeferredValue<T>(value: T): T {
--   local [prevValue, setValue] = mountState(value)
--   mountEffect(() => {
--     local prevTransition = ReactCurrentBatchConfig.transition
--     ReactCurrentBatchConfig.transition = 1
--     try {
--       setValue(value)
--     } finally {
--       ReactCurrentBatchConfig.transition = prevTransition
--     end
--   }, [value])
--   return prevValue
-- end

-- function updateDeferredValue<T>(value: T): T {
--   local [prevValue, setValue] = updateState(value)
--   updateEffect(() => {
--     local prevTransition = ReactCurrentBatchConfig.transition
--     ReactCurrentBatchConfig.transition = 1
--     try {
--       setValue(value)
--     } finally {
--       ReactCurrentBatchConfig.transition = prevTransition
--     end
--   }, [value])
--   return prevValue
-- end

-- function rerenderDeferredValue<T>(value: T): T {
--   local [prevValue, setValue] = rerenderState(value)
--   updateEffect(() => {
--     local prevTransition = ReactCurrentBatchConfig.transition
--     ReactCurrentBatchConfig.transition = 1
--     try {
--       setValue(value)
--     } finally {
--       ReactCurrentBatchConfig.transition = prevTransition
--     end
--   }, [value])
--   return prevValue
-- end

-- function startTransition(setPending, callback)
--   local priorityLevel = getCurrentPriorityLevel()
--   if decoupleUpdatePriorityFromScheduler)
--     local previousLanePriority = getCurrentUpdateLanePriority()
--     setCurrentUpdateLanePriority(
--       higherLanePriority(previousLanePriority, InputContinuousLanePriority),
--     )

--     runWithPriority(
--       priorityLevel < UserBlockingPriority
--         ? UserBlockingPriority
--         : priorityLevel,
--       () => {
--         setPending(true)
--       },
--     )

--     -- TODO: Can remove this. Was only necessary because we used to give
--     -- different behavior to transitions without a config object. Now they are
--     -- all treated the same.
--     setCurrentUpdateLanePriority(DefaultLanePriority)

--     runWithPriority(
--       priorityLevel > NormalPriority ? NormalPriority : priorityLevel,
--       () => {
--         local prevTransition = ReactCurrentBatchConfig.transition
--         ReactCurrentBatchConfig.transition = 1
--         try {
--           setPending(false)
--           callback()
--         } finally {
--           if decoupleUpdatePriorityFromScheduler)
--             setCurrentUpdateLanePriority(previousLanePriority)
--           end
--           ReactCurrentBatchConfig.transition = prevTransition
--         end
--       },
--     )
--   } else {
--     runWithPriority(
--       priorityLevel < UserBlockingPriority
--         ? UserBlockingPriority
--         : priorityLevel,
--       () => {
--         setPending(true)
--       },
--     )

--     runWithPriority(
--       priorityLevel > NormalPriority ? NormalPriority : priorityLevel,
--       () => {
--         local prevTransition = ReactCurrentBatchConfig.transition
--         ReactCurrentBatchConfig.transition = 1
--         try {
--           setPending(false)
--           callback()
--         } finally {
--           ReactCurrentBatchConfig.transition = prevTransition
--         end
--       },
--     )
--   end
-- end

-- function mountTransition(): [(() => void) => void, boolean] {
--   local [isPending, setPending] = mountState(false)
--   -- The `start` method can be stored on a ref, since `setPending`
--   -- never changes.
--   local start = startTransition.bind(null, setPending)
--   mountRef(start)
--   return [start, isPending]
-- end

-- function updateTransition(): [(() => void) => void, boolean] {
--   local [isPending] = updateState(false)
--   local startRef = updateRef()
--   local start: (() => void) => void = (startRef.current: any)
--   return [start, isPending]
-- end

-- function rerenderTransition(): [(() => void) => void, boolean] {
--   local [isPending] = rerenderState(false)
--   local startRef = updateRef()
--   local start: (() => void) => void = (startRef.current: any)
--   return [start, isPending]
-- end

local isUpdatingOpaqueValueInRenderPhase = false
exports.getIsUpdatingOpaqueValueInRenderPhaseInDEV = function(): boolean?
	if __DEV__ then
		return isUpdatingOpaqueValueInRenderPhase
	end
	return nil
end

-- function warnOnOpaqueIdentifierAccessInDEV(fiber)
--   if __DEV__ then
--     -- TODO: Should warn in effects and callbacks, too
--     local name = getComponentName(fiber.type) or 'Unknown'
--     if getIsRendering() and not didWarnAboutUseOpaqueIdentifier[name] then
--       console.error(
--         'The object passed back from useOpaqueIdentifier is meant to be ' ..
--           'passed through to attributes only. Do not read the ' ..
--           'value directly.'
--       )
--       didWarnAboutUseOpaqueIdentifier[name] = true
--     end
--   end
-- end

function mountOpaqueIdentifier()
	local makeId
	if __DEV__ then
		console.warn("!!! unimplemented: warnOnOpaqueIdentifierAccessInDEV")
	-- makeId = makeClientIdInDEV.bind(
	--     nil,
	--     warnOnOpaqueIdentifierAccessInDEV.bind(null, currentlyRenderingFiber),
	--   )
	else
		makeId = makeClientId
	end

	if getIsHydrating() then
		unimplemented("ReactFiberHooks: getIsHydrating() true")
		return nil
	--   local didUpgrade = false
	--   local fiber = currentlyRenderingFiber
	--   local readValue = function()
	--     if not didUpgrade then
	--       -- Only upgrade once. This works even inside the render phase because
	--       -- the update is added to a shared queue, which outlasts the
	--       -- in-progress render.
	--       didUpgrade = true
	--       if __DEV__ then
	--         isUpdatingOpaqueValueInRenderPhase = true
	--         setId(makeId())
	--         isUpdatingOpaqueValueInRenderPhase = false
	--         warnOnOpaqueIdentifierAccessInDEV(fiber)
	--       else
	--         setId(makeId())
	--       end
	--     end
	--     invariant(
	--       false,
	--       'The object passed back from useOpaqueIdentifier is meant to be ' ..
	--         'passed through to attributes only. Do not read the value directly.'
	--     )
	--   end
	--   local id = makeOpaqueHydratingObject(readValue)

	--   local setId = mountState(id)[1]

	--   if bit32.band(currentlyRenderingFiber.mode, ReactTypeOfMode.BlockingMode) == ReactTypeOfMode.NoMode then
	--     if __DEV__ and enableDoubleInvokingEffects then
	--       currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags,
	--         MountPassiveDevEffect, PassiveEffect, PassiveStaticEffect)
	--     else
	--       currentlyRenderingFiber.flags = bit32.bor(currentlyRenderingFiber.flags,
	-- 				PassiveEffect, PassiveStaticEffect)
	--     end
	--     pushEffect(
	--       bit32.bor(HookHasEffect, HookPassive),
	--       function()
	--         setId(makeId())
	-- 			end,
	--       nil,
	--       nil
	--     )
	--   end
	--   return id
	else
		local id = makeId()
		mountState(id)
		return id
	end
end

function updateOpaqueIdentifier(): OpaqueIDType
	local id, _ = updateState(nil)
	return id
end

function rerenderOpaqueIdentifier(): OpaqueIDType
	local id, _ = rerenderState(nil)
	return id
end

function dispatchAction<S, A>(fiber: Fiber, queue: UpdateQueue<S, A>, action: A, ...): ()
	if __DEV__ then
		local childrenLength = select("#", ...)
		local extraArg
		if childrenLength == 1 then
			extraArg = select(1, ...)
		end
		if type(extraArg) == "function" then
			console.error(
				"State updates from the useState() and useReducer() Hooks don't support the "
					.. "second callback argument. To execute a side effect after "
					.. "rendering, declare it in the component body with useEffect()."
			)
		end
	end

	local eventTime = requestEventTime()
	local lane = requestUpdateLane(fiber)

	local update: Update<S, A> = {
		lane = lane,
		action = action,
		eagerReducer = nil,
		eagerState = nil,
		next = nil :: any,
	}

	-- Append the update to the end of the list.
	local pending = queue.pending
	if pending == nil then
		-- This is the first update. Create a circular list.
		update.next = update
	else
		update.next = pending.next
		pending.next = update
	end
	queue.pending = update

	local alternate = fiber.alternate
	if fiber == currentlyRenderingFiber or (alternate ~= nil and alternate == currentlyRenderingFiber) then
		-- This is a render phase update. Stash it in a lazily-created map of
		-- queue -> linked list of updates. After this render pass, we'll restart
		-- and apply the stashed updates on top of the work-in-progress hook.
		didScheduleRenderPhaseUpdate = true
		didScheduleRenderPhaseUpdateDuringThisPass = true
	else
		if fiber.lanes == NoLanes and (alternate == nil or alternate.lanes == NoLanes) then
			-- The queue is currently empty, which means we can eagerly compute the
			-- next state before entering the render phase. If the new state is the
			-- same as the current state, we may be able to bail out entirely.
			local lastRenderedReducer = queue.lastRenderedReducer
			if lastRenderedReducer ~= nil then
				local prevDispatcher
				if __DEV__ then
					prevDispatcher = ReactCurrentDispatcher.current
					ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
				end
				-- try
				local currentState: S = queue.lastRenderedState :: any
				-- performance: only wrap the thing that can throw in a pcall to elimiante anon function creation overhead
				local ok, eagerState = pcall(lastRenderedReducer, currentState, action)
				-- Stash the eagerly computed state, and the reducer used to compute
				-- it, on the update object. If the reducer hasn't changed by the
				-- time we enter the render phase, then the eager state can be used
				-- without calling the reducer again.
				if ok then
					update.eagerReducer = lastRenderedReducer
					update.eagerState = eagerState
				end

				-- finally
				if __DEV__ then
					ReactCurrentDispatcher.current = prevDispatcher
				end

				if is(eagerState, currentState) then
					-- Fast path. We can bail out without scheduling React to re-render.
					-- It's still possible that we'll need to rebase this update later,
					-- if the component re-renders for a different reason and by that
					-- time the reducer has changed.
					return
				end
				-- catch
				if not ok then
					-- Suppress the error. It will throw again in the render phase.
				end
			end
		end
		if __DEV__ then
			-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
			-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ as well as jest
			if type(_G.jest) ~= "nil" or _G.__TESTEZ_RUNNING_TEST__ then
				warnIfNotScopedWithMatchingAct(fiber)
				warnIfNotCurrentlyActingUpdatesInDEV(fiber)
			end
		end
		scheduleUpdateOnFiber(fiber, lane, eventTime)
	end

	if __DEV__ then
		if enableDebugTracing then
			if bit32.band(fiber.mode, DebugTracingMode) ~= 0 then
				local name = getComponentName(fiber.type) or "Unknown"
				logStateUpdateScheduled(name, lane, action)
			end
		end
	end

	if enableSchedulingProfiler then
		markStateUpdateScheduled(fiber, lane)
	end

	return
end

-- deviation: Move these to the top so they're in scope for above functions
local ContextOnlyDispatcher: Dispatcher = {
	readContext = readContext,

	useCallback = throwInvalidHookError :: any,
	useContext = throwInvalidHookError :: any,
	useEffect = throwInvalidHookError :: any,
	useImperativeHandle = throwInvalidHookError :: any,
	useLayoutEffect = throwInvalidHookError :: any,
	useMemo = throwInvalidHookError :: any,
	useReducer = throwInvalidHookError :: any,
	useRef = throwInvalidHookError :: any,
	useBinding = throwInvalidHookError :: any,
	useState = throwInvalidHookError :: any,
	useDebugValue = throwInvalidHookError :: any,
	-- useDeferredValue = throwInvalidHookError,
	-- useTransition = throwInvalidHookError,
	useMutableSource = throwInvalidHookError :: any,
	useOpaqueIdentifier = throwInvalidHookError :: any,

	unstable_isNewReconciler = enableNewReconciler,
}
exports.ContextOnlyDispatcher = ContextOnlyDispatcher

local HooksDispatcherOnMount: Dispatcher = {
	readContext = readContext,

	useCallback = mountCallback,
	useContext = readContext,
	useEffect = mountEffect,
	useImperativeHandle = mountImperativeHandle,
	useLayoutEffect = mountLayoutEffect,
	-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
	useMemo = mountMemo :: any,
	useReducer = mountReducer,
	useRef = mountRef,
	useBinding = mountBinding,
	useState = mountState,
	useDebugValue = mountDebugValue,
	-- useDeferredValue = mountDeferredValue,
	-- useTransition = mountTransition,
	useMutableSource = mountMutableSource,
	useOpaqueIdentifier = mountOpaqueIdentifier,

	unstable_isNewReconciler = enableNewReconciler,
}

local HooksDispatcherOnUpdate: Dispatcher = {
	readContext = readContext,

	useCallback = updateCallback,
	useContext = readContext,
	useEffect = updateEffect,
	useImperativeHandle = updateImperativeHandle,
	useLayoutEffect = updateLayoutEffect,
	-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
	useMemo = updateMemo :: any,
	useReducer = updateReducer,
	useRef = updateRef,
	useBinding = updateBinding,
	useState = updateState,
	useDebugValue = updateDebugValue,
	-- useDeferredValue = updateDeferredValue,
	-- useTransition = updateTransition,
	useMutableSource = updateMutableSource,
	useOpaqueIdentifier = updateOpaqueIdentifier,

	unstable_isNewReconciler = enableNewReconciler,
}

local HooksDispatcherOnRerender: Dispatcher = {
	readContext = readContext,

	useCallback = updateCallback,
	useContext = readContext,
	useEffect = updateEffect,
	useImperativeHandle = updateImperativeHandle,
	useLayoutEffect = updateLayoutEffect,
	-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
	useMemo = updateMemo :: any,
	useReducer = rerenderReducer,
	useRef = updateRef,
	useBinding = updateBinding,
	useState = rerenderState,
	useDebugValue = updateDebugValue,
	-- useDeferredValue = rerenderDeferredValue,
	-- useTransition = rerenderTransition,
	useMutableSource = updateMutableSource,
	useOpaqueIdentifier = rerenderOpaqueIdentifier,

	unstable_isNewReconciler = enableNewReconciler,
}

if __DEV__ then
	local warnInvalidContextAccess = function()
		console.error(
			"Context can only be read while React is rendering. "
				.. "In classes, you can read it in the render method or getDerivedStateFromProps. "
				.. "In function components, you can read it directly in the function body, but not "
				.. "inside Hooks like useReducer() or useMemo()."
		)
	end

	local warnInvalidHookAccess = function()
		console.error(
			"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. "
				.. "You can only call Hooks at the top level of your React function. "
				.. "For more information, see "
				.. "https://reactjs.org/link/rules-of-hooks"
		)
	end

	HooksDispatcherOnMountInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			mountHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useEffect"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			mountHookTypesDev()
			checkDepsAreArrayDev(deps)
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(mountMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			-- FIXME Luau: TypeError: Type 'boolean' could not be converted into 'T'
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			local ok, result, setResult = pcall(mountReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			mountHookTypesDev()
			return mountRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			mountHookTypesDev()
			return mountBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			-- deviation: Lua version of mountState return two items, not list like upstream.
			local ok, result, setResult = pcall(mountState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			mountHookTypesDev()
			return mountDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       mountHookTypesDev()
		--       return mountDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       mountHookTypesDev()
		--       return mountTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			mountHookTypesDev()
			return mountMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function()
			currentHookNameInDev = "useOpaqueIdentifier"
			mountHookTypesDev()
			return mountOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	HooksDispatcherOnMountWithHookTypesInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			updateHookTypesDev()
			checkDepsAreArrayDev(deps)
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useEffect"
			updateHookTypesDev()
			return mountEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			updateHookTypesDev()
			return mountImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			updateHookTypesDev()
			return mountLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(mountMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			local ok, result, setResult = pcall(mountReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			updateHookTypesDev()
			return mountRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			updateHookTypesDev()
			return mountBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			-- deviation: Lua version of mountState return two items, not list like upstream
			local ok, result, setResult = pcall(mountState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of mountState return two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			updateHookTypesDev()
			return mountDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       updateHookTypesDev()
		--       return mountDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       updateHookTypesDev()
		--       return mountTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			updateHookTypesDev()
			return mountMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function()
			currentHookNameInDev = "useOpaqueIdentifier"
			updateHookTypesDev()
			return mountOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	HooksDispatcherOnUpdateInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			updateHookTypesDev()
			return updateCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useEffect"
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			local ok, result, setResult = pcall(updateReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			-- deviation: Lua version of updateState returns two items, not list like upstream
			local ok, result, setResult = pcall(updateState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       updateHookTypesDev()
		--       return updateDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       updateHookTypesDev()
		--       return updateTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			updateHookTypesDev()
			return updateOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	HooksDispatcherOnRerenderInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			updateHookTypesDev()
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV
			local ok, result, setResult = pcall(rerenderReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnRerenderInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(rerenderState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       updateHookTypesDev()
		--       return rerenderDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       updateHookTypesDev()
		--       return rerenderTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			updateHookTypesDev()
			return rerenderOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	InvalidNestedHooksDispatcherOnMountInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			warnInvalidContextAccess()
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useLayoutEffect"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			warnInvalidHookAccess()
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(mountMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			warnInvalidHookAccess()
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			local ok, result, setResult = pcall(mountReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			warnInvalidHookAccess()
			mountHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnMountInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(mountState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountDebugValue(value, formatterFn)
		end,
		-- useDeferredValue<T>(value: T): T {
		--   currentHookNameInDev = 'useDeferredValue'
		--   warnInvalidHookAccess()
		--   mountHookTypesDev()
		--   return mountDeferredValue(value)
		-- },
		-- useTransition(): [(() => void) => void, boolean] {
		--   currentHookNameInDev = 'useTransition'
		--   warnInvalidHookAccess()
		--   mountHookTypesDev()
		--   return mountTransition()
		-- },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			warnInvalidHookAccess()
			mountHookTypesDev()
			return mountOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	InvalidNestedHooksDispatcherOnUpdateInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			warnInvalidContextAccess()
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return mountCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			local ok, result, setResult = pcall(updateReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher

			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(updateState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return updateDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return updateTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}

	InvalidNestedHooksDispatcherOnRerenderInDEV = {
		readContext = function<T>(context: ReactContext<T>, observedBits: number | boolean | nil): T
			warnInvalidContextAccess()
			return readContext(context, observedBits)
		end,
		useCallback = function<T>(callback: T, deps: Array<any> | nil): T
			currentHookNameInDev = "useCallback"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateCallback(callback, deps)
		end,
		useContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
			currentHookNameInDev = "useContext"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return readContext(context, observedBits)
		end,
		useEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateEffect(create, deps)
		end,
		useImperativeHandle = function<T>(
			ref: { current: T | nil } | ((inst: T | nil) -> ...any) | nil,
			create: () -> T,
			deps: Array<any> | nil
		): ()
			currentHookNameInDev = "useImperativeHandle"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateImperativeHandle(ref, create, deps)
		end,
		useLayoutEffect = function(
			-- TODO: Luau needs union type packs for this type to translate idiomatically
			create: (() -> ()) | (() -> (() -> ())),
			deps: Array<any>?
		): ()
			currentHookNameInDev = "useLayoutEffect"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateLayoutEffect(create, deps)
		end,
		-- FIXME Luau: work around 'Failed to unify type packs' error: CLI-51338
		useMemo = function<T...>(create: () -> T..., deps: Array<any> | nil): ...any
			currentHookNameInDev = "useMemo"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			--[[
        ROBLOX DEVIATION: `results` captures all pcall return value: either
        { false, errorObject } or { true, ...returnValues }
      ]]
			local results = { pcall(updateMemo, create, deps) }
			ReactCurrentDispatcher.current = prevDispatcher
			if not results[1] then
				error(results[2])
			end
			return unpack(results, 2)
		end :: any,
		useReducer = function<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
			currentHookNameInDev = "useReducer"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			local ok, result, setResult = pcall(rerenderReducer, reducer, initialArg, init)
			-- finally
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState and useReducer return two items, not list like upstream
			return result, setResult
		end,
		-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
		useRef = function<T>(initialValue: T): { current: T | nil }
			currentHookNameInDev = "useRef"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateRef(initialValue)
		end,
		-- deviation: Bindings are a feature unique to Roact
		useBinding = function<T>(initialValue: T): (ReactBinding<T>, ReactBindingUpdater<T>)
			currentHookNameInDev = "useBinding"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateBinding(initialValue)
		end,
		useState = function<S>(initialState: (() -> S) | S): (S, Dispatch<BasicStateAction<S>>)
			currentHookNameInDev = "useState"
			warnInvalidHookAccess()
			updateHookTypesDev()
			local prevDispatcher = ReactCurrentDispatcher.current
			ReactCurrentDispatcher.current = InvalidNestedHooksDispatcherOnUpdateInDEV
			-- deviation: Lua version of useState returns two items, not list like upstream
			local ok, result, setResult = pcall(rerenderState, initialState)
			ReactCurrentDispatcher.current = prevDispatcher
			if not ok then
				error(result)
			end
			-- deviation: Lua version of useState returns two items, not list like upstream
			return result, setResult
		end,
		useDebugValue = function<T>(value: T, formatterFn: ((value: T) -> any)?): ()
			currentHookNameInDev = "useDebugValue"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateDebugValue(value, formatterFn)
		end,
		--     useDeferredValue<T>(value: T): T {
		--       currentHookNameInDev = 'useDeferredValue'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return rerenderDeferredValue(value)
		--     },
		--     useTransition(): [(() => void) => void, boolean] {
		--       currentHookNameInDev = 'useTransition'
		--       warnInvalidHookAccess()
		--       updateHookTypesDev()
		--       return rerenderTransition()
		--     },
		useMutableSource = function<Source, Snapshot>(
			source: MutableSource<Source>,
			getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
			subscribe: MutableSourceSubscribeFn<Source, Snapshot>
		): Snapshot
			currentHookNameInDev = "useMutableSource"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return updateMutableSource(source, getSnapshot, subscribe)
		end,
		useOpaqueIdentifier = function(): OpaqueIDType
			currentHookNameInDev = "useOpaqueIdentifier"
			warnInvalidHookAccess()
			updateHookTypesDev()
			return rerenderOpaqueIdentifier()
		end,

		unstable_isNewReconciler = enableNewReconciler,
	}
end

local function renderWithHooks<Props, SecondArg>(
	current: Fiber | nil,
	workInProgress: Fiber,
	Component: (p: Props, arg: SecondArg) -> any,
	props: Props,
	secondArg: SecondArg,
	nextRenderLanes: Lanes
): any
	renderLanes = nextRenderLanes
	currentlyRenderingFiber = workInProgress

	if __DEV__ then
		hookTypesDev = if current ~= nil then (current._debugHookTypes :: any) :: Array<HookType> else nil
		-- deviation START: index variable offset by one for Lua
		hookTypesUpdateIndexDev = 0
		-- deviation END
		-- Used for hot reloading:
		-- performance: eliminate unuseful cmp in hot path, we don't currently support hot reloading
		-- ignorePreviousDependencies =
		--   current ~= nil and current.type ~= workInProgress.type
	end

	workInProgress.memoizedState = nil
	-- performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
	workInProgress.updateQueue = nil
	workInProgress.lanes = NoLanes

	-- The following should have already been reset
	-- currentHook = nil
	-- workInProgressHook = nil

	-- didScheduleRenderPhaseUpdate = false

	-- TODO Warn if no hooks are used at all during mount, then some are used during update.
	-- Currently we will identify the update render as a mount because memoizedState == nil.
	-- This is tricky because it's valid for certain types of components (e.g. React.lazy)

	-- Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.
	-- Non-stateful hooks (e.g. context) don't get added to memoizedState,
	-- so memoizedState would be nil during updates and mounts.
	if __DEV__ then
		if current ~= nil and current.memoizedState ~= nil then
			ReactCurrentDispatcher.current = HooksDispatcherOnUpdateInDEV
		elseif hookTypesDev ~= nil then
			-- This dispatcher handles an edge case where a component is updating,
			-- but no stateful hooks have been used.
			-- We want to match the production code behavior (which will use HooksDispatcherOnMount),
			-- but with the extra DEV validation to ensure hooks ordering hasn't changed.
			-- This dispatcher does that.
			ReactCurrentDispatcher.current = HooksDispatcherOnMountWithHookTypesInDEV
		else
			ReactCurrentDispatcher.current = HooksDispatcherOnMountInDEV
		end
	else
		ReactCurrentDispatcher.current = (current == nil or current.memoizedState == nil) and HooksDispatcherOnMount
			or HooksDispatcherOnUpdate
	end

	local children = Component(props, secondArg)

	-- Check if there was a render phase update
	if didScheduleRenderPhaseUpdateDuringThisPass then
		-- Keep rendering in a loop for as long as render phase updates continue to
		-- be scheduled. Use a counter to prevent infinite loops.
		local numberOfReRenders: number = 0
		repeat
			didScheduleRenderPhaseUpdateDuringThisPass = false
			-- performance: use React 18 approach to avoid invariant in hot path
			if numberOfReRenders >= RE_RENDER_LIMIT then
				error(
					Error.new(
						"Too many re-renders. React limits the number of renders to prevent " .. "an infinite loop."
					)
				)
			end

			numberOfReRenders += 1
			-- performance: eliminate unuseful cmp in hot path, we don't currently support hot reloading
			-- if __DEV__ then
			-- Even when hot reloading, allow dependencies to stabilize
			-- after first render to prevent infinite render phase updates.
			-- ignorePreviousDependencies = false
			-- end

			-- Start over from the beginning of the list
			currentHook = nil
			workInProgressHook = nil

			-- performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
			workInProgress.updateQueue = nil

			if __DEV__ then
				-- Also validate hook order for cascading updates.
				hookTypesUpdateIndexDev = 0
			end

			ReactCurrentDispatcher.current = __DEV__ and HooksDispatcherOnRerenderInDEV or HooksDispatcherOnRerender

			children = Component(props, secondArg)
		until not didScheduleRenderPhaseUpdateDuringThisPass
	end

	-- We can assume the previous dispatcher is always this one, since we set it
	-- at the beginning of the render phase and there's no re-entrancy.
	ReactCurrentDispatcher.current = ContextOnlyDispatcher

	if __DEV__ then
		workInProgress._debugHookTypes = hookTypesDev
	end

	-- This check uses currentHook so that it works the same in DEV and prod bundles.
	-- hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
	local didRenderTooFewHooks = currentHook ~= nil and currentHook.next ~= nil

	renderLanes = NoLanes
	currentlyRenderingFiber = nil :: any

	currentHook = nil
	workInProgressHook = nil

	if __DEV__ then
		currentHookNameInDev = nil
		hookTypesDev = nil
		hookTypesUpdateIndexDev = 0
	end

	didScheduleRenderPhaseUpdate = false

	-- performance: use React 18 approach that avoid invariant in hot paths
	if didRenderTooFewHooks then
		error(
			Error.new(
				"Rendered fewer hooks than expected. This may be caused by an accidental " .. "early return statement."
			)
		)
	end

	return children
end
exports.renderWithHooks = renderWithHooks

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000610e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFF44A6A4169E4AA486C1D01F7AA2134A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberHostConfig</string>
								<string name="ScriptGuid">{524B8C4E-650B-4ED2-BAC9-9F21CA811556}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/9ac42dd074c42b66ecc0334b75200b1d2989f892/packages/react-reconciler/src/ReactFiberHostConfig.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[ eslint-disable react-internal/invariant-args ]]

-- FIXME: Cannot carry types over via the module overriding that's in use
-- here; this is a particularly tricky case of cross-dependency type definitions
-- Use a common set of typedefs across ReactTestHostConfig and ReactRobloxHostTypes
type Object = { [string]: any }

export type Instance = Object
export type HostInstance = Instance
export type TextInstance = Instance
export type Container = Object
export type HostContext = Object
export type HydratableInstance = Instance | SuspenseInstance
export type SuspenseInstance = Object
export type PublicInstance = HostInstance

export type Type = string
export type Props = Object
export type ChildSet = {} -- void, unused
export type RendererInspectionConfig = Object

-- if _G.__NO_LOADMODULE__ then
local exports: { [string]: any } = {}
return exports
-- end

-- -- We expect that our Rollup, Jest, and Flow configurations
-- -- always shim this module with the corresponding host config
-- -- (either provided by a renderer, or a generic shim for npm).
-- --
-- -- We should never resolve to this file, but it exists to make
-- -- sure that if we *do* accidentally break the configuration,
-- -- the failure isn't silent.

-- -- deviation: FIXME (roblox): is there a way to configure luau to account for this module
-- -- being shimmed?
-- error('This module must be shimmed by a specific renderer.')
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000610f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB44B547002A940DB982586CCD6876770">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberHostContext.new</string>
								<string name="ScriptGuid">{3012EFDE-317C-42C5-B8C1-E2B92A0DFC80}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberHostContext.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

-- local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Container = ReactFiberHostConfig.Container
type HostContext = ReactFiberHostConfig.HostContext

-- local invariant = require(Packages.Shared).invariant

local getChildHostContext = ReactFiberHostConfig.getChildHostContext
local getRootHostContext = ReactFiberHostConfig.getRootHostContext
local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop

-- FIXME (roblox): The upstream code here should be guaranteeing that the type
-- is always this exact object, but I think ours will match against any empty
-- table
-- declare class NoContextT {}
type NoContextT = {}
local NO_CONTEXT: NoContextT = {}

local contextStackCursor: StackCursor<HostContext | NoContextT> = createCursor(NO_CONTEXT)
local contextFiberStackCursor: StackCursor<Fiber | NoContextT> = createCursor(NO_CONTEXT)
local rootInstanceStackCursor: StackCursor<Container | NoContextT> = createCursor(NO_CONTEXT)

function requiredContext<Value>(c: Value | NoContextT): Value
	-- performance: eliminate expensive optional cmp in hot path
	-- invariant(
	--   c ~= NO_CONTEXT,
	--   "Expected host context to exist. This error is likely caused by a bug " ..
	--     "in React. Please file an issue."
	-- )
	return c :: any
end

function getRootHostContainer(): Container
	-- performance: inline requiredContext impl for hot path
	-- local rootInstance = requiredContext(rootInstanceStackCursor.current)
	-- return rootInstance
	return rootInstanceStackCursor.current
end

function pushHostContainer(fiber: Fiber, nextRootInstance: Container)
	-- Push current root instance onto the stack
	-- This allows us to reset root when portals are popped.
	push(rootInstanceStackCursor, nextRootInstance, fiber)
	-- Track the context and the Fiber that provided it.
	-- This enables us to pop only Fibers that provide unique contexts.
	push(contextFiberStackCursor, fiber, fiber)

	-- Finally, we need to push the host context to the stack.
	-- However, we can't just call getRootHostContext() and push it because
	-- we'd have a different number of entries on the stack depending on
	-- whether getRootHostContext() throws somewhere in renderer code or not.
	-- So we push an empty value first. This lets us safely unwind on errors.
	push(contextStackCursor, NO_CONTEXT, fiber)
	local nextRootContext = getRootHostContext(nextRootInstance)
	-- Now that we know this function doesn't throw, replace it.
	pop(contextStackCursor, fiber)
	push(contextStackCursor, nextRootContext, fiber)
end

function popHostContainer(fiber: Fiber)
	pop(contextStackCursor, fiber)
	pop(contextFiberStackCursor, fiber)
	pop(rootInstanceStackCursor, fiber)
end

function getHostContext(): HostContext
	-- performance: inline requiredContext impl for hot path
	-- local context = requiredContext(contextStackCursor.current)
	-- return context
	return contextStackCursor.current
end

function pushHostContext(fiber: Fiber)
	local rootInstance: Container = requiredContext(rootInstanceStackCursor.current)
	local context: HostContext = requiredContext(contextStackCursor.current)
	local nextContext = getChildHostContext(context, fiber.type, rootInstance)

	-- Don't push this Fiber's context unless it's unique.
	if context == nextContext then
		return
	end

	-- Track the context and the Fiber that provided it.
	-- This enables us to pop only Fibers that provide unique contexts.
	push(contextFiberStackCursor, fiber, fiber)
	push(contextStackCursor, nextContext, fiber)
end

function popHostContext(fiber: Fiber)
	-- Do not pop unless this Fiber provided the current context.
	-- pushHostContext() only pushes Fibers that provide unique contexts.
	if contextFiberStackCursor.current ~= fiber then
		return
	end

	pop(contextStackCursor, fiber)
	pop(contextFiberStackCursor, fiber)
end

return {
	getHostContext = getHostContext,
	getRootHostContainer = getRootHostContainer,
	popHostContainer = popHostContainer,
	popHostContext = popHostContext,
	pushHostContainer = pushHostContainer,
	pushHostContext = pushHostContext,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006110</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE1EE15860BBF4165BDA8E4FC44870AFD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberHotReloading.new</string>
								<string name="ScriptGuid">{949BC448-B113-4B92-A83A-D44D54F1B992}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/6edaf6f764f23043f0cd1c2da355b42f641afd8b/packages/react-reconciler/src/ReactFiberHotReloading.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent

local ReactElementType = require(Packages.Shared)
-- deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type ReactElement = ReactElementType.ReactElement<any, any>

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
-- local type {FiberRoot} = require(script.Parent.ReactInternalTypes)
-- local type {Instance} = require(script.Parent.ReactFiberHostConfig)
-- local type {ReactNodeList} = require(Packages.Shared).ReactTypes

-- local {
-- 	flushSync,
-- 	scheduleUpdateOnFiber,
-- 	flushPassiveEffects,
-- } = require(script.Parent.ReactFiberWorkLoop.new)
-- local {updateContainer} = require(script.Parent.ReactFiberReconciler.new)
-- local {emptyContextObject} = require(script.Parent.ReactFiberContext.new)
-- local {SyncLane, NoTimestamp} = require(script.Parent.ReactFiberLane)
-- local {
-- 	ClassComponent,
-- 	FunctionComponent,
-- 	ForwardRef,
-- 	HostComponent,
-- 	HostPortal,
-- 	HostRoot,
-- 	MemoComponent,
-- 	SimpleMemoComponent,
-- } = require(script.Parent.ReactWorkTags)
local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
-- 	REACT_MEMO_TYPE,
-- 	REACT_LAZY_TYPE,

export type Family = {
	current: any,
}

-- export type RefreshUpdate = {|
-- 	staleFamilies: Set<Family>,
-- 	updatedFamilies: Set<Family>,
-- |}

-- Resolves type to a family.
type RefreshHandler = (any) -> Family?

-- -- Used by React Refresh runtime through DevTools Global Hook.
-- export type SetRefreshHandler = (handler: RefreshHandler | nil) => void
-- export type ScheduleRefresh = (root: FiberRoot, update: RefreshUpdate) => void
-- export type ScheduleRoot = (root: FiberRoot, element: ReactNodeList) => void
-- export type FindHostInstancesForRefresh = (
-- 	root: FiberRoot,
-- 	families: Array<Family>,
-- ) => Set<Instance>

-- FIXME (roblox): restore type 'resolveFamily: RefreshHandler?' when type
-- refinement in Luau works better
local resolveFamily = nil
-- $FlowFixMe Flow gets confused by a WeakSet feature check below.
-- deviation: Using table instead of WeakSet
local failedBoundaries: { [number]: Fiber } | nil = nil

local exports = {}

-- export local setRefreshHandler = (handler: RefreshHandler | nil): void => {
-- 	if _G.__DEV__)
-- 		resolveFamily = handler
-- 	end
-- end

local function resolveFunctionForHotReloading(type: any): any
	if _G.__DEV__ then
		if resolveFamily == nil then
			-- Hot reloading is disabled.
			return type
		end
		local family = resolveFamily(type)
		if family == nil then
			return type
		end
		-- Use the latest known implementation.
		return family.current
	else
		return type
	end
end
exports.resolveFunctionForHotReloading = resolveFunctionForHotReloading

local function resolveClassForHotReloading(type: any): any
	-- No implementation differences.
	return resolveFunctionForHotReloading(type)
end
exports.resolveClassForHotReloading = resolveClassForHotReloading

local function resolveForwardRefForHotReloading(type: any): any
	if _G.__DEV__ then
		if resolveFamily == nil then
			-- Hot reloading is disabled.
			return type
		end
		local family = resolveFamily(type)
		if family == nil then
			-- Check if we're dealing with a real forwardRef. Don't want to crash early.
			if type ~= nil and typeof(type.render) == "function" then
				-- ForwardRef is special because its resolved .type is an object,
				-- but it's possible that we only have its inner render function in the map.
				-- If that inner render function is different, we'll build a new forwardRef type.
				local currentRender = resolveFunctionForHotReloading(type.render)
				if type.render ~= currentRender then
					local syntheticType = {
						["$$typeof"] = REACT_FORWARD_REF_TYPE,
						render = currentRender,
						-- deviation: Luau needs table initializers to be complete
						displayName = nil,
					}
					if type.displayName ~= nil then
						syntheticType.displayName = type.displayName
					end
					return syntheticType
				end
			end
			return type
		end
		-- Use the latest known implementation.
		return family.current
	else
		return type
	end
end
exports.resolveForwardRefForHotReloading = resolveForwardRefForHotReloading

exports.isCompatibleFamilyForHotReloading = function(fiber: Fiber, element: ReactElement): boolean
	warn("isCompatibleFamilyForHotReloading is stubbed (returns false)")
	return false
	-- if _G.__DEV__ then
	-- 	if resolveFamily == nil then
	-- 		-- Hot reloading is disabled.
	-- 		return false
	-- 	end

	-- 	local prevType = fiber.elementType
	-- 	local nextType = element.type

	-- 	-- If we got here, we know types aren't == equal.
	-- 	local needsCompareFamilies = false

	-- 	local $$typeofNextType =
	-- 		typeof nextType == 'table’' and nextType ~= nil
	-- 			? nextType.$$typeof
	-- 			: nil

	-- 	switch (fiber.tag)
	-- 		case ClassComponent: {
	-- 			if typeof nextType == 'function')
	-- 				needsCompareFamilies = true
	-- 			end
	-- 			break
	-- 		end
	-- 		case FunctionComponent: {
	-- 			if typeof nextType == 'function')
	-- 				needsCompareFamilies = true
	-- 			} else if $$typeofNextType == REACT_LAZY_TYPE)
	-- 				-- We don't know the inner type yet.
	-- 				-- We're going to assume that the lazy inner type is stable,
	-- 				-- and so it is sufficient to avoid reconciling it away.
	-- 				-- We're not going to unwrap or actually use the new lazy type.
	-- 				needsCompareFamilies = true
	-- 			end
	-- 			break
	-- 		end
	-- 		case ForwardRef: {
	-- 			if $$typeofNextType == REACT_FORWARD_REF_TYPE)
	-- 				needsCompareFamilies = true
	-- 			} else if $$typeofNextType == REACT_LAZY_TYPE)
	-- 				needsCompareFamilies = true
	-- 			end
	-- 			break
	-- 		end
	-- 		case MemoComponent:
	-- 		case SimpleMemoComponent: {
	-- 			if $$typeofNextType == REACT_MEMO_TYPE)
	-- 				-- TODO: if it was but can no longer be simple,
	-- 				-- we shouldn't set this.
	-- 				needsCompareFamilies = true
	-- 			} else if $$typeofNextType == REACT_LAZY_TYPE)
	-- 				needsCompareFamilies = true
	-- 			end
	-- 			break
	-- 		end
	-- 		default:
	-- 			return false
	-- 	end

	-- 	-- Check if both types have a family and it's the same one.
	-- 	if needsCompareFamilies)
	-- 		-- NOTE: memo() and forwardRef() we'll compare outer rather than inner type.
	-- 		-- This means both of them need to be registered to preserve state.
	-- 		-- If we unwrapped and compared the inner types for wrappers instead,
	-- 		-- then we would risk falsely saying two separate memo(Foo)
	-- 		-- calls are equivalent because they wrap the same Foo function.
	-- 		local prevFamily = resolveFamily(prevType)
	-- 		if prevFamily ~= undefined and prevFamily == resolveFamily(nextType))
	-- 			return true
	-- 		end
	-- 	end
	-- 	return false
	-- } else {
	-- 	return false
	-- end
end

exports.markFailedErrorBoundaryForHotReloading = function(fiber: Fiber)
	if _G.__DEV__ then
		if resolveFamily == nil then
			-- Hot reloading is disabled.
			return
		end
		-- if typeof(WeakSet) ~= 'function' then
		-- 	return
		-- end
		-- deviation: {} in place of WeakSet
		if failedBoundaries == nil then
			failedBoundaries = {}
		end
		-- FIXME: remove :: once Luau understands nil check
		table.insert(failedBoundaries :: { [number]: Fiber }, fiber)
	end
end

-- export local scheduleRefresh: ScheduleRefresh = (
-- 	root: FiberRoot,
-- 	update: RefreshUpdate,
-- ): void => {
-- 	if _G.__DEV__)
-- 		if resolveFamily == nil)
-- 			-- Hot reloading is disabled.
-- 			return
-- 		end
-- 		local {staleFamilies, updatedFamilies} = update
-- 		flushPassiveEffects()
-- 		flushSync(() => {
-- 			scheduleFibersWithFamiliesRecursively(
-- 				root.current,
-- 				updatedFamilies,
-- 				staleFamilies,
-- 			)
-- 		})
-- 	end
-- end

-- export local scheduleRoot: ScheduleRoot = (
-- 	root: FiberRoot,
-- 	element: ReactNodeList,
-- ): void => {
-- 	if _G.__DEV__)
-- 		if root.context ~= emptyContextObject)
-- 			-- Super edge case: root has a legacy _renderSubtree context
-- 			-- but we don't know the parentComponent so we can't pass it.
-- 			-- Just ignore. We'll delete this with _renderSubtree code path later.
-- 			return
-- 		end
-- 		flushPassiveEffects()
-- 		flushSync(() => {
-- 			updateContainer(element, root, nil, nil)
-- 		})
-- 	end
-- end

-- function scheduleFibersWithFamiliesRecursively(
-- 	fiber: Fiber,
-- 	updatedFamilies: Set<Family>,
-- 	staleFamilies: Set<Family>,
-- )
-- 	if _G.__DEV__)
-- 		local {alternate, child, sibling, tag, type} = fiber

-- 		local candidateType = nil
-- 		switch (tag)
-- 			case FunctionComponent:
-- 			case SimpleMemoComponent:
-- 			case ClassComponent:
-- 				candidateType = type
-- 				break
-- 			case ForwardRef:
-- 				candidateType = type.render
-- 				break
-- 			default:
-- 				break
-- 		end

-- 		if resolveFamily == nil)
-- 			throw new Error('Expected resolveFamily to be set during hot reload.')
-- 		end

-- 		local needsRender = false
-- 		local needsRemount = false
-- 		if candidateType ~= nil)
-- 			local family = resolveFamily(candidateType)
-- 			if family ~= undefined)
-- 				if staleFamilies.has(family))
-- 					needsRemount = true
-- 				} else if updatedFamilies.has(family))
-- 					if tag == ClassComponent)
-- 						needsRemount = true
-- 					} else {
-- 						needsRender = true
-- 					end
-- 				end
-- 			end
-- 		end
-- 		if failedBoundaries ~= nil)
-- 			if
-- 				failedBoundaries.has(fiber) or
-- 				(alternate ~= nil and failedBoundaries.has(alternate))
-- 			)
-- 				needsRemount = true
-- 			end
-- 		end

-- 		if needsRemount)
-- 			fiber._debugNeedsRemount = true
-- 		end
-- 		if needsRemount or needsRender)
-- 			scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
-- 		end
-- 		if child ~= nil and !needsRemount)
-- 			scheduleFibersWithFamiliesRecursively(
-- 				child,
-- 				updatedFamilies,
-- 				staleFamilies,
-- 			)
-- 		end
-- 		if sibling ~= nil)
-- 			scheduleFibersWithFamiliesRecursively(
-- 				sibling,
-- 				updatedFamilies,
-- 				staleFamilies,
-- 			)
-- 		end
-- 	end
-- end

-- export local findHostInstancesForRefresh: FindHostInstancesForRefresh = (
-- 	root: FiberRoot,
-- 	families: Array<Family>,
-- ): Set<Instance> => {
-- 	if _G.__DEV__)
-- 		local hostInstances = new Set()
-- 		local types = new Set(families.map(family => family.current))
-- 		findHostInstancesForMatchingFibersRecursively(
-- 			root.current,
-- 			types,
-- 			hostInstances,
-- 		)
-- 		return hostInstances
-- 	} else {
-- 		throw new Error(
-- 			'Did not expect findHostInstancesForRefresh to be called in production.',
-- 		)
-- 	end
-- end

-- function findHostInstancesForMatchingFibersRecursively(
-- 	fiber: Fiber,
-- 	types: Set<any>,
-- 	hostInstances: Set<Instance>,
-- )
-- 	if _G.__DEV__)
-- 		local {child, sibling, tag, type} = fiber

-- 		local candidateType = nil
-- 		switch (tag)
-- 			case FunctionComponent:
-- 			case SimpleMemoComponent:
-- 			case ClassComponent:
-- 				candidateType = type
-- 				break
-- 			case ForwardRef:
-- 				candidateType = type.render
-- 				break
-- 			default:
-- 				break
-- 		end

-- 		local didMatch = false
-- 		if candidateType ~= nil)
-- 			if types.has(candidateType))
-- 				didMatch = true
-- 			end
-- 		end

-- 		if didMatch)
-- 			-- We have a match. This only drills down to the closest host components.
-- 			-- There's no need to search deeper because for the purpose of giving
-- 			-- visual feedback, "flashing" outermost parent rectangles is sufficient.
-- 			findHostInstancesForFiberShallowly(fiber, hostInstances)
-- 		} else {
-- 			-- If there's no match, maybe there will be one further down in the child tree.
-- 			if child ~= nil)
-- 				findHostInstancesForMatchingFibersRecursively(
-- 					child,
-- 					types,
-- 					hostInstances,
-- 				)
-- 			end
-- 		end

-- 		if sibling ~= nil)
-- 			findHostInstancesForMatchingFibersRecursively(
-- 				sibling,
-- 				types,
-- 				hostInstances,
-- 			)
-- 		end
-- 	end
-- end

-- function findHostInstancesForFiberShallowly(
-- 	fiber: Fiber,
-- 	hostInstances: Set<Instance>,
-- ): void {
-- 	if _G.__DEV__)
-- 		local foundHostInstances = findChildHostInstancesForFiberShallowly(
-- 			fiber,
-- 			hostInstances,
-- 		)
-- 		if foundHostInstances)
-- 			return
-- 		end
-- 		-- If we didn't find any host children, fallback to closest host parent.
-- 		local node = fiber
-- 		while (true)
-- 			switch (node.tag)
-- 				case HostComponent:
-- 					hostInstances.add(node.stateNode)
-- 					return
-- 				case HostPortal:
-- 					hostInstances.add(node.stateNode.containerInfo)
-- 					return
-- 				case HostRoot:
-- 					hostInstances.add(node.stateNode.containerInfo)
-- 					return
-- 			end
-- 			if node.return == nil)
-- 				throw new Error('Expected to reach root first.')
-- 			end
-- 			node = node.return
-- 		end
-- 	end
-- end

-- function findChildHostInstancesForFiberShallowly(
-- 	fiber: Fiber,
-- 	hostInstances: Set<Instance>,
-- ): boolean {
-- 	if _G.__DEV__)
-- 		local node: Fiber = fiber
-- 		local foundHostInstances = false
-- 		while (true)
-- 			if node.tag == HostComponent)
-- 				-- We got a match.
-- 				foundHostInstances = true
-- 				hostInstances.add(node.stateNode)
-- 				-- There may still be more, so keep searching.
-- 			} else if node.child ~= nil)
-- 				node.child.return = node
-- 				node = node.child
-- 				continue
-- 			end
-- 			if node == fiber)
-- 				return foundHostInstances
-- 			end
-- 			while (node.sibling == nil)
-- 				if node.return == nil or node.return == fiber)
-- 					return foundHostInstances
-- 				end
-- 				node = node.return
-- 			end
-- 			node.sibling.return = node.return
-- 			node = node.sibling
-- 		end
-- 	end
-- 	return false
-- end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006111</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8DAE5F016FAA41A8A01EBCEFE57FB23B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberHydrationContext.new</string>
								<string name="ScriptGuid">{14FE430C-4F1E-4E2E-A7E0-EA20BD3CBAE3}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberHydrationContext.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. message)
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type TextInstance = ReactFiberHostConfig.TextInstance
type HydratableInstance = ReactFiberHostConfig.HydratableInstance
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
type Container = ReactFiberHostConfig.Container
type HostContext = ReactFiberHostConfig.HostContext

local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local HostComponent = ReactWorkTags.HostComponent
local HostText = ReactWorkTags.HostText
local HostRoot = ReactWorkTags.HostRoot
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
-- local Deletion = ReactFiberFlags.Deletion

local invariant = require(Packages.Shared).invariant

local ReactFiber = require(script.Parent["ReactFiber.new"])
-- local createFiberFromHostInstanceForDeletion = ReactFiber.createFiberFromHostInstanceForDeletion
local createFiberFromDehydratedFragment = ReactFiber.createFiberFromDehydratedFragment

local supportsHydration = ReactFiberHostConfig.supportsHydration
local getNextHydratableSibling = ReactFiberHostConfig.getNextHydratableSibling
local getFirstHydratableChild = ReactFiberHostConfig.getFirstHydratableChild
local canHydrateInstance = ReactFiberHostConfig.canHydrateInstance
local canHydrateTextInstance = ReactFiberHostConfig.canHydrateTextInstance
local canHydrateSuspenseInstance = ReactFiberHostConfig.canHydrateSuspenseInstance
local hydrateInstance = ReactFiberHostConfig.hydrateInstance
local hydrateTextInstance = ReactFiberHostConfig.hydrateTextInstance
local hydrateSuspenseInstance = ReactFiberHostConfig.hydrateSuspenseInstance
local getNextHydratableInstanceAfterSuspenseInstance =
	ReactFiberHostConfig.getNextHydratableInstanceAfterSuspenseInstance
local didNotMatchHydratedContainerTextInstance = ReactFiberHostConfig.didNotMatchHydratedContainerTextInstance
local didNotMatchHydratedTextInstance = ReactFiberHostConfig.didNotMatchHydratedTextInstance
local shouldSetTextContent = ReactFiberHostConfig.shouldSetTextContent

-- local {
--   didNotHydrateContainerInstance,
--   didNotHydrateInstance,
--   didNotFindHydratableContainerInstance,
--   didNotFindHydratableContainerTextInstance,
--   didNotFindHydratableContainerSuspenseInstance,
--   didNotFindHydratableInstance,
--   didNotFindHydratableTextInstance,
--   didNotFindHydratableSuspenseInstance,
-- } = require(Packages../ReactFiberHostConfig'
local enableSuspenseServerRenderer = require(Packages.Shared).ReactFeatureFlags.enableSuspenseServerRenderer
local OffscreenLane = require(script.Parent.ReactFiberLane).OffscreenLane

-- The deepest Fiber on the stack involved in a hydration context.
-- This may have been an insertion or a hydration.
local hydrationParentFiber: Fiber? = nil
local nextHydratableInstance: nil | HydratableInstance = nil
local isHydrating: boolean = false

function warnIfHydrating()
	if _G.__DEV__ then
		if isHydrating then
			console.error("We should not be hydrating here. This is a bug in React. Please file a bug.")
		end
	end
end

function enterHydrationState(fiber: Fiber): boolean
	if not supportsHydration then
		return false
	end

	local parentInstance = fiber.stateNode.containerInfo
	nextHydratableInstance = getFirstHydratableChild(parentInstance)
	hydrationParentFiber = fiber
	isHydrating = true
	return true
end

function reenterHydrationStateFromDehydratedSuspenseInstance(fiber: Fiber, suspenseInstance: SuspenseInstance): boolean
	if not supportsHydration then
		return false
	end

	nextHydratableInstance = getNextHydratableSibling(suspenseInstance)
	popToNextHostParent(fiber)
	isHydrating = true
	return true
end

function deleteHydratableInstance(returnFiber: Fiber?, instance: HydratableInstance)
	unimplemented("deleteHydratableInstance")
	-- if _G.__DEV__ then
	--   switch (returnFiber.tag)
	--     case HostRoot:
	--       didNotHydrateContainerInstance(
	--         returnFiber.stateNode.containerInfo,
	--         instance,
	--       )
	--       break
	--     case HostComponent:
	--       didNotHydrateInstance(
	--         returnFiber.type,
	--         returnFiber.memoizedProps,
	--         returnFiber.stateNode,
	--         instance,
	--       )
	--       break
	-- 		end
	-- 	end

	-- local childToDelete = createFiberFromHostInstanceForDeletion()
	-- childToDelete.stateNode = instance
	-- childToDelete.return = returnFiber

	-- local deletions = returnFiber.deletions
	-- if deletions == nil)
	--   returnFiber.deletions = [childToDelete]
	--   -- TODO (effects) Rename this to better reflect its new usage (e.g. ChildDeletions)
	--   returnFiber.flags |= Deletion
	-- } else {
	--   deletions.push(childToDelete)
	-- }
end

function insertNonHydratedInstance(returnFiber: Fiber?, fiber: Fiber)
	unimplemented("insertNonHydratedInstance")
	fiber.flags = bit32.bor(bit32.band(fiber.flags, bit32.bnot(Hydrating)), Placement)
	if _G.__DEV__ then
		-- switch (returnFiber.tag)
		--   case HostRoot: {
		--     local parentContainer = returnFiber.stateNode.containerInfo
		--     switch (fiber.tag)
		--       case HostComponent:
		--         local type = fiber.type
		--         local props = fiber.pendingProps
		--         didNotFindHydratableContainerInstance(parentContainer, type, props)
		--         break
		--       case HostText:
		--         local text = fiber.pendingProps
		--         didNotFindHydratableContainerTextInstance(parentContainer, text)
		--         break
		--       case SuspenseComponent:
		--         didNotFindHydratableContainerSuspenseInstance(parentContainer)
		--         break
		--     }
		--     break
		--   }
		--   case HostComponent: {
		--     local parentType = returnFiber.type
		--     local parentProps = returnFiber.memoizedProps
		--     local parentInstance = returnFiber.stateNode
		--     switch (fiber.tag)
		--       case HostComponent:
		--         local type = fiber.type
		--         local props = fiber.pendingProps
		--         didNotFindHydratableInstance(
		--           parentType,
		--           parentProps,
		--           parentInstance,
		--           type,
		--           props,
		--         )
		--         break
		--       case HostText:
		--         local text = fiber.pendingProps
		--         didNotFindHydratableTextInstance(
		--           parentType,
		--           parentProps,
		--           parentInstance,
		--           text,
		--         )
		--         break
		--       case SuspenseComponent:
		--         didNotFindHydratableSuspenseInstance(
		--           parentType,
		--           parentProps,
		--           parentInstance,
		--         )
		--         break
		--     }
		--     break
		--   }
		--   default:
		--     return
		-- end
	end
end

function tryHydrate(fiber, nextInstance)
	if fiber.tag == HostComponent then
		local type_ = fiber.type
		local props = fiber.pendingProps
		local instance = canHydrateInstance(nextInstance, type_, props)
		if instance ~= nil then
			fiber.stateNode = instance
			return true
		end
		return false
	elseif fiber.tag == HostText then
		local text = fiber.pendingProps
		local textInstance = canHydrateTextInstance(nextInstance, text)
		if textInstance ~= nil then
			fiber.stateNode = textInstance
			return true
		end
		return false
	elseif fiber.tag == SuspenseComponent then
		if enableSuspenseServerRenderer then
			local suspenseInstance: nil | SuspenseInstance = canHydrateSuspenseInstance(nextInstance)
			if suspenseInstance ~= nil then
				local suspenseState: SuspenseState = {
					dehydrated = suspenseInstance,
					retryLane = OffscreenLane,
				}
				fiber.memoizedState = suspenseState
				-- Store the dehydrated fragment as a child fiber.
				-- This simplifies the code for getHostSibling and deleting nodes,
				-- since it doesn't have to consider all Suspense boundaries and
				-- check if they're dehydrated ones or not.
				local dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance)
				dehydratedFragment.return_ = fiber
				fiber.child = dehydratedFragment
				return true
			end
		end
		return false
	else
		return false
	end
end

function tryToClaimNextHydratableInstance(fiber: Fiber)
	if not isHydrating then
		return
	end
	local nextInstance = nextHydratableInstance
	if not nextInstance then
		-- Nothing to hydrate. Make it an insertion.
		insertNonHydratedInstance(hydrationParentFiber, fiber)
		isHydrating = false
		hydrationParentFiber = fiber
		return
	end
	-- FIXME Luau: Luau doesn't narrow based on the guard above
	local firstAttemptedInstance = nextInstance :: HydratableInstance
	if not tryHydrate(fiber, nextInstance) then
		-- If we can't hydrate this instance let's try the next one.
		-- We use this as a heuristic. It's based on intuition and not data so it
		-- might be flawed or unnecessary.
		nextInstance = getNextHydratableSibling(firstAttemptedInstance)
		if not nextInstance or not tryHydrate(fiber, nextInstance) then
			-- Nothing to hydrate. Make it an insertion.
			insertNonHydratedInstance(hydrationParentFiber, fiber)
			isHydrating = false
			hydrationParentFiber = fiber
			return
		end
		-- We matched the next one, we'll now assume that the first one was
		-- superfluous and we'll delete it. Since we can't eagerly delete it
		-- we'll have to schedule a deletion. To do that, this node needs a dummy
		-- fiber associated with it.
		deleteHydratableInstance(hydrationParentFiber, firstAttemptedInstance)
	end
	hydrationParentFiber = fiber
	nextHydratableInstance = getFirstHydratableChild(nextInstance)
end

function prepareToHydrateHostInstance(fiber: Fiber, rootContainerInstance: Container, hostContext: HostContext): boolean
	if not supportsHydration then
		invariant(
			false,
			"Expected prepareToHydrateHostInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end

	local instance: Instance = fiber.stateNode
	local updatePayload =
		hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber)
	-- TODO: Type this specific to this type of component.
	fiber.updateQueue = updatePayload
	-- If the update payload indicates that there is a change or if there
	-- is a new ref we mark this as an update.
	if updatePayload ~= nil then
		return true
	end
	return false
end

function prepareToHydrateHostTextInstance(fiber: Fiber): boolean
	if not supportsHydration then
		invariant(
			false,
			"Expected prepareToHydrateHostTextInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end

	local textInstance: TextInstance = fiber.stateNode
	local textContent: string = fiber.memoizedProps
	local shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber)
	if _G.__DEV__ then
		if shouldUpdate then
			-- We assume that prepareToHydrateHostTextInstance is called in a context where the
			-- hydration parent is the parent host component of this host text.
			local returnFiber = hydrationParentFiber
			if returnFiber ~= nil then
				if returnFiber.tag == HostRoot then
					local parentContainer = returnFiber.stateNode.containerInfo
					didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent)
				elseif returnFiber.tag == HostComponent then
					local parentType = returnFiber.type
					local parentProps = returnFiber.memoizedProps
					local parentInstance = returnFiber.stateNode
					didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent)
				end
			end
		end
	end
	return shouldUpdate
end

function prepareToHydrateHostSuspenseInstance(fiber: Fiber)
	if not supportsHydration then
		invariant(
			false,
			"Expected prepareToHydrateHostSuspenseInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end

	local suspenseState: SuspenseState = fiber.memoizedState
	local suspenseInstance: nil | SuspenseInstance
	if suspenseState ~= nil then
		suspenseInstance = suspenseState.dehydrated
	else
		suspenseInstance = nil
	end

	invariant(
		suspenseInstance,
		"Expected to have a hydrated suspense instance. "
			.. "This error is likely caused by a bug in React. Please file an issue."
	)
	hydrateSuspenseInstance(suspenseInstance, fiber)
end

function skipPastDehydratedSuspenseInstance(fiber: Fiber): nil | HydratableInstance
	if not supportsHydration then
		invariant(
			false,
			"Expected skipPastDehydratedSuspenseInstance() to never be called. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end
	local suspenseState: SuspenseState = fiber.memoizedState
	local suspenseInstance: nil | SuspenseInstance
	if suspenseState ~= nil then
		suspenseInstance = suspenseState.dehydrated
	else
		suspenseInstance = nil
	end
	invariant(
		suspenseInstance,
		"Expected to have a hydrated suspense instance. "
			.. "This error is likely caused by a bug in React. Please file an issue."
	)
	return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance)
end

function popToNextHostParent(fiber: Fiber)
	local parent = fiber.return_
	while
		parent ~= nil
		and parent.tag ~= HostComponent
		and parent.tag ~= HostRoot
		and parent.tag ~= SuspenseComponent
	do
		parent = parent.return_
	end
	hydrationParentFiber = parent
end

function popHydrationState(fiber: Fiber): boolean
	if not supportsHydration then
		return false
	end
	if fiber ~= hydrationParentFiber then
		-- We're deeper than the current hydration context, inside an inserted
		-- tree.
		return false
	end
	if not isHydrating then
		-- If we're not currently hydrating but we're in a hydration context, then
		-- we were an insertion and now need to pop up reenter hydration of our
		-- siblings.
		popToNextHostParent(fiber)
		isHydrating = true
		return false
	end

	local type_ = fiber.type

	-- If we have any remaining hydratable nodes, we need to delete them now.
	-- We only do this deeper than head and body since they tend to have random
	-- other nodes in them. We also ignore components with pure text content in
	-- side of them.
	-- TODO: Better heuristic.
	if
		fiber.tag ~= HostComponent
		or (type_ ~= "head" and type_ ~= "body" and not shouldSetTextContent(type_, fiber.memoizedProps))
	then
		local nextInstance = nextHydratableInstance
		while nextInstance do
			deleteHydratableInstance(fiber, nextInstance)
			nextInstance = getNextHydratableSibling(nextInstance)
		end
	end

	popToNextHostParent(fiber)
	if fiber.tag == SuspenseComponent then
		nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber)
	else
		if hydrationParentFiber then
			nextHydratableInstance = getNextHydratableSibling(fiber.stateNode)
		else
			nextHydratableInstance = nil
		end
	end
	return true
end

function resetHydrationState()
	if not supportsHydration then
		return
	end

	hydrationParentFiber = nil
	nextHydratableInstance = nil
	isHydrating = false
end

function getIsHydrating(): boolean
	return isHydrating
end

return {
	warnIfHydrating = warnIfHydrating,
	enterHydrationState = enterHydrationState,
	getIsHydrating = getIsHydrating,
	reenterHydrationStateFromDehydratedSuspenseInstance = reenterHydrationStateFromDehydratedSuspenseInstance,
	resetHydrationState = resetHydrationState,
	tryToClaimNextHydratableInstance = tryToClaimNextHydratableInstance,
	prepareToHydrateHostInstance = prepareToHydrateHostInstance,
	prepareToHydrateHostTextInstance = prepareToHydrateHostTextInstance,
	prepareToHydrateHostSuspenseInstance = prepareToHydrateHostSuspenseInstance,
	popHydrationState = popHydrationState,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006112</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE3E5573223994F9C8790EBCF707788B1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberLane</string>
								<string name="ScriptGuid">{200BC40E-1AD9-4396-9EFC-91FF3D42E9E0}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/6f62abb58ae46d9c88525635f1790487285666e6/packages/react-reconciler/src/ReactFiberLane.js
--!strict
--[[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local Packages = script.Parent.Parent
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local console = require(Packages.Shared).console

local ReactFiberSchedulerPriorities = require(script.Parent["ReactFiberSchedulerPriorities.roblox"])

-- deviation: Instead of defining these here, and and re-exporting in
-- `ReactInternalTypes`, we depend on and re-export them here to avoid cyclical
-- require issues
export type LanePriority = ReactInternalTypes.LanePriority
export type Lane = ReactInternalTypes.Lane
export type Lanes = ReactInternalTypes.Lanes
export type LaneMap<T> = ReactInternalTypes.LaneMap<T>

local invariant = require(Packages.Shared).invariant

local ImmediateSchedulerPriority = ReactFiberSchedulerPriorities.ImmediatePriority
local UserBlockingSchedulerPriority = ReactFiberSchedulerPriorities.UserBlockingPriority
local NormalSchedulerPriority = ReactFiberSchedulerPriorities.NormalPriority
local LowSchedulerPriority = ReactFiberSchedulerPriorities.LowPriority
local IdleSchedulerPriority = ReactFiberSchedulerPriorities.IdlePriority
local NoSchedulerPriority = ReactFiberSchedulerPriorities.NoPriority

local exports = {}

local SyncLanePriority: LanePriority = 15
exports.SyncLanePriority = SyncLanePriority
local SyncBatchedLanePriority: LanePriority = 14
exports.SyncBatchedLanePriority = SyncBatchedLanePriority

local InputDiscreteHydrationLanePriority: LanePriority = 13
local InputDiscreteLanePriority: LanePriority = 12
exports.InputDiscreteLanePriority = InputDiscreteLanePriority

local InputContinuousHydrationLanePriority: LanePriority = 11
local InputContinuousLanePriority: LanePriority = 10
exports.InputContinuousLanePriority = InputContinuousLanePriority

local DefaultHydrationLanePriority: LanePriority = 9
local DefaultLanePriority: LanePriority = 8
exports.DefaultLanePriority = DefaultLanePriority

local TransitionHydrationPriority: LanePriority = 7
local TransitionPriority: LanePriority = 6
exports.TransitionPriority = TransitionPriority

local RetryLanePriority: LanePriority = 5

local SelectiveHydrationLanePriority: LanePriority = 4

local IdleHydrationLanePriority: LanePriority = 3
local IdleLanePriority: LanePriority = 2

local OffscreenLanePriority: LanePriority = 1

local NoLanePriority: LanePriority = 0
exports.NoLanePriority = NoLanePriority

-- performance: only use was for loop that was manually unrolled
-- local TotalLanes = 31

local NoLanes: Lanes = --[[                             ]]
	0b0000000000000000000000000000000
exports.NoLanes = NoLanes
local NoLane: Lane = --[[                               ]]
	0b0000000000000000000000000000000
exports.NoLane = NoLane

local SyncLane: Lane = --[[                             ]]
	0b0000000000000000000000000000001
exports.SyncLane = SyncLane
local SyncBatchedLane: Lanes = --[[                     ]]
	0b0000000000000000000000000000010
exports.SyncBatchedLane = SyncBatchedLane

local InputDiscreteHydrationLane: Lane = --[[           ]]
	0b0000000000000000000000000000100
exports.InputDiscreteHydrationLane = InputDiscreteHydrationLane
local InputDiscreteLanes: Lanes = --[[                  ]]
	0b0000000000000000000000000011000

local InputContinuousHydrationLane: Lane = --[[         ]]
	0b0000000000000000000000000100000
local InputContinuousLanes: Lanes = --[[                ]]
	0b0000000000000000000000011000000

local DefaultHydrationLane: Lane = --[[                 ]]
	0b0000000000000000000000100000000
exports.DefaultHydrationLane = DefaultHydrationLane
local DefaultLanes: Lanes = --[[                        ]]
	0b0000000000000000000111000000000
exports.DefaultLanes = DefaultLanes

local TransitionHydrationLane: Lane = --[[              ]]
	0b0000000000000000001000000000000
local TransitionLanes: Lanes = --[[                     ]]
	0b0000000001111111110000000000000

local RetryLanes: Lanes = --[[                          ]]
	0b0000011110000000000000000000000
-- deviation: we expose this symbol from the module for ReactUpdateQueue.roblox tests, we don't re-export outside the package
exports.RetryLanes = RetryLanes
local SomeRetryLane: Lanes = --[[                       ]]
	0b0000010000000000000000000000000
exports.SomeRetryLane = SomeRetryLane

local SelectiveHydrationLane: Lane = --[[               ]]
	0b0000100000000000000000000000000
exports.SelectiveHydrationLane = SelectiveHydrationLane

local NonIdleLanes = --[[                               ]]
	0b0000111111111111111111111111111

local IdleHydrationLane: Lane = --[[                    ]]
	0b0001000000000000000000000000000
exports.IdleHydrationLane = IdleHydrationLane
local IdleLanes: Lanes = --[[                           ]]
	0b0110000000000000000000000000000

local OffscreenLane: Lane = --[[                        ]]
	0b1000000000000000000000000000000
exports.OffscreenLane = OffscreenLane

local NoTimestamp = -1
exports.NoTimestamp = NoTimestamp

local currentUpdateLanePriority: LanePriority = exports.NoLanePriority

exports.getCurrentUpdateLanePriority = function(): LanePriority
	return currentUpdateLanePriority
end

exports.setCurrentUpdateLanePriority = function(newLanePriority: LanePriority)
	currentUpdateLanePriority = newLanePriority
end

-- // "Registers" used to "return" multiple values
-- // Used by getHighestPriorityLanes and getNextLanes:
local return_highestLanePriority: LanePriority = exports.DefaultLanePriority

local function getHighestPriorityLanes(lanes: Lanes | Lane): Lanes
	if bit32.band(SyncLane, lanes) ~= NoLanes then
		return_highestLanePriority = SyncLanePriority
		return SyncLane
	end
	if bit32.band(SyncBatchedLane, lanes) ~= NoLanes then
		return_highestLanePriority = SyncBatchedLanePriority
		return SyncBatchedLane
	end
	if bit32.band(InputDiscreteHydrationLane, lanes) ~= NoLanes then
		return_highestLanePriority = InputDiscreteHydrationLanePriority
		return InputDiscreteHydrationLane
	end
	local inputDiscreteLanes = bit32.band(InputDiscreteLanes, lanes)
	if inputDiscreteLanes ~= NoLanes then
		return_highestLanePriority = InputDiscreteLanePriority
		return inputDiscreteLanes
	end
	if bit32.band(lanes, InputContinuousHydrationLane) ~= NoLanes then
		return_highestLanePriority = InputContinuousHydrationLanePriority
		return InputContinuousHydrationLane
	end
	local inputContinuousLanes = bit32.band(InputContinuousLanes, lanes)
	if inputContinuousLanes ~= NoLanes then
		return_highestLanePriority = InputContinuousLanePriority
		return inputContinuousLanes
	end
	if bit32.band(lanes, DefaultHydrationLane) ~= NoLanes then
		return_highestLanePriority = DefaultHydrationLanePriority
		return DefaultHydrationLane
	end
	local defaultLanes = bit32.band(DefaultLanes, lanes)
	if defaultLanes ~= NoLanes then
		return_highestLanePriority = DefaultLanePriority
		return defaultLanes
	end
	if bit32.band(lanes, TransitionHydrationLane) ~= NoLanes then
		return_highestLanePriority = TransitionHydrationPriority
		return TransitionHydrationLane
	end
	local transitionLanes = bit32.band(TransitionLanes, lanes)
	if transitionLanes ~= NoLanes then
		return_highestLanePriority = TransitionPriority
		return transitionLanes
	end
	local retryLanes = bit32.band(RetryLanes, lanes)
	if retryLanes ~= NoLanes then
		return_highestLanePriority = RetryLanePriority
		return retryLanes
	end
	if bit32.band(lanes, SelectiveHydrationLane) ~= 0 then
		return_highestLanePriority = SelectiveHydrationLanePriority
		return SelectiveHydrationLane
	end
	if bit32.band(lanes, IdleHydrationLane) ~= NoLanes then
		return_highestLanePriority = IdleHydrationLanePriority
		return IdleHydrationLane
	end
	local idleLanes = bit32.band(IdleLanes, lanes)
	if idleLanes ~= NoLanes then
		return_highestLanePriority = IdleLanePriority
		return idleLanes
	end
	if bit32.band(OffscreenLane, lanes) ~= NoLanes then
		return_highestLanePriority = OffscreenLanePriority
		return OffscreenLane
	end
	if _G.__DEV__ then
		console.error("Should have found matching lanes. This is a bug in React.")
	end
	-- // This shouldn't be reachable, but as a fallback, return the entire bitmask.
	return_highestLanePriority = DefaultLanePriority
	return lanes
end

local function schedulerPriorityToLanePriority(schedulerPriorityLevel: ReactPriorityLevel): LanePriority
	if schedulerPriorityLevel == ImmediateSchedulerPriority then
		return SyncLanePriority
	elseif schedulerPriorityLevel == UserBlockingSchedulerPriority then
		return InputContinuousLanePriority
	elseif schedulerPriorityLevel == NormalSchedulerPriority or schedulerPriorityLevel == LowSchedulerPriority then
		-- // TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.
		return DefaultLanePriority
	elseif schedulerPriorityLevel == IdleSchedulerPriority then
		return IdleLanePriority
	else
		return NoLanePriority
	end
end
exports.schedulerPriorityToLanePriority = schedulerPriorityToLanePriority

local function lanePriorityToSchedulerPriority(lanePriority: LanePriority): ReactPriorityLevel
	if lanePriority == SyncLanePriority or lanePriority == SyncBatchedLanePriority then
		return ImmediateSchedulerPriority
	elseif
		lanePriority == InputDiscreteHydrationLanePriority
		or lanePriority == InputDiscreteLanePriority
		or lanePriority == InputContinuousHydrationLanePriority
		or lanePriority == InputContinuousLanePriority
	then
		return UserBlockingSchedulerPriority
	elseif
		lanePriority == DefaultHydrationLanePriority
		or lanePriority == DefaultLanePriority
		or lanePriority == TransitionHydrationPriority
		or lanePriority == TransitionPriority
		or lanePriority == SelectiveHydrationLanePriority
		or lanePriority == RetryLanePriority
	then
		return NormalSchedulerPriority
	elseif
		lanePriority == IdleHydrationLanePriority
		or lanePriority == IdleLanePriority
		or lanePriority == OffscreenLanePriority
	then
		return IdleSchedulerPriority
	elseif lanePriority == NoLanePriority then
		return NoSchedulerPriority
	else
		invariant(false, "Invalid update priority: %s. This is a bug in React.", lanePriority)
		-- deviation: luau doesn't know that invariant throws, so we error
		error("unreachable")
	end
end
exports.lanePriorityToSchedulerPriority = lanePriorityToSchedulerPriority

-- deviation: pre-declare pickArbitraryLaneIndex to keep ordering
local pickArbitraryLaneIndex, getLowestPriorityLane, getEqualOrHigherPriorityLanes

local function getNextLanes(root: FiberRoot, wipLanes: Lanes): Lanes
	-- // Early bailout if there's no pending work left.
	local pendingLanes = root.pendingLanes
	if pendingLanes == NoLanes then
		return_highestLanePriority = NoLanePriority
		return NoLanes
	end

	local nextLanes = NoLanes
	local nextLanePriority = NoLanePriority

	local expiredLanes = root.expiredLanes
	local suspendedLanes = root.suspendedLanes
	local pingedLanes = root.pingedLanes

	-- // Check if any work has expired.
	if expiredLanes ~= NoLanes then
		nextLanes = expiredLanes
		return_highestLanePriority = SyncLanePriority
		nextLanePriority = SyncLanePriority
	else
		-- // Do not work on any idle work until all the non-idle work has finished,
		-- // even if the work is suspended.
		local nonIdlePendingLanes = bit32.band(pendingLanes, NonIdleLanes)
		if nonIdlePendingLanes ~= NoLanes then
			local nonIdleUnblockedLanes = bit32.band(nonIdlePendingLanes, bit32.bnot(suspendedLanes))
			if nonIdleUnblockedLanes ~= NoLanes then
				nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes)
				nextLanePriority = return_highestLanePriority
			else
				local nonIdlePingedLanes = bit32.band(nonIdlePendingLanes, pingedLanes)
				if nonIdlePingedLanes ~= NoLanes then
					nextLanes = getHighestPriorityLanes(nonIdlePingedLanes)
					nextLanePriority = return_highestLanePriority
				end
			end
		else
			-- // The only remaining work is Idle.
			local unblockedLanes = bit32.band(pendingLanes, bit32.bnot(suspendedLanes))
			if unblockedLanes ~= NoLanes then
				nextLanes = getHighestPriorityLanes(unblockedLanes)
				nextLanePriority = return_highestLanePriority
			else
				if pingedLanes ~= NoLanes then
					nextLanes = getHighestPriorityLanes(pingedLanes)
					nextLanePriority = return_highestLanePriority
				end
			end
		end
	end

	if nextLanes == NoLanes then
		-- // This should only be reachable if we're suspended
		-- // TODO: Consider warning in this path if a fallback timer is not scheduled.
		return NoLanes
	end

	-- // If there are higher priority lanes, we'll include them even if they
	-- // are suspended.
	-- performance: inline getEqualOrHigherPriorityLanes to avoid function call overhead in hot path
	-- nextLanes = bit32.band(pendingLanes, getEqualOrHigherPriorityLanes(nextLanes))
	nextLanes = bit32.band(pendingLanes, bit32.lshift(getLowestPriorityLane(nextLanes), 1) - 1)

	-- // If we're already in the middle of a render, switching lanes will interrupt
	-- // it and we'll lose our progress. We should only do this if the new lanes are
	-- // higher priority.
	if
		wipLanes ~= NoLanes
		and wipLanes ~= nextLanes
		-- // If we already suspended with a delay, then interrupting is fine. Don't
		-- // bother waiting until the root is complocale.
		and bit32.band(wipLanes, suspendedLanes) == NoLanes
	then
		getHighestPriorityLanes(wipLanes)
		local wipLanePriority = return_highestLanePriority
		if nextLanePriority <= wipLanePriority then
			return wipLanes
		else
			return_highestLanePriority = nextLanePriority
		end
	end

	-- // Check for entangled lanes and add them to the batch.
	-- //
	-- // A lane is said to be entangled with another when it's not allowed to render
	-- // in a batch that does not also include the other lane. Typically we do this
	-- // when multiple updates have the same source, and we only want to respond to
	-- // the most recent event from that source.
	-- //
	-- // Note that we apply entanglements *after* checking for partial work above.
	-- // This means that if a lane is entangled during an interleaved event while
	-- // it's already rendering, we won't interrupt it. This is intentional, since
	-- // entanglement is usually "best effort": we'll try our best to render the
	-- // lanes in the same batch, but it's not worth throwing out partially
	-- // complocaled work in order to do it.
	-- //
	-- // For those exceptions where entanglement is semantically important, like
	-- // useMutableSource, we should ensure that there is no partial work at the
	-- // time we apply the entanglement.
	local entangledLanes = root.entangledLanes
	if entangledLanes ~= NoLanes then
		local entanglements = root.entanglements
		local lanes = bit32.band(nextLanes, entangledLanes)
		while lanes > 0 do
			local index = pickArbitraryLaneIndex(lanes)
			local lane = bit32.lshift(1, index)

			nextLanes = bit32.bor(nextLanes, entanglements[index])

			lanes = bit32.band(lanes, bit32.bnot(lane))
		end
	end

	return nextLanes
end
exports.getNextLanes = getNextLanes

local function getMostRecentEventTime(root: FiberRoot, lanes: Lanes): number
	local eventTimes = root.eventTimes

	local mostRecentEventTime = NoTimestamp
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		local eventTime = eventTimes[index]
		if eventTime > mostRecentEventTime then
			mostRecentEventTime = eventTime
		end

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end

	return mostRecentEventTime
end
exports.getMostRecentEventTime = getMostRecentEventTime

local function computeExpirationTime(lane: Lane, currentTime: number)
	-- // TODO: Expiration heuristic is constant per lane, so could use a map.
	getHighestPriorityLanes(lane)
	local priority = return_highestLanePriority
	if priority >= InputContinuousLanePriority then
		-- // User interactions should expire slightly more quickly.
		-- //
		-- // NOTE: This is set to the corresponding constant as in Scheduler.js. When
		-- // we made it larger, a product metric in www regressed, suggesting there's
		-- // a user interaction that's being starved by a series of synchronous
		-- // updates. If that theory is correct, the proper solution is to fix the
		-- // starvation. However, this scenario supports the idea that expiration
		-- // times are an important safeguard when starvation does happen.
		-- //
		-- // Also note that, in the case of user input specifically, this will soon no
		-- // longer be an issue because we plan to make user input synchronous by
		-- // default (until you enter `startTransition`, of course.)
		-- //
		-- // If weren't planning to make these updates synchronous soon anyway, I
		-- // would probably make this number a configurable parameter.
		return currentTime + 250
	elseif priority >= TransitionPriority then
		return currentTime + 5000
	else
		-- // Anything idle priority or lower should never expire.
		return NoTimestamp
	end
end
exports.computeExpirationTime = computeExpirationTime

local function markStarvedLanesAsExpired(root: FiberRoot, currentTime: number)
	-- // TODO: This gets called every time we yield. We can optimize by storing
	-- // the earliest expiration time on the root. Then use that to quickly bail out
	-- // of this function.

	local pendingLanes = root.pendingLanes
	local suspendedLanes = root.suspendedLanes
	local pingedLanes = root.pingedLanes
	local expirationTimes = root.expirationTimes

	-- // Iterate through the pending lanes and check if we've reached their
	-- // expiration time. If so, we'll assume the update is being starved and mark
	-- // it as expired to force it to finish.
	local lanes = pendingLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		local expirationTime = expirationTimes[index]
		if expirationTime == NoTimestamp then
			-- // Found a pending lane with no expiration time. If it's not suspended, or
			-- // if it's pinged, assume it's CPU-bound. Compute a new expiration time
			-- // using the current time.
			if bit32.band(lane, suspendedLanes) == NoLanes or bit32.band(lane, pingedLanes) ~= NoLanes then
				-- // Assumes timestamps are monotonically increasing.
				expirationTimes[index] = computeExpirationTime(lane, currentTime)
			end
		elseif expirationTime <= currentTime then
			-- // This lane expired
			root.expiredLanes = bit32.bor(root.expiredLanes, lane)
		end

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markStarvedLanesAsExpired = markStarvedLanesAsExpired

-- // This returns the highest priority pending lanes regardless of whether they
-- // are suspended.
local function getHighestPriorityPendingLanes(root: FiberRoot)
	return getHighestPriorityLanes(root.pendingLanes)
end
exports.getHighestPriorityPendingLanes = getHighestPriorityPendingLanes

local function getLanesToRetrySynchronouslyOnError(root: FiberRoot): Lanes
	local everythingButOffscreen = bit32.band(root.pendingLanes, bit32.bnot(OffscreenLane))
	if everythingButOffscreen ~= NoLanes then
		return everythingButOffscreen
	end
	if bit32.band(everythingButOffscreen, OffscreenLane) ~= 0 then
		return OffscreenLane
	end
	return NoLanes
end
exports.getLanesToRetrySynchronouslyOnError = getLanesToRetrySynchronouslyOnError

local function returnNextLanesPriority()
	return return_highestLanePriority
end
exports.returnNextLanesPriority = returnNextLanesPriority

local function includesNonIdleWork(lanes: Lanes)
	return bit32.band(lanes, NonIdleLanes) ~= NoLanes
end
exports.includesNonIdleWork = includesNonIdleWork

local function includesOnlyRetries(lanes: Lanes)
	return bit32.band(lanes, RetryLanes) == lanes
end
exports.includesOnlyRetries = includesOnlyRetries

local function includesOnlyTransitions(lanes: Lanes)
	return bit32.band(lanes, TransitionLanes) == lanes
end
exports.includesOnlyTransitions = includesOnlyTransitions

-- deviation: pre-declare pickArbitraryLane to keep ordering
local pickArbitraryLane

-- // To ensure consistency across multiple updates in the same event, this should
-- // be a pure function, so that it always returns the same lane for given inputs.
local function findUpdateLane(lanePriority: LanePriority, wipLanes: Lanes): Lane
	if lanePriority == NoLanePriority then
		-- break
	elseif lanePriority == SyncLanePriority then
		return SyncLane
	elseif lanePriority == SyncBatchedLanePriority then
		return SyncBatchedLane
	elseif lanePriority == InputDiscreteLanePriority then
		local lane = pickArbitraryLane(bit32.band(InputDiscreteLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // Shift to the next priority level
			return findUpdateLane(InputContinuousLanePriority, wipLanes)
		end
		return lane
	elseif lanePriority == InputContinuousLanePriority then
		local lane = pickArbitraryLane(bit32.band(InputContinuousLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // Shift to the next priority level
			return findUpdateLane(DefaultLanePriority, wipLanes)
		end
		return lane
	elseif lanePriority == DefaultLanePriority then
		local lane = pickArbitraryLane(bit32.band(DefaultLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // If all the default lanes are already being worked on, look for a
			-- // lane in the transition range.
			lane = pickArbitraryLane(bit32.band(TransitionLanes, bit32.bnot(wipLanes)))
			if lane == NoLane then
				-- // All the transition lanes are taken, too. This should be very
				-- // rare, but as a last resort, pick a default lane. This will have
				-- // the effect of interrupting the current work-in-progress render.
				lane = pickArbitraryLane(DefaultLanes)
			end
		end
		return lane
	elseif
		lanePriority == TransitionPriority -- // Should be handled by findTransitionLane instead
		or lanePriority == RetryLanePriority -- // Should be handled by findRetryLane instead
	then
		-- break
	elseif lanePriority == IdleLanePriority then
		local lane = pickArbitraryLane(bit32.band(IdleLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			lane = pickArbitraryLane(IdleLanes)
		end
		return lane
	else
		-- // The remaining priorities are not valid for updates
	end
	invariant(false, "Invalid update priority: %s. This is a bug in React.", lanePriority)
	-- deviation: luau doesn't know that invariant throws, so we error
	error("unreachable")
end
exports.findUpdateLane = findUpdateLane

-- // To ensure consistency across multiple updates in the same event, this should
-- // be pure function, so that it always returns the same lane for given inputs.
local function findTransitionLane(wipLanes: Lanes, pendingLanes: Lanes): Lane
	-- // First look for lanes that are completely unclaimed, i.e. have no
	-- // pending work.
	local lane = pickArbitraryLane(bit32.band(TransitionLanes, bit32.bnot(pendingLanes)))
	if lane == NoLane then
		-- // If all lanes have pending work, look for a lane that isn't currently
		-- // being worked on.
		lane = pickArbitraryLane(bit32.band(TransitionLanes, bit32.bnot(wipLanes)))
		if lane == NoLane then
			-- // If everything is being worked on, pick any lane. This has the
			-- // effect of interrupting the current work-in-progress.
			lane = pickArbitraryLane(TransitionLanes)
		end
	end
	return lane
end
exports.findTransitionLane = findTransitionLane

-- // To ensure consistency across multiple updates in the same event, this should
-- // be pure function, so that it always returns the same lane for given inputs.
local function findRetryLane(wipLanes: Lanes): Lane
	-- // This is a fork of `findUpdateLane` designed specifically for Suspense
	-- // "retries" — a special update that attempts to flip a Suspense boundary
	-- // from its placeholder state to its primary/resolved state.
	local lane = pickArbitraryLane(bit32.band(RetryLanes, bit32.bnot(wipLanes)))
	if lane == NoLane then
		lane = pickArbitraryLane(RetryLanes)
	end
	return lane
end
exports.findRetryLane = findRetryLane

local function getHighestPriorityLane(lanes: Lanes)
	return bit32.band(lanes, -lanes)
end

function getLowestPriorityLane(lanes: Lanes): Lane
	-- // This finds the most significant non-zero bit.
	local index = 31 - bit32.countlz(lanes)
	if index < 0 then
		return NoLanes
	else
		return bit32.lshift(1, index)
	end
end

function getEqualOrHigherPriorityLanes(lanes: Lanes | Lane): Lanes
	return bit32.lshift(getLowestPriorityLane(lanes), 1) - 1
end

function pickArbitraryLane(lanes: Lanes): Lane
	-- // This wrapper function gets inlined. Only exists so to communicate that it
	-- // doesn't matter which bit is selected; you can pick any bit without
	-- // affecting the algorithms where its used. Here I'm using
	-- // getHighestPriorityLane because it requires the fewest operations.
	return getHighestPriorityLane(lanes)
end
exports.pickArbitraryLane = pickArbitraryLane

function pickArbitraryLaneIndex(lanes: Lanes)
	return 31 - bit32.countlz(lanes)
end

-- performance: all uses have been inlined
-- local function laneToIndex(lane: Lane)
-- 	return pickArbitraryLaneIndex(lane)
-- end

local function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane)
	return bit32.band(a, b) ~= NoLanes
end
exports.includesSomeLane = includesSomeLane

local function isSubsetOfLanes(set: Lanes, subset: Lanes | Lane)
	return bit32.band(set, subset) == subset
end
exports.isSubsetOfLanes = isSubsetOfLanes

local function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes
	return bit32.bor(a, b)
end
exports.mergeLanes = mergeLanes

local function removeLanes(set: Lanes, subset: Lanes | Lane): Lanes
	return bit32.band(set, bit32.bnot(subset))
end
exports.removeLanes = removeLanes

-- // Seems redundant, but it changes the type from a single lane (used for
-- // updates) to a group of lanes (used for flushing work).
local function laneToLanes(lane: Lane): Lanes
	return lane
end
exports.laneToLanes = laneToLanes

local function higherPriorityLane(a: Lane, b: Lane)
	-- // This works because the bit ranges decrease in priority as you go left.
	if a ~= NoLane and b ~= NoLane then
		if a < b then
			return a
		end
		return b
	else
		if a ~= NoLane then
			return a
		end
		return b
	end
end
exports.higherPriorityLane = higherPriorityLane

local function higherLanePriority(a: LanePriority, b: LanePriority): LanePriority
	if a ~= NoLanePriority and a > b then
		return a
	else
		return b
	end
end
exports.higherLanePriority = higherLanePriority

-- deviation: luau does not support generic functions yet
-- local function createLaneMap<T>(initial: T): LaneMap<T>
local function createLaneMap(initial): LaneMap<any>
	-- // Intentionally pushing one by one.
	-- // https://v8.dev/blog/elements-kinds#avoid-creating-holes
	-- performance: manually unroll this loop so the table creation is a one-shot
	--for i = 0, TotalLanes do
	local laneMap = {
		[0] = initial,
		[1] = initial,
		[2] = initial,
		[3] = initial,
		[4] = initial,
		[5] = initial,
		[6] = initial,
		[7] = initial,
		[8] = initial,
		[9] = initial,
		[10] = initial,
		[11] = initial,
		[12] = initial,
		[13] = initial,
		[14] = initial,
		[15] = initial,
		[16] = initial,
		[17] = initial,
		[18] = initial,
		[19] = initial,
		[20] = initial,
		[21] = initial,
		[22] = initial,
		[23] = initial,
		[24] = initial,
		[25] = initial,
		[26] = initial,
		[27] = initial,
		[28] = initial,
		[29] = initial,
		[30] = initial,
		[31] = initial,
		-- TODO: must be updated when TotalLanes is updated!
	}
	return laneMap
end
exports.createLaneMap = createLaneMap

local function markRootUpdated(root: FiberRoot, updateLane: Lane, eventTime: number)
	root.pendingLanes = bit32.bor(root.pendingLanes, updateLane)

	-- // TODO: Theoretically, any update to any lane can unblock any other lane. But
	-- // it's not practical to try every single possible combination. We need a
	-- // heuristic to decide which lanes to attempt to render, and in which batches.
	-- // For now, we use the same heuristic as in the old ExpirationTimes model:
	-- // retry any lane at equal or lower priority, but don't try updates at higher
	-- // priority without also including the lower priority updates. This works well
	-- // when considering updates across different priority levels, but isn't
	-- // sufficient for updates within the same priority, since we want to treat
	-- // those updates as parallel.

	-- // Unsuspend any update at equal or lower priority.
	local higherPriorityLanes = updateLane - 1 -- // Turns 0b1000 into 0b0111

	root.suspendedLanes = bit32.band(root.suspendedLanes, higherPriorityLanes)
	root.pingedLanes = bit32.band(root.pingedLanes, higherPriorityLanes)

	local eventTimes = root.eventTimes
	-- performance: inline laneToIndex in hot path
	-- local index = laneToIndex(updateLane)
	local index = 31 - bit32.countlz(updateLane)
	-- // We can always overwrite an existing timestamp because we prefer the most
	-- // recent event, and we assume time is monotonically increasing.
	eventTimes[index] = eventTime
end
exports.markRootUpdated = markRootUpdated

local function markRootSuspended(root: FiberRoot, suspendedLanes: Lanes)
	root.suspendedLanes = bit32.bor(root.suspendedLanes, suspendedLanes)
	root.pingedLanes = bit32.band(root.pingedLanes, bit32.bnot(suspendedLanes))

	-- // The suspended lanes are no longer CPU-bound. Clear their expiration times.
	local expirationTimes = root.expirationTimes
	local lanes = suspendedLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		expirationTimes[index] = NoTimestamp

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markRootSuspended = markRootSuspended

local function markRootPinged(root: FiberRoot, pingedLanes: Lanes, eventTime: number)
	root.pingedLanes = bit32.bor(root.pingedLanes, bit32.band(root.suspendedLanes, pingedLanes))
end
exports.markRootPinged = markRootPinged

local function markRootExpired(root: FiberRoot, expiredLanes: Lanes)
	root.expiredLanes = bit32.bor(root.expiredLanes, bit32.band(expiredLanes, root.pendingLanes))
end
exports.markRootExpired = markRootExpired

local function markDiscreteUpdatesExpired(root: FiberRoot)
	root.expiredLanes = bit32.bor(root.expiredLanes, bit32.band(InputDiscreteLanes, root.pendingLanes))
end
exports.markDiscreteUpdatesExpired = markDiscreteUpdatesExpired

local function hasDiscreteLanes(lanes: Lanes)
	return bit32.band(lanes, InputDiscreteLanes) ~= NoLanes
end
exports.hasDiscreteLanes = hasDiscreteLanes

local function markRootMutableRead(root: FiberRoot, updateLane: Lane)
	root.mutableReadLanes = bit32.bor(root.mutableReadLanes, bit32.band(updateLane, root.pendingLanes))
end
exports.markRootMutableRead = markRootMutableRead

local function markRootFinished(root: FiberRoot, remainingLanes: Lanes)
	local noLongerPendingLanes = bit32.band(root.pendingLanes, bit32.bnot(remainingLanes))

	root.pendingLanes = remainingLanes

	-- // Let's try everything again
	root.suspendedLanes = 0
	root.pingedLanes = 0

	root.expiredLanes = bit32.band(root.expiredLanes, remainingLanes)
	root.mutableReadLanes = bit32.band(root.mutableReadLanes, remainingLanes)

	root.entangledLanes = bit32.band(root.entangledLanes, remainingLanes)

	local entanglements = root.entanglements
	local eventTimes = root.eventTimes
	local expirationTimes = root.expirationTimes

	-- // Clear the lanes that no longer have pending work
	local lanes = noLongerPendingLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		entanglements[index] = NoLanes
		eventTimes[index] = NoTimestamp
		expirationTimes[index] = NoTimestamp

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markRootFinished = markRootFinished

local function markRootEntangled(root: FiberRoot, entangledLanes: Lanes)
	root.entangledLanes = bit32.bor(root.entangledLanes, entangledLanes)

	local entanglements = root.entanglements
	local lanes = entangledLanes
	while lanes > 0 do
		local index = pickArbitraryLaneIndex(lanes)
		local lane = bit32.lshift(1, index)

		entanglements[index] = bit32.bor(entanglements[index], entangledLanes)

		lanes = bit32.band(lanes, bit32.bnot(lane))
	end
end
exports.markRootEntangled = markRootEntangled

local function getBumpedLaneForHydration(root: FiberRoot, renderLanes: Lanes): Lane
	getHighestPriorityLanes(renderLanes)
	local highestLanePriority = return_highestLanePriority

	local lane

	if highestLanePriority == SyncLanePriority or highestLanePriority == SyncBatchedLanePriority then
		lane = NoLane
	elseif
		highestLanePriority == InputDiscreteHydrationLanePriority
		or highestLanePriority == InputDiscreteLanePriority
	then
		lane = InputDiscreteHydrationLane
	elseif
		highestLanePriority == InputContinuousHydrationLanePriority
		or highestLanePriority == InputContinuousLanePriority
	then
		lane = InputContinuousHydrationLane
	elseif highestLanePriority == DefaultHydrationLanePriority or highestLanePriority == DefaultLanePriority then
		lane = DefaultHydrationLane
	elseif highestLanePriority == TransitionHydrationPriority or highestLanePriority == TransitionPriority then
		lane = TransitionHydrationLane
	elseif highestLanePriority == RetryLanePriority then
		-- // Shouldn't be reachable under normal circumstances, so there's no
		-- // dedicated lane for retry priority. Use the one for long transitions.
		lane = TransitionHydrationLane
	elseif highestLanePriority == SelectiveHydrationLanePriority then
		lane = SelectiveHydrationLane
	elseif highestLanePriority == IdleHydrationLanePriority or highestLanePriority == IdleLanePriority then
		lane = IdleHydrationLane
	elseif highestLanePriority == OffscreenLanePriority or highestLanePriority == NoLanePriority then
		lane = NoLane
	else
		invariant(false, "Invalid lane: %s. This is a bug in React.", tostring(lane))
	end

	-- // Check if the lane we chose is suspended. If so, that indicates that we
	-- // already attempted and failed to hydrate at that level. Also check if we're
	-- // already rendering that lane, which is rare but could happen.
	if bit32.band(lane, bit32.bor(root.suspendedLanes, renderLanes)) ~= NoLane then
		-- // Give up trying to hydrate and fall back to client render.
		return NoLane
	end

	return lane
end
exports.getBumpedLaneForHydration = getBumpedLaneForHydration

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006113</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3CA3509A445C4A6787329AAEFB4FCA2F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberLazyComponent.new</string>
								<string name="ScriptGuid">{B844B59E-1211-44E1-BB77-3D66D913F729}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberLazyComponent.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

type Object = { [any]: any }

local function resolveDefaultProps(Component: any, baseProps: Object): Object
	-- deviation: check if type is table before checking defaultProps to prevent non-table index
	if Component and typeof(Component) == "table" and Component.defaultProps then
		-- Resolve default props. Taken from ReactElement
		-- FIXME Luau: hard cast to object until we can model this better in Luau. avoids Expected type table, got 'Object & any & any & { [any]: any }' instead
		local props = table.clone(baseProps) :: Object
		local defaultProps = Component.defaultProps
		for propName, _ in defaultProps do
			if props[propName] == nil then
				props[propName] = defaultProps[propName]
			end
		end
		return props
	end
	return baseProps
end

return {
	resolveDefaultProps = resolveDefaultProps,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006114</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX61F507DB0A6C4E43B023F14D21874607">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberNewContext.new</string>
								<string name="ScriptGuid">{0D833AE8-F6AF-4FA2-8279-4CC1307B1E3F}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/1eaafc9ade46ba708b2361b324dd907d019e3939/packages/react-reconciler/src/ReactFiberNewContext.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Number = LuauPolyfill.Number
local Error = LuauPolyfill.Error

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
type ReactContext<T> = ReactTypes.ReactContext<T>
local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type ContextDependency<T> = ReactInternalTypes.ContextDependency<T>

local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
type SharedQueue<T> = ReactUpdateQueue.SharedQueue<T>

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local isPrimaryRenderer = ReactFiberHostConfig.isPrimaryRenderer
local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop
local MAX_SIGNED_31_BIT_INT = require(script.Parent.MaxInts).MAX_SIGNED_31_BIT_INT
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ContextProvider = ReactWorkTags.ContextProvider
local ClassComponent = ReactWorkTags.ClassComponent
-- local DehydratedFragment = ReactWorkTags.DehydratedFragment
local NoLanes = ReactFiberLane.NoLanes
local NoTimestamp = ReactFiberLane.NoTimestamp
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local includesSomeLane = ReactFiberLane.includesSomeLane
local mergeLanes = ReactFiberLane.mergeLanes
local pickArbitraryLane = ReactFiberLane.pickArbitraryLane

local is = require(Packages.Shared).objectIs
local createUpdate = ReactUpdateQueue.createUpdate
local ForceUpdate = ReactUpdateQueue.ForceUpdate
-- deviation: passed in as an arg to eliminate cycle
-- local markWorkInProgressReceivedUpdate = require(script.Parent["ReactFiberBeginWork.new"]).markWorkInProgressReceivedUpdate
-- local enableSuspenseServerRenderer = require(Packages.Shared).ReactFeatureFlags.enableSuspenseServerRenderer

local exports = {}

local valueCursor: StackCursor<any> = createCursor(nil)

local rendererSigil
if _G.__DEV__ then
	-- Use this to detect multiple renderers using the same context
	rendererSigil = {}
end

local currentlyRenderingFiber: Fiber | nil = nil
local lastContextDependency: ContextDependency<any> | nil = nil
local lastContextWithAllBitsObserved: ReactContext<any> | nil = nil

local isDisallowedContextReadInDEV: boolean = false

exports.resetContextDependencies = function(): ()
	-- This is called right before React yields execution, to ensure `readContext`
	-- cannot be called outside the render phase.
	currentlyRenderingFiber = nil
	lastContextDependency = nil
	lastContextWithAllBitsObserved = nil
	if _G.__DEV__ then
		isDisallowedContextReadInDEV = false
	end
end

exports.enterDisallowedContextReadInDEV = function(): ()
	if _G.__DEV__ then
		isDisallowedContextReadInDEV = true
	end
end

exports.exitDisallowedContextReadInDEV = function(): ()
	if _G.__DEV__ then
		isDisallowedContextReadInDEV = false
	end
end

exports.pushProvider = function<T>(providerFiber: Fiber, nextValue: T): ()
	local context: ReactContext<T> = providerFiber.type._context

	if isPrimaryRenderer then
		push(valueCursor, context._currentValue, providerFiber)

		context._currentValue = nextValue
		if _G.__DEV__ then
			if context._currentRenderer ~= nil and context._currentRenderer ~= rendererSigil then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same context provider. This is currently unsupported."
				)
			end
			context._currentRenderer = rendererSigil
		end
	else
		push(valueCursor, context._currentValue2, providerFiber)

		context._currentValue2 = nextValue
		if _G.__DEV__ then
			if context._currentRenderer2 ~= nil and context._currentRenderer2 ~= rendererSigil then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same context provider. This is currently unsupported."
				)
			end
			context._currentRenderer2 = rendererSigil
		end
	end
end

exports.popProvider = function(providerFiber: Fiber)
	local currentValue = valueCursor.current

	pop(valueCursor, providerFiber)

	local context: ReactContext<any> = providerFiber.type._context
	if isPrimaryRenderer then
		context._currentValue = currentValue
	else
		context._currentValue2 = currentValue
	end
end

exports.calculateChangedBits = function<T>(context: ReactContext<T>, newValue: T, oldValue: T)
	if is(oldValue, newValue) then
		-- No change
		return 0
	else
		-- deviation: unravel ternary that's unsafe to translate
		local changedBits = MAX_SIGNED_31_BIT_INT
		if typeof(context._calculateChangedBits) == "function" then
			changedBits = context._calculateChangedBits(oldValue, newValue)
		end

		-- performance: eliminate nice-to-have compare in hot path that's removed in React 18
		-- if _G.__DEV__ then
		--   if bit32.band(changedBits, MAX_SIGNED_31_BIT_INT) ~= changedBits then
		--     console.error(
		--       "calculateChangedBits: Expected the return value to be a " ..
		--         "31-bit integer. Instead received: %s",
		--       changedBits
		--     )
		--   end
		-- end
		-- deviation: JS does a bitwise OR with 0 presumably to floor the value and
		-- coerce to an int; we just use math.floor
		return math.floor(changedBits)
	end
end

exports.scheduleWorkOnParentPath = function(parent: Fiber | nil, renderLanes: Lanes)
	-- Update the child lanes of all the ancestors, including the alternates.
	local node = parent
	while node ~= nil do
		local alternate = node.alternate
		if not isSubsetOfLanes(node.childLanes, renderLanes) then
			node.childLanes = mergeLanes(node.childLanes, renderLanes)
			if alternate ~= nil then
				alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes)
			end
		elseif alternate ~= nil and not isSubsetOfLanes(alternate.childLanes, renderLanes) then
			alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes)
		else
			-- Neither alternate was updated, which means the rest of the
			-- ancestor path already has sufficient priority.
			break
		end
		node = node.return_
	end
end

exports.propagateContextChange = function<T>(
	workInProgress: Fiber,
	context: ReactContext<T>,
	changedBits: number,
	renderLanes: Lanes
): ()
	local fiber = workInProgress.child
	if fiber ~= nil then
		-- Set the return pointer of the child to the work-in-progress fiber.
		fiber.return_ = workInProgress
	end
	while fiber ~= nil do
		local nextFiber

		-- Visit this fiber.
		local list = fiber.dependencies
		if list ~= nil then
			nextFiber = fiber.child

			local dependency = list.firstContext
			while dependency ~= nil do
				-- Check if the context matches.
				if
					dependency.context == context
					-- performance: unstable observedBits is removed in React 18
					and bit32.band(dependency.observedBits, changedBits) ~= 0
				then
					-- Match! Schedule an update on this fiber.

					if fiber.tag == ClassComponent then
						-- Schedule a force update on the work-in-progress.
						local update = createUpdate(NoTimestamp, pickArbitraryLane(renderLanes))
						update.tag = ForceUpdate
						-- TODO: Because we don't have a work-in-progress, this will add the
						-- update to the current fiber, too, which means it will persist even if
						-- this render is thrown away. Since it's a race condition, not sure it's
						-- worth fixing.

						-- Inlined `enqueueUpdate` to remove interleaved update check
						local updateQueue = fiber.updateQueue
						if updateQueue == nil then
							-- Only occurs if the fiber has been unmounted.
						else
							local sharedQueue: SharedQueue<any> = (updateQueue :: any).shared
							local pending = sharedQueue.pending
							if pending == nil then
								-- This is the first update. Create a circular list.
								update.next = update
							else
								update.next = pending.next
								pending.next = update
							end
							sharedQueue.pending = update
						end
					end

					-- performance: inline mergeLanes(fiber.lanes, renderLanes)
					fiber.lanes = bit32.bor(fiber.lanes, renderLanes)
					local alternate = fiber.alternate
					if alternate ~= nil then
						-- performance: inline mergeLanes(alternate.lanes, renderLanes)
						alternate.lanes = bit32.bor(alternate.lanes, renderLanes)
					end
					exports.scheduleWorkOnParentPath(fiber.return_, renderLanes)

					-- Mark the updated lanes on the list, too.
					-- performance: inline mergeLanes(list.lanes, renderLanes)
					list.lanes = bit32.bor(list.lanes, renderLanes)

					-- Since we already found a match, we can stop traversing the
					-- dependency list.
					break
				end
				dependency = dependency.next
			end
		elseif fiber.tag == ContextProvider then
			-- Don't scan deeper if this is a matching provider
			if fiber.type == workInProgress.type then
				nextFiber = nil
			else
				nextFiber = fiber.child
			end
			-- performance: eliminate always-false compare in tab switching hot path
			-- elseif
			--   enableSuspenseServerRenderer and
			--   fiber.tag == DehydratedFragment
			-- then
			--   -- If a dehydrated suspense boundary is in this subtree, we don't know
			--   -- if it will have any context consumers in it. The best we can do is
			--   -- mark it as having updates.
			--   local parentSuspense = fiber.return_
			--   if parentSuspense == nil then
			--     error("We just came from a parent so we must have had a parent. This is a bug in React.")
			--   end
			--   parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes)
			--   local alternate = parentSuspense.alternate
			--   if alternate ~= nil then
			--     alternate.lanes = mergeLanes(alternate.lanes, renderLanes)
			--   end
			--   -- This is intentionally passing this fiber as the parent
			--   -- because we want to schedule this fiber as having work
			--   -- on its children. We'll use the childLanes on
			--   -- this fiber to indicate that a context has changed.
			--   exports.scheduleWorkOnParentPath(parentSuspense, renderLanes)
			--   nextFiber = fiber.sibling
		else
			-- Traverse down.
			nextFiber = fiber.child
		end

		if nextFiber ~= nil then
			-- Set the return pointer of the child to the work-in-progress fiber.
			nextFiber.return_ = fiber
		else
			-- No child. Traverse to next sibling.
			nextFiber = fiber
			while nextFiber ~= nil do
				if nextFiber == workInProgress then
					-- We're back to the root of this subtree. Exit.
					nextFiber = nil
					break
				end
				local sibling = nextFiber.sibling
				if sibling ~= nil then
					-- Set the return pointer of the sibling to the work-in-progress fiber.
					sibling.return_ = nextFiber.return_
					nextFiber = sibling
					break
				end
				-- No more siblings. Traverse up.
				nextFiber = nextFiber.return_
			end
		end
		fiber = nextFiber
	end
end

-- deviation: third argument added to eliminate cycle
exports.prepareToReadContext = function(
	workInProgress: Fiber,
	renderLanes: Lanes,
	markWorkInProgressReceivedUpdate: () -> ()
): ()
	currentlyRenderingFiber = workInProgress
	lastContextDependency = nil
	lastContextWithAllBitsObserved = nil

	local dependencies = workInProgress.dependencies
	if dependencies ~= nil then
		local firstContext = dependencies.firstContext
		if firstContext ~= nil then
			if includesSomeLane(dependencies.lanes, renderLanes) then
				-- Context list has a pending update. Mark that this fiber performed work.
				markWorkInProgressReceivedUpdate()
			end
			-- Reset the work-in-progress list
			dependencies.firstContext = nil
		end
	end
end

exports.readContext = function<T>(context: ReactContext<T>, observedBits: nil | number | boolean): T
	if _G.__DEV__ then
		-- This warning would fire if you read context inside a Hook like useMemo.
		-- Unlike the class check below, it's not enforced in production for perf.
		if isDisallowedContextReadInDEV then
			console.error(
				"Context can only be read while React is rendering. "
					.. "In classes, you can read it in the render method or getDerivedStateFromProps. "
					.. "In function components, you can read it directly in the function body, but not "
					.. "inside Hooks like useReducer() or useMemo()."
			)
		end
	end

	if lastContextWithAllBitsObserved == context then
		-- Nothing to do. We already observe everything in this context.
	elseif observedBits == false or observedBits == 0 then
		-- Do not observe any updates.
	else
		local resolvedObservedBits -- Avoid deopting on observable arguments or heterogeneous types.
		if typeof(observedBits) ~= "number" or observedBits == Number.MAX_SAFE_INTEGER then
			-- Observe all updates.
			-- lastContextWithAllBitsObserved = ((context: any): ReactContext<mixed>)
			lastContextWithAllBitsObserved = context
			resolvedObservedBits = Number.MAX_SAFE_INTEGER
		else
			resolvedObservedBits = observedBits
		end

		local contextItem = {
			-- context: ((context: any): ReactContext<mixed>),
			context = context,
			observedBits = resolvedObservedBits,
			next = nil,
		}

		if lastContextDependency == nil then
			if currentlyRenderingFiber == nil then
				error(
					Error.new(
						"Context can only be read while React is rendering. "
							.. "In classes, you can read it in the render method or getDerivedStateFromProps. "
							.. "In function components, you can read it directly in the function body, but not "
							.. "inside Hooks like useReducer() or useMemo()."
					)
				)
			end

			-- This is the first dependency for this component. Create a new list.
			lastContextDependency = contextItem;
			(currentlyRenderingFiber :: Fiber).dependencies = {
				lanes = NoLanes,
				firstContext = contextItem,
				responders = nil,
			}
		else
			-- Append a new context item.
			(lastContextDependency :: any).next = contextItem
			lastContextDependency = contextItem
		end
	end
	return if isPrimaryRenderer then context._currentValue else context._currentValue2
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006115</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8F2EFD8F3E244705B922F352EB7F93E9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberOffscreenComponent</string>
								<string name="ScriptGuid">{4EFF06CE-1ECD-4DA5-8F31-D1F7FDCA7A1B}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/1faf9e3dd5d6492f3607d5c721055819e4106bc6/packages/react-reconciler/src/ReactFiberOffscreenComponent.js
--!strict
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList

local ReactFiberLanes = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLanes.Lanes

export type OffscreenProps = {
	-- TODO: Pick an API before exposing the Offscreen type. I've chosen an enum
	-- for now, since we might have multiple variants. For example, hiding the
	-- content without changing the layout.
	--
	-- Default mode is visible. Kind of a weird default for a component
	-- called "Offscreen." Possible alt: <Visibility />?
	mode: string | nil,
	children: ReactNodeList,
}

-- We use the existence of the state object as an indicator that the component
-- is hidden.
export type OffscreenState = {
	-- TODO: This doesn't do anything, yet. It's always NoLanes. But eventually it
	-- will represent the pending work that must be included in the render in
	-- order to unhide the component.
	baseLanes: Lanes,
}

return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006116</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX31230762A787471F90ACA9C1E939F734">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberReconciler</string>
								<string name="ScriptGuid">{229F27F4-60EA-4B24-A856-A79A6C8422B2}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/faa697f4f9afe9f1c98e315b2a9e70f5a74a7a74/packages/react-reconciler/src/ReactFiberReconciler.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

-- deviation: old version of reconciler not ported
return require(script.Parent["ReactFiberReconciler.new"])
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006117</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE1A07FB42BF7429F8207934895BA54FA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberReconciler.new</string>
								<string name="ScriptGuid">{47E47D0A-FC7B-48A3-810E-B3FC4E3B9BD1}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/50d9451f320a9aaf94304209193562cc385567d8/packages/react-reconciler/src/ReactFiberReconciler.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local flowtypes = require(Packages.Shared)
type React_Component<Props, State> = flowtypes.React_Component<Props, State>
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
type Function = (...any) -> ...any

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

type Object = { [string]: any }
type Array<T> = { [number]: T }

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type SuspenseHydrationCallbacks = ReactInternalTypes.SuspenseHydrationCallbacks
type FiberRoot = ReactInternalTypes.FiberRoot

local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Instance = ReactFiberHostConfig.Instance
type TextInstance = ReactFiberHostConfig.TextInstance
type Container = ReactFiberHostConfig.Container
type PublicInstance = ReactFiberHostConfig.PublicInstance
type RendererInspectionConfig = ReactFiberHostConfig.RendererInspectionConfig

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList

local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLane.Lane
type LanePriority = ReactFiberLane.LanePriority
local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local ReactFiberTreeReflection = require(script.Parent.ReactFiberTreeReflection)
local findCurrentHostFiber = ReactFiberTreeReflection.findCurrentHostFiber
local findCurrentHostFiberWithNoPortals = ReactFiberTreeReflection.findCurrentHostFiberWithNoPortals
local getInstance = require(Packages.Shared).ReactInstanceMap.get
local HostComponent = ReactWorkTags.HostComponent
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local getComponentName = require(Packages.Shared).getComponentName
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local enableSchedulingProfiler = require(Packages.Shared).ReactFeatureFlags.enableSchedulingProfiler
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local getPublicInstance = require(script.Parent.ReactFiberHostConfig).getPublicInstance
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local findCurrentUnmaskedContext = ReactFiberContext.findCurrentUnmaskedContext
local processChildContext = ReactFiberContext.processChildContext
local emptyContextObject = ReactFiberContext.emptyContextObject
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local ReactFiberRoot = require(script.Parent["ReactFiberRoot.new"])
local createFiberRoot = ReactFiberRoot.createFiberRoot
local ReactFiberDevToolsHook = require(script.Parent["ReactFiberDevToolsHook.new"])
local injectInternals = ReactFiberDevToolsHook.injectInternals
local onScheduleRoot = ReactFiberDevToolsHook.onScheduleRoot
local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"]) :: any
local requestEventTime = ReactFiberWorkLoop.requestEventTime
local requestUpdateLane = ReactFiberWorkLoop.requestUpdateLane
local scheduleUpdateOnFiber = ReactFiberWorkLoop.scheduleUpdateOnFiber
local flushRoot = ReactFiberWorkLoop.flushRoot
local batchedEventUpdates = ReactFiberWorkLoop.batchedEventUpdates
local batchedUpdates = ReactFiberWorkLoop.batchedUpdates
local unbatchedUpdates = ReactFiberWorkLoop.unbatchedUpdates
local flushSync = ReactFiberWorkLoop.flushSync
local flushControlled = ReactFiberWorkLoop.flushControlled
local deferredUpdates = ReactFiberWorkLoop.deferredUpdates
local discreteUpdates = ReactFiberWorkLoop.discreteUpdates
local flushDiscreteUpdates = ReactFiberWorkLoop.flushDiscreteUpdates
local flushPassiveEffects = ReactFiberWorkLoop.flushPassiveEffects
local warnIfNotScopedWithMatchingAct = ReactFiberWorkLoop.warnIfNotScopedWithMatchingAct
local warnIfUnmockedScheduler = ReactFiberWorkLoop.warnIfUnmockedScheduler
local IsThisRendererActing = ReactFiberWorkLoop.IsThisRendererActing
local act = ReactFiberWorkLoop.act :: (() -> ()) -> ()
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
local createUpdate = ReactUpdateQueue.createUpdate
local enqueueUpdate = ReactUpdateQueue.enqueueUpdate
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
local ReactCurrentFiberIsRendering = ReactCurrentFiber.isRendering
-- deviation: this property would be captured as values instead of bound
-- local ReactCurrentFiber.current = ReactCurrentFiber.current
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local StrictMode = ReactTypeOfMode.StrictMode
local SyncLane = ReactFiberLane.SyncLane
local InputDiscreteHydrationLane = ReactFiberLane.InputDiscreteHydrationLane
local SelectiveHydrationLane = ReactFiberLane.SelectiveHydrationLane
local NoTimestamp = ReactFiberLane.NoTimestamp
local getHighestPriorityPendingLanes = ReactFiberLane.getHighestPriorityPendingLanes
local higherPriorityLane = ReactFiberLane.higherPriorityLane
local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority
-- local ReactFiberHotReloading = require(script.Parent["ReactFiberHotReloading.new"])
-- local scheduleRefresh = ReactFiberHotReloading.scheduleRefresh
-- local scheduleRoot = ReactFiberHotReloading.scheduleRoot
-- local setRefreshHandler = ReactFiberHotReloading.setRefreshHandler
-- local findHostInstancesForRefresh = ReactFiberHotReloading.findHostInstancesForRefresh
local markRenderScheduled = require(script.Parent.SchedulingProfiler).markRenderScheduled

local exports = {}

-- deviation: explicitly export internal type definitions used by the noop and test renderers
exports.ReactRootTags = ReactRootTags
-- deviation: explicitly export internal type definitions used by the test renderer
exports.ReactWorkTags = ReactWorkTags

-- deviation: explicitly export internal type definitions used by the dev tools
exports.ReactTypeOfMode = ReactTypeOfMode
exports.ReactFiberFlags = ReactFiberFlags
exports.getNearestMountedFiber = ReactFiberTreeReflection.getNearestMountedFiber
exports.findCurrentFiberUsingSlowPath = ReactFiberTreeReflection.findCurrentFiberUsingSlowPath

-- exports.registerMutableSourceForHydration = require(script.Parent["ReactMutableSource.new"]).registerMutableSourceForHydration
exports.createPortal = require(script.Parent.ReactPortal).createPortal
-- local ReactTestSelectors = require(script.Parent.ReactTestSelectors)
-- exports.createComponentSelector = ReactTestSelectors.createComponentSelector
-- FIXME: Should we deviate and fix this typo?
-- exports.createHasPsuedoClassSelector = ReactTestSelectors.createHasPsuedoClassSelector
-- exports.createRoleSelector = ReactTestSelectors.createRoleSelector
-- exports.createTestNameSelector = ReactTestSelectors.createTestNameSelector
-- exports.createTextSelector = ReactTestSelectors.createTextSelector
-- exports.getFindAllNodesFailureDescription = ReactTestSelectors.getFindAllNodesFailureDescription
-- exports.findAllNodes = ReactTestSelectors.findAllNodes
-- exports.findBoundingRects = ReactTestSelectors.findBoundingRects
-- exports.focusWithin = ReactTestSelectors.focusWithin
-- exports.observeVisibleRects = ReactTestSelectors.observeVisibleRects

type OpaqueRoot = FiberRoot

-- 0 is PROD, 1 is DEV.
-- Might add PROFILE later.
type BundleType = number

type DevToolsConfig = {
	bundleType: BundleType,
	version: string,
	rendererPackageName: string,
	-- NOTE: this actually *does* depend on Fiber internal fields.
	-- Used by "inspect clicked DOM element" in React DevTools.
	findFiberByHostInstance: ((Instance | TextInstance) -> Fiber)?,
	rendererConfig: RendererInspectionConfig?,
}

local didWarnAboutNestedUpdates
local didWarnAboutFindNodeInStrictMode

if __DEV__ then
	didWarnAboutNestedUpdates = false
	didWarnAboutFindNodeInStrictMode = {}
end

local function getContextForSubtree(parentComponent: any?): Object
	if not parentComponent then
		return emptyContextObject
	end

	local fiber = getInstance(parentComponent)
	local parentContext = findCurrentUnmaskedContext(fiber)

	if fiber.tag == ClassComponent then
		local Component = fiber.type
		if isLegacyContextProvider(Component) then
			return processChildContext(fiber, Component, parentContext)
		end
	end

	return parentContext
end

local function findHostInstance(component: Object): PublicInstance | nil
	local fiber = getInstance(component)
	if fiber == nil then
		if typeof(component.render) == "function" then
			invariant(false, "Unable to find node on an unmounted component.")
		else
			invariant(
				false,
				"Argument appears to not be a ReactComponent. Keys: %s",
				-- deviation: explicitly coerce the array of strings into a string
				table.concat(Object.keys(component))
			)
		end
	end
	local hostFiber = findCurrentHostFiber(fiber)
	if hostFiber == nil then
		return nil
	end
	return hostFiber.stateNode
end

local function findHostInstanceWithWarning(component: Object, methodName: string): PublicInstance | nil
	if __DEV__ then
		local fiber = getInstance(component)
		if fiber == nil then
			if typeof(component.render) == "function" then
				invariant(false, "Unable to find node on an unmounted component.")
			else
				invariant(
					false,
					"Argument appears to not be a ReactComponent. Keys: %s",
					-- deviation: explicitly convert array into string
					table.concat(Object.keys(component))
				)
			end
		end
		local hostFiber = findCurrentHostFiber(fiber)
		if hostFiber == nil then
			return nil
		end
		if bit32.band(hostFiber.mode, StrictMode) ~= 0 then
			local componentName = getComponentName(fiber.type) or "Component"
			if not didWarnAboutFindNodeInStrictMode[componentName] then
				didWarnAboutFindNodeInStrictMode[componentName] = true

				local previousFiber = ReactCurrentFiber.current
				local ok, result = xpcall(function()
					setCurrentDebugFiberInDEV(hostFiber)
					if bit32.band(fiber.mode, StrictMode) ~= 0 then
						console.error(
							"%s is deprecated in StrictMode. "
								.. "%s was passed an instance of %s which is inside StrictMode. "
								.. "Instead, add a ref directly to the element you want to reference. "
								.. "Learn more about using refs safely here: "
								.. "https://reactjs.org/link/strict-mode-find-node",
							methodName,
							methodName,
							componentName
						)
					else
						console.error(
							"%s is deprecated in StrictMode. "
								.. "%s was passed an instance of %s which renders StrictMode children. "
								.. "Instead, add a ref directly to the element you want to reference. "
								.. "Learn more about using refs safely here: "
								.. "https://reactjs.org/link/strict-mode-find-node",
							methodName,
							methodName,
							componentName
						)
					end
				end, describeError)

				-- Ideally this should reset to previous but this shouldn't be called in
				-- render and there's another warning for that anyway.
				if previousFiber then
					setCurrentDebugFiberInDEV(previousFiber)
				else
					resetCurrentDebugFiberInDEV()
				end

				if not ok then
					error(result)
				end
			end
		end
		return hostFiber.stateNode
	end
	return findHostInstance(component)
end

exports.createContainer = function(
	containerInfo: Container,
	tag: RootTag,
	hydrate: boolean,
	hydrationCallbacks: nil | SuspenseHydrationCallbacks
): OpaqueRoot
	return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks)
end

exports.updateContainer = function(
	element: ReactNodeList,
	container: OpaqueRoot,
	parentComponent,
	callback: Function?
): Lane
	if __DEV__ then
		onScheduleRoot(container, element)
	end
	local current = container.current
	local eventTime = requestEventTime()
	if __DEV__ then
		-- deviation: use TestEZ's __TESTEZ_RUNNING_TEST__ (no jest global)
		-- $FlowExpectedError - jest isn't a global, and isn't recognized outside of tests
		if _G.__TESTEZ_RUNNING_TEST__ then
			warnIfUnmockedScheduler(current)
			warnIfNotScopedWithMatchingAct(current)
		end
	end
	local lane = requestUpdateLane(current)

	if enableSchedulingProfiler then
		markRenderScheduled(lane)
	end

	local context = getContextForSubtree(parentComponent)
	if container.context == nil then
		container.context = context
	else
		container.pendingContext = context
	end

	if __DEV__ then
		if ReactCurrentFiberIsRendering and ReactCurrentFiber.current ~= nil and not didWarnAboutNestedUpdates then
			didWarnAboutNestedUpdates = true
			console.error(
				"Render methods should be a pure function of props and state; "
					.. "triggering nested component updates from render is not allowed. "
					.. "If necessary, trigger nested updates in componentDidUpdate.\n\n"
					.. "Check the render method of %s.",
				getComponentName((ReactCurrentFiber.current :: any).type) or "Unknown"
			)
		end
	end

	local update = createUpdate(eventTime, lane)
	-- deviation: We need to set element to a placeholder so that it gets
	-- removed from previous state when merging tables
	if element == nil then
		element = Object.None
	end
	-- Caution: React DevTools currently depends on this property
	-- being called "element".
	update.payload = {
		element = element,
	}

	-- deviation: no undefined, so not needed
	-- callback = callback == undefined ? nil : callback
	if callback ~= nil then
		if __DEV__ then
			if typeof(callback) ~= "function" then
				console.error(
					"render(...): Expected the last optional `callback` argument to be a "
						.. "function. Instead received: %s.",
					tostring(callback)
				)
			end
		end
		update.callback = callback
	end

	enqueueUpdate(current, update)
	scheduleUpdateOnFiber(current, lane, eventTime)

	return lane
end

-- FIXME: WIP
exports.batchedEventUpdates = batchedEventUpdates
exports.batchedUpdates = batchedUpdates
exports.unbatchedUpdates = unbatchedUpdates
exports.deferredUpdates = deferredUpdates
exports.discreteUpdates = discreteUpdates
exports.flushDiscreteUpdates = flushDiscreteUpdates
exports.flushControlled = flushControlled
exports.flushSync = flushSync
exports.flushPassiveEffects = flushPassiveEffects
exports.IsThisRendererActing = IsThisRendererActing
exports.act = act

exports.getPublicRootInstance = function(container: OpaqueRoot): React_Component<any, any> | PublicInstance | nil
	local containerFiber = container.current
	if not containerFiber.child then
		return nil
	end
	if containerFiber.child.tag == HostComponent then
		return getPublicInstance(containerFiber.child.stateNode)
	else
		return containerFiber.child.stateNode
	end
end

-- deviation: Declare function ahead of use
local markRetryLaneIfNotHydrated

exports.attemptSynchronousHydration = function(fiber: Fiber)
	if fiber.tag == HostRoot then
		local root: FiberRoot = fiber.stateNode
		if root.hydrate then
			-- Flush the first scheduled "update".
			local lanes = getHighestPriorityPendingLanes(root)
			flushRoot(root, lanes)
		end
	elseif fiber.tag == SuspenseComponent then
		local eventTime = requestEventTime()
		flushSync(function()
			return scheduleUpdateOnFiber(fiber, SyncLane, eventTime)
		end)
		-- If we're still blocked after this, we need to increase
		-- the priority of any promises resolving within this
		-- boundary so that they next attempt also has higher pri.
		local retryLane = InputDiscreteHydrationLane
		markRetryLaneIfNotHydrated(fiber, retryLane)
	end
end

local function markRetryLaneImpl(fiber: Fiber, retryLane: Lane)
	local suspenseState: SuspenseState? = fiber.memoizedState
	if suspenseState then
		if suspenseState ~= nil and suspenseState.dehydrated ~= nil then
			suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane)
		end
	end
end

-- Increases the priority of thennables when they resolve within this boundary.
markRetryLaneIfNotHydrated = function(fiber: Fiber, retryLane: Lane)
	markRetryLaneImpl(fiber, retryLane)
	-- TODO: grab local for this since Luau can't deal with nested type narrowing
	local alternate = fiber.alternate
	if alternate then
		markRetryLaneImpl(alternate, retryLane)
	end
end

exports.attemptUserBlockingHydration = function(fiber: Fiber)
	if fiber.tag ~= SuspenseComponent then
		-- We ignore HostRoots here because we can't increase
		-- their priority and they should not suspend on I/O,
		-- since you have to wrap anything that might suspend in
		-- Suspense.
		return
	end
	local eventTime = requestEventTime()
	local lane = InputDiscreteHydrationLane
	scheduleUpdateOnFiber(fiber, lane, eventTime)
	markRetryLaneIfNotHydrated(fiber, lane)
end

exports.attemptContinuousHydration = function(fiber: Fiber)
	if fiber.tag ~= SuspenseComponent then
		-- We ignore HostRoots here because we can't increase
		-- their priority and they should not suspend on I/O,
		-- since you have to wrap anything that might suspend in
		-- Suspense.
		return
	end
	local eventTime = requestEventTime()
	local lane = SelectiveHydrationLane
	scheduleUpdateOnFiber(fiber, lane, eventTime)
	markRetryLaneIfNotHydrated(fiber, lane)
end

exports.attemptHydrationAtCurrentPriority = function(fiber: Fiber)
	if fiber.tag ~= SuspenseComponent then
		-- We ignore HostRoots here because we can't increase
		-- their priority other than synchronously flush it.
		return
	end
	local eventTime = requestEventTime()
	local lane = requestUpdateLane(fiber)
	scheduleUpdateOnFiber(fiber, lane, eventTime)
	markRetryLaneIfNotHydrated(fiber, lane)
end

exports.runWithPriority = function<T>(priority: LanePriority, fn: () -> T): T
	local previousPriority = getCurrentUpdateLanePriority()
	-- performance: hoist non-throwable out of try{} to eliminate anon function
	setCurrentUpdateLanePriority(priority)
	local ok, result = xpcall(fn, describeError)
	setCurrentUpdateLanePriority(previousPriority)
	if not ok then
		error(result)
	end
	return result
end

exports.getCurrentUpdateLanePriority = getCurrentUpdateLanePriority

exports.findHostInstance = findHostInstance

exports.findHostInstanceWithWarning = findHostInstanceWithWarning

exports.findHostInstanceWithNoPortals = function(fiber: Fiber): PublicInstance?
	local hostFiber = findCurrentHostFiberWithNoPortals(fiber)
	if hostFiber == nil then
		return nil
	end
	if hostFiber.tag == FundamentalComponent then
		return hostFiber.stateNode.instance
	end
	return hostFiber.stateNode
end

local function shouldSuspendImpl(fiber)
	return false
end

exports.shouldSuspend = function(fiber: Fiber): boolean
	return shouldSuspendImpl(fiber)
end

local overrideHookState = nil
local overrideHookStateDeletePath = nil
local overrideHookStateRenamePath = nil
local overrideProps = nil
local overridePropsDeletePath = nil
local overridePropsRenamePath = nil
local scheduleUpdate = nil
local setSuspenseHandler = nil

if __DEV__ then
	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithDeleteImpl(obj: Object, path: Array<string | number>, index: number)
		local key = path[index]
		local updated
		if Array.isArray(obj) then
			updated = Array.slice(obj)
		else
			updated = table.clone(obj)
		end
		if index + 1 == #path then
			if Array.isArray(updated) then
				-- Narrow type
				local updatedIndex: number = key
				Array.splice(updated, updatedIndex, 1)
			else
				updated[key] = nil
			end
			return updated
		end
		-- $FlowFixMe number or string is fine here
		updated[key] = copyWithDeleteImpl(obj[key], path, index + 1)
		return updated
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithDelete(obj: Object, path: Array<string | number>): Object | Array<any>
		return copyWithDeleteImpl(obj, path, 0)
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithRenameImpl(
		obj: Object,
		oldPath: Array<string | number>,
		newPath: Array<string | number>,
		index: number
	)
		local oldKey = oldPath[index]
		local updated
		if Array.isArray(obj) then
			updated = Array.slice(obj)
		else
			updated = table.clone(obj)
		end
		if index + 1 == #oldPath then
			local newKey = newPath[index]
			-- $FlowFixMe number or string is fine here
			updated[newKey] = updated[oldKey]
			if Array.isArray(updated) then
				Array.splice(updated, oldKey, 1)
			else
				updated[oldKey] = nil
			end
		else
			-- $FlowFixMe number or string is fine here
			updated[oldKey] = copyWithRenameImpl(
				-- $FlowFixMe number or string is fine here
				obj[oldKey],
				oldPath,
				newPath,
				index + 1
			)
		end
		return updated
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithRename(
		obj: Object,
		oldPath: Array<string | number>,
		newPath: Array<string | number>
	): Object | Array<any> | nil
		if #oldPath ~= #newPath then
			console.warn("copyWithRename() expects paths of the same length")
			return nil
		else
			for i = 1, #newPath do
				if oldPath[i] ~= newPath[i] then
					console.warn("copyWithRename() expects paths to be the same except for the deepest key")
					return nil
				end
			end
		end
		return copyWithRenameImpl(obj, oldPath, newPath, 0)
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithSetImpl(obj: Object, path: Array<string | number>, index: number, value: any)
		if index >= (#path + 1) then
			return value
		end
		local key = path[index]
		local updated
		if Array.isArray(obj) then
			updated = Array.slice(obj)
		else
			updated = table.clone(obj)
		end
		-- $FlowFixMe number or string is fine here
		updated[key] = copyWithSetImpl(obj[key], path, index + 2, value)
		return updated
	end

	-- deviation: FIXME: obj: `Object | Array<any>`, narrowing not possible with `isArray`
	local function copyWithSet(obj: Object, path: Array<string | number>, value: any): Object | Array<any>
		return copyWithSetImpl(obj, path, 1, value)
	end

	local function findHook(fiber: Fiber, id: number)
		-- For now, the "id" of stateful hooks is just the stateful hook index.
		-- This may change in the future with e.g. nested hooks.
		local currentHook = fiber.memoizedState
		while currentHook ~= nil and id > 1 do
			currentHook = currentHook.next
			id -= 1
		end
		return currentHook
	end

	-- Support DevTools editable values for useState and useReducer.
	overrideHookState = function(fiber: Fiber, id: number, path: Array<string | number>, value: any)
		local hook = findHook(fiber, id)
		if hook ~= nil then
			local newState = copyWithSet(hook.memoizedState, path, value)
			hook.memoizedState = newState
			hook.baseState = newState

			-- We aren't actually adding an update to the queue,
			-- because there is no update we can add for useReducer hooks that won't trigger an error.
			-- (There's no appropriate action type for DevTools overrides.)
			-- As a result though, React will see the scheduled update as a noop and bailout.
			-- Shallow cloning props works as a workaround for now to bypass the bailout check.
			fiber.memoizedProps = table.clone(fiber.memoizedProps)

			scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
		end
	end
	overrideHookStateDeletePath = function(fiber: Fiber, id: number, path: Array<string | number>)
		local hook = findHook(fiber, id)
		if hook ~= nil then
			local newState = copyWithDelete(hook.memoizedState, path)
			hook.memoizedState = newState
			hook.baseState = newState

			-- We aren't actually adding an update to the queue,
			-- because there is no update we can add for useReducer hooks that won't trigger an error.
			-- (There's no appropriate action type for DevTools overrides.)
			-- As a result though, React will see the scheduled update as a noop and bailout.
			-- Shallow cloning props works as a workaround for now to bypass the bailout check.
			fiber.memoizedProps = table.clone(fiber.memoizedProps)

			scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
		end
	end
	overrideHookStateRenamePath = function(
		fiber: Fiber,
		id: number,
		oldPath: Array<string | number>,
		newPath: Array<string | number>
	)
		local hook = findHook(fiber, id)
		if hook ~= nil then
			local newState = copyWithRename(hook.memoizedState, oldPath, newPath)
			hook.memoizedState = newState
			hook.baseState = newState

			-- We aren't actually adding an update to the queue,
			-- because there is no update we can add for useReducer hooks that won't trigger an error.
			-- (There's no appropriate action type for DevTools overrides.)
			-- As a result though, React will see the scheduled update as a noop and bailout.
			-- Shallow cloning props works as a workaround for now to bypass the bailout check.
			fiber.memoizedProps = table.clone(fiber.memoizedProps)

			scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
		end
	end

	-- Support DevTools props for function components, forwardRef, memo, host components, etc.
	overrideProps = function(fiber: Fiber, path: Array<string | number>, value: any)
		fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value)
		-- TODO: grab local for this since Luau can't deal with nested type narrowing
		local alternate = fiber.alternate
		if alternate then
			alternate.pendingProps = fiber.pendingProps
		end
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end
	overridePropsDeletePath = function(fiber: Fiber, path: Array<string | number>)
		fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path)
		-- TODO: grab local for this since Luau can't deal with nested type narrowing
		local alternate = fiber.alternate
		if alternate then
			alternate.pendingProps = fiber.pendingProps
		end
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end
	overridePropsRenamePath = function(fiber: Fiber, oldPath: Array<string | number>, newPath: Array<string | number>)
		fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath)
		-- TODO: grab local for this since Luau can't deal with nested type narrowing
		local alternate = fiber.alternate
		if alternate then
			alternate.pendingProps = fiber.pendingProps
		end
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end

	scheduleUpdate = function(fiber: Fiber)
		scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp)
	end

	setSuspenseHandler = function(newShouldSuspendImpl: (Fiber) -> boolean)
		shouldSuspendImpl = newShouldSuspendImpl
	end
end

function findHostInstanceByFiber(fiber: Fiber): Instance | TextInstance | nil
	local hostFiber = findCurrentHostFiber(fiber)
	if hostFiber == nil then
		return nil
	end
	return hostFiber.stateNode
end

function emptyFindFiberByHostInstance(instance: Instance | TextInstance): Fiber | nil
	return nil
end

function getCurrentFiberForDevTools()
	return ReactCurrentFiber.current
end

exports.injectIntoDevTools = function(devToolsConfig: DevToolsConfig): boolean
	local findFiberByHostInstance = devToolsConfig.findFiberByHostInstance
	local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
	local getCurrentFiber = nil
	if __DEV__ then
		getCurrentFiber = getCurrentFiberForDevTools
	end
	return injectInternals({
		bundleType = devToolsConfig.bundleType,
		version = devToolsConfig.version,
		rendererPackageName = devToolsConfig.rendererPackageName,
		rendererConfig = devToolsConfig.rendererConfig,
		overrideHookState = overrideHookState,
		overrideHookStateDeletePath = overrideHookStateDeletePath,
		overrideHookStateRenamePath = overrideHookStateRenamePath,
		overrideProps = overrideProps,
		overridePropsDeletePath = overridePropsDeletePath,
		overridePropsRenamePath = overridePropsRenamePath,
		setSuspenseHandler = setSuspenseHandler,
		scheduleUpdate = scheduleUpdate,
		currentDispatcherRef = ReactCurrentDispatcher,
		findHostInstanceByFiber = findHostInstanceByFiber,
		findFiberByHostInstance = findFiberByHostInstance or emptyFindFiberByHostInstance,
		-- FIXME: WIP
		-- React Refresh
		-- findHostInstancesForRefresh = __DEV__ and findHostInstancesForRefresh or nil,
		-- scheduleRefresh = __DEV__ and scheduleRefresh or nil,
		-- scheduleRoot = __DEV__ and scheduleRoot or nil,
		-- setRefreshHandler = __DEV__ and setRefreshHandler or nil,
		-- Enables DevTools to append owner stacks to error messages in DEV mode.
		getCurrentFiber = getCurrentFiber,
	})
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006118</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF193E46784FC4BC6A429380DF8D38381">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberRoot.new</string>
								<string name="ScriptGuid">{A7AF9AA3-26D9-48D4-983A-FF2F6786757A}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/96ac799eace5d989de3b4f80e6414e94a08ff77a/packages/react-reconciler/src/ReactFiberRoot.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set
local Map = LuauPolyfill.Map

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type SuspenseHydrationCallbacks = ReactInternalTypes.SuspenseHydrationCallbacks
local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local noTimeout = ReactFiberHostConfig.noTimeout
local supportsHydration = ReactFiberHostConfig.supportsHydration
local ReactFiber = require(script.Parent["ReactFiber.new"])
local createHostRootFiber = ReactFiber.createHostRootFiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
local NoLanes = ReactFiberLane.NoLanes
local NoLanePriority = ReactFiberLane.NoLanePriority
local NoTimestamp = ReactFiberLane.NoTimestamp
local createLaneMap = ReactFiberLane.createLaneMap
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local enableSuspenseCallback = ReactFeatureFlags.enableSuspenseCallback
-- deviation: import from tracing from Scheduler export to avoid direct file access
local Scheduler = require(Packages.Scheduler).tracing
local unstable_getThreadID = Scheduler.unstable_getThreadID
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
local initializeUpdateQueue = ReactUpdateQueue.initializeUpdateQueue
local LegacyRoot = ReactRootTags.LegacyRoot
local BlockingRoot = ReactRootTags.BlockingRoot
local ConcurrentRoot = ReactRootTags.ConcurrentRoot

local exports = {}

local function FiberRootNode(containerInfo, tag, hydrate)
	-- performance: See if this kind of object init is faster in Luau
	local rootNode = {
		tag = tag,
		containerInfo = containerInfo,
		pendingChildren = nil,
		-- TODO: this isn't typesafe upstream
		current = (nil :: any) :: Fiber,
		pingCache = nil,
		finishedWork = nil,
		timeoutHandle = noTimeout,
		context = nil,
		pendingContext = nil,
		hydrate = hydrate,
		callbackNode = nil,
		callbackPriority = NoLanePriority,
		eventTimes = createLaneMap(NoLanes),
		expirationTimes = createLaneMap(NoTimestamp),

		pendingLanes = NoLanes,
		suspendedLanes = NoLanes,
		pingedLanes = NoLanes,
		expiredLanes = NoLanes,
		mutableReadLanes = NoLanes,
		finishedLanes = NoLanes,

		entangledLanes = NoLanes,
		entanglements = createLaneMap(NoLanes),
	}

	if supportsHydration then
		rootNode.mutableSourceEagerHydrationData = nil
	end

	if enableSchedulerTracing then
		rootNode.interactionThreadID = unstable_getThreadID()
		rootNode.memoizedInteractions = Set.new()
		rootNode.pendingInteractionMap = Map.new()
	end
	if enableSuspenseCallback then
		rootNode.hydrationCallbacks = nil
	end

	if _G.__DEV__ then
		if tag == BlockingRoot then
			rootNode._debugRootType = "createBlockingRoot()"
		elseif tag == ConcurrentRoot then
			rootNode._debugRootType = "createRoot()"
		elseif tag == LegacyRoot then
			rootNode._debugRootType = "createLegacyRoot()"
		end
	end

	return rootNode
end

exports.createFiberRoot = function(
	containerInfo: any,
	tag: RootTag,
	hydrate: boolean,
	hydrationCallbacks: SuspenseHydrationCallbacks?
): FiberRoot
	local root: FiberRoot = FiberRootNode(containerInfo, tag, hydrate)
	if enableSuspenseCallback then
		root.hydrationCallbacks = hydrationCallbacks
	end

	-- Cyclic construction. This cheats the type system right now because
	-- stateNode is any.
	local uninitializedFiber = createHostRootFiber(tag)
	root.current = uninitializedFiber
	uninitializedFiber.stateNode = root

	initializeUpdateQueue(uninitializedFiber)

	return root
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006119</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1A6BEFD3EC7D44618D363B5EC48C311B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberSchedulerPriorities.roblox</string>
								<string name="ScriptGuid">{7011EAB5-72CA-4E7D-B1E5-0CA542E1349C}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/d17086c7c813402a550d15a2f56dc43f1dbd1735/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js
--[[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

-- deviation: Type definition and values extracted from
-- SchedulerWithReactIntegration.new. This helps avoid a cyclic dependency that
-- can occur between SchedulerWithReactIntegration.new, ReactFiberLanes, and
-- various files that depend upon them

export type ReactPriorityLevel = number

local exports: { [string]: ReactPriorityLevel } = {
	-- // Except for NoPriority, these correspond to Scheduler priorities. We use
	-- // ascending numbers so we can compare them like numbers. They start at 90 to
	-- // avoid clashing with Scheduler's priorities.
	ImmediatePriority = 99,
	UserBlockingPriority = 98,
	NormalPriority = 97,
	LowPriority = 96,
	IdlePriority = 95,
	-- // NoPriority is the absence of priority. Also React-only.
	NoPriority = 90,
}

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000611a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA59DE6EF31154050A916F1B0A7F8B0B2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberStack.new</string>
								<string name="ScriptGuid">{E98D30FB-5119-4201-9FDB-4E45F4437F81}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberStack.new.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

type Array<T> = { [number]: T }
-- deviation: use this table when pushing nil values
type null = {}
local NULL: null = {}

export type StackCursor<T> = { current: T }

local valueStack: Array<any> = {}

local fiberStack: Array<Fiber | null>

if _G.__DEV__ then
	fiberStack = {}
end

local index = 0

local function createCursor<T>(defaultValue: T): StackCursor<T>
	return {
		current = defaultValue,
	}
end

local function isEmpty(): boolean
	return index == 0
end

local function pop<T>(cursor: StackCursor<T>, fiber: Fiber): ()
	if index < 1 then
		if _G.__DEV__ then
			console.error("Unexpected pop.")
		end
		return
	end

	if _G.__DEV__ then
		-- TODO: workaround for Luau analysis bug
		if fiber ~= fiberStack[index] :: Fiber then
			console.error("Unexpected Fiber popped.")
		end
	end

	local value = valueStack[index]
	if value == NULL then
		-- TODO: this is a sort of incorrect typing in upstream
		cursor.current = nil :: any
	else
		cursor.current = value
	end

	valueStack[index] = nil

	if _G.__DEV__ then
		fiberStack[index] = nil
	end

	index -= 1
end

local function push<T>(cursor: StackCursor<T>, value: T, fiber: Fiber): ()
	index += 1

	local stackValue = cursor.current
	if stackValue == nil then
		valueStack[index] = NULL
	else
		valueStack[index] = stackValue
	end

	if _G.__DEV__ then
		fiberStack[index] = fiber
	end

	cursor.current = value
end

local function checkThatStackIsEmpty()
	if _G.__DEV__ then
		if index ~= 0 then
			console.error("Expected an empty stack. Something was not reset properly.")
		end
	end
end

local function resetStackAfterFatalErrorInDev()
	if _G.__DEV__ then
		index = 0
		-- deviation: Original js simply sets `length`
		table.clear(valueStack)
		table.clear(fiberStack)
	end
end

return {
	createCursor = createCursor,
	isEmpty = isEmpty,
	pop = pop,
	push = push,
	-- DEV only:
	checkThatStackIsEmpty = checkThatStackIsEmpty,
	resetStackAfterFatalErrorInDev = resetStackAfterFatalErrorInDev,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000611b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD3AC4C28AC4A41D8B6C979AA4B6D3F22">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberSuspenseComponent.new</string>
								<string name="ScriptGuid">{176EF768-6D94-4CCB-A13D-12F12D0CCB4D}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/1faf9e3dd5d6492f3607d5c721055819e4106bc6/packages/react-reconciler/src/ReactFiberSuspenseComponent.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent

local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
type Wakeable = ReactTypes.Wakeable

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLane.Lane
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local DidCapture = ReactFiberFlags.DidCapture
local isSuspenseInstancePending = ReactFiberHostConfig.isSuspenseInstancePending
local isSuspenseInstanceFallback = ReactFiberHostConfig.isSuspenseInstanceFallback

-- deviation: Common types
type Set<T> = { [T]: boolean }

export type SuspenseProps = {
	children: ReactNodeList?,
	fallback: ReactNodeList?,

	-- TODO: Add "unstable_" prefix?
	suspenseCallback: (Set<Wakeable>?) -> any,

	unstable_expectedLoadTime: number?,
}

-- A nil SuspenseState represents an unsuspended normal Suspense boundary.
-- A non-null SuspenseState means that it is blocked for one reason or another.
-- - A non-null dehydrated field means it's blocked pending hydration.
--   - A non-null dehydrated field can use isSuspenseInstancePending or
--     isSuspenseInstanceFallback to query the reason for being dehydrated.
-- - A nil dehydrated field means it's blocked by something suspending and
--   we're currently showing a fallback instead.
export type SuspenseState = {
	-- If this boundary is still dehydrated, we store the SuspenseInstance
	-- here to indicate that it is dehydrated (flag) and for quick access
	-- to check things like isSuspenseInstancePending.
	dehydrated: SuspenseInstance?,
	-- Represents the lane we should attempt to hydrate a dehydrated boundary at.
	-- OffscreenLane is the default for dehydrated boundaries.
	-- NoLane is the default for normal boundaries, which turns into "normal" pri.
	retryLane: Lane,
}

-- deviation: Can't use literals for types
-- export type SuspenseListTailMode = 'collapsed' | 'hidden' | void
export type SuspenseListTailMode = string?

export type SuspenseListRenderState = {
	isBackwards: boolean,
	-- The currently rendering tail row.
	rendering: Fiber?,
	-- The absolute time when we started rendering the most recent tail row.
	renderingStartTime: number,
	-- The last of the already rendered children.
	last: Fiber?,
	-- Remaining rows on the tail of the list.
	tail: Fiber?,
	-- Tail insertions setting.
	tailMode: SuspenseListTailMode,
}

local exports = {}

exports.shouldCaptureSuspense = function(workInProgress: Fiber, hasInvisibleParent: boolean): boolean
	-- If it was the primary children that just suspended, capture and render the
	-- fallback. Otherwise, don't capture and bubble to the next boundary.
	local nextState: SuspenseState? = workInProgress.memoizedState
	if nextState then
		if nextState.dehydrated ~= nil then
			-- A dehydrated boundary always captures.
			return true
		end
		return false
	end
	local props = workInProgress.memoizedProps
	-- In order to capture, the Suspense component must have a fallback prop.
	if props.fallback == nil then
		return false
	end
	-- Regular boundaries always capture.
	if props.unstable_avoidThisFallback ~= true then
		return true
	end
	-- If it's a boundary we should avoid, then we prefer to bubble up to the
	-- parent boundary if it is currently invisible.
	if hasInvisibleParent then
		return false
	end
	-- If the parent is not able to handle it, we must handle it.
	return true
end

exports.findFirstSuspended = function(row: Fiber): Fiber?
	local node = row
	while node ~= nil do
		if node.tag == SuspenseComponent then
			local state: SuspenseState? = node.memoizedState
			if state then
				local dehydrated: SuspenseInstance? = state.dehydrated
				if
					dehydrated == nil
					or isSuspenseInstancePending(dehydrated)
					or isSuspenseInstanceFallback(dehydrated)
				then
					return node
				end
			end
		elseif
			node.tag == SuspenseListComponent
			-- revealOrder undefined can't be trusted because it don't
			-- keep track of whether it suspended or not.
			and node.memoizedProps.revealOrder ~= nil
		then
			local didSuspend = bit32.band(node.flags, DidCapture) ~= NoFlags
			if didSuspend then
				return node
			end
		elseif node.child ~= nil then
			node.child.return_ = node
			node = node.child
			continue
		end
		if node == row then
			return nil
		end
		while node.sibling == nil do
			if node.return_ == nil or node.return_ == row then
				return nil
			end
			-- FIXME Luau: Luau narrowing doesn't understand this loop until nil pattern
			node = node.return_ :: Fiber
		end
		-- FIXME Luau: Luau narrowing doesn't understand this loop until nil pattern
		(node.sibling :: Fiber).return_ = node.return_
		node = node.sibling :: Fiber
	end
	return nil
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000611c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD1BF3D84278443BDB4D75E600DDFEC7F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberSuspenseContext.new</string>
								<string name="ScriptGuid">{EB1BC5F6-13A2-4AD2-90F7-C64AD368FB31}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberSuspenseContext.new.js
--!strict
-- upstream: https://github.com/facebook/react/blob/17f582e0453b808860be59ed3437c6a426ae52de/packages/react-reconciler/src/ReactFiberSuspenseContext.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>

local createCursor = ReactFiberStack.createCursor
local push = ReactFiberStack.push
local pop = ReactFiberStack.pop

export type SuspenseContext = number
export type SubtreeSuspenseContext = SuspenseContext
export type ShallowSuspenseContext = SuspenseContext

local exports = {}

local DefaultSuspenseContext: SuspenseContext = 0b00

-- // The Suspense Context is split into two parts. The lower bits is
-- // inherited deeply down the subtree. The upper bits only affect
-- // this immediate suspense boundary and gets reset each new
-- // boundary or suspense list.
local SubtreeSuspenseContextMask: SuspenseContext = 0b01

-- // Subtree Flags:

-- // InvisibleParentSuspenseContext indicates that one of our parent Suspense
-- // boundaries is not currently showing visible main content.
-- // Either because it is already showing a fallback or is not mounted at all.
-- // We can use this to determine if it is desirable to trigger a fallback at
-- // the parent. If not, then we might need to trigger undesirable boundaries
-- // and/or suspend the commit to avoid hiding the parent content.
local InvisibleParentSuspenseContext: SubtreeSuspenseContext = 0b01
exports.InvisibleParentSuspenseContext = InvisibleParentSuspenseContext

-- // Shallow Flags:

-- // ForceSuspenseFallback can be used by SuspenseList to force newly added
-- // items into their fallback state during one of the render passes.
local ForceSuspenseFallback: ShallowSuspenseContext = 0b10
exports.ForceSuspenseFallback = ForceSuspenseFallback

local suspenseStackCursor: StackCursor<SuspenseContext> = createCursor(DefaultSuspenseContext)
exports.suspenseStackCursor = suspenseStackCursor

function exports.hasSuspenseContext(parentContext: SuspenseContext, flag: SuspenseContext): boolean
	return bit32.band(parentContext, flag) ~= 0
end

function exports.setDefaultShallowSuspenseContext(parentContext: SuspenseContext): SuspenseContext
	return bit32.band(parentContext, SubtreeSuspenseContextMask)
end

function exports.setShallowSuspenseContext(
	parentContext: SuspenseContext,
	shallowContext: ShallowSuspenseContext
): SuspenseContext
	return bit32.bor(bit32.band(parentContext, SubtreeSuspenseContextMask), shallowContext)
end

function exports.addSubtreeSuspenseContext(
	parentContext: SuspenseContext,
	subtreeContext: SubtreeSuspenseContext
): SuspenseContext
	return bit32.bor(parentContext, subtreeContext)
end

function exports.pushSuspenseContext(fiber: Fiber, newContext: SuspenseContext)
	push(suspenseStackCursor, newContext, fiber)
end

function exports.popSuspenseContext(fiber: Fiber)
	pop(suspenseStackCursor, fiber)
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000611d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1BCDE196078C46C98F980CBA0215B7AD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberThrow.new</string>
								<string name="ScriptGuid">{C8B1423A-3F8D-4ED0-AFCC-4D5533058126}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberThrow.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
type Error = LuauPolyfill.Error
type Map<K, V> = { [K]: V }
type Object = { [string]: any }
type Set<T> = { [T]: boolean }

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
local ReactCapturedValue = require(script.Parent.ReactCapturedValue)
type CapturedValue<T> = ReactCapturedValue.CapturedValue<T>
local ReactUpdateQueue = require(script.Parent["ReactUpdateQueue.new"])
type Update<T> = ReactInternalTypes.Update<T>

local ReactTypes = require(Packages.Shared)
type React_Component<Props, State> = ReactTypes.React_Component<Props, State>
type Thenable<T> = ReactTypes.Thenable<T>
type Wakeable = ReactTypes.Wakeable

local ReactFiberSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"])
type SuspenseContext = ReactFiberSuspenseContext.SuspenseContext

local getComponentName = require(Packages.Shared).getComponentName

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostRoot = ReactWorkTags.HostRoot
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local IncompleteClassComponent = ReactWorkTags.IncompleteClassComponent

local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local DidCapture = ReactFiberFlags.DidCapture
local Incomplete = ReactFiberFlags.Incomplete
local NoFlags = ReactFiberFlags.NoFlags
local ShouldCapture = ReactFiberFlags.ShouldCapture
local LifecycleEffectMask = ReactFiberFlags.LifecycleEffectMask
local ForceUpdateForLegacySuspense = ReactFiberFlags.ForceUpdateForLegacySuspense
local shouldCaptureSuspense = require(script.Parent["ReactFiberSuspenseComponent.new"]).shouldCaptureSuspense
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local NoMode = ReactTypeOfMode.NoMode
local BlockingMode = ReactTypeOfMode.BlockingMode
local DebugTracingMode = ReactTypeOfMode.DebugTracingMode
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableDebugTracing = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local createCapturedValue = require(script.Parent.ReactCapturedValue).createCapturedValue

local enqueueCapturedUpdate = ReactUpdateQueue.enqueueCapturedUpdate
local createUpdate = ReactUpdateQueue.createUpdate
local CaptureUpdate = ReactUpdateQueue.CaptureUpdate
local ForceUpdate = ReactUpdateQueue.ForceUpdate
local enqueueUpdate = ReactUpdateQueue.enqueueUpdate
local markFailedErrorBoundaryForHotReloading =
	require(script.Parent["ReactFiberHotReloading.new"]).markFailedErrorBoundaryForHotReloading

local hasSuspenseContext = ReactFiberSuspenseContext.hasSuspenseContext
local InvisibleParentSuspenseContext = ReactFiberSuspenseContext.InvisibleParentSuspenseContext
local suspenseStackCursor = ReactFiberSuspenseContext.suspenseStackCursor

-- FIXME: these will incur a dependency cycle
-- onUncaughtError would be very easy to extract out, or to transplant into this file
local ReactFiberWorkLoop
local markLegacyErrorBoundaryAsFailedRef, isAlreadyFailedLegacyErrorBoundaryRef, pingSuspendedRootRef

-- deviation: lazy initialize ReactFiberWorkLoop to prevent cyclic module dependency
local markLegacyErrorBoundaryAsFailed = function(...)
	if not markLegacyErrorBoundaryAsFailedRef then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
		markLegacyErrorBoundaryAsFailedRef = ReactFiberWorkLoop.markLegacyErrorBoundaryAsFailed
	end
	return markLegacyErrorBoundaryAsFailedRef(...)
end
-- local {
--   renderDidError,
--   onUncaughtError,
--   markLegacyErrorBoundaryAsFailed,
--   isAlreadyFailedLegacyErrorBoundary,
--   pingSuspendedRoot,
-- } = require(Packages../ReactFiberWorkLoop.new'
local pingSuspendedRoot = function(...)
	if ReactFiberWorkLoop == nil then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
	end
	pingSuspendedRootRef = ReactFiberWorkLoop.pingSuspendedRoot
	return pingSuspendedRootRef(...)
end
local isAlreadyFailedLegacyErrorBoundary = function(...)
	if ReactFiberWorkLoop == nil then
		ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
	end
	isAlreadyFailedLegacyErrorBoundaryRef = ReactFiberWorkLoop.isAlreadyFailedLegacyErrorBoundary
	return isAlreadyFailedLegacyErrorBoundaryRef(...)
end

local logCapturedError = require(script.Parent.ReactFiberErrorLogger).logCapturedError
local logComponentSuspended = require(script.Parent.DebugTracing).logComponentSuspended
local markComponentSuspended = require(script.Parent.SchedulingProfiler).markComponentSuspended

local SyncLane = ReactFiberLane.SyncLane
local NoTimestamp = ReactFiberLane.NoTimestamp
local includesSomeLane = ReactFiberLane.includesSomeLane
local mergeLanes = ReactFiberLane.mergeLanes
local pickArbitraryLane = ReactFiberLane.pickArbitraryLane

-- local PossiblyWeakMap = typeof WeakMap == 'function' ? WeakMap : Map

function createRootErrorUpdate(
	fiber: Fiber,
	errorInfo: CapturedValue<Error>,
	lane: Lane,
	-- deviation: parameterize method to avoid circular dependency
	onUncaughtError
): Update<any>
	local update = createUpdate(NoTimestamp, lane)
	-- Unmount the root by rendering nil.
	update.tag = CaptureUpdate
	-- Caution: React DevTools currently depends on this property
	-- being called "element".
	update.payload = { element = Object.None }
	local _error = errorInfo.value
	update.callback = function()
		if onUncaughtError ~= nil then
			onUncaughtError(_error)
		end
		logCapturedError(fiber, errorInfo)
	end
	return update
end

function createClassErrorUpdate(fiber: Fiber, errorInfo: CapturedValue<Error>, lane: Lane): Update<any>
	local update = createUpdate(NoTimestamp, lane)
	update.tag = CaptureUpdate
	local getDerivedStateFromError = (fiber.type :: React_Component<any, any>).getDerivedStateFromError
	if typeof(getDerivedStateFromError) == "function" then
		local error_ = errorInfo.value
		update.payload = function()
			logCapturedError(fiber, errorInfo)
			return getDerivedStateFromError(error_)
		end
	end

	local inst = fiber.stateNode
	if inst ~= nil and typeof(inst.componentDidCatch) == "function" then
		update.callback = function()
			if _G.__DEV__ then
				markFailedErrorBoundaryForHotReloading(fiber)
			end
			if typeof(getDerivedStateFromError) ~= "function" then
				-- To preserve the preexisting retry behavior of error boundaries,
				-- we keep track of which ones already failed during this batch.
				-- This gets reset before we yield back to the browser.
				-- TODO: Warn in strict mode if getDerivedStateFromError is
				-- not defined.
				-- FIXME: used to be `this` upstream, needs verification by ReactIncremental unwinding test
				markLegacyErrorBoundaryAsFailed(inst)

				-- Only log here if componentDidCatch is the only error boundary method defined
				logCapturedError(fiber, errorInfo)
			end
			local error_ = errorInfo.value
			local stack = errorInfo.stack
			-- FIXME: used to be `this` upstream, needs verification by ReactIncremental unwinding test
			inst:componentDidCatch(error_, {
				componentStack = stack or "",
			})
			if _G.__DEV__ then
				if typeof(getDerivedStateFromError) ~= "function" then
					-- If componentDidCatch is the only error boundary method defined,
					-- then it needs to call setState to recover from errors.
					-- If no state update is scheduled then the boundary will swallow the error.
					if not includesSomeLane(fiber.lanes, SyncLane) then
						console.error(
							"%s: Error boundaries should implement getDerivedStateFromError(). "
								.. "In that method, return a state update to display an error message or fallback UI.",
							getComponentName(fiber.type) or "Unknown"
						)
					end
				end
			end
		end
	elseif _G.__DEV__ then
		update.callback = function()
			markFailedErrorBoundaryForHotReloading(fiber)
		end
	end
	return update
end

local function attachPingListener(root: FiberRoot, wakeable: Wakeable, lanes: Lanes)
	-- Attach a listener to the promise to "ping" the root and retry. But only if
	-- one does not already exist for the lanes we're currently rendering (which
	-- acts like a "thread ID" here).
	local pingCache: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)> | nil = root.pingCache
	local threadIDs
	if pingCache == nil then
		-- deviation: use table in place of WeakMap
		-- performance: slight re-ordering so we initialize the table in one shot
		threadIDs = {} :: Set<any>
		root.pingCache = {
			[wakeable] = threadIDs,
		} :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>
		pingCache = root.pingCache :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>
	else
		threadIDs = (pingCache :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>)[wakeable] :: Set<any>
		if threadIDs == nil then
			threadIDs = {} :: Set<any>;
			(pingCache :: Map<Wakeable, (Set<any> | Map<Wakeable, Set<any>>)>)[wakeable] = threadIDs
		end
	end
	if not threadIDs[lanes] then
		-- Memoize using the thread ID to prevent redundant listeners.
		threadIDs[lanes] = true
		local ping = function()
			return pingSuspendedRoot(root, wakeable, lanes)
		end
		wakeable:andThen(ping, ping)
	end
end

function throwException(
	root: FiberRoot,
	returnFiber: Fiber,
	sourceFiber: Fiber,
	value: any,
	rootRenderLanes: Lanes,
	onUncaughtError,
	renderDidError
)
	-- The source fiber did not complete.
	sourceFiber.flags = bit32.bor(sourceFiber.flags, Incomplete)

	if value ~= nil and typeof(value) == "table" and typeof(value.andThen) == "function" then
		-- This is a wakeable.
		local wakeable: Wakeable = value

		if _G.__DEV__ then
			if enableDebugTracing then
				if bit32.band(sourceFiber.mode, DebugTracingMode) ~= 0 then
					local name = getComponentName(sourceFiber.type) or "Unknown"
					logComponentSuspended(name, wakeable)
				end
			end
		end

		if enableSchedulingProfiler then
			markComponentSuspended(sourceFiber, wakeable)
		end

		if bit32.band(sourceFiber.mode, BlockingMode) == NoMode then
			-- Reset the memoizedState to what it was before we attempted
			-- to render it.
			local currentSource = sourceFiber.alternate
			if currentSource then
				-- performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
				sourceFiber.updateQueue = currentSource.updateQueue
				sourceFiber.memoizedState = currentSource.memoizedState
				sourceFiber.lanes = currentSource.lanes
			else
				-- performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
				sourceFiber.updateQueue = nil
				sourceFiber.memoizedState = nil
			end
		end

		local hasInvisibleParentBoundary =
			hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext :: SuspenseContext)

		-- Schedule the nearest Suspense to re-render the timed out view.
		local workInProgress = returnFiber
		repeat
			if
				workInProgress.tag == SuspenseComponent
				and shouldCaptureSuspense(workInProgress, hasInvisibleParentBoundary)
			then
				-- Found the nearest boundary.

				-- Stash the promise on the boundary fiber. If the boundary times out, we'll
				-- attach another listener to flip the boundary back to its normal state.
				local wakeables: Set<Wakeable> = workInProgress.updateQueue
				if wakeables == nil then
					local updateQueue = {
						[wakeable] = true,
					}
					-- performance TODO: return non-nil updateQueue object to the ReactUpdateQUeue pool
					workInProgress.updateQueue = updateQueue
				else
					wakeables[wakeable] = true
				end

				-- If the boundary is outside of blocking mode, we should *not*
				-- suspend the commit. Pretend as if the suspended component rendered
				-- nil and keep rendering. In the commit phase, we'll schedule a
				-- subsequent synchronous update to re-render the Suspense.
				--
				-- NOTE: It doesn't matter whether the component that suspended was
				-- inside a blocking mode tree. If the Suspense is outside of it, we
				-- should *not* suspend the commit.
				if bit32.band(workInProgress.mode, BlockingMode) == NoMode then
					workInProgress.flags = bit32.bor(workInProgress.flags, DidCapture)
					sourceFiber.flags = bit32.bor(sourceFiber.flags, ForceUpdateForLegacySuspense)

					-- We're going to commit this fiber even though it didn't complete.
					-- But we shouldn't call any lifecycle methods or callbacks. Remove
					-- all lifecycle effect tags.
					sourceFiber.flags =
						bit32.band(sourceFiber.flags, bit32.bnot(bit32.bor(LifecycleEffectMask, Incomplete)))

					if sourceFiber.tag == ClassComponent then
						local currentSourceFiber = sourceFiber.alternate
						if currentSourceFiber == nil then
							-- This is a new mount. Change the tag so it's not mistaken for a
							-- completed class component. For example, we should not call
							-- componentWillUnmount if it is deleted.
							sourceFiber.tag = IncompleteClassComponent
						else
							-- When we try rendering again, we should not reuse the current fiber,
							-- since it's known to be in an inconsistent state. Use a force update to
							-- prevent a bail out.
							local update = createUpdate(NoTimestamp, SyncLane)
							update.tag = ForceUpdate
							enqueueUpdate(sourceFiber, update)
						end
					end

					-- The source fiber did not complete. Mark it with Sync priority to
					-- indicate that it still has pending work.
					sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane)

					-- Exit without suspending.
					return
				end

				-- Confirmed that the boundary is in a concurrent mode tree. Continue
				-- with the normal suspend path.
				--
				-- After this we'll use a set of heuristics to determine whether this
				-- render pass will run to completion or restart or "suspend" the commit.
				-- The actual logic for this is spread out in different places.
				--
				-- This first principle is that if we're going to suspend when we complete
				-- a root, then we should also restart if we get an update or ping that
				-- might unsuspend it, and vice versa. The only reason to suspend is
				-- because you think you might want to restart before committing. However,
				-- it doesn't make sense to restart only while in the period we're suspended.
				--
				-- Restarting too aggressively is also not good because it starves out any
				-- intermediate loading state. So we use heuristics to determine when.

				-- Suspense Heuristics
				--
				-- If nothing threw a Promise or all the same fallbacks are already showing,
				-- then don't suspend/restart.
				--
				-- If this is an initial render of a new tree of Suspense boundaries and
				-- those trigger a fallback, then don't suspend/restart. We want to ensure
				-- that we can show the initial loading state as quickly as possible.
				--
				-- If we hit a "Delayed" case, such as when we'd switch from content back into
				-- a fallback, then we should always suspend/restart. Transitions apply
				-- to this case. If none is defined, JND is used instead.
				--
				-- If we're already showing a fallback and it gets "retried", allowing us to show
				-- another level, but there's still an inner boundary that would show a fallback,
				-- then we suspend/restart for 500ms since the last time we showed a fallback
				-- anywhere in the tree. This effectively throttles progressive loading into a
				-- consistent train of commits. This also gives us an opportunity to restart to
				-- get to the completed state slightly earlier.
				--
				-- If there's ambiguity due to batching it's resolved in preference of:
				-- 1) "delayed", 2) "initial render", 3) "retry".
				--
				-- We want to ensure that a "busy" state doesn't get force committed. We want to
				-- ensure that new initial loading states can commit as soon as possible.

				attachPingListener(root, wakeable, rootRenderLanes)

				workInProgress.flags = bit32.bor(workInProgress.flags, ShouldCapture)
				workInProgress.lanes = rootRenderLanes

				return
			end
			-- This boundary already captured during this render. Continue to the next
			-- boundary.
			workInProgress = workInProgress.return_ :: Fiber -- TODO: Luau narrowing doesn't understand this loop until nil pattern
		until workInProgress == nil

		-- No boundary was found. Fallthrough to error mode.
		-- TODO: Use invariant so the message is stripped in prod?
		value = (getComponentName(sourceFiber.type) or "A React component")
			.. " suspended while rendering, but no fallback UI was specified.\n"
			.. "\n"
			.. "Add a <Suspense fallback=...> component higher in the tree to "
			.. "provide a loading indicator or placeholder to display."
	end

	-- We didn't find a boundary that could handle this type of exception. Start
	-- over and traverse parent path again, this time treating the exception
	-- as an error.
	renderDidError()

	value = createCapturedValue(value, sourceFiber)
	local workInProgress = returnFiber
	repeat
		if workInProgress.tag == HostRoot then
			local errorInfo = value
			workInProgress.flags = bit32.bor(workInProgress.flags, ShouldCapture)
			local lane = pickArbitraryLane(rootRenderLanes)
			workInProgress.lanes = mergeLanes(workInProgress.lanes, lane)
			-- deviation: parameterize method onUncaughtError to avoid circular dependency
			local update = createRootErrorUpdate(workInProgress, errorInfo, lane, onUncaughtError)
			enqueueCapturedUpdate(workInProgress, update)
			return
		elseif workInProgress.tag == ClassComponent then
			-- Capture and retry
			local errorInfo = value
			local ctor = workInProgress.type
			local instance = workInProgress.stateNode
			if
				bit32.band(workInProgress.flags, DidCapture) == NoFlags
				and (
					typeof(ctor.getDerivedStateFromError) == "function"
					or (
						instance ~= nil
						and typeof(instance.componentDidCatch) == "function"
						and not isAlreadyFailedLegacyErrorBoundary(instance)
					)
				)
			then
				workInProgress.flags = bit32.bor(workInProgress.flags, ShouldCapture)
				local lane = pickArbitraryLane(rootRenderLanes)
				workInProgress.lanes = mergeLanes(workInProgress.lanes, lane)
				-- Schedule the error boundary to re-render using updated state
				local update = createClassErrorUpdate(workInProgress, errorInfo, lane)
				enqueueCapturedUpdate(workInProgress, update)
				return
			end
		end
		workInProgress = workInProgress.return_ :: Fiber -- TODO: Luau narrowing doesn't understand this loop until nil pattern
	until workInProgress == nil
end

return {
	throwException = throwException,
	createRootErrorUpdate = createRootErrorUpdate,
	createClassErrorUpdate = createClassErrorUpdate,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000611e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX010A61C1AF7B4232B9CAFFFCBC952EC9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberTransition</string>
								<string name="ScriptGuid">{33C71EF5-7745-45BC-8890-C9380927DBC6}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/ddd1faa1972b614dfbfae205f2aa4a6c0b39a759/packages/react-reconciler/src/ReactFiberTransition.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent

local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals

local ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig

return {
	NoTransition = 0,
	requestCurrentTransition = function(): number
		return ReactCurrentBatchConfig.transition
	end,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000611f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB68D39B2DC8B4223BB86D3A3BB135084">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberTreeReflection</string>
								<string name="ScriptGuid">{3D12598E-59A7-4BFF-81FA-8640D35B9C79}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberTreeReflection.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
type Container = ReactFiberHostConfig.Container
type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local invariant = require(Packages.Shared).invariant

local getInstance = require(Packages.Shared).ReactInstanceMap.get
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local getComponentName = require(Packages.Shared).getComponentName
local ReactWorkTags = require(script.Parent.ReactWorkTags)
local ClassComponent = ReactWorkTags.ClassComponent
local HostComponent = ReactWorkTags.HostComponent
local HostRoot = ReactWorkTags.HostRoot
local HostPortal = ReactWorkTags.HostPortal
local HostText = ReactWorkTags.HostText
local FundamentalComponent = ReactWorkTags.FundamentalComponent
local SuspenseComponent = ReactWorkTags.SuspenseComponent
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local NoFlags = ReactFiberFlags.NoFlags
local Placement = ReactFiberFlags.Placement
local Hydrating = ReactFiberFlags.Hydrating
local enableFundamentalAPI = require(Packages.Shared).ReactFeatureFlags.enableFundamentalAPI

local ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner

local exports = {}

local function getNearestMountedFiber(fiber: Fiber): Fiber?
	local node = fiber
	-- FIXME Luau: Luau should infer this annotation
	local nearestMounted: Fiber | nil = fiber
	if not fiber.alternate then
		-- If there is no alternate, this might be a new tree that isn't inserted
		-- yet. If it is, then it will have a pending insertion effect on it.
		local nextNode = node
		repeat
			node = nextNode
			if bit32.band(node.flags, bit32.bor(Placement, Hydrating)) ~= NoFlags then
				-- This is an insertion or in-progress hydration. The nearest possible
				-- mounted fiber is the parent but we need to continue to figure out
				-- if that one is still mounted.
				nearestMounted = node.return_
			end
			nextNode = node.return_
		until not nextNode
	else
		while node.return_ do
			node = node.return_
		end
	end
	if node.tag == HostRoot then
		-- TODO: Check if this was a nested HostRoot when used with
		-- renderContainerIntoSubtree.
		return nearestMounted
	end
	-- If we didn't hit the root, that means that we're in an disconnected tree
	-- that has been unmounted.
	return nil
end
exports.getNearestMountedFiber = getNearestMountedFiber

exports.getSuspenseInstanceFromFiber = function(fiber: Fiber): SuspenseInstance?
	if fiber.tag == SuspenseComponent then
		local suspenseState: SuspenseState? = fiber.memoizedState
		if suspenseState == nil then
			local current = fiber.alternate
			if current ~= nil then
				suspenseState = current.memoizedState
			end
		end
		if suspenseState then
			return suspenseState.dehydrated
		end
	end
	return nil
end

exports.getContainerFromFiber = function(fiber: Fiber): Container?
	return if fiber.tag == HostRoot then fiber.stateNode.containerInfo else nil
end

exports.isFiberMounted = function(fiber: Fiber): boolean
	return getNearestMountedFiber(fiber) == fiber
end

-- TODO: Missing React$ internal flow types
-- exports.isMounted = function(component: React$Component<any, any>): boolean
exports.isMounted = function(component): boolean
	if _G.__DEV__ then
		local owner: any = ReactCurrentOwner.current
		if owner ~= nil and owner.tag == ClassComponent then
			local ownerFiber: Fiber = owner
			local instance = ownerFiber.stateNode
			if not instance._warnedAboutRefsInRender then
				console.error(
					"%s is accessing isMounted inside its render() function. "
						.. "render() should be a pure function of props and state. It should "
						.. "never access something that requires stale data from the previous "
						.. "render, such as refs. Move this logic to componentDidMount and "
						.. "componentDidUpdate instead.",
					getComponentName(ownerFiber.type) or "A component"
				)
			end
			instance._warnedAboutRefsInRender = true
		end
	end

	local fiber: Fiber? = getInstance(component)
	if not fiber then
		return false
	else
		-- FIXME: remove any cast once Luau understands if-statement nil check
		local fiberNonNil: any = fiber
		return getNearestMountedFiber(fiberNonNil) == fiber
	end
end

local function assertIsMounted(fiber)
	invariant(getNearestMountedFiber(fiber) == fiber, "Unable to find node on an unmounted component.")
end

local function findCurrentFiberUsingSlowPath(fiber: Fiber): Fiber?
	local alternate = fiber.alternate
	if not alternate then
		-- If there is no alternate, then we only need to check if it is mounted.
		local nearestMounted = getNearestMountedFiber(fiber)
		invariant(nearestMounted ~= nil, "Unable to find node on an unmounted component.")
		if nearestMounted ~= fiber then
			return nil
		end
		return fiber
	end
	-- If we have two possible branches, we'll walk backwards up to the root
	-- to see what path the root points to. On the way we may hit one of the
	-- special cases and we'll deal with them.
	local a: Fiber = fiber
	local b: Fiber = alternate
	while true do
		local parentA = a.return_
		if parentA == nil then
			-- We're at the root.
			break
		end
		local parentB = parentA.alternate
		if parentB == nil then
			-- There is no alternate. This is an unusual case. Currently, it only
			-- happens when a Suspense component is hidden. An extra fragment fiber
			-- is inserted in between the Suspense fiber and its children. Skip
			-- over this extra fragment fiber and proceed to the next parent.
			local nextParent = parentA.return_
			if nextParent ~= nil then
				a = nextParent
				b = nextParent
				continue
			end
			-- If there's no parent, we're at the root.
			break
		end

		-- If both copies of the parent fiber point to the same child, we can
		-- assume that the child is current. This happens when we bailout on low
		-- priority: the bailed out fiber's child reuses the current child.
		if parentA.child == parentB.child then
			local child = parentA.child
			while child do
				if child == a then
					-- We've determined that A is the current branch.
					assertIsMounted(parentA)
					return fiber
				end
				if child == b then
					-- We've determined that B is the current branch.
					assertIsMounted(parentA)
					return alternate
				end
				child = child.sibling
			end
			-- We should never have an alternate for any mounting node. So the only
			-- way this could possibly happen is if this was unmounted, if at all.
			invariant(false, "Unable to find node on an unmounted component.")
		end

		if a.return_ ~= b.return_ then
			-- The return pointer of A and the return pointer of B point to different
			-- fibers. We assume that return pointers never criss-cross, so A must
			-- belong to the child set of A.return, and B must belong to the child
			-- set of B.return.
			a = parentA
			b = parentB
		else
			-- The return pointers point to the same fiber. We'll have to use the
			-- default, slow path: scan the child sets of each parent alternate to see
			-- which child belongs to which set.
			--
			-- Search parent A's child set
			local didFindChild = false
			local child = parentA.child
			while child do
				if child == a then
					didFindChild = true
					a = parentA
					b = parentB
					break
				end
				if child == b then
					didFindChild = true
					b = parentA
					a = parentB
					break
				end
				child = child.sibling
			end
			if not didFindChild then
				-- Search parent B's child set
				child = parentB.child
				while child do
					if child == a then
						didFindChild = true
						a = parentB
						b = parentA
						break
					end
					if child == b then
						didFindChild = true
						b = parentB
						a = parentA
						break
					end
					child = child.sibling
				end
				invariant(
					didFindChild,
					"Child was not found in either parent set. This indicates a bug "
						.. "in React related to the return pointer. Please file an issue."
				)
			end
		end

		invariant(
			a.alternate == b,
			"Return fibers should always be each others' alternates. "
				.. "This error is likely caused by a bug in React. Please file an issue."
		)
	end
	-- If the root is not a host container, we're in a disconnected tree. I.e.
	-- unmounted.
	invariant(a.tag == HostRoot, "Unable to find node on an unmounted component.")
	if a.stateNode.current == a then
		-- We've determined that A is the current branch.
		return fiber
	end
	-- Otherwise B has to be current branch.
	return alternate
end
exports.findCurrentFiberUsingSlowPath = findCurrentFiberUsingSlowPath

exports.findCurrentHostFiber = function(parent: Fiber): Fiber?
	local currentParent = findCurrentFiberUsingSlowPath(parent)
	if not currentParent then
		return nil
	end

	-- Next we'll drill down this component to find the first HostComponent/Text.
	-- FIXME Luau: Luau doesn't narrow based on above branch
	local node: Fiber = currentParent :: Fiber
	while true do
		local child = node.child
		if node.tag == HostComponent or node.tag == HostText then
			return node
		elseif child then
			child.return_ = node
			node = child
			continue
		end
		if node == currentParent then
			return nil
		end
		local return_ = node.return_
		local sibling = node.sibling
		while not sibling do
			if not return_ or return_ == currentParent then
				return nil
			end
			-- FIXME Luau: Luau doesn't narrow based on above branch
			node = return_ :: Fiber
		end
		-- FIXME Luau: Luau doesn't narrow based on above branch
		(sibling :: Fiber).return_ = return_ :: Fiber
		node = sibling :: Fiber
	end
	-- Flow needs the return nil here, but ESLint complains about it.
	-- eslint-disable-next-line no-unreachable
	return nil
end

exports.findCurrentHostFiberWithNoPortals = function(parent: Fiber): Fiber?
	local currentParent = findCurrentFiberUsingSlowPath(parent)
	if not currentParent then
		return nil
	end

	-- Next we'll drill down this component to find the first HostComponent/Text.
	local node: Fiber = currentParent :: Fiber
	while true do
		local child = node.child
		if
			node.tag == HostComponent
			or node.tag == HostText
			or (enableFundamentalAPI and node.tag == FundamentalComponent)
		then
			return node
		elseif child and node.tag ~= HostPortal then
			child.return_ = node
			node = child
			continue
		end
		if node == currentParent then
			return nil
		end
		local return_ = node.return_
		local sibling = node.sibling
		while not sibling do
			if not return_ or return_ == currentParent then
				return nil
			end
			-- FIXME Luau: Luau doesn't narrow based on above branch
			node = return_ :: Fiber
		end
		-- FIXME Luau: Luau doesn't narrow based on above branch
		(sibling :: Fiber).return_ = return_ :: Fiber
		node = sibling :: Fiber
	end
	-- Flow needs the return nil here, but ESLint complains about it.
	-- eslint-disable-next-line no-unreachable
	return nil
end

exports.isFiberSuspenseAndTimedOut = function(fiber: Fiber): boolean
	local memoizedState = fiber.memoizedState
	return fiber.tag == SuspenseComponent and memoizedState ~= nil and memoizedState.dehydrated == nil
end

exports.doesFiberContain = function(parentFiber: Fiber, childFiber: Fiber): boolean
	local node = childFiber
	local parentFiberAlternate = parentFiber.alternate
	while node ~= nil do
		if node == parentFiber or node == parentFiberAlternate then
			return true
		end
		-- FIXME Luau: Luau doesn't understand loop until not nil pattern
		node = node.return_ :: Fiber
	end
	return false
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006120</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9BEC953C4B80432CA83023AB872CBC48">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberUnwindWork.new</string>
								<string name="ScriptGuid">{1B25AE32-DDBE-4648-8621-F92233812974}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactFiberUnwindWork.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState

local resetMutableSourceWorkInProgressVersions =
	require(script.Parent["ReactMutableSource.new"]).resetWorkInProgressVersions
local ReactWorkTags = require(script.Parent.ReactWorkTags)
-- local {ReactFiberFlags.DidCapture, ReactFiberFlags.NoFlags, ReactFiberFlags.ShouldCapture} = require(script.Parent.ReactFiberFlags)
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer

local ReactFiberHostContext = require(script.Parent["ReactFiberHostContext.new"])
local popHostContainer = ReactFiberHostContext.popHostContainer
local popHostContext = ReactFiberHostContext.popHostContext
local popSuspenseContext = require(script.Parent["ReactFiberSuspenseContext.new"]).popSuspenseContext
local resetHydrationState = require(script.Parent["ReactFiberHydrationContext.new"]).resetHydrationState
local ReactFiberContext = require(script.Parent["ReactFiberContext.new"])
local isLegacyContextProvider = ReactFiberContext.isContextProvider
local popLegacyContext = ReactFiberContext.popContext
local popTopLevelLegacyContextObject = ReactFiberContext.popTopLevelContextObject
local popProvider = require(script.Parent["ReactFiberNewContext.new"]).popProvider
-- FIXME: this causes a circular require
local popRenderLanesRef
local popRenderLanes = function(...)
	if not popRenderLanesRef then
		popRenderLanesRef = require(script.Parent["ReactFiberWorkLoop.new"]).popRenderLanes
	end
	return popRenderLanesRef(...)
end
local transferActualDuration = require(script.Parent["ReactProfilerTimer.new"]).transferActualDuration

local invariant = require(Packages.Shared).invariant

local function unwindWork(workInProgress: Fiber, renderLanes: Lanes): Fiber?
	if workInProgress.tag == ReactWorkTags.ClassComponent then
		local Component = workInProgress.type
		if isLegacyContextProvider(Component) then
			popLegacyContext(workInProgress)
		end
		local flags = workInProgress.flags
		if bit32.band(flags, ReactFiberFlags.ShouldCapture) ~= 0 then
			workInProgress.flags =
				bit32.bor(bit32.band(flags, bit32.bnot(ReactFiberFlags.ShouldCapture)), ReactFiberFlags.DidCapture)
			if
				enableProfilerTimer
				and bit32.band(workInProgress.mode, ReactTypeOfMode.ProfileMode) ~= ReactTypeOfMode.NoMode
			then
				transferActualDuration(workInProgress)
			end
			return workInProgress
		end
		return nil
	elseif workInProgress.tag == ReactWorkTags.HostRoot then
		popHostContainer(workInProgress)
		popTopLevelLegacyContextObject(workInProgress)
		resetMutableSourceWorkInProgressVersions()
		local flags = workInProgress.flags
		invariant(
			bit32.band(flags, ReactFiberFlags.DidCapture) == ReactFiberFlags.NoFlags,
			"The root failed to unmount after an error. This is likely a bug in " .. "React. Please file an issue."
		)
		workInProgress.flags =
			bit32.bor(bit32.band(flags, bit32.bnot(ReactFiberFlags.ShouldCapture)), ReactFiberFlags.DidCapture)
		return workInProgress
	elseif workInProgress.tag == ReactWorkTags.HostComponent then
		-- TODO: popHydrationState
		popHostContext(workInProgress)
		return nil
	elseif workInProgress.tag == ReactWorkTags.SuspenseComponent then
		popSuspenseContext(workInProgress)
		if enableSuspenseServerRenderer then
			local suspenseState = workInProgress.memoizedState
			if suspenseState ~= nil and suspenseState.dehydrated ~= nil then
				invariant(
					workInProgress.alternate ~= nil,
					"Threw in newly mounted dehydrated component. This is likely a bug in "
						.. "React. Please file an issue."
				)
				resetHydrationState()
			end
		end
		local flags = workInProgress.flags
		if bit32.band(flags, ReactFiberFlags.ShouldCapture) ~= 0 then
			workInProgress.flags =
				bit32.bor(bit32.band(flags, bit32.bnot(ReactFiberFlags.ShouldCapture)), ReactFiberFlags.DidCapture)
			-- Captured a suspense effect. Re-render the boundary.
			if
				enableProfilerTimer
				and (bit32.band(workInProgress.mode, ReactTypeOfMode.ProfileMode) ~= ReactTypeOfMode.NoMode)
			then
				transferActualDuration(workInProgress)
			end
			return workInProgress
		end
		return nil
	elseif workInProgress.tag == ReactWorkTags.SuspenseListComponent then
		popSuspenseContext(workInProgress)
		-- SuspenseList doesn't actually catch anything. It should've been
		-- caught by a nested boundary. If not, it should bubble through.
		return nil
	elseif workInProgress.tag == ReactWorkTags.HostPortal then
		popHostContainer(workInProgress)
		return nil
	elseif workInProgress.tag == ReactWorkTags.ContextProvider then
		popProvider(workInProgress)
		return nil
	elseif
		workInProgress.tag == ReactWorkTags.OffscreenComponent
		or workInProgress.tag == ReactWorkTags.LegacyHiddenComponent
	then
		popRenderLanes(workInProgress)
		return nil
	else
		return nil
	end
end

function unwindInterruptedWork(interruptedWork: Fiber)
	if interruptedWork.tag == ReactWorkTags.ClassComponent then
		-- deviation: Lua doesn't support properties on functions
		local childContextTypes
		if typeof(interruptedWork.type) == "table" then
			childContextTypes = interruptedWork.type.childContextTypes
		end
		if childContextTypes ~= nil then
			popLegacyContext(interruptedWork)
		end
	elseif interruptedWork.tag == ReactWorkTags.HostRoot then
		popHostContainer(interruptedWork)
		popTopLevelLegacyContextObject(interruptedWork)
		resetMutableSourceWorkInProgressVersions()
	elseif interruptedWork.tag == ReactWorkTags.HostComponent then
		popHostContext(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.HostPortal then
		popHostContainer(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.SuspenseComponent then
		popSuspenseContext(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.SuspenseListComponent then
		popSuspenseContext(interruptedWork)
	elseif interruptedWork.tag == ReactWorkTags.ContextProvider then
		popProvider(interruptedWork)
	elseif
		interruptedWork.tag == ReactWorkTags.OffscreenComponent
		or interruptedWork.tag == ReactWorkTags.LegacyHiddenComponent
	then
		popRenderLanes(interruptedWork)
		return
	else -- default
		return
	end
end

return {
	unwindWork = unwindWork,
	unwindInterruptedWork = unwindInterruptedWork,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006121</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX48023621AA9047459B572089706097DF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberWorkInProgress</string>
								<string name="ScriptGuid">{F8C803FE-522C-46B9-8E5E-A02512B236DC}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- deviation: this is an extraction of a single state field
-- (and associated mutation/getters) from ReactFiberWorkLooop.new
-- which allows us to break dependency cycles involving that module
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiberWorkLoop.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local ReactFiberLane = require(script.Parent.ReactFiberLane)
local _workInProgressRootSkippedLanes: Lanes = ReactFiberLane.NoLanes
local mergeLanes = ReactFiberLane.mergeLanes
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane

local exports = {}

-- TODO: turn this into newindex property accessor
exports.workInProgressRootSkippedLanes = function(value: Lanes?): Lanes
	if value == nil then
		return _workInProgressRootSkippedLanes
	end

	-- FIXME Luau: Luau should narrow based on guard above
	_workInProgressRootSkippedLanes = value :: Lanes
	return _workInProgressRootSkippedLanes
end

exports.markSkippedUpdateLanes = function(lane: Lane | Lanes): ()
	_workInProgressRootSkippedLanes = mergeLanes(lane, _workInProgressRootSkippedLanes)
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006122</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE940B0A391C74D46A5D7AC1675EA4D38">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberWorkLoop.new</string>
								<string name="ScriptGuid">{DC9A156A-61E1-4C5E-8394-83791671A3CD}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactFiberWorkLoop.new.js
--!nonstrict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local __DEV__ = _G.__DEV__
local __YOLO__ = _G.__YOLO__

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Set = LuauPolyfill.Set
type Set<T> = LuauPolyfill.Set<T>
type Array<T> = LuauPolyfill.Array<T>

local exports: any = {}

local ReactTypes = require(Packages.Shared)
type Thenable<T> = ReactTypes.Thenable<T>
type Wakeable = ReactTypes.Wakeable

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type FiberRoot = ReactInternalTypes.FiberRoot
type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel
local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lanes = ReactFiberLane.Lanes
type Lane = ReactFiberLane.Lane
-- The scheduler is imported here *only* to detect whether it's been mocked
local Scheduler = require(Packages.Scheduler)
-- deviation: we import from top-level Scheduler exports to avoid direct file access

type Interaction = Scheduler.Interaction

local ReactFiberSuspenseComponent = require(script.Parent["ReactFiberSuspenseComponent.new"])
type SuspenseState = ReactFiberSuspenseComponent.SuspenseState
local ReactFiberStack = require(script.Parent["ReactFiberStack.new"])
type StackCursor<T> = ReactFiberStack.StackCursor<T>

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- deviation: Use some properties directly instead of localizing to avoid 200 limit
-- local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local replayFailedUnitOfWorkWithInvokeGuardedCallback = ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback
-- local warnAboutUnmockedScheduler = ReactFeatureFlags.warnAboutUnmockedScheduler
-- local deferRenderPhaseUpdateToNextBatch = ReactFeatureFlags.ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch
-- local decoupleUpdatePriorityFromScheduler = ReactFeatureFlags.ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
local enableDebugTracing = ReactFeatureFlags.enableDebugTracing
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local skipUnmountedBoundaries = ReactFeatureFlags.skipUnmountedBoundaries
local enableDoubleInvokingEffects = ReactFeatureFlags.enableDoubleInvokingEffects
local ReactShared = require(Packages.Shared)
-- deviation: we pull in Dispatcher type because we need it for our lazy loading deviations to typecheck
type Dispatcher = ReactShared.Dispatcher
local describeError = require(Packages.Shared).describeError
local ReactSharedInternals = ReactShared.ReactSharedInternals
local invariant = ReactShared.invariant

local SchedulerWithReactIntegration = require(script.Parent["SchedulerWithReactIntegration.new"])
local scheduleCallback = SchedulerWithReactIntegration.scheduleCallback
local cancelCallback = SchedulerWithReactIntegration.cancelCallback
local getCurrentPriorityLevel = SchedulerWithReactIntegration.getCurrentPriorityLevel
local runWithPriority = SchedulerWithReactIntegration.runWithPriority
local shouldYield = SchedulerWithReactIntegration.shouldYield
local requestPaint = SchedulerWithReactIntegration.requestPaint
local now = SchedulerWithReactIntegration.now
local NoSchedulerPriority = SchedulerWithReactIntegration.NoPriority
local ImmediateSchedulerPriority = SchedulerWithReactIntegration.ImmediatePriority
local UserBlockingSchedulerPriority = SchedulerWithReactIntegration.UserBlockingPriority
local NormalSchedulerPriority = SchedulerWithReactIntegration.NormalPriority
local flushSyncCallbackQueue = SchedulerWithReactIntegration.flushSyncCallbackQueue
local scheduleSyncCallback = SchedulerWithReactIntegration.scheduleSyncCallback
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local {
--   DebugTracing.logCommitStarted,
--   DebugTracing.logCommitStopped,
--   DebugTracing.logLayoutEffectsStarted,
--   DebugTracing.logLayoutEffectsStopped,
--   logPassiveEffectsStarted,
--   DebugTracing.logPassiveEffectsStopped,
--   DebugTracing.logRenderStarted,
--   DebugTracing.logRenderStopped,
local DebugTracing = require(script.Parent.DebugTracing)
-- local {
--   SchedulingProfiler.markCommitStarted,
--   SchedulingProfiler.markCommitStopped,
--   SchedulingProfiler.markLayoutEffectsStarted,
--   SchedulingProfiler.markLayoutEffectsStopped,
--   SchedulingProfiler.markPassiveEffectsStarted,
--   SchedulingProfiler.markPassiveEffectsStopped,
--   SchedulingProfiler.markRenderStarted,
--   SchedulingProfiler.markRenderYielded,
--   SchedulingProfiler.markRenderStopped,
local SchedulingProfiler = require(script.Parent.SchedulingProfiler)

local SchedulerTracing = require(Packages.Scheduler).tracing
local __interactionsRef, __subscriberRef = SchedulerTracing.__interactionsRef, SchedulerTracing.__subscriberRef

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local prepareForCommit = ReactFiberHostConfig.prepareForCommit
-- local resetAfterCommit = ReactFiberHostConfig.resetAfterCommit
-- local scheduleTimeout = ReactFiberHostConfig.scheduleTimeout
-- local cancelTimeout = ReactFiberHostConfig.cancelTimeout
-- local noTimeout = ReactFiberHostConfig.noTimeout
-- local warnsIfNotActing = ReactFiberHostConfig.warnsIfNotActing
-- local beforeActiveInstanceBlur = ReactFiberHostConfig.beforeActiveInstanceBlur
-- local afterActiveInstanceBlur = ReactFiberHostConfig.afterActiveInstanceBlur
-- local clearContainer = ReactFiberHostConfig.clearContainer

local ReactFiber = require(script.Parent["ReactFiber.new"])
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local createWorkInProgress = ReactFiber.createWorkInProgress
-- local assignFiberPropertiesInDEV = ReactFiber.assignFiberPropertiesInDEV
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local NoMode = ReactTypeOfMode.NoMode
-- local StrictMode = ReactTypeOfMode.StrictMode
-- local ProfileMode = ReactTypeOfMode.ProfileMode
-- local BlockingMode = ReactTypeOfMode.BlockingMode
-- local ConcurrentMode = ReactTypeOfMode.ConcurrentMode
local ReactWorkTags = require(script.Parent.ReactWorkTags)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local HostRoot = ReactWorkTags.HostRoot
-- local IndeterminateComponent = ReactWorkTags.IndeterminateComponent
-- local ClassComponent = ReactWorkTags.ClassComponent
-- local SuspenseComponent = ReactWorkTags.SuspenseComponent
-- local SuspenseListComponent = ReactWorkTags.SuspenseListComponent
-- local FunctionComponent = ReactWorkTags.FunctionComponent
-- local ForwardRef = ReactWorkTags.ForwardRef
-- local MemoComponent = ReactWorkTags.MemoComponent
-- local SimpleMemoComponent = ReactWorkTags.SimpleMemoComponent
local LegacyRoot = require(script.Parent.ReactRootTags).LegacyRoot
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
type Flags = ReactFiberFlags.Flags
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local NoFlags = ReactFiberFlags.NoFlags
-- local Placement = ReactFiberFlags.Placement
-- local Incomplete = ReactFiberFlags.Incomplete
-- local HostEffectMask = ReactFiberFlags.HostEffectMask
-- local Hydrating = ReactFiberFlags.Hydrating
-- local BeforeMutationMask = ReactFiberFlags.BeforeMutationMask
-- local MutationMask = ReactFiberFlags.MutationMask
-- local LayoutMask = ReactFiberFlags.LayoutMask
-- local PassiveMask = ReactFiberFlags.PassiveMask
-- local NoLane = ReactFiberLane.NoLane
local SyncLane = ReactFiberLane.SyncLane
local SyncBatchedLane = ReactFiberLane.SyncBatchedLane
local NoTimestamp = ReactFiberLane.NoTimestamp
local findUpdateLane = ReactFiberLane.findUpdateLane
local findTransitionLane = ReactFiberLane.findTransitionLane
local findRetryLane = ReactFiberLane.findRetryLane
local includesSomeLane = ReactFiberLane.includesSomeLane
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local mergeLanes = ReactFiberLane.mergeLanes
local removeLanes = ReactFiberLane.removeLanes
local pickArbitraryLane = ReactFiberLane.pickArbitraryLane
local hasDiscreteLanes = ReactFiberLane.hasDiscreteLanes
local includesNonIdleWork = ReactFiberLane.includesNonIdleWork
local includesOnlyRetries = ReactFiberLane.includesOnlyRetries
local includesOnlyTransitions = ReactFiberLane.includesOnlyTransitions
local getNextLanes = ReactFiberLane.getNextLanes
local returnNextLanesPriority = ReactFiberLane.returnNextLanesPriority
local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority
local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
local markStarvedLanesAsExpired = ReactFiberLane.markStarvedLanesAsExpired
local getLanesToRetrySynchronouslyOnError = ReactFiberLane.getLanesToRetrySynchronouslyOnError
local getMostRecentEventTime = ReactFiberLane.getMostRecentEventTime
local markRootUpdated = ReactFiberLane.markRootUpdated
local markRootSuspended_dontCallThisOneDirectly = ReactFiberLane.markRootSuspended
local markRootPinged = ReactFiberLane.markRootPinged
local markRootExpired = ReactFiberLane.markRootExpired
local markDiscreteUpdatesExpired = ReactFiberLane.markDiscreteUpdatesExpired
local markRootFinished = ReactFiberLane.markRootFinished
local schedulerPriorityToLanePriority = ReactFiberLane.schedulerPriorityToLanePriority
local lanePriorityToSchedulerPriority = ReactFiberLane.lanePriorityToSchedulerPriority
local ReactFiberTransition = require(script.Parent.ReactFiberTransition)
-- deviation: Use properties directly instead of localizing to avoid 200 limit
-- local requestCurrentTransition = ReactFiberTransition.requestCurrentTransition
-- local NoTransition = ReactFiberTransition.NoTransition

local ReactFiberUnwindWork = require(script.Parent["ReactFiberUnwindWork.new"]) :: any
local unwindWork = ReactFiberUnwindWork.unwindWork
local unwindInterruptedWork = ReactFiberUnwindWork.unwindInterruptedWork
local ReactFiberThrow = require(script.Parent["ReactFiberThrow.new"]) :: any
local throwException = ReactFiberThrow.throwException
local createRootErrorUpdate = ReactFiberThrow.createRootErrorUpdate
local createClassErrorUpdate = ReactFiberThrow.createClassErrorUpdate
local ReactFiberCommitWork = require(script.Parent["ReactFiberCommitWork.new"])
local commitBeforeMutationEffectOnFiber = ReactFiberCommitWork.commitBeforeMutationLifeCycles
local commitPlacement = ReactFiberCommitWork.commitPlacement
local commitWork = ReactFiberCommitWork.commitWork
local commitDeletion = ReactFiberCommitWork.commitDeletion
local commitPassiveUnmountOnFiber = ReactFiberCommitWork.commitPassiveUnmount
local commitPassiveUnmountInsideDeletedTreeOnFiber = ReactFiberCommitWork.commitPassiveUnmountInsideDeletedTree
local commitPassiveMountOnFiber = ReactFiberCommitWork.commitPassiveMount
local commitDetachRef = ReactFiberCommitWork.commitDetachRef
-- local commitAttachRef = ReactFiberCommitWork.commitAttachRef
-- local commitResetTextContent = ReactFiberCommitWork.commitResetTextContent
-- local isSuspenseBoundaryBeingHidden = ReactFiberCommitWork.isSuspenseBoundaryBeingHidden
local invokeLayoutEffectMountInDEV = ReactFiberCommitWork.invokeLayoutEffectMountInDEV
local invokePassiveEffectMountInDEV = ReactFiberCommitWork.invokePassiveEffectMountInDEV
local invokeLayoutEffectUnmountInDEV = ReactFiberCommitWork.invokeLayoutEffectUnmountInDEV
local invokePassiveEffectUnmountInDEV = ReactFiberCommitWork.invokePassiveEffectUnmountInDEV
local recursivelyCommitLayoutEffects = ReactFiberCommitWork.recursivelyCommitLayoutEffects

local Promise = require(Packages.Promise)

local enqueueUpdate = require(script.Parent["ReactUpdateQueue.new"]).enqueueUpdate

local resetContextDependencies = require(script.Parent["ReactFiberNewContext.new"]).resetContextDependencies

-- deviation: Pre-declare function
local ensureRootIsScheduled

-- deviation: lazy init for functions from ReactFiberHooks, put in table b/c local var limit
local lazyInitRefs = {
	resetHooksAfterThrowRef = (nil :: any) :: (...any) -> ...any,
	ContextOnlyDispatcherRef = (nil :: any) :: Dispatcher,
	getIsUpdatingOpaqueValueInRenderPhaseInDEVRef = (nil :: any) :: (...any) -> ...any,
	originalBeginWorkRef = (nil :: any) :: (...any) -> ...any,
	completeWorkRef = (nil :: any) :: (...any) -> ...any,
}

-- deviation: lazy initialize beginwork to break cyclic dependencies
local originalBeginWork = function(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
	if not lazyInitRefs.originalBeginWorkRef then
		lazyInitRefs.originalBeginWorkRef = require(script.Parent["ReactFiberBeginWork.new"]).beginWork
	end
	return lazyInitRefs.originalBeginWorkRef(current, workInProgress, renderLanes)
end

local completeWork = function(current: Fiber | nil, workInProgress: Fiber, renderLanes: Lanes): Fiber | nil
	if not lazyInitRefs.completeWorkRef then
		lazyInitRefs.completeWorkRef = require(script.Parent["ReactFiberCompleteWork.new"]).completeWork
	end
	return (lazyInitRefs.completeWorkRef :: any)(current, workInProgress, renderLanes)
end

local ReactFiberHooks
-- deviation: lazy init for functions from ReactFiberHooks
local function initReactFiberHooks()
	ReactFiberHooks = require(script.Parent["ReactFiberHooks.new"])
	lazyInitRefs.resetHooksAfterThrowRef = ReactFiberHooks.resetHooksAfterThrow
	lazyInitRefs.ContextOnlyDispatcherRef = ReactFiberHooks.ContextOnlyDispatcher
	lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef =
		ReactFiberHooks.getIsUpdatingOpaqueValueInRenderPhaseInDEV
end

-- deviation: lazy init for resetHooksAfterThrow from ReactFiberHooks
local resetHooksAfterThrow = function(): ()
	if not lazyInitRefs.resetHooksAfterThrowRef then
		initReactFiberHooks()
	end
	return lazyInitRefs.resetHooksAfterThrowRef()
end

-- deviation: lazy init for ContextOnlyDispatcher from ReactFiberHooks
local ContextOnlyDispatcher = function(): Dispatcher
	if not lazyInitRefs.ContextOnlyDispatcherRef then
		initReactFiberHooks()
	end
	return lazyInitRefs.ContextOnlyDispatcherRef
end

-- deviation: lazy init for getIsUpdatingOpaqueValueInRenderPhaseInDEV from ReactFiberHooks
local getIsUpdatingOpaqueValueInRenderPhaseInDEV = function(): boolean?
	if not lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef then
		initReactFiberHooks()
	end
	return lazyInitRefs.getIsUpdatingOpaqueValueInRenderPhaseInDEVRef()
end

local createCapturedValue = require(script.Parent.ReactCapturedValue).createCapturedValue
local pushToStack = ReactFiberStack.push
local popFromStack = ReactFiberStack.pop
local createCursor = ReactFiberStack.createCursor

local ReactProfilerTimer = require(script.Parent["ReactProfilerTimer.new"])

-- DEV stuff
local getComponentName = require(Packages.Shared).getComponentName
local ReactStrictModeWarnings = require(script.Parent["ReactStrictModeWarnings.new"])
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
-- deviation: these two properties would be captured as values instead of bound
-- local ReactCurrentDebugFiberIsRenderingInDEV = ReactCurrentFiber.isRendering
local ReactCurrentFiberCurrent = ReactCurrentFiber.current
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local ReactErrorUtils = require(Packages.Shared).ReactErrorUtils
local invokeGuardedCallback = ReactErrorUtils.invokeGuardedCallback
local hasCaughtError = ReactErrorUtils.hasCaughtError
local clearCaughtError = ReactErrorUtils.clearCaughtError
local onCommitRootDevTools = require(script.Parent["ReactFiberDevToolsHook.new"]).onCommitRoot
local onCommitRootTestSelector = require(script.Parent.ReactTestSelectors).onCommitRoot

-- Used by `act`
local enqueueTask = require(Packages.Shared).enqueueTask
local doesFiberContain = require(script.Parent.ReactFiberTreeReflection).doesFiberContain

local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher
local ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner
local IsSomeRendererActing = ReactSharedInternals.IsSomeRendererActing
local captureCommitPhaseErrorOnRoot, flushPassiveMountEffects

-- local ceil = math.ceil

-- deviation: Pre-declare functions
local mod: { [string]: any } = {}

type ExecutionContext = number

local NoContext = --[[                    ]]
	0b0000000
local BatchedContext = --[[               ]]
	0b0000001
local EventContext = --[[                 ]]
	0b0000010
local DiscreteEventContext = --[[         ]]
	0b0000100
local LegacyUnbatchedContext = --[[       ]]
	0b0001000
local RenderContext = --[[                ]]
	0b0010000
local CommitContext = --[[                ]]
	0b0100000
local RetryAfterError = --[[              ]]
	0b1000000

exports.NoContext = NoContext
exports.RetryAfterError = RetryAfterError

-- deviation: Luau doesn't yet support literal types
-- type RootExitStatus = 0 | 1 | 2 | 3 | 4 | 5
type RootExitStatus = number
-- deviation: Define constants in a table instead of locals to avoid 200 limit
local RootExitStatus: { [string]: RootExitStatus } = {
	Incomplete = 0,
	FatalErrored = 1,
	Errored = 2,
	Suspended = 3,
	SuspendedWithDelay = 4,
	Completed = 5,
}

-- Describes where we are in the React execution stack
local executionContext: ExecutionContext = NoContext
-- The root we're working on
local workInProgressRoot: FiberRoot? = nil
-- The fiber we're working on
local workInProgress: Fiber? = nil
-- The lanes we're rendering
local workInProgressRootRenderLanes: Lanes = ReactFiberLane.NoLanes

-- Stack that allows components to change the render lanes for its subtree
-- This is a superset of the lanes we started working on at the root. The only
-- case where it's different from `workInProgressRootRenderLanes` is when we
-- enter a subtree that is hidden and needs to be unhidden: Suspense and
-- Offscreen component.
--
-- Most things in the work loop should deal with workInProgressRootRenderLanes.
-- Most things in begin/complete phases should deal with exports.subtreeRenderLanes.
exports.subtreeRenderLanes = ReactFiberLane.NoLanes
local subtreeRenderLanesCursor: StackCursor<Lanes> = createCursor(ReactFiberLane.NoLanes)

-- Whether to root completed, errored, suspended, etc.
local workInProgressRootExitStatus: RootExitStatus = RootExitStatus.Incomplete
-- A fatal error, if one is thrown
local workInProgressRootFatalError: any = nil
-- "Included" lanes refer to lanes that were worked on during this render. It's
-- slightly different than `renderLanes` because `renderLanes` can change as you
-- enter and exit an Offscreen tree. This value is the combination of all render
-- lanes for the entire render phase.
local workInProgressRootIncludedLanes: Lanes = ReactFiberLane.NoLanes
-- The work left over by components that were visited during this render. Only
-- includes unprocessed updates, not work in bailed out children.
local ReactFiberWorkInProgress = require(script.Parent.ReactFiberWorkInProgress)
local workInProgressRootSkippedLanes: (value: Lanes?) -> Lanes = ReactFiberWorkInProgress.workInProgressRootSkippedLanes --: Lanes = ReactFiberLane.NoLanes
-- Lanes that were updated (in an interleaved event) during this render.
local workInProgressRootUpdatedLanes: Lanes = ReactFiberLane.NoLanes
-- Lanes that were pinged (in an interleaved event) during this render.
local workInProgressRootPingedLanes: Lanes = ReactFiberLane.NoLanes

local mostRecentlyUpdatedRoot: FiberRoot | nil = nil

-- The most recent time we committed a fallback. This lets us ensure a train
-- model where we don't commit new loading states in too quick succession.
local globalMostRecentFallbackTime: number = 0
local FALLBACK_THROTTLE_MS: number = 500

-- The absolute time for when we should start giving up on rendering
-- more and prefer CPU suspense heuristics instead.
local workInProgressRootRenderTargetTime: number = math.huge
-- How long a render is supposed to take before we start following CPU
-- suspense heuristics and opt out of rendering more content.
local RENDER_TIMEOUT_MS = 500

-- Used to avoid traversing the return path to find the nearest Profiler ancestor during commit.
local nearestProfilerOnStack: Fiber | nil = nil

local function resetRenderTimer()
	workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS
end

exports.getRenderTargetTime = function(): number
	return workInProgressRootRenderTargetTime
end

local hasUncaughtError = false
local firstUncaughtError = nil
local legacyErrorBoundariesThatAlreadyFailed: Set<any> | nil = nil

local rootDoesHavePassiveEffects: boolean = false
local rootWithPendingPassiveEffects: FiberRoot? = nil
local pendingPassiveEffectsRenderPriority: ReactPriorityLevel = NoSchedulerPriority
local pendingPassiveEffectsLanes: Lanes = ReactFiberLane.NoLanes

local rootsWithPendingDiscreteUpdates: Set<ReactInternalTypes.FiberRoot> | nil = nil

-- Use these to prevent an infinite loop of nested updates
local NESTED_UPDATE_LIMIT = 50
local nestedUpdateCount: number = 0
local rootWithNestedUpdates: FiberRoot | nil = nil

local NESTED_PASSIVE_UPDATE_LIMIT = 50
local nestedPassiveUpdateCount: number = 0

-- Marks the need to reschedule pending interactions at these lanes
-- during the commit phase. This enables them to be traced across components
-- that spawn new work during render. E.g. hidden boundaries, suspended SSR
-- hydration or SuspenseList.
-- TODO: Can use a bitmask instead of an array
local spawnedWorkDuringRender: nil | Array<Lane | Lanes> = nil

-- If two updates are scheduled within the same event, we should treat their
-- event times as simultaneous, even if the actual clock time has advanced
-- between the first and second call.
local currentEventTime: number = NoTimestamp
local currentEventWipLanes: Lanes = ReactFiberLane.NoLanes
local currentEventPendingLanes: Lanes = ReactFiberLane.NoLanes

local focusedInstanceHandle: nil | Fiber = nil
local shouldFireAfterActiveInstanceBlur: boolean = false

exports.getWorkInProgressRoot = function(): FiberRoot?
	return workInProgressRoot
end

exports.requestEventTime = function()
	if bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) ~= NoContext then
		-- We're inside React, so it's fine to read the actual time.
		return now()
	end
	-- We're not inside React, so we may be in the middle of a browser event.
	if currentEventTime ~= NoTimestamp then
		-- Use the same start time for all updates until we enter React again.
		return currentEventTime
	end
	-- This is the first update since React yielded. Compute a new start time.
	currentEventTime = now()
	return currentEventTime
end

-- exports.getCurrentTime()
--   return now()
-- end

exports.requestUpdateLane = function(fiber: Fiber): Lane
	-- Special cases
	local mode = fiber.mode
	if bit32.band(mode, ReactTypeOfMode.BlockingMode) == ReactTypeOfMode.NoMode then
		return SyncLane :: Lane
	elseif bit32.band(mode, ReactTypeOfMode.ConcurrentMode) == ReactTypeOfMode.NoMode then
		return if getCurrentPriorityLevel() == ImmediateSchedulerPriority
			then SyncLane :: Lane
			else SyncBatchedLane :: Lane
	elseif
		not ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch
		and bit32.band(executionContext, RenderContext) ~= NoContext
		and workInProgressRootRenderLanes ~= ReactFiberLane.NoLanes
	then
		-- This is a render phase update. These are not officially supported. The
		-- old behavior is to give this the same "thread" (expiration time) as
		-- whatever is currently rendering. So if you call `setState` on a component
		-- that happens later in the same render, it will flush. Ideally, we want to
		-- remove the special case and treat them as if they came from an
		-- interleaved event. Regardless, this pattern is not officially supported.
		-- This behavior is only a fallback. The flag only exists until we can roll
		-- out the setState warning, since existing code might accidentally rely on
		-- the current behavior.
		return pickArbitraryLane(workInProgressRootRenderLanes)
	end

	-- The algorithm for assigning an update to a lane should be stable for all
	-- updates at the same priority within the same event. To do this, the inputs
	-- to the algorithm must be the same. For example, we use the `renderLanes`
	-- to avoid choosing a lane that is already in the middle of rendering.
	--
	-- However, the "included" lanes could be mutated in between updates in the
	-- same event, like if you perform an update inside `flushSync`. Or any other
	-- code path that might call `prepareFreshStack`.
	--
	-- The trick we use is to cache the first of each of these inputs within an
	-- event. Then reset the cached values once we can be sure the event is over.
	-- Our heuristic for that is whenever we enter a concurrent work loop.
	--
	-- We'll do the same for `currentEventPendingLanes` below.
	if currentEventWipLanes == ReactFiberLane.NoLanes then
		currentEventWipLanes = workInProgressRootIncludedLanes
	end

	local isTransition = ReactFiberTransition.requestCurrentTransition() ~= ReactFiberTransition.NoTransition
	if isTransition then
		if currentEventPendingLanes ~= ReactFiberLane.NoLanes then
			if mostRecentlyUpdatedRoot ~= nil then
				currentEventPendingLanes = mostRecentlyUpdatedRoot.pendingLanes
			else
				currentEventPendingLanes = ReactFiberLane.NoLanes
			end
		end
		return findTransitionLane(currentEventWipLanes, currentEventPendingLanes)
	end

	-- TODO: Remove this dependency on the Scheduler priority.
	-- To do that, we're replacing it with an update lane priority.
	local schedulerPriority = getCurrentPriorityLevel()

	-- The old behavior was using the priority level of the Scheduler.
	-- This couples React to the Scheduler internals, so we're replacing it
	-- with the currentUpdateLanePriority above. As an example of how this
	-- could be problematic, if we're not inside `Scheduler.runWithPriority`,
	-- then we'll get the priority of the current running Scheduler task,
	-- which is probably not what we want.
	local lane
	if
		-- TODO: Temporary. We're removing the concept of discrete updates.
		bit32.band(executionContext, DiscreteEventContext) ~= NoContext
		and schedulerPriority == UserBlockingSchedulerPriority
	then
		lane = findUpdateLane(ReactFiberLane.InputDiscreteLanePriority, currentEventWipLanes)
	else
		local schedulerLanePriority = schedulerPriorityToLanePriority(schedulerPriority)

		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			-- In the new strategy, we will track the current update lane priority
			-- inside React and use that priority to select a lane for this update.
			-- For now, we're just logging when they're different so we can assess.
			local currentUpdateLanePriority = getCurrentUpdateLanePriority()

			if
				schedulerLanePriority ~= currentUpdateLanePriority
				and currentUpdateLanePriority ~= ReactFiberLane.NoLanePriority
			then
				if __DEV__ then
					console.error(
						"Expected current scheduler lane priority %s to match current update lane priority %s",
						tostring(schedulerLanePriority),
						tostring(currentUpdateLanePriority)
					)
				end
			end
		end

		lane = findUpdateLane(schedulerLanePriority, currentEventWipLanes)
	end

	return lane
end

function requestRetryLane(fiber: Fiber): Lane
	-- This is a fork of `requestUpdateLane` designed specifically for Suspense
	-- "retries" — a special update that attempts to flip a Suspense boundary
	-- from its placeholder state to its primary/resolved state.

	-- Special cases
	local mode = fiber.mode
	if bit32.band(mode, ReactTypeOfMode.BlockingMode) == ReactTypeOfMode.NoMode then
		return SyncLane :: Lane
	elseif bit32.band(mode, ReactTypeOfMode.ConcurrentMode) == ReactTypeOfMode.NoMode then
		return if getCurrentPriorityLevel() == ImmediateSchedulerPriority
			then SyncLane :: Lane
			else SyncBatchedLane :: Lane
	end

	-- See `requestUpdateLane` for explanation of `currentEventWipLanes`
	if currentEventWipLanes == ReactFiberLane.NoLanes then
		currentEventWipLanes = workInProgressRootIncludedLanes
	end
	return findRetryLane(currentEventWipLanes)
end

exports.scheduleUpdateOnFiber = function(fiber: Fiber, lane: Lane, eventTime: number): FiberRoot | nil
	mod.checkForNestedUpdates()

	local root = mod.markUpdateLaneFromFiberToRoot(fiber, lane)
	if root == nil then
		return nil
	end

	-- Mark that the root has a pending update.
	markRootUpdated(root, lane, eventTime)

	if root == workInProgressRoot then
		-- Received an update to a tree that's in the middle of rendering. Mark
		-- that there was an interleaved update work on this root. Unless the
		-- `ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch` flag is off and this is a render
		-- phase update. In that case, we don't treat render phase updates as if
		-- they were interleaved, for backwards compat reasons.
		mod.warnAboutRenderPhaseUpdatesInDEV(fiber)

		if
			ReactFeatureFlags.deferRenderPhaseUpdateToNextBatch
			or bit32.band(executionContext, RenderContext) == NoContext
		then
			workInProgressRootUpdatedLanes = mergeLanes(workInProgressRootUpdatedLanes, lane)
		end
		if workInProgressRootExitStatus == RootExitStatus.SuspendedWithDelay then
			-- The root already suspended with a delay, which means this render
			-- definitely won't finish. Since we have a new update, let's mark it as
			-- suspended now, right before marking the incoming update. This has the
			-- effect of interrupting the current render and switching to the update.
			-- TODO: Make sure this doesn't override pings that happen while we've
			-- already started rendering.
			mod.markRootSuspended(root, workInProgressRootRenderLanes)
		end
	end

	-- TODO: requestUpdateLanePriority also reads the priority. Pass the
	-- priority as an argument to that function and this one.
	local priorityLevel = getCurrentPriorityLevel()

	if lane == SyncLane then
		if
			-- Check if we're inside unbatchedUpdates
			bit32.band(executionContext, LegacyUnbatchedContext) ~= NoContext
			-- Check if we're not already rendering
			and bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext
		then
			-- Register pending interactions on the root to avoid losing traced interaction data.
			mod.schedulePendingInteractions(root, lane)

			-- This is a legacy edge case. The initial mount of a ReactDOM.render-ed
			-- root inside of batchedUpdates should be synchronous, but layout updates
			-- should be deferred until the end of the batch.
			mod.performSyncWorkOnRoot(root)
		else
			ensureRootIsScheduled(root, eventTime)
			mod.schedulePendingInteractions(root, lane)
			if executionContext == NoContext then
				-- Flush the synchronous work now, unless we're already working or inside
				-- a batch. This is intentionally inside scheduleUpdateOnFiber instead of
				-- scheduleCallbackForFiber to preserve the ability to schedule a callback
				-- without immediately flushing it. We only do this for user-initiated
				-- updates, to preserve historical behavior of legacy mode.
				resetRenderTimer()
				flushSyncCallbackQueue()
			end
		end
	else
		-- Schedule a discrete update but only if it's not Sync.
		if
			bit32.band(executionContext, DiscreteEventContext) ~= NoContext
			-- Only updates at user-blocking priority or greater are considered
			-- discrete, even inside a discrete event.
			and (priorityLevel == UserBlockingSchedulerPriority or priorityLevel == ImmediateSchedulerPriority)
		then
			-- This is the result of a discrete event. Track the lowest priority
			-- discrete update per root so we can flush them early, if needed.
			if rootsWithPendingDiscreteUpdates == nil then
				rootsWithPendingDiscreteUpdates = Set.new({ root })
			else
				rootsWithPendingDiscreteUpdates:add(root)
			end
		end
		-- Schedule other updates after in case the callback is sync.
		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, lane)
	end

	-- We use this when assigning a lane for a transition inside
	-- `requestUpdateLane`. We assume it's the same as the root being updated,
	-- since in the common case of a single root app it probably is. If it's not
	-- the same root, then it's not a huge deal, we just might batch more stuff
	-- together more than necessary.
	mostRecentlyUpdatedRoot = root
	return root
end

-- This is split into a separate function so we can mark a fiber with pending
-- work without treating it as a typical update that originates from an event
-- e.g. retrying a Suspense boundary isn't an update, but it does schedule work
-- on a fiber.
mod.markUpdateLaneFromFiberToRoot = function(sourceFiber: Fiber, lane: Lane): FiberRoot?
	-- Update the source fiber's lanes
	sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane)
	local alternate = sourceFiber.alternate
	if alternate ~= nil then
		alternate.lanes = mergeLanes(alternate.lanes, lane)
	end
	if __DEV__ then
		if
			alternate == nil
			and bit32.band(sourceFiber.flags, bit32.bor(ReactFiberFlags.Placement, ReactFiberFlags.Hydrating))
				~= ReactFiberFlags.NoFlags
		then
			mod.warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
		end
	end
	-- Walk the parent path to the root and update the child expiration time.
	local node = sourceFiber
	local parent = sourceFiber.return_
	while parent ~= nil do
		parent.childLanes = mergeLanes(parent.childLanes, lane)
		alternate = parent.alternate
		if alternate ~= nil then
			alternate.childLanes = mergeLanes(alternate.childLanes, lane)
		else
			if __DEV__ then
				if
					bit32.band(parent.flags, bit32.bor(ReactFiberFlags.Placement, ReactFiberFlags.Hydrating))
					~= ReactFiberFlags.NoFlags
				then
					mod.warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber)
				end
			end
		end
		node = parent
		parent = parent.return_
	end
	if node.tag == ReactWorkTags.HostRoot then
		local root: FiberRoot = node.stateNode
		return root
	else
		return nil
	end
end

-- Use this function to schedule a task for a root. There's only one task per
-- root; if a task was already scheduled, we'll check to make sure the priority
-- of the existing task is the same as the priority of the next level that the
-- root has work on. This function is called on every update, and right before
-- exiting a task.
ensureRootIsScheduled = function(root: FiberRoot, currentTime: number)
	local existingCallbackNode = root.callbackNode

	-- Check if any lanes are being starved by other work. If so, mark them as
	-- expired so we know to work on those next.
	markStarvedLanesAsExpired(root, currentTime)

	-- Determine the next lanes to work on, and their priority.
	local lanes
	if root == workInProgressRoot then
		lanes = workInProgressRootRenderLanes
	else
		lanes = ReactFiberLane.NoLanes
	end
	local nextLanes = getNextLanes(root, lanes)
	-- This returns the priority level computed during the `getNextLanes` call.
	local newCallbackPriority = returnNextLanesPriority()

	if nextLanes == ReactFiberLane.NoLanes then
		-- Special case: There's nothing to work on.
		if existingCallbackNode ~= nil then
			cancelCallback(existingCallbackNode)
			root.callbackNode = nil
			root.callbackPriority = ReactFiberLane.NoLanePriority
		end
		return
	end

	-- Check if there's an existing task. We may be able to reuse it.
	if existingCallbackNode ~= nil then
		local existingCallbackPriority = root.callbackPriority
		if existingCallbackPriority == newCallbackPriority then
			-- The priority hasn't changed. We can reuse the existing task. Exit.
			return
		end
		-- The priority changed. Cancel the existing callback. We'll schedule a new
		-- one below.
		cancelCallback(existingCallbackNode)
	end

	-- Schedule a new callback.
	local newCallbackNode
	if newCallbackPriority == ReactFiberLane.SyncLanePriority then
		-- Special case: Sync React callbacks are scheduled on a special
		-- internal queue
		newCallbackNode = scheduleSyncCallback(function()
			return mod.performSyncWorkOnRoot(root)
		end)
	elseif newCallbackPriority == ReactFiberLane.SyncBatchedLanePriority then
		newCallbackNode = scheduleCallback(ImmediateSchedulerPriority, function()
			return mod.performSyncWorkOnRoot(root)
		end)
	else
		local schedulerPriorityLevel = lanePriorityToSchedulerPriority(newCallbackPriority)
		newCallbackNode = scheduleCallback(schedulerPriorityLevel, function()
			return mod.performConcurrentWorkOnRoot(root)
		end)
	end

	root.callbackPriority = newCallbackPriority
	root.callbackNode = newCallbackNode
end

-- This is the entry point for every concurrent task, i.e. anything that
-- goes through Scheduler.
-- FIXME Luau: Luau needs explicit annotation with nil-able returns
mod.performConcurrentWorkOnRoot = function(root): (() -> ...any) | nil
	-- Since we know we're in a React event, we can clear the current
	-- event time. The next update will compute a new event time.
	currentEventTime = NoTimestamp
	currentEventWipLanes = ReactFiberLane.NoLanes
	currentEventPendingLanes = ReactFiberLane.NoLanes

	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Should not already be working."
	)

	-- Flush any pending passive effects before deciding which lanes to work on,
	-- in case they schedule additional work.
	local originalCallbackNode = root.callbackNode
	local didFlushPassiveEffects = exports.flushPassiveEffects()
	if didFlushPassiveEffects then
		-- Something in the passive effect phase may have canceled the current task.
		-- Check if the task node for this root was changed.
		if root.callbackNode ~= originalCallbackNode then
			-- The current task was canceled. Exit. We don't need to call
			-- `ensureRootIsScheduled` because the check above implies either that
			-- there's a new task, or that there's no remaining work on this root.
			return nil
		else
			-- Current task was not canceled. Continue.
		end
	end

	-- Determine the next expiration time to work on, using the fields stored
	-- on the root.
	local lanes =
		getNextLanes(root, if root == workInProgressRoot then workInProgressRootRenderLanes else ReactFiberLane.NoLanes)
	if lanes == ReactFiberLane.NoLanes then
		-- Defensive coding. This is never expected to happen.
		return nil
	end

	local exitStatus = mod.renderRootConcurrent(root, lanes)

	if includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes) then
		-- The render included lanes that were updated during the render phase.
		-- For example, when unhiding a hidden tree, we include all the lanes
		-- that were previously skipped when the tree was hidden. That set of
		-- lanes is a superset of the lanes we started rendering with.
		--
		-- So we'll throw out the current work and restart.
		mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
	elseif exitStatus ~= RootExitStatus.Incomplete then
		if exitStatus == RootExitStatus.Errored then
			executionContext = bit32.bor(executionContext, RetryAfterError)

			-- If an error occurred during hydration,
			-- discard server response and fall back to client side render.
			if root.hydrate then
				root.hydrate = false
				ReactFiberHostConfig.clearContainer(root.containerInfo)
			end

			-- If something threw an error, try rendering one more time. We'll render
			-- synchronously to block concurrent data mutations, and we'll includes
			-- all pending updates are included. If it still fails after the second
			-- attempt, we'll give up and commit the resulting tree.
			lanes = getLanesToRetrySynchronouslyOnError(root)
			if lanes ~= ReactFiberLane.NoLanes then
				exitStatus = mod.renderRootSync(root, lanes)
			end
		end

		if exitStatus == RootExitStatus.FatalErrored then
			local fatalError = workInProgressRootFatalError
			mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
			mod.markRootSuspended(root, lanes)
			ensureRootIsScheduled(root, now())
			error(fatalError)
		end

		-- We now have a consistent tree. The next step is either to commit it,
		-- or, if something suspended, wait to commit it after a timeout.
		local finishedWork: Fiber = root.current.alternate :: any
		root.finishedWork = finishedWork
		root.finishedLanes = lanes
		mod.finishConcurrentRender(root, exitStatus, lanes)
	end

	ensureRootIsScheduled(root, now())
	if root.callbackNode == originalCallbackNode then
		-- The task node scheduled for this root is the same one that's
		-- currently executed. Need to return a continuation.
		return function()
			return mod.performConcurrentWorkOnRoot(root)
		end
	end
	-- FIXME Luau: Luau shouldn't error on nil-able returns
	return nil :: any
end

-- we track the 'depth' of the act() calls with this counter,
-- so we can tell if any async act() calls try to run in parallel.
local actingUpdatesScopeDepth = 0
local didWarnAboutUsingActInProd = false

function shouldForceFlushFallbacksInDEV()
	-- Never force flush in production. This function should get stripped out.
	return __DEV__ and actingUpdatesScopeDepth > 0
end

mod.finishConcurrentRender = function(root, exitStatus, lanes)
	if exitStatus == RootExitStatus.Incomplete or exitStatus == RootExitStatus.FatalErrored then
		invariant(false, "Root did not complete. This is a bug in React.")
	-- Flow knows about invariant, so it complains if I add a break
	-- if I do. eslint-disable-next-line no-fallthrough
	-- statement, but eslint doesn't know about invariant, so it complains
	elseif exitStatus == RootExitStatus.Errored then
		-- We should have already attempted to retry this tree. If we reached
		-- this point, it errored again. Commit it.
		mod.commitRoot(root)
	elseif exitStatus == RootExitStatus.Suspended then
		mod.markRootSuspended(root, lanes)

		-- We have an acceptable loading state. We need to figure out if we
		-- should immediately commit it or wait a bit.
		if
			includesOnlyRetries(lanes)
			-- do not delay if we're inside an act() scope
			and not shouldForceFlushFallbacksInDEV()
		then
			-- This render only included retries, no updates. Throttle committing
			-- retries so that we don't show too many loading states too quickly.
			local msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now()
			-- Don't bother with a very short suspense time.
			if msUntilTimeout > 10 then
				local nextLanes = getNextLanes(root, ReactFiberLane.NoLanes)
				if nextLanes ~= ReactFiberLane.NoLanes then
					-- There's additional work on this root.
					return
				end
				local suspendedLanes = root.suspendedLanes
				if not isSubsetOfLanes(suspendedLanes, lanes) then
					-- We should prefer to render the fallback of at the last
					-- suspended level. Ping the last suspended level to try
					-- rendering it again.
					-- FIXME: What if the suspended lanes are Idle? Should not restart.
					local eventTime = exports.requestEventTime()
					markRootPinged(root, suspendedLanes, eventTime)
					return
				end

				-- The render is suspended, it hasn't timed out, and there's no
				-- lower priority work to do. Instead of committing the fallback
				-- immediately, wait for more data to arrive.
				root.timeoutHandle = ReactFiberHostConfig.scheduleTimeout(function()
					return mod.commitRoot(root)
				end, msUntilTimeout)
				return
			end
		end
		-- The work expired. Commit immediately.
		mod.commitRoot(root)
	elseif exitStatus == RootExitStatus.SuspendedWithDelay then
		mod.markRootSuspended(root, lanes)

		if includesOnlyTransitions(lanes) then
			-- This is a transition, so we should exit without committing a
			-- placeholder and without scheduling a timeout. Delay indefinitely
			-- until we receive more data.
			return
		end

		if not shouldForceFlushFallbacksInDEV() then
			-- This is not a transition, but we did trigger an avoided state.
			-- Schedule a placeholder to display after a short delay, using the Just
			-- Noticeable Difference.
			-- TODO: Is the JND optimization worth the added complexity? If this is
			-- the only reason we track the event time, then probably not.
			-- Consider removing.

			local mostRecentEventTime = getMostRecentEventTime(root, lanes)
			local eventTimeMs = mostRecentEventTime
			local timeElapsedMs = now() - eventTimeMs
			local msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs

			-- Don't bother with a very short suspense time.
			if msUntilTimeout > 10 then
				-- Instead of committing the fallback immediately, wait for more data
				-- to arrive.
				root.timeoutHandle = ReactFiberHostConfig.scheduleTimeout(function()
					return mod.commitRoot(root)
				end, msUntilTimeout)
				return
			end
		end
		-- Commit the placeholder.
		mod.commitRoot(root)
	elseif exitStatus == RootExitStatus.Completed then
		-- The work completed. Ready to commit.
		mod.commitRoot(root)
	else
		invariant(false, "Unknown root exit status.")
	end
end

mod.markRootSuspended = function(root, suspendedLanes)
	-- When suspending, we should always exclude lanes that were pinged or (more
	-- rarely, since we try to avoid it) updated during the render phase.
	-- TODO: Lol maybe there's a better way to factor this besides this
	-- obnoxiously named function :)
	suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes)
	suspendedLanes = removeLanes(suspendedLanes, workInProgressRootUpdatedLanes)
	markRootSuspended_dontCallThisOneDirectly(root, suspendedLanes)
end

-- This is the entry point for synchronous tasks that don't go
-- through Scheduler
mod.performSyncWorkOnRoot = function(root)
	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Should not already be working."
	)

	exports.flushPassiveEffects()

	local lanes
	local exitStatus
	if root == workInProgressRoot and includesSomeLane(root.expiredLanes, workInProgressRootRenderLanes) then
		-- There's a partial tree, and at least one of its lanes has expired. Finish
		-- rendering it before rendering the rest of the expired work.
		lanes = workInProgressRootRenderLanes
		exitStatus = mod.renderRootSync(root, lanes)
		if includesSomeLane(workInProgressRootIncludedLanes, workInProgressRootUpdatedLanes) then
			-- The render included lanes that were updated during the render phase.
			-- For example, when unhiding a hidden tree, we include all the lanes
			-- that were previously skipped when the tree was hidden. That set of
			-- lanes is a superset of the lanes we started rendering with.
			--
			-- Note that this only happens when part of the tree is rendered
			-- concurrently. If the whole tree is rendered synchronously, then there
			-- are no interleaved events.
			lanes = getNextLanes(root, lanes)
			exitStatus = mod.renderRootSync(root, lanes)
		end
	else
		lanes = getNextLanes(root, ReactFiberLane.NoLanes)
		exitStatus = mod.renderRootSync(root, lanes)
	end

	if root.tag ~= LegacyRoot and exitStatus == RootExitStatus.Errored then
		executionContext = bit32.bor(executionContext, RetryAfterError)

		-- If an error occurred during hydration,
		-- discard server response and fall back to client side render.
		if root.hydrate then
			root.hydrate = false
			ReactFiberHostConfig.clearContainer(root.containerInfo)
		end

		-- If something threw an error, try rendering one more time. We'll render
		-- synchronously to block concurrent data mutations, and we'll includes
		-- all pending updates are included. If it still fails after the second
		-- attempt, we'll give up and commit the resulting tree.
		lanes = getLanesToRetrySynchronouslyOnError(root)
		if lanes ~= ReactFiberLane.NoLanes then
			exitStatus = mod.renderRootSync(root, lanes)
		end
	end

	if exitStatus == RootExitStatus.FatalErrored then
		local fatalError = workInProgressRootFatalError
		mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
		mod.markRootSuspended(root, lanes)
		ensureRootIsScheduled(root, now())
		error(fatalError)
	end

	-- We now have a consistent tree. Because this is a sync render, we
	-- will commit it even if something suspended.
	local finishedWork: Fiber = root.current.alternate :: any
	root.finishedWork = finishedWork
	root.finishedLanes = lanes
	mod.commitRoot(root)

	-- Before exiting, make sure there's a callback scheduled for the next
	-- pending level.
	ensureRootIsScheduled(root, now())

	return nil
end

exports.flushRoot = function(root: FiberRoot, lanes: Lanes)
	markRootExpired(root, lanes)
	ensureRootIsScheduled(root, now())
	if bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext then
		resetRenderTimer()
		flushSyncCallbackQueue()
	end
end

exports.getExecutionContext = function(): ExecutionContext
	return executionContext
end

exports.flushDiscreteUpdates = function()
	-- TODO: Should be able to flush inside batchedUpdates, but not inside `act`.
	-- However, `act` uses `batchedUpdates`, so there's no way to distinguish
	-- those two cases. Need to fix this before exposing flushDiscreteUpdates
	-- as a public API.
	if bit32.band(executionContext, bit32.bor(BatchedContext, RenderContext, CommitContext)) ~= NoContext then
		if __DEV__ then
			if bit32.band(executionContext, RenderContext) ~= NoContext then
				console.error(
					"unstable_flushDiscreteUpdates: Cannot flush updates when React is " .. "already rendering."
				)
			end
		end
		-- We're already rendering, so we can't synchronously flush pending work.s
		-- This is probably a nested event dispatch triggered by a lifecycle/effect,
		-- like `el.focus()`. Exit.
		return
	end
	mod.flushPendingDiscreteUpdates()
	-- If the discrete updates scheduled passive effects, flush them now so that
	-- they fire before the next serial event.
	exports.flushPassiveEffects()
end

exports.deferredUpdates = function<A>(fn: () -> A): A
	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()
		-- deviation: YOLO flag for disabling pcall
		local ok, result
		if not __YOLO__ then
			-- performance: hoist non-throwable out of try{} to eliminate anon function
			setCurrentUpdateLanePriority(ReactFiberLane.DefaultLanePriority)
			ok, result = xpcall(runWithPriority, describeError, NormalSchedulerPriority, fn)
		else
			ok = true
			setCurrentUpdateLanePriority(ReactFiberLane.DefaultLanePriority)
			result = runWithPriority(NormalSchedulerPriority, fn)
		end

		-- finally
		setCurrentUpdateLanePriority(previousLanePriority)

		if ok then
			return result
		else
			error(result)
		end
	else
		return runWithPriority(NormalSchedulerPriority, fn)
	end
end

mod.flushPendingDiscreteUpdates = function()
	if rootsWithPendingDiscreteUpdates ~= nil then
		-- For each root with pending discrete updates, schedule a callback to
		-- immediately flush them.
		local roots = rootsWithPendingDiscreteUpdates
		rootsWithPendingDiscreteUpdates = nil
		roots:forEach(function(root)
			markDiscreteUpdatesExpired(root)
			ensureRootIsScheduled(root, now())
		end)
	end
	-- Now flush the immediate queue.
	flushSyncCallbackQueue()
end

exports.batchedUpdates = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, BatchedContext)

	-- deviation: YOLO flag for disabling pcall
	local ok, result
	if not __YOLO__ then
		ok, result = xpcall(fn, describeError, a)
	else
		ok = true
		result = fn(a)
	end

	-- finally
	executionContext = prevExecutionContext
	if executionContext == NoContext then
		-- Flush the immediate callbacks that were scheduled during this batch
		resetRenderTimer()
		flushSyncCallbackQueue()
	end

	if ok then
		return result
	else
		error(result)
	end
end

exports.batchedEventUpdates = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, EventContext)

	-- deviation: YOLO flag for disabling pcall
	local ok, result
	if not __YOLO__ then
		ok, result = xpcall(fn, describeError, a)
	else
		ok = true
		result = fn(a)
	end

	-- finally
	executionContext = prevExecutionContext
	if executionContext == NoContext then
		-- Flush the immediate callbacks that were scheduled during this batch
		resetRenderTimer()
		flushSyncCallbackQueue()
	end

	if ok then
		return result
	else
		error(result)
	end
end

exports.discreteUpdates = function<A, B, C, D, R>(fn: (A, B, C, D) -> R, a: A, b: B, c: C, d: D): R
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, DiscreteEventContext)

	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()
		-- performance: extract non-throwable fn call out of try{} so we can remove an anon function
		setCurrentUpdateLanePriority(ReactFiberLane.InputDiscreteLanePriority)
		local ok, result = xpcall(runWithPriority, describeError, UserBlockingSchedulerPriority, function()
			return fn(a, b, c, d)
		end)

		-- finally
		setCurrentUpdateLanePriority(previousLanePriority)
		executionContext = prevExecutionContext
		if executionContext == NoContext then
			-- Flush the immediate callbacks that were scheduled during this batch
			resetRenderTimer()
			flushSyncCallbackQueue()
		end

		if ok then
			return result
		else
			error(result)
		end
	else
		local ok, result = xpcall(runWithPriority, describeError, UserBlockingSchedulerPriority, function()
			return fn(a, b, c, d)
		end)

		-- finally
		executionContext = prevExecutionContext
		if executionContext == NoContext then
			-- Flush the immediate callbacks that were scheduled during this batch
			resetRenderTimer()
			flushSyncCallbackQueue()
		end

		if ok then
			return result
		else
			error(result)
		end
	end
end

exports.unbatchedUpdates = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	executionContext = bit32.band(executionContext, bit32.bnot(BatchedContext))
	executionContext = bit32.bor(executionContext, LegacyUnbatchedContext)
	-- deviation: YOLO flag for disabling pcall
	local ok, result
	if not __YOLO__ then
		ok, result = xpcall(fn, describeError, a)
	else
		ok = true
		result = fn(a)
	end

	-- finally
	executionContext = prevExecutionContext
	if executionContext == NoContext then
		-- Flush the immediate callbacks that were scheduled during this batch
		resetRenderTimer()
		flushSyncCallbackQueue()
	end

	if ok then
		return result
	else
		error(result)
	end
end

exports.flushSync = function<A, R>(fn: (A) -> R, a: A): R
	local prevExecutionContext = executionContext
	if (bit32.band(prevExecutionContext, bit32.bor(RenderContext, CommitContext))) ~= NoContext then
		if __DEV__ then
			console.error(
				"flushSync was called from inside a lifecycle method. React cannot "
					.. "flush when React is already rendering. Consider moving this call to "
					.. "a scheduler task or micro task."
			)
		end
		return fn(a)
	end
	executionContext = bit32.bor(executionContext, BatchedContext)

	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()

		-- performance: extract non-throwable call out of try{} to eliminate an anon function
		setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
		-- deviation: YOLO flag for disabling pcall
		local ok, result
		if not __YOLO__ then
			if fn then
				ok, result = xpcall(runWithPriority, describeError, ImmediateSchedulerPriority, function()
					return fn(a)
				end)
			else
				ok = true
				-- NOTE: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		else
			ok = true
			setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
			if fn then
				result = runWithPriority(ImmediateSchedulerPriority, function()
					return fn(a)
				end)
			else
				-- NOTE: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		end

		-- finally
		setCurrentUpdateLanePriority(previousLanePriority)
		executionContext = prevExecutionContext
		-- Flush the immediate callbacks that were scheduled during this batch.
		-- Note that this will happen even if batchedUpdates is higher up
		-- the stack.
		flushSyncCallbackQueue()

		if not ok then
			error(result)
		end
		return result
	else
		-- deviation: YOLO flag for disabling pcall
		local ok, result
		if not __YOLO__ then
			if fn then
				ok, result = xpcall(runWithPriority, describeError, ImmediateSchedulerPriority, function()
					return fn(a)
				end)
			else
				ok = true
				-- NOTE: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		else
			ok = true
			if fn then
				result = runWithPriority(ImmediateSchedulerPriority, function()
					return fn(a)
				end)
			else
				-- NOTE: return (undefined: $FlowFixMe)
				result = nil :: any
			end
		end
		-- NOTE: finally
		executionContext = prevExecutionContext
		-- Flush the immediate callbacks that were scheduled during this batch.
		-- Note that this will happen even if batchedUpdates is higher up
		-- the stack.
		flushSyncCallbackQueue()
		if not ok then
			error(result)
		end
		return result
	end
end

exports.flushControlled = function(fn: () -> any)
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, BatchedContext)
	if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
		local previousLanePriority = getCurrentUpdateLanePriority()
		-- performance: extract non-throwable call out of try{} to eliminate an anon function
		setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
		local ok, result = xpcall(runWithPriority, describeError, ImmediateSchedulerPriority, fn)

		-- finally
		setCurrentUpdateLanePriority(previousLanePriority)

		executionContext = prevExecutionContext
		if executionContext == NoContext then
			-- Flush the immediate callbacks that were scheduled during this batch
			resetRenderTimer()
			flushSyncCallbackQueue()
		end

		if not ok then
			error(result)
		end
	else
		local ok, result = xpcall(runWithPriority, describeError, ImmediateSchedulerPriority, fn)
		-- finally
		executionContext = prevExecutionContext
		if executionContext == NoContext then
			-- Flush the immediate callbacks that were scheduled during this batch
			resetRenderTimer()
			flushSyncCallbackQueue()
		end

		if not ok then
			error(result)
		end
	end
end

exports.pushRenderLanes = function(fiber: Fiber, lanes: Lanes)
	pushToStack(subtreeRenderLanesCursor, exports.subtreeRenderLanes, fiber)
	exports.subtreeRenderLanes = mergeLanes(exports.subtreeRenderLanes, lanes)
	workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes)
end

exports.popRenderLanes = function(fiber: Fiber)
	exports.subtreeRenderLanes = subtreeRenderLanesCursor.current
	popFromStack(subtreeRenderLanesCursor, fiber)
end

mod.prepareFreshStack = function(root: FiberRoot, lanes: Lanes)
	root.finishedWork = nil
	root.finishedLanes = ReactFiberLane.NoLanes

	local timeoutHandle = root.timeoutHandle
	if timeoutHandle ~= ReactFiberHostConfig.noTimeout then
		-- The root previous suspended and scheduled a timeout to commit a fallback
		-- state. Now that we have additional work, cancel the timeout.
		root.timeoutHandle = ReactFiberHostConfig.noTimeout
		-- $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
		ReactFiberHostConfig.cancelTimeout(timeoutHandle)
	end

	if workInProgress ~= nil then
		local interruptedWork = workInProgress.return_
		while interruptedWork ~= nil do
			unwindInterruptedWork(interruptedWork)
			interruptedWork = interruptedWork.return_
		end
	end
	workInProgressRoot = root
	workInProgress = ReactFiber.createWorkInProgress(root.current, nil)
	workInProgressRootRenderLanes = lanes
	exports.subtreeRenderLanes = lanes
	workInProgressRootIncludedLanes = lanes
	workInProgressRootExitStatus = RootExitStatus.Incomplete
	workInProgressRootFatalError = nil
	workInProgressRootSkippedLanes(ReactFiberLane.NoLanes)
	workInProgressRootUpdatedLanes = ReactFiberLane.NoLanes
	workInProgressRootPingedLanes = ReactFiberLane.NoLanes

	if ReactFeatureFlags.enableSchedulerTracing then
		spawnedWorkDuringRender = nil
	end

	if __DEV__ then
		ReactStrictModeWarnings.discardPendingWarnings()
	end
end

mod.handleError = function(root, thrownValue): ()
	while true do
		local erroredWork = workInProgress
		-- FIXME Luau: CLI-49835, "Function only returns 1 value, 2 are required"
		local ok, yetAnotherThrownValue = pcall(function()
			-- Reset module-level state that was set during the render phase.
			resetContextDependencies()
			resetHooksAfterThrow()
			resetCurrentDebugFiberInDEV()
			-- TODO: I found and added this missing line while investigating a
			-- separate issue. Write a regression test using string refs.
			ReactCurrentOwner.current = nil

			if erroredWork == nil or erroredWork.return_ == nil then
				-- Expected to be working on a non-root fiber. This is a fatal error
				-- because there's no ancestor that can handle it; the root is
				-- supposed to capture all errors that weren't caught by an error
				-- boundary.
				workInProgressRootExitStatus = RootExitStatus.FatalErrored
				workInProgressRootFatalError = thrownValue
				-- Set `workInProgress` to nil. This represents advancing to the next
				-- sibling, or the parent if there are no siblings. But since the root
				-- has no siblings nor a parent, we set it to nil. Usually this is
				-- handled by `completeUnitOfWork` or `unwindWork`, but since we're
				-- intentionally not calling those, we need set it here.
				-- TODO: Consider calling `unwindWork` to pop the contexts.
				workInProgress = nil
				-- FIXME: THIS IS A BUG, WE SHOULD BAIL ON THE OUTER FUNCTION -- NOT THE PCALL!
				return
			end

			-- FIXME Luau: Luau doesn't narrow based on the erroredWork == nil then return above
			if
				ReactFeatureFlags.enableProfilerTimer
				and bit32.band((erroredWork :: Fiber).mode, ReactTypeOfMode.ProfileMode) ~= 0
			then
				-- Record the time spent rendering before an error was thrown. This
				-- avoids inaccurate Profiler durations in the case of a
				-- suspended render.
				ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(erroredWork :: Fiber, true)
			end

			-- deviation, we pass in onUncaughtError and renderDidError here since throwException can't call them due to a require cycle
			throwException(
				root,
				(erroredWork :: Fiber).return_,
				erroredWork :: Fiber,
				thrownValue,
				workInProgressRootRenderLanes,
				exports.onUncaughtError,
				exports.renderDidError
			)
			mod.completeUnitOfWork(erroredWork)
		end)
		if not ok then
			-- Something in the return path also threw.
			thrownValue = yetAnotherThrownValue
			if workInProgress == erroredWork and erroredWork ~= nil then
				-- If this boundary has already errored, then we had trouble processing
				-- the error. Bubble it to the next boundary.
				erroredWork = erroredWork.return_
				workInProgress = erroredWork
			else
				erroredWork = workInProgress
			end
			continue
		end
		-- Return to the normal work loop.
		return
	end
end

mod.pushDispatcher = function()
	local prevDispatcher = ReactCurrentDispatcher.current

	-- deviation: lazy init of ContextOnlyDispatcher wrapped in a function
	ReactCurrentDispatcher.current = ContextOnlyDispatcher()
	if prevDispatcher == nil then
		-- The React isomorphic package does not include a default dispatcher.
		-- Instead the first renderer will lazily attach one, in order to give
		-- nicer error messages.

		-- deviation: lazy init of ContextOnlyDispatcher wrapped in a function
		return ContextOnlyDispatcher()
	else
		return prevDispatcher
	end
end

mod.popDispatcher = function(prevDispatcher)
	ReactCurrentDispatcher.current = prevDispatcher
end

mod.pushInteractions = function(root)
	if ReactFeatureFlags.enableSchedulerTracing then
		local prevInteractions: Set<Interaction>? = __interactionsRef.current
		__interactionsRef.current = root.memoizedInteractions
		return prevInteractions
	end
	return nil
end

mod.popInteractions = function(prevInteractions)
	if ReactFeatureFlags.enableSchedulerTracing then
		__interactionsRef.current = prevInteractions
	end
end

exports.markCommitTimeOfFallback = function(): ()
	globalMostRecentFallbackTime = now()
end

exports.markSkippedUpdateLanes = function(lane: Lane | Lanes): ()
	ReactFiberWorkInProgress.markSkippedUpdateLanes(lane)
end

exports.renderDidSuspend = function(): ()
	if workInProgressRootExitStatus == RootExitStatus.Incomplete then
		workInProgressRootExitStatus = RootExitStatus.Suspended
	end
end

exports.renderDidSuspendDelayIfPossible = function(): ()
	if
		workInProgressRootExitStatus == RootExitStatus.Incomplete
		or workInProgressRootExitStatus == RootExitStatus.Suspended
	then
		workInProgressRootExitStatus = RootExitStatus.SuspendedWithDelay
	end

	-- Check if there are updates that we skipped tree that might have unblocked
	-- this render.
	if
		workInProgressRoot ~= nil
		and (
			includesNonIdleWork(workInProgressRootSkippedLanes())
			or includesNonIdleWork(workInProgressRootUpdatedLanes)
		)
	then
		-- Mark the current render as suspended so that we switch to working on
		-- the updates that were skipped. Usually we only suspend at the end of
		-- the render phase.
		-- TODO: We should probably always mark the root as suspended immediately
		-- (inside this function), since by suspending at the end of the render
		-- phase introduces a potential mistake where we suspend lanes that were
		-- pinged or updated while we were rendering.
		mod.markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes)
	end
end

exports.renderDidError = function()
	if workInProgressRootExitStatus ~= RootExitStatus.Completed then
		workInProgressRootExitStatus = RootExitStatus.Errored
	end
end

-- Called during render to determine if anything has suspended.
-- Returns false if we're not sure.
exports.renderHasNotSuspendedYet = function(): boolean
	-- If something errored or completed, we can't really be sure,
	-- so those are false.
	return workInProgressRootExitStatus == RootExitStatus.Incomplete
end

mod.renderRootSync = function(root: FiberRoot, lanes: Lanes)
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, RenderContext)
	local prevDispatcher = mod.pushDispatcher()

	-- If the root or lanes have changed, throw out the existing stack
	-- and prepare a fresh one. Otherwise we'll continue where we left off.
	if workInProgressRoot ~= root or workInProgressRootRenderLanes ~= lanes then
		mod.prepareFreshStack(root, lanes)
		mod.startWorkOnPendingInteractions(root, lanes)
	end

	local prevInteractions = mod.pushInteractions(root)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markRenderStarted(lanes)
	end

	while true do
		-- deviation: YOLO flag for disabling pcall
		local ok, thrownValue
		if not __YOLO__ then
			ok, thrownValue = xpcall(mod.workLoopSync, describeError)
		else
			ok = true
			mod.workLoopSync()
		end

		if not ok then
			mod.handleError(root, thrownValue)
		else
			break
		end
	end
	resetContextDependencies()
	if ReactFeatureFlags.enableSchedulerTracing then
		mod.popInteractions(prevInteractions)
	end

	executionContext = prevExecutionContext
	mod.popDispatcher(prevDispatcher)

	if workInProgress ~= nil then
		-- This is a sync render, so we should have finished the whole tree.
		invariant(
			false,
			"Cannot commit an incomplete root. This error is likely caused by a "
				.. "bug in React. Please file an issue."
		)
	end

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStopped()
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markRenderStopped()
	end

	-- Set this to nil to indicate there's no in-progress render.
	workInProgressRoot = nil
	workInProgressRootRenderLanes = ReactFiberLane.NoLanes

	return workInProgressRootExitStatus
end

-- The work loop is an extremely hot path. Tell Closure not to inline it.
--[[* @noinline ]]
mod.workLoopSync = function()
	-- Already timed out, so perform work without checking if we need to yield.
	while workInProgress ~= nil do
		mod.performUnitOfWork(workInProgress)
	end
end

mod.renderRootConcurrent = function(root: FiberRoot, lanes: Lanes)
	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, RenderContext)
	local prevDispatcher = mod.pushDispatcher()

	-- If the root or lanes have changed, throw out the existing stack
	-- and prepare a fresh one. Otherwise we'll continue where we left off.
	if workInProgressRoot ~= root or workInProgressRootRenderLanes ~= lanes then
		resetRenderTimer()
		mod.prepareFreshStack(root, lanes)
		mod.startWorkOnPendingInteractions(root, lanes)
	end

	local prevInteractions = mod.pushInteractions(root)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markRenderStarted(lanes)
	end

	while true do
		-- deviation: YOLO flag for disabling pcall
		local ok, thrownValue
		if not __YOLO__ then
			-- deviation: when converting `try` to `pcall`, we can't use break inside it
			ok, thrownValue = xpcall(mod.workLoopConcurrent, describeError)
			if ok then
				thrownValue = "break"
			end
		else
			ok = true
			thrownValue = "break"
			mod.workLoopConcurrent()
		end

		if thrownValue == "break" then
			break
		end
		if not ok then
			mod.handleError(root, thrownValue)
		end
	end
	resetContextDependencies()
	if ReactFeatureFlags.enableSchedulerTracing then
		mod.popInteractions(prevInteractions)
	end

	mod.popDispatcher(prevDispatcher)
	executionContext = prevExecutionContext

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logRenderStopped()
		end
	end

	-- Check if the tree has completed.
	if workInProgress ~= nil then
		-- Still work remaining.
		if enableSchedulingProfiler then
			SchedulingProfiler.markRenderYielded()
		end
		return RootExitStatus.Incomplete
	else
		-- Completed the tree.
		if enableSchedulingProfiler then
			SchedulingProfiler.markRenderStopped()
		end

		-- Set this to nil to indicate there's no in-progress render.
		workInProgressRoot = nil
		workInProgressRootRenderLanes = ReactFiberLane.NoLanes

		-- Return the final exit status.
		return workInProgressRootExitStatus
	end
end

--[[* @noinline ]]
mod.workLoopConcurrent = function()
	-- Perform work until Scheduler asks us to yield
	while workInProgress ~= nil and not shouldYield() do
		mod.performUnitOfWork(workInProgress)
	end
end

mod.performUnitOfWork = function(unitOfWork: Fiber): ()
	-- The current, flushed, state of this fiber is the alternate. Ideally
	-- nothing should rely on this, but relying on it here means that we don't
	-- need an additional field on the work in progress.
	local current = unitOfWork.alternate
	setCurrentDebugFiberInDEV(unitOfWork)

	local next_
	if
		ReactFeatureFlags.enableProfilerTimer
		and bit32.band(unitOfWork.mode, ReactTypeOfMode.ProfileMode) ~= ReactTypeOfMode.NoMode
	then
		ReactProfilerTimer.startProfilerTimer(unitOfWork)
		next_ = mod.beginWork(current, unitOfWork, exports.subtreeRenderLanes)
		ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true)
	else
		next_ = mod.beginWork(current, unitOfWork, exports.subtreeRenderLanes)
	end

	resetCurrentDebugFiberInDEV()
	unitOfWork.memoizedProps = unitOfWork.pendingProps
	if next_ == nil then
		-- If this doesn't spawn new work, complete the current work.
		mod.completeUnitOfWork(unitOfWork)
	else
		workInProgress = next_
	end

	ReactCurrentOwner.current = nil
end

mod.completeUnitOfWork = function(unitOfWork: Fiber)
	-- Attempt to complete the current unit of work, then move to the next
	-- sibling. If there are no more siblings, return to the parent fiber.
	local completedWork = unitOfWork
	repeat
		-- The current, flushed, state of this fiber is the alternate. Ideally
		-- nothing should rely on this, but relying on it here means that we don't
		-- need an additional field on the work in progress.
		local current = completedWork.alternate
		local returnFiber = completedWork.return_

		-- Check if the work completed or if something threw.
		if bit32.band(completedWork.flags, ReactFiberFlags.Incomplete) == ReactFiberFlags.NoFlags then
			setCurrentDebugFiberInDEV(completedWork)
			local next_
			if
				not ReactFeatureFlags.enableProfilerTimer
				or bit32.band(completedWork.mode, ReactTypeOfMode.ProfileMode) == ReactTypeOfMode.NoMode
			then
				next_ = completeWork(current, completedWork, exports.subtreeRenderLanes)
			else
				ReactProfilerTimer.startProfilerTimer(completedWork)
				next_ = completeWork(current, completedWork, exports.subtreeRenderLanes)
				-- Update render duration assuming we didn't error.
				ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(completedWork, false)
			end
			resetCurrentDebugFiberInDEV()

			if next_ ~= nil then
				-- Completing this fiber spawned new work. Work on that next.
				workInProgress = next_
				return
			end
		else
			-- This fiber did not complete because something threw. Pop values off
			-- the stack without entering the complete phase. If this is a boundary,
			-- capture values if possible.
			local next_ = unwindWork(completedWork, exports.subtreeRenderLanes)

			-- Because this fiber did not complete, don't reset its expiration time.

			if next_ ~= nil then
				-- If completing this work spawned new work, do that next. We'll come
				-- back here again.
				-- Since we're restarting, remove anything that is not a host effect
				-- from the effect tag.
				next_.flags = bit32.band(next_.flags, ReactFiberFlags.HostEffectMask)
				workInProgress = next_
				return
			end

			if
				ReactFeatureFlags.enableProfilerTimer
				and bit32.band(completedWork.mode, ReactTypeOfMode.ProfileMode) ~= ReactTypeOfMode.NoMode
			then
				-- Record the render duration for the fiber that errored.
				ReactProfilerTimer.stopProfilerTimerIfRunningAndRecordDelta(completedWork, false)

				-- Include the time spent working on failed children before continuing.
				-- TODO: actualDuration is nil-able and only populated with enableProfilerTimer. contribute default value upstream.
				local actualDuration = completedWork.actualDuration or 0
				local child = completedWork.child
				while child ~= nil do
					actualDuration += child.actualDuration or 0
					child = child.sibling
				end
				completedWork.actualDuration = actualDuration
			end

			if returnFiber ~= nil then
				-- Mark the parent fiber as incomplete
				returnFiber.flags = bit32.bor(returnFiber.flags, ReactFiberFlags.Incomplete)
				returnFiber.subtreeFlags = ReactFiberFlags.NoFlags
				returnFiber.deletions = nil
			end
		end

		local siblingFiber = completedWork.sibling
		if siblingFiber ~= nil then
			-- If there is more work to do in this returnFiber, do that next.
			workInProgress = siblingFiber
			return
		end
		-- Otherwise, return to the parent
		-- FIXME Luau: Luau doesn't understand that completedWork is only nil-able at this point in the control flow
		completedWork = returnFiber :: any
		-- Update the next thing we're working on in case something throws.
		workInProgress = completedWork
	until completedWork == nil

	-- We've reached the root.
	if workInProgressRootExitStatus == RootExitStatus.Incomplete then
		workInProgressRootExitStatus = RootExitStatus.Completed
	end
end

mod.commitRoot = function(root)
	local renderPriorityLevel = getCurrentPriorityLevel()
	runWithPriority(ImmediateSchedulerPriority, function()
		return mod.commitRootImpl(root, renderPriorityLevel)
	end)
	return nil
end

-- FIXME Luau: Luau doesn't infer root as FiberRoot via the callgraph from ensureRootIsScheduled(root: FiberRoot)
mod.commitRootImpl = function(root: FiberRoot, renderPriorityLevel)
	repeat
		-- `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which
		-- means `flushPassiveEffects` will sometimes result in additional
		-- passive effects. So we need to keep flushing in a loop until there are
		-- no more pending effects.
		-- TODO: Might be better if `flushPassiveEffects` did not automatically
		-- flush synchronous work at the end, to avoid factoring hazards like this.
		exports.flushPassiveEffects()
	until rootWithPendingPassiveEffects == nil
	flushRenderPhaseStrictModeWarningsInDEV()

	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Should not already be working."
	)

	-- FIXME Luau: Luau doesn't narrow finishedWork based on the nil guard below
	local finishedWork = root.finishedWork :: Fiber
	local lanes = root.finishedLanes

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logCommitStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markCommitStarted(lanes)
	end

	if finishedWork == nil then
		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logCommitStopped()
			end
		end

		if enableSchedulingProfiler then
			SchedulingProfiler.markCommitStopped()
		end

		return nil
	end
	root.finishedWork = nil
	root.finishedLanes = ReactFiberLane.NoLanes

	invariant(
		finishedWork ~= root.current,
		"Cannot commit the same tree as before. This error is likely caused by "
			.. "a bug in React. Please file an issue."
	)

	-- commitRoot never returns a continuation; it always finishes synchronously.
	-- So we can clear these now to allow a new callback to be scheduled.
	root.callbackNode = nil

	-- Update the first and last pending times on this root. The new first
	-- pending time is whatever is left on the root fiber.
	local remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes)
	markRootFinished(root, remainingLanes)

	-- Clear already finished discrete updates in case that a later call of
	-- `flushDiscreteUpdates` starts a useless render pass which may cancels
	-- a scheduled timeout.
	if rootsWithPendingDiscreteUpdates ~= nil then
		if not hasDiscreteLanes(remainingLanes) and rootsWithPendingDiscreteUpdates:has(root) then
			rootsWithPendingDiscreteUpdates:delete(root)
		end
	end

	if root == workInProgressRoot then
		-- We can reset these now that they are finished.
		workInProgressRoot = nil
		workInProgress = nil
		workInProgressRootRenderLanes = ReactFiberLane.NoLanes
	else
		-- This indicates that the last root we worked on is not the same one that
		-- we're committing now. This most commonly happens when a suspended root
		-- times out.
	end

	-- Check if there are any effects in the whole tree.
	-- TODO: This is left over from the effect list implementation, where we had
	-- to check for the existence of `firstEffect` to satsify Flow. I think the
	-- only other reason this optimization exists is because it affects profiling.
	-- Reconsider whether this is necessary.
	local subtreeHasEffects = bit32.band(
		finishedWork.subtreeFlags,
		bit32.bor(
			ReactFiberFlags.BeforeMutationMask,
			ReactFiberFlags.MutationMask,
			ReactFiberFlags.LayoutMask,
			ReactFiberFlags.PassiveMask
		)
	) ~= ReactFiberFlags.NoFlags
	local rootHasEffect = bit32.band(
		finishedWork.flags,
		bit32.bor(
			ReactFiberFlags.BeforeMutationMask,
			ReactFiberFlags.MutationMask,
			ReactFiberFlags.LayoutMask,
			ReactFiberFlags.PassiveMask
		)
	) ~= ReactFiberFlags.NoFlags

	if subtreeHasEffects or rootHasEffect then
		local previousLanePriority
		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			previousLanePriority = getCurrentUpdateLanePriority()
			setCurrentUpdateLanePriority(ReactFiberLane.SyncLanePriority)
		end

		local prevExecutionContext = executionContext
		executionContext = bit32.bor(executionContext, CommitContext)
		local prevInteractions = mod.pushInteractions(root)

		-- Reset this to nil before calling lifecycles
		ReactCurrentOwner.current = nil

		-- The commit phase is broken into several sub-phases. We do a separate pass
		-- of the effect list for each phase: all mutation effects come before all
		-- layout effects, and so on.

		-- The first phase a "before mutation" phase. We use this phase to read the
		-- state of the host tree right before we mutate it. This is where
		-- getSnapshotBeforeUpdate is called.
		focusedInstanceHandle = ReactFiberHostConfig.prepareForCommit(root.containerInfo)
		shouldFireAfterActiveInstanceBlur = false

		mod.commitBeforeMutationEffects(finishedWork)

		-- We no longer need to track the active instance fiber
		focusedInstanceHandle = nil

		if ReactFeatureFlags.enableProfilerTimer then
			-- Mark the current commit time to be shared by all Profilers in this
			-- batch. This enables them to be grouped later.
			ReactProfilerTimer.recordCommitTime()
		end

		-- The next phase is the mutation phase, where we mutate the host tree.
		mod.commitMutationEffects(finishedWork, root, renderPriorityLevel)

		if shouldFireAfterActiveInstanceBlur then
			ReactFiberHostConfig.afterActiveInstanceBlur()
		end
		ReactFiberHostConfig.resetAfterCommit(root.containerInfo)

		-- The work-in-progress tree is now the current tree. This must come after
		-- the mutation phase, so that the previous tree is still current during
		-- componentWillUnmount, but before the layout phase, so that the finished
		-- work is current during componentDidMount/Update.
		root.current = finishedWork

		-- The next phase is the layout phase, where we call effects that read
		-- the host tree after it's been mutated. The idiomatic use case for this is
		-- layout, but class component lifecycles also fire here for legacy reasons.
		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logLayoutEffectsStarted(lanes)
			end
		end
		if enableSchedulingProfiler then
			SchedulingProfiler.markLayoutEffectsStarted(lanes)
		end

		if __DEV__ then
			setCurrentDebugFiberInDEV(finishedWork)
			invokeGuardedCallback(
				nil,
				recursivelyCommitLayoutEffects,
				nil,
				finishedWork,
				root,
				-- deviation: pass in this function to avoid dependency cycle
				exports.captureCommitPhaseError,
				exports.schedulePassiveEffectCallback
			)
			if hasCaughtError() then
				local err = clearCaughtError()
				captureCommitPhaseErrorOnRoot(finishedWork, finishedWork, err)
			end
			resetCurrentDebugFiberInDEV()
		else
			-- deviation: YOLO flag for disabling pcall
			local ok, result
			if not __YOLO__ then
				-- deviation: pass in captureCommitPhaseError and schedulePassiveEffectCallback to avoid dependency cycle
				ok, result = xpcall(
					recursivelyCommitLayoutEffects,
					describeError,
					finishedWork,
					root,
					exports.captureCommitPhaseError,
					exports.schedulePassiveEffectCallback
				)
			else
				ok = true
				recursivelyCommitLayoutEffects(
					finishedWork,
					root,
					exports.captureCommitPhaseError,
					exports.schedulePassiveEffectCallback
				)
			end

			if not ok then
				captureCommitPhaseErrorOnRoot(finishedWork, finishedWork, result)
			end
		end

		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logLayoutEffectsStopped()
			end
		end
		if enableSchedulingProfiler then
			SchedulingProfiler.markLayoutEffectsStopped()
		end

		-- If there are pending passive effects, schedule a callback to process them.
		if
			bit32.band(finishedWork.subtreeFlags, ReactFiberFlags.PassiveMask) ~= ReactFiberFlags.NoFlags
			or bit32.band(finishedWork.flags, ReactFiberFlags.PassiveMask) ~= ReactFiberFlags.NoFlags
		then
			if not rootDoesHavePassiveEffects then
				rootDoesHavePassiveEffects = true
				scheduleCallback(NormalSchedulerPriority, function()
					exports.flushPassiveEffects()
					return nil
				end)
			end
		end

		-- Tell Scheduler to yield at the end of the frame, so the browser has an
		-- opportunity to paint.
		requestPaint()

		if ReactFeatureFlags.enableSchedulerTracing then
			mod.popInteractions(prevInteractions)
		end
		executionContext = prevExecutionContext

		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler and previousLanePriority ~= nil then
			-- Reset the priority to the previous non-sync value.
			setCurrentUpdateLanePriority(previousLanePriority)
		end
	else
		-- No effects.
		root.current = finishedWork
		-- Measure these anyway so the flamegraph explicitly shows that there were
		-- no effects.
		-- TODO: Maybe there's a better way to report this.
		if ReactFeatureFlags.enableProfilerTimer then
			ReactProfilerTimer.recordCommitTime()
		end
	end

	local rootDidHavePassiveEffects = rootDoesHavePassiveEffects

	if rootDoesHavePassiveEffects then
		-- This commit has passive effects. Stash a reference to them. But don't
		-- schedule a callback until after flushing layout work.
		rootDoesHavePassiveEffects = false
		rootWithPendingPassiveEffects = root
		pendingPassiveEffectsLanes = lanes
		pendingPassiveEffectsRenderPriority = renderPriorityLevel
	end

	-- Read this again, since an effect might have updated it
	remainingLanes = root.pendingLanes

	-- Check if there's remaining work on this root
	if remainingLanes ~= ReactFiberLane.NoLanes then
		if ReactFeatureFlags.enableSchedulerTracing then
			if spawnedWorkDuringRender ~= nil then
				local expirationTimes = spawnedWorkDuringRender
				spawnedWorkDuringRender = nil
				for i = 1, #expirationTimes do
					scheduleInteractions(root, expirationTimes[i], root.memoizedInteractions)
				end
			end
			mod.schedulePendingInteractions(root, remainingLanes)
		end
	else
		-- If there's no remaining work, we can clear the set of already failed
		-- error boundaries.
		legacyErrorBoundariesThatAlreadyFailed = nil
	end

	if __DEV__ and enableDoubleInvokingEffects then
		if not rootDidHavePassiveEffects then
			commitDoubleInvokeEffectsInDEV(root.current, false)
		end
	end

	if ReactFeatureFlags.enableSchedulerTracing then
		if not rootDidHavePassiveEffects then
			-- If there are no passive effects, then we can complete the pending interactions.
			-- Otherwise, we'll wait until after the passive effects are flushed.
			-- Wait to do this until after remaining work has been scheduled,
			-- so that we don't prematurely signal complete for interactions when there's e.g. hidden work.
			mod.finishPendingInteractions(root, lanes)
		end
	end

	if remainingLanes == SyncLane then
		-- Count the number of times the root synchronously re-renders without
		-- finishing. If there are too many, it indicates an infinite update loop.
		if root == rootWithNestedUpdates then
			nestedUpdateCount += 1
		else
			nestedUpdateCount = 0
			rootWithNestedUpdates = root
		end
	else
		nestedUpdateCount = 0
	end

	onCommitRootDevTools(finishedWork.stateNode, renderPriorityLevel)

	if __DEV__ then
		onCommitRootTestSelector()
	end

	-- Always call this before exiting `commitRoot`, to ensure that any
	-- additional work on this root is scheduled.
	ensureRootIsScheduled(root, now())

	if hasUncaughtError then
		hasUncaughtError = false
		local error_ = firstUncaughtError
		firstUncaughtError = nil
		-- FIXME: we lose the original stack trace when we re-throw this way
		error(error_)
	end

	if bit32.band(executionContext, LegacyUnbatchedContext) ~= NoContext then
		if __DEV__ then
			if enableDebugTracing then
				DebugTracing.logCommitStopped()
			end
		end

		if enableSchedulingProfiler then
			SchedulingProfiler.markCommitStopped()
		end

		-- This is a legacy edge case. We just committed the initial mount of
		-- a ReactDOM.render-ed root inside of batchedUpdates. The commit fired
		-- synchronously, but layout updates should be deferred until the end
		-- of the batch.
		return nil
	end

	-- If layout work was scheduled, flush it now.
	flushSyncCallbackQueue()

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logCommitStopped()
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markCommitStopped()
	end

	return nil
end

mod.commitBeforeMutationEffects = function(firstChild: Fiber)
	local fiber = firstChild
	while fiber ~= nil do
		if fiber.deletions ~= nil then
			mod.commitBeforeMutationEffectsDeletions(fiber.deletions)
		end

		if fiber.child ~= nil then
			local primarySubtreeFlags = bit32.band(fiber.subtreeFlags, ReactFiberFlags.BeforeMutationMask)
			if primarySubtreeFlags ~= ReactFiberFlags.NoFlags then
				mod.commitBeforeMutationEffects(fiber.child)
			end
		end

		if __DEV__ then
			setCurrentDebugFiberInDEV(fiber)
			invokeGuardedCallback(nil, mod.commitBeforeMutationEffectsImpl, nil, fiber)
			if hasCaughtError() then
				local error_ = clearCaughtError()
				exports.captureCommitPhaseError(fiber, fiber.return_, error_)
			end
			resetCurrentDebugFiberInDEV()
		else
			-- deviation: YOLO flag for disabling pcall
			local ok, error_
			if not __YOLO__ then
				ok, error_ = xpcall(mod.commitBeforeMutationEffectsImpl, describeError, fiber)
			else
				ok = true
				mod.commitBeforeMutationEffectsImpl(fiber)
			end

			if not ok then
				exports.captureCommitPhaseError(fiber, fiber.return_, error_)
			end
		end
		-- FIXME Luau: Luau doesn't narrow correctly for the while ~= nil pattern
		fiber = fiber.sibling :: Fiber
	end
end

mod.commitBeforeMutationEffectsImpl = function(fiber: Fiber)
	local current = fiber.alternate
	local flags = fiber.flags

	if not shouldFireAfterActiveInstanceBlur and focusedInstanceHandle ~= nil then
		-- Check to see if the focused element was inside of a hidden (Suspense) subtree.
		-- TODO: Move this out of the hot path using a dedicated effect tag.
		if
			fiber.tag == ReactWorkTags.SuspenseComponent
			and ReactFiberCommitWork.isSuspenseBoundaryBeingHidden(current, fiber)
			and doesFiberContain(fiber, focusedInstanceHandle)
		then
			shouldFireAfterActiveInstanceBlur = true
			ReactFiberHostConfig.beforeActiveInstanceBlur()
		end
	end

	if bit32.band(flags, ReactFiberFlags.Snapshot) ~= ReactFiberFlags.NoFlags then
		setCurrentDebugFiberInDEV(fiber)
		commitBeforeMutationEffectOnFiber(current, fiber)
		resetCurrentDebugFiberInDEV()
	end

	if bit32.band(flags, ReactFiberFlags.Passive) ~= ReactFiberFlags.NoFlags then
		-- If there are passive effects, schedule a callback to flush at
		-- the earliest opportunity.
		if not rootDoesHavePassiveEffects then
			rootDoesHavePassiveEffects = true
			scheduleCallback(NormalSchedulerPriority, function()
				exports.flushPassiveEffects()
				return nil
			end)
		end
	end
end

mod.commitBeforeMutationEffectsDeletions = function(deletions: Array<Fiber>)
	for i = 1, #deletions do
		local fiber = deletions[i]

		-- TODO (effects) It would be nice to avoid calling doesFiberContain()
		-- Maybe we can repurpose one of the subtreeFlags positions for this instead?
		-- Use it to store which part of the tree the focused instance is in?
		-- This assumes we can safely determine that instance during the "render" phase.
		if doesFiberContain(fiber, (focusedInstanceHandle :: any) :: Fiber) then
			shouldFireAfterActiveInstanceBlur = true
			ReactFiberHostConfig.beforeActiveInstanceBlur()
		end
	end
end

mod.commitMutationEffects = function(firstChild: Fiber, root: FiberRoot, renderPriorityLevel: ReactPriorityLevel)
	local fiber = firstChild
	while fiber ~= nil do
		local deletions = fiber.deletions
		if deletions ~= nil then
			-- performance: React 18 inlines commitMutationEffectsDeletions, pulling that in based on tab switching hot path
			for _, childToDelete in deletions do
				-- FIXME Luau: CLI-49835, "Function only returns 1 value, 2 are required"
				local ok, error_ =
					xpcall(commitDeletion, describeError, root, childToDelete, fiber, renderPriorityLevel)
				if not ok then
					exports.captureCommitPhaseError(childToDelete, fiber, error_)
				end
			end
		end

		if fiber.child ~= nil then
			local mutationFlags = bit32.band(fiber.subtreeFlags, ReactFiberFlags.MutationMask)
			if mutationFlags ~= ReactFiberFlags.NoFlags then
				mod.commitMutationEffects(fiber.child, root, renderPriorityLevel)
			end
		end

		if __DEV__ then
			setCurrentDebugFiberInDEV(fiber)
			invokeGuardedCallback(nil, mod.commitMutationEffectsImpl, nil, fiber, root, renderPriorityLevel)
			if hasCaughtError() then
				local error_ = clearCaughtError()
				exports.captureCommitPhaseError(fiber, fiber.return_, error_)
			end
			resetCurrentDebugFiberInDEV()
		else
			-- deviation: YOLO flag for disabling pcall
			local ok, result
			if not __YOLO__ then
				ok, result = xpcall(mod.commitMutationEffectsImpl, describeError, fiber, root, renderPriorityLevel)
			else
				ok = true
				mod.commitMutationEffectsImpl(fiber, root, renderPriorityLevel)
			end
			if not ok then
				exports.captureCommitPhaseError(fiber, fiber.return_, result)
			end
		end
		-- FIXME Luau: Luau doesn't understand the while ~= nil construct
		fiber = fiber.sibling :: Fiber
	end
end

mod.commitMutationEffectsImpl = function(fiber: Fiber, root: FiberRoot, renderPriorityLevel)
	local flags = fiber.flags
	-- performance: avoid always-false compare for Roblox renderer in hot path
	-- if bit32.band(flags, ReactFiberFlags.ContentReset) ~= 0 then
	--   unimplemented("commitResetTextContent")
	-- commitResetTextContent(fiber)
	-- end

	if bit32.band(flags, ReactFiberFlags.Ref) ~= 0 then
		local current = fiber.alternate
		if current ~= nil then
			commitDetachRef(current)
		end
		-- performance: avoid always-false compare for Roblox renderer in hot path
		-- if ReactFeatureFlags.enableScopeAPI then
		--   -- TODO: This is a temporary solution that allowed us to transition away from React Flare on www.
		--   if fiber.tag == ReactWorkTags.ScopeComponent then
		--     commitAttachRef(fiber)
		--   end
		-- end
	end

	-- The following switch statement is only concerned about placement,
	-- updates, and deletions. To avoid needing to add a case for every possible
	-- bitmap value, we remove the secondary effects from the effect tag and
	-- switch on that value.
	local primaryFlags =
		bit32.band(flags, bit32.bor(ReactFiberFlags.Placement, ReactFiberFlags.Update, ReactFiberFlags.Hydrating))
	if primaryFlags == ReactFiberFlags.Placement then
		commitPlacement(fiber)
		-- Clear the "placement" from effect tag so that we know that this is
		-- inserted, before any life-cycles like componentDidMount gets called.
		-- TODO: findDOMNode doesn't rely on this any more but isMounted does
		-- and isMounted is deprecated anyway so we should be able to kill this.
		fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Placement))
	elseif primaryFlags == ReactFiberFlags.PlacementAndUpdate then
		-- Placement
		commitPlacement(fiber)
		-- Clear the "placement" from effect tag so that we know that this is
		-- inserted, before any life-cycles like componentDidMount gets called.
		fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Placement))

		-- Update
		local current = fiber.alternate
		commitWork(current, fiber)
		-- performance: avoid always-false compare for Roblox renderer in hot path
		-- elseif primaryFlags == ReactFiberFlags.Hydrating then
		--   fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Hydrating))
		-- elseif primaryFlags == ReactFiberFlags.HydratingAndUpdate then
		--   fiber.flags = bit32.band(fiber.flags, bit32.bnot(ReactFiberFlags.Hydrating))
		--   -- Update
		--   local current = fiber.alternate
		--   commitWork(current, fiber)
	elseif primaryFlags == ReactFiberFlags.Update then
		local current = fiber.alternate
		commitWork(current, fiber)
	end
end

mod.commitMutationEffectsDeletions = function(
	deletions: Array<Fiber>,
	fiber: Fiber,
	root: FiberRoot,
	renderPriorityLevel
)
	-- performance: align to React 18, which ditches the __DEV__ branch and use of invokeGuardedCallback
	for _, childToDelete in deletions do
		-- FIXME Luau: CLI-49835, "Function only returns 1 value, 2 are required"
		local ok, error_ = xpcall(commitDeletion, describeError, root, childToDelete, fiber, renderPriorityLevel)
		if not ok then
			exports.captureCommitPhaseError(childToDelete, fiber, error_)
		end
	end
end

exports.schedulePassiveEffectCallback = function()
	if not rootDoesHavePassiveEffects then
		rootDoesHavePassiveEffects = true
		scheduleCallback(NormalSchedulerPriority, function()
			exports.flushPassiveEffects()
			return nil
		end)
	end
end

-- deviation: Pre-declare functions
local flushPassiveEffectsImpl
exports.flushPassiveEffects = function(): boolean
	-- Returns whether passive effects were flushed.
	if pendingPassiveEffectsRenderPriority ~= NoSchedulerPriority then
		local priorityLevel = if pendingPassiveEffectsRenderPriority > NormalSchedulerPriority
			then NormalSchedulerPriority
			else pendingPassiveEffectsRenderPriority
		pendingPassiveEffectsRenderPriority = NoSchedulerPriority
		if ReactFeatureFlags.decoupleUpdatePriorityFromScheduler then
			local previousLanePriority = getCurrentUpdateLanePriority()

			-- performance: extract non-throwable function from try{} to remove need for anon function
			setCurrentUpdateLanePriority(schedulerPriorityToLanePriority(priorityLevel))
			-- deviation: YOLO flag for disabling pcall
			local ok, result
			if not __YOLO__ then
				ok, result = xpcall(runWithPriority, describeError, priorityLevel, flushPassiveEffectsImpl)
			else
				ok = true
				setCurrentUpdateLanePriority(schedulerPriorityToLanePriority(priorityLevel))
				result = runWithPriority(priorityLevel, flushPassiveEffectsImpl)
			end

			-- finally
			setCurrentUpdateLanePriority(previousLanePriority)

			if not ok then
				error(result)
			end
			return result
		else
			return runWithPriority(priorityLevel, flushPassiveEffectsImpl)
		end
	end
	return false
end

flushPassiveMountEffects = function(root, firstChild: Fiber): ()
	local fiber = firstChild
	while fiber ~= nil do
		local prevProfilerOnStack = nil
		if ReactFeatureFlags.enableProfilerTimer and ReactFeatureFlags.enableProfilerCommitHooks then
			if fiber.tag == ReactWorkTags.Profiler then
				prevProfilerOnStack = nearestProfilerOnStack
				nearestProfilerOnStack = fiber
			end
		end

		local primarySubtreeFlags = bit32.band(fiber.subtreeFlags, ReactFiberFlags.PassiveMask)

		if fiber.child ~= nil and primarySubtreeFlags ~= ReactFiberFlags.NoFlags then
			flushPassiveMountEffects(root, fiber.child)
		end

		if bit32.band(fiber.flags, ReactFiberFlags.Passive) ~= ReactFiberFlags.NoFlags then
			if __DEV__ then
				setCurrentDebugFiberInDEV(fiber)
				invokeGuardedCallback(nil, commitPassiveMountOnFiber, nil, root, fiber)
				if hasCaughtError() then
					local error_ = clearCaughtError()
					exports.captureCommitPhaseError(fiber, fiber.return_, error_)
				end
				resetCurrentDebugFiberInDEV()
			else
				-- deviation: YOLO flag for disabling pcall
				local ok, error_
				if not __YOLO__ then
					ok, error_ = xpcall(commitPassiveMountOnFiber, describeError, root, fiber)
				else
					ok = true
					commitPassiveMountOnFiber(root, fiber)
				end

				if not ok then
					exports.captureCommitPhaseError(fiber, fiber.return_, error_)
				end
			end
		end

		if ReactFeatureFlags.enableProfilerTimer and ReactFeatureFlags.enableProfilerCommitHooks then
			if fiber.tag == ReactWorkTags.Profiler then
				-- Bubble times to the next nearest ancestor Profiler.
				-- After we process that Profiler, we'll bubble further up.
				if prevProfilerOnStack ~= nil then
					prevProfilerOnStack.stateNode.passiveEffectDuration += fiber.stateNode.passiveEffectDuration
				end

				nearestProfilerOnStack = prevProfilerOnStack
			end
		end

		-- FIXME Luau: Luau doesn't understand the loop ~= nil construct
		fiber = fiber.sibling :: Fiber
	end
end

local function flushPassiveUnmountEffects(firstChild: Fiber): ()
	local fiber = firstChild
	while fiber ~= nil do
		local deletions = fiber.deletions
		if deletions ~= nil then
			for i = 1, #deletions do
				local fiberToDelete = deletions[i]
				mod.flushPassiveUnmountEffectsInsideOfDeletedTree(fiberToDelete, fiber)

				-- Now that passive effects have been processed, it's safe to detach lingering pointers.
				mod.detachFiberAfterEffects(fiberToDelete)
			end
		end

		local child = fiber.child
		if child ~= nil then
			-- If any children have passive effects then traverse the subtree.
			-- Note that this requires checking subtreeFlags of the current Fiber,
			-- rather than the subtreeFlags/effectsTag of the first child,
			-- since that would not cover passive effects in siblings.
			local passiveFlags = bit32.band(fiber.subtreeFlags, ReactFiberFlags.PassiveMask)
			if passiveFlags ~= ReactFiberFlags.NoFlags then
				flushPassiveUnmountEffects(child)
			end
		end

		local primaryFlags = bit32.band(fiber.flags, ReactFiberFlags.Passive)
		if primaryFlags ~= ReactFiberFlags.NoFlags then
			setCurrentDebugFiberInDEV(fiber)
			commitPassiveUnmountOnFiber(fiber)
			resetCurrentDebugFiberInDEV()
		end

		-- FIXME Luau: Luau doesn't understand the loop ~= nil construct
		fiber = fiber.sibling :: Fiber
	end
end

mod.flushPassiveUnmountEffectsInsideOfDeletedTree = function(fiberToDelete: Fiber, nearestMountedAncestor: Fiber)
	if bit32.band(fiberToDelete.subtreeFlags, ReactFiberFlags.PassiveStatic) ~= ReactFiberFlags.NoFlags then
		-- If any children have passive effects then traverse the subtree.
		-- Note that this requires checking subtreeFlags of the current Fiber,
		-- rather than the subtreeFlags/effectsTag of the first child,
		-- since that would not cover passive effects in siblings.
		local child = fiberToDelete.child
		while child ~= nil do
			mod.flushPassiveUnmountEffectsInsideOfDeletedTree(child, nearestMountedAncestor)
			child = child.sibling
		end
	end

	if bit32.band(fiberToDelete.flags, ReactFiberFlags.PassiveStatic) ~= ReactFiberFlags.NoFlags then
		setCurrentDebugFiberInDEV(fiberToDelete)
		commitPassiveUnmountInsideDeletedTreeOnFiber(fiberToDelete, nearestMountedAncestor)
		resetCurrentDebugFiberInDEV()
	end
end

flushPassiveEffectsImpl = function()
	if rootWithPendingPassiveEffects == nil then
		return false
	end

	-- FIXME Luau: Luau doesn't narrow to non-nil with the guard above
	local root = rootWithPendingPassiveEffects :: FiberRoot
	local lanes = pendingPassiveEffectsLanes
	rootWithPendingPassiveEffects = nil
	pendingPassiveEffectsLanes = ReactFiberLane.NoLanes

	invariant(
		bit32.band(executionContext, bit32.bor(RenderContext, CommitContext)) == NoContext,
		"Cannot flush passive effects while already rendering."
	)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logPassiveEffectsStarted(lanes)
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markPassiveEffectsStarted(lanes)
	end

	local prevExecutionContext = executionContext
	executionContext = bit32.bor(executionContext, CommitContext)
	local prevInteractions = mod.pushInteractions(root)

	-- It's important that ALL pending passive effect destroy functions are called
	-- before ANY passive effect create functions are called.
	-- Otherwise effects in sibling components might interfere with each other.
	-- e.g. a destroy function in one component may unintentionally override a ref
	-- value set by a create function in another component.
	-- Layout effects have the same constraint.
	flushPassiveUnmountEffects(root.current)
	flushPassiveMountEffects(root, root.current)

	if __DEV__ then
		if enableDebugTracing then
			DebugTracing.logPassiveEffectsStopped()
		end
	end

	if enableSchedulingProfiler then
		SchedulingProfiler.markPassiveEffectsStopped()
	end

	if __DEV__ and enableDoubleInvokingEffects then
		commitDoubleInvokeEffectsInDEV(root.current, true)
	end

	if ReactFeatureFlags.enableSchedulerTracing then
		mod.popInteractions(prevInteractions)
		mod.finishPendingInteractions(root, lanes)
	end

	executionContext = prevExecutionContext

	flushSyncCallbackQueue()

	-- If additional passive effects were scheduled, increment a counter. If this
	-- exceeds the limit, we'll fire a warning.
	if rootWithPendingPassiveEffects == nil then
		nestedPassiveUpdateCount = 0
	else
		nestedPassiveUpdateCount = nestedPassiveUpdateCount + 1
	end

	return true
end

exports.isAlreadyFailedLegacyErrorBoundary = function(instance): boolean
	return legacyErrorBoundariesThatAlreadyFailed ~= nil and legacyErrorBoundariesThatAlreadyFailed:has(instance)
end

exports.markLegacyErrorBoundaryAsFailed = function(instance)
	if legacyErrorBoundariesThatAlreadyFailed == nil then
		legacyErrorBoundariesThatAlreadyFailed = Set.new({ instance })
	else
		legacyErrorBoundariesThatAlreadyFailed:add(instance)
	end
end

-- TODO: this function and the related fields should be extracted/relocated to break a cycle
local function prepareToThrowUncaughtError(error_)
	if not hasUncaughtError then
		hasUncaughtError = true
		firstUncaughtError = error_
	end
end
exports.onUncaughtError = prepareToThrowUncaughtError

captureCommitPhaseErrorOnRoot = function(rootFiber: Fiber, sourceFiber: Fiber, error_)
	local errorInfo = createCapturedValue(error_, sourceFiber)
	-- deviation: parameterize method onUncaughtError to avoid circular dependency
	local update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane, exports.onUncaughtError)
	enqueueUpdate(rootFiber, update)
	local eventTime = exports.requestEventTime()
	local root = mod.markUpdateLaneFromFiberToRoot(rootFiber, SyncLane)
	if root ~= nil then
		markRootUpdated(root, SyncLane, eventTime)
		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, SyncLane)
	end
end

-- exports.captureCommitPhaseError(
--   sourceFiber: Fiber,
--   nearestMountedAncestor: Fiber | nil,
--   error: mixed
-- )
exports.captureCommitPhaseError = function(sourceFiber: Fiber, nearestMountedAncestor, error_)
	if sourceFiber.tag == ReactWorkTags.HostRoot then
		-- Error was thrown at the root. There is no parent, so the root
		-- itself should capture it.
		captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error_)
		return
	end

	local fiber = nil
	if skipUnmountedBoundaries then
		fiber = nearestMountedAncestor
	else
		fiber = sourceFiber.return_
	end

	while fiber ~= nil do
		if fiber.tag == ReactWorkTags.HostRoot then
			captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error_)
			return
		else
			if fiber.tag == ReactWorkTags.ClassComponent then
				local ctor = fiber.type
				local instance = fiber.stateNode
				if
					typeof(ctor.getDerivedStateFromError) == "function"
					or (
						typeof(instance.componentDidCatch) == "function"
						and not exports.isAlreadyFailedLegacyErrorBoundary(instance)
					)
				then
					local errorInfo = createCapturedValue(error_, sourceFiber)
					local update = createClassErrorUpdate(fiber, errorInfo, SyncLane)
					enqueueUpdate(fiber, update)
					local eventTime = exports.requestEventTime()
					local root = mod.markUpdateLaneFromFiberToRoot(fiber, SyncLane)
					if root ~= nil then
						markRootUpdated(root, SyncLane, eventTime)
						ensureRootIsScheduled(root, eventTime)
						mod.schedulePendingInteractions(root, SyncLane)
					end
					return
				end
			end
			fiber = fiber.return_
		end
	end
end

exports.pingSuspendedRoot = function(root: FiberRoot, wakeable: Wakeable, pingedLanes: Lanes)
	local pingCache = root.pingCache
	if pingCache ~= nil then
		-- The wakeable resolved, so we no longer need to memoize, because it will
		-- never be thrown again.
		pingCache[wakeable] = nil
	end

	local eventTime = exports.requestEventTime()
	markRootPinged(root, pingedLanes, eventTime)

	if workInProgressRoot == root and isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes) then
		-- Received a ping at the same priority level at which we're currently
		-- rendering. We might want to restart this render. This should mirror
		-- the logic of whether or not a root suspends once it completes.

		-- TODO: If we're rendering sync either due to Sync, Batched or expired,
		-- we should probably never restart.

		-- If we're suspended with delay, or if it's a retry, we'll always suspend
		-- so we can always restart.
		if
			workInProgressRootExitStatus == RootExitStatus.SuspendedWithDelay
			or workInProgressRootExitStatus == RootExitStatus.Suspended
				and includesOnlyRetries(workInProgressRootRenderLanes)
				and now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS
		then
			-- Restart from the root.
			mod.prepareFreshStack(root, ReactFiberLane.NoLanes)
		else
			-- Even though we can't restart right now, we might get an
			-- opportunity later. So we mark this render as having a ping.
			workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes)
		end
	end

	ensureRootIsScheduled(root, eventTime)
	mod.schedulePendingInteractions(root, pingedLanes)
end

function retryTimedOutBoundary(boundaryFiber: Fiber, retryLane: Lane)
	-- The boundary fiber (a Suspense component or SuspenseList component)
	-- previously was rendered in its fallback state. One of the promises that
	-- suspended it has resolved, which means at least part of the tree was
	-- likely unblocked. Try rendering again, at a new expiration time.
	if retryLane == ReactFiberLane.NoLane then
		retryLane = requestRetryLane(boundaryFiber)
	end
	-- TODO: Special case idle priority?
	local eventTime = exports.requestEventTime()
	local root = mod.markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane)
	if root ~= nil then
		markRootUpdated(root, retryLane, eventTime)
		ensureRootIsScheduled(root, eventTime)
		mod.schedulePendingInteractions(root, retryLane)
	end
end

-- exports.retryDehydratedSuspenseBoundary(boundaryFiber: Fiber)
--   local suspenseState: nil | SuspenseState = boundaryFiber.memoizedState
--   local retryLane = NoLane
--   if suspenseState ~= nil)
--     retryLane = suspenseState.retryLane
--   end
--   retryTimedOutBoundary(boundaryFiber, retryLane)
-- end

exports.resolveRetryWakeable = function(boundaryFiber: Fiber, wakeable: Wakeable)
	local retryLane = ReactFiberLane.NoLane -- Default
	local retryCache -- : WeakSet<Wakeable> | Set<Wakeable> | nil
	-- performance: avoid always-false comapare
	-- if ReactFeatureFlags.enableSuspenseServerRenderer then
	--   if boundaryFiber.tag == ReactWorkTags.SuspenseComponent then
	--       retryCache = boundaryFiber.stateNode
	--       local suspenseState: nil | SuspenseState = boundaryFiber.memoizedState
	--       if suspenseState ~= nil then
	--         -- TODO: Remove Luau narrowing workaround
	--         retryLane = (suspenseState :: SuspenseState).retryLane
	--       end
	--     elseif boundaryFiber.tag == ReactWorkTags.SuspenseListComponent then
	--       retryCache = boundaryFiber.stateNode
	--     else
	--       invariant(
	--         false,
	--         'Pinged unknown suspense boundary type. ' ..
	--           'This is probably a bug in React.'
	--       )
	--   end
	-- else
	retryCache = boundaryFiber.stateNode
	-- end

	if retryCache ~= nil then
		-- The wakeable resolved, so we no longer need to memoize, because it will
		-- never be thrown again.
		retryCache:delete(wakeable)
	end

	retryTimedOutBoundary(boundaryFiber, retryLane)
end

-- Computes the next Just Noticeable Difference (JND) boundary.
-- The theory is that a person can't tell the difference between small differences in time.
-- Therefore, if we wait a bit longer than necessary that won't translate to a noticeable
-- difference in the experience. However, waiting for longer might mean that we can avoid
-- showing an intermediate loading state. The longer we have already waited, the harder it
-- is to tell small differences in time. Therefore, the longer we've already waited,
-- the longer we can wait additionally. At some point we have to give up though.
-- We pick a train model where the next boundary commits at a consistent schedule.
-- These particular numbers are vague estimates. We expect to adjust them based on research.
-- FIXME Luau: Luau needs an explicit number annotation here, but should infer: CLI-49832
function jnd(timeElapsed: number): number
	if timeElapsed < 120 then
		return 120
	elseif timeElapsed < 480 then
		return 480
	elseif timeElapsed < 1080 then
		return 1080
	elseif timeElapsed < 1920 then
		return 1920
	elseif timeElapsed < 3000 then
		return 3000
	elseif timeElapsed < 4320 then
		return 4320
	else
		return math.ceil(timeElapsed / 1960) * 1960
	end
end

mod.checkForNestedUpdates = function()
	if nestedUpdateCount > NESTED_UPDATE_LIMIT then
		nestedUpdateCount = 0
		rootWithNestedUpdates = nil
		invariant(
			false,
			"Maximum update depth exceeded. This can happen when a component "
				.. "repeatedly calls setState inside componentWillUpdate or "
				.. "componentDidUpdate. React limits the number of nested updates to "
				.. "prevent infinite loops."
		)
	end

	if __DEV__ then
		if nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT then
			nestedPassiveUpdateCount = 0
			console.error(
				"Maximum update depth exceeded. This can happen when a component "
					.. "calls setState inside useEffect, but useEffect either doesn't "
					.. "have a dependency array, or one of the dependencies changes on "
					.. "every render."
			)
		end
	end
end

function flushRenderPhaseStrictModeWarningsInDEV()
	if __DEV__ then
		ReactStrictModeWarnings.flushLegacyContextWarning()

		if ReactFeatureFlags.warnAboutDeprecatedLifecycles then
			ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings()
		end
	end
end

function commitDoubleInvokeEffectsInDEV(fiber: Fiber, hasPassiveEffects: boolean)
	if __DEV__ and enableDoubleInvokingEffects then
		setCurrentDebugFiberInDEV(fiber)
		invokeEffectsInDev(fiber, ReactFiberFlags.MountLayoutDev, invokeLayoutEffectUnmountInDEV)
		if hasPassiveEffects then
			invokeEffectsInDev(fiber, ReactFiberFlags.MountPassiveDev, invokePassiveEffectUnmountInDEV)
		end

		invokeEffectsInDev(fiber, ReactFiberFlags.MountLayoutDev, invokeLayoutEffectMountInDEV)
		if hasPassiveEffects then
			invokeEffectsInDev(fiber, ReactFiberFlags.MountPassiveDev, invokePassiveEffectMountInDEV)
		end
		resetCurrentDebugFiberInDEV()
	end
end

function invokeEffectsInDev(firstChild: Fiber, fiberFlags: Flags, invokeEffectFn: (fiber: Fiber) -> ()): ()
	if __DEV__ and enableDoubleInvokingEffects then
		local fiber = firstChild
		while fiber ~= nil do
			if fiber.child ~= nil then
				local primarySubtreeFlag = bit32.band(fiber.subtreeFlags, fiberFlags)
				if primarySubtreeFlag ~= ReactFiberFlags.NoFlags then
					invokeEffectsInDev(fiber.child, fiberFlags, invokeEffectFn)
				end
			end

			if bit32.band(fiber.flags, fiberFlags) ~= ReactFiberFlags.NoFlags then
				invokeEffectFn(fiber)
			end
			-- FIXME Luau: Luau doesn't understand the loop ~= nil construct
			fiber = fiber.sibling :: Fiber
		end
	end
end

-- deviation: FIXME restore type Set<string>?, has trouble with narrowing
local didWarnStateUpdateForNotYetMountedComponent: any = nil
mod.warnAboutUpdateOnNotYetMountedFiberInDEV = function(fiber)
	if __DEV__ then
		if bit32.band(executionContext, RenderContext) ~= NoContext then
			-- We local the other warning about render phase updates deal with this one.
			return
		end

		if bit32.band(fiber.mode, bit32.bor(ReactTypeOfMode.BlockingMode, ReactTypeOfMode.ConcurrentMode)) == 0 then
			return
		end

		local tag = fiber.tag
		if
			tag ~= ReactWorkTags.IndeterminateComponent
			and tag ~= ReactWorkTags.HostRoot
			and tag ~= ReactWorkTags.ClassComponent
			and tag ~= ReactWorkTags.FunctionComponent
			and tag ~= ReactWorkTags.ForwardRef
			and tag ~= ReactWorkTags.MemoComponent
			and tag ~= ReactWorkTags.SimpleMemoComponent
			and tag ~= ReactWorkTags.Block
		then
			-- Only warn for user-defined components, not internal ones like Suspense.
			return
		end

		-- We show the whole stack but dedupe on the top component's name because
		-- the problematic code almost always lies inside that component.
		local componentName = getComponentName(fiber.type) or "ReactComponent"
		if didWarnStateUpdateForNotYetMountedComponent ~= nil then
			if didWarnStateUpdateForNotYetMountedComponent[componentName] then
				return
			end
			didWarnStateUpdateForNotYetMountedComponent[componentName] = true
		else
			-- FIXME? not sure this translation is correct
			didWarnStateUpdateForNotYetMountedComponent = { [componentName] = true }
		end

		local previousFiber = ReactCurrentFiber.current
		local ok, result = pcall(function()
			setCurrentDebugFiberInDEV(fiber)
			console.error(
				"Can't perform a React state update on a component that hasn't mounted yet. "
					.. "This indicates that you have a side-effect in your render function that "
					.. "asynchronously later calls tries to update the component. Move this work to "
					.. "useEffect instead."
			)
		end)

		-- finally
		if previousFiber then
			setCurrentDebugFiberInDEV(fiber)
		else
			resetCurrentDebugFiberInDEV()
		end

		if not ok then
			error(result)
		end
	end
end

-- deviation: Declared on the mod table instead of as a local
if __DEV__ and ReactFeatureFlags.replayFailedUnitOfWorkWithInvokeGuardedCallback then
	local dummyFiber = nil
	mod.beginWork = function(current, unitOfWork, lanes)
		-- If a component throws an error, we replay it again in a synchronously
		-- dispatched event, so that the debugger will treat it as an uncaught
		-- error See ReactErrorUtils for more information.

		-- Before entering the begin phase, copy the work-in-progress onto a dummy
		-- fiber. If beginWork throws, we'll use this to reset the state.
		local originalWorkInProgressCopy = ReactFiber.assignFiberPropertiesInDEV(dummyFiber, unitOfWork)
		local ok, result = xpcall(originalBeginWork, describeError, current, unitOfWork, lanes)
		if not ok then
			local originalError = result

			if
				originalError ~= nil
				and typeof(originalError) == "table"
				and typeof(originalError.andThen) == "function"
			then
				-- Don't replay promises. Treat everything else like an error.
				error(originalError)
			end

			-- Keep this code in sync with handleError; any changes here must have
			-- corresponding changes there.
			resetContextDependencies()
			resetHooksAfterThrow()
			-- Don't reset current debug fiber, since we're about to work on the
			-- same fiber again.

			-- Unwind the failed stack frame
			unwindInterruptedWork(unitOfWork)

			-- Restore the original properties of the fiber.
			ReactFiber.assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy)

			if
				ReactFeatureFlags.enableProfilerTimer
				and bit32.band(unitOfWork.mode, ReactTypeOfMode.ProfileMode) ~= 0
			then
				-- Reset the profiler timer.
				ReactProfilerTimer.startProfilerTimer(unitOfWork)
			end

			-- Run beginWork again.
			invokeGuardedCallback(nil, originalBeginWork, nil, current, unitOfWork, lanes)

			if hasCaughtError() then
				local replayError = clearCaughtError()
				-- `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.
				-- Rethrow this error instead of the original one.
				error(replayError)
			else
				-- This branch is reachable if the render phase is impure.
				error(originalError)
			end
		end

		return result
	end
else
	mod.beginWork = originalBeginWork
end

local didWarnAboutUpdateInRender = false
local didWarnAboutUpdateInRenderForAnotherComponent
if __DEV__ then
	didWarnAboutUpdateInRenderForAnotherComponent = {}
end

mod.warnAboutRenderPhaseUpdatesInDEV = function(fiber: Fiber): ()
	if __DEV__ then
		if
			ReactCurrentFiber.isRendering
			and bit32.band(executionContext, RenderContext) ~= NoContext
			and not getIsUpdatingOpaqueValueInRenderPhaseInDEV()
		then
			if
				fiber.tag == ReactWorkTags.FunctionComponent
				or fiber.tag == ReactWorkTags.ForwardRef
				or fiber.tag == ReactWorkTags.SimpleMemoComponent
			then
				local renderingComponentName = (function()
					if workInProgress ~= nil then
						return getComponentName((workInProgress :: Fiber).type)
					end
					return "Unknown"
				end)()
				-- Dedupe by the rendering component because it's the one that needs to be fixed.
				local dedupeKey = renderingComponentName
				-- deviation:
				-- if !didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey))
				if didWarnAboutUpdateInRenderForAnotherComponent[dedupeKey] == nil then
					didWarnAboutUpdateInRenderForAnotherComponent[dedupeKey] = true
					local setStateComponentName = getComponentName(fiber.type) or "Unknown"
					console.error(
						"Cannot update a component (`%s`) while rendering a "
							.. "different component (`%s`). To locate the bad setState() call inside `%s`, "
							.. "follow the stack trace as described in https://reactjs.org/link/setstate-in-render",
						setStateComponentName,
						renderingComponentName,
						renderingComponentName
					)
				end
			elseif fiber.tag == ReactWorkTags.ClassComponent then
				if not didWarnAboutUpdateInRender then
					console.error(
						"Cannot update during an existing state transition (such as "
							.. "within `render`). Render methods should be a pure "
							.. "function of props and state."
					)
					didWarnAboutUpdateInRender = true
				end
			end
		end
	end
end

-- a 'shared' variable that changes when act() opens/closes in tests.
exports.IsThisRendererActing = { current = false }

exports.warnIfNotScopedWithMatchingAct = function(fiber: Fiber)
	if __DEV__ then
		if
			ReactFiberHostConfig.warnsIfNotActing == true
			and IsSomeRendererActing.current == true
			and exports.IsThisRendererActing.current ~= true
		then
			local previousFiber = ReactCurrentFiber.current
			local ok, result = pcall(function()
				setCurrentDebugFiberInDEV(fiber)
				-- deviation: error modified to suggest proper lua instead of JS

				-- FIXME (roblox): return to this when we have a better idea of what it
				-- looks like; in React, this string is broken up oddly to avoid
				-- confusing tools, but we don't have any reason to do that right now
				console.error(
					"It looks like you're using the wrong act() around your test interactions.\n"
						.. "Be sure to use the matching version of act() corresponding to your renderer:\n\n"
						.. "-- for react-roblox:\n"
						.. "local React = require(Packages.React)\n"
						.. "-- ...\n"
						.. "React.TestUtils.act(function() ... end)\n\n"
						.. "-- for react-test-renderer:\n"
						.. "local TestRenderer = require(Packages.ReactTestRenderer)\n"
						.. "-- ...\n"
						.. "TestRenderer.act(function() ... end)"
				)
			end)

			-- finally
			if previousFiber then
				setCurrentDebugFiberInDEV(fiber)
			else
				resetCurrentDebugFiberInDEV()
			end

			if not ok then
				error(result)
			end
		end
	end
end

exports.warnIfNotCurrentlyActingEffectsInDEV = function(fiber: Fiber): ()
	if __DEV__ then
		if
			ReactFiberHostConfig.warnsIfNotActing == true
			and bit32.band(fiber.mode, ReactTypeOfMode.StrictMode) ~= ReactTypeOfMode.NoMode
			and IsSomeRendererActing.current == false
			and exports.IsThisRendererActing.current == false
		then
			-- deviation: Use Lua syntax for example fix
			console.error(
				"An update to %s ran an effect, but was not wrapped in act(...).\n\n"
					.. "When testing, code that causes React state updates should be "
					.. "wrapped into act(...):\n\n"
					.. "act(function()\n"
					.. "  --[[ fire events that update state ]]\n"
					.. "end)\n"
					.. "--[[ assert on the output ]]\n\n"
					.. "This ensures that you're testing the behavior the user would see "
					.. "in the real client."
					.. " Learn more at https://reactjs.org/link/wrap-tests-with-act",
				getComponentName(fiber.type)
			)
		end
	end
end

exports.warnIfNotCurrentlyActingUpdatesInDEV = function(fiber: Fiber): ()
	if __DEV__ then
		if
			ReactFiberHostConfig.warnsIfNotActing == true
			and executionContext == NoContext
			and IsSomeRendererActing.current == false
			and exports.IsThisRendererActing.current == false
		then
			local previousFiber = ReactCurrentFiberCurrent
			local ok, result = pcall(function()
				setCurrentDebugFiberInDEV(fiber)
				-- deviation: Use Lua syntax for example fix
				console.error(
					"An update to %s inside a test was not wrapped in act(...).\n\n"
						.. "When testing, code that causes React state updates should be "
						.. "wrapped into act(...):\n\n"
						.. "act(function()\n"
						.. "  --[[ fire events that update state ]]\n"
						.. "end)\n"
						.. "--[[ assert on the output ]]\n\n"
						.. "This ensures that you're testing the behavior the user would see "
						.. "in the client application."
						.. " Learn more at https://reactjs.org/link/wrap-tests-with-act",
					getComponentName(fiber.type)
				)
			end)

			-- Finally
			if previousFiber then
				setCurrentDebugFiberInDEV(fiber)
			else
				resetCurrentDebugFiberInDEV()
			end

			if ok then
				return result
			end
		end
	end
	-- deviation: explicit return to silence analyze
	return
end

-- In tests, we want to enforce a mocked scheduler.
local didWarnAboutUnmockedScheduler = false
-- TODO Before we release concurrent mode, revisit this and decide whether a mocked
-- scheduler is the actual recommendation. The alternative could be a testing build,
-- a new lib, or whatever; we dunno just yet. This message is for early adopters
-- to get their tests right.

exports.warnIfUnmockedScheduler = function(fiber: Fiber)
	if __DEV__ then
		if didWarnAboutUnmockedScheduler == false and Scheduler.unstable_flushAllWithoutAsserting == nil then
			if
				bit32.band(fiber.mode, ReactTypeOfMode.BlockingMode) ~= 0
				or bit32.band(fiber.mode, ReactTypeOfMode.ConcurrentMode) ~= 0
			then
				didWarnAboutUnmockedScheduler = true
				-- deviation: error modified to suggest proper lua instead of JS

				-- FIXME (roblox): return to this when jest-roblox is in use; in React,
				-- this string is broken up oddly to avoid confusing tools, but we don't
				-- have any reason to do that right now
				console.error(
					"In Concurrent or Sync modes, the 'scheduler' module needs to be mocked "
						.. "to guarantee consistent behaviour across tests and client application. "
						.. "For example, with Jest: \n"
						-- Break up requires to avoid accidentally parsing them as dependencies.
						.. "jest.mock('scheduler', function() return require(Packages.Scheduler).unstable_mock end)\n\n"
						.. "For more info, visit https://reactjs.org/link/mock-scheduler"
				)
			elseif ReactFeatureFlags.warnAboutUnmockedScheduler == true then
				didWarnAboutUnmockedScheduler = true
				-- deviation: error modified to suggest proper lua instead of JS

				-- FIXME (roblox): return to this when jest-roblox is in use; in React,
				-- this string is broken up oddly to avoid confusing tools, but we don't
				-- have any reason to do that right now
				console.error(
					"Starting from React v18, the 'scheduler' module will need to be mocked "
						.. "to guarantee consistent behaviour across tests and client applications. "
						.. "For example, with Jest: \n"
						-- Break up requires to avoid accidentally parsing them as dependencies.
						.. "jest.mock('scheduler', function() return require(Packages.Scheduler).unstable_mock end)\n\n"
						.. "For more info, visit https://reactjs.org/link/mock-scheduler"
				)
			end
		end
	end
end

function computeThreadID(root: FiberRoot, lane: Lane | Lanes)
	-- Interaction threads are unique per root and expiration time.
	-- NOTE: Intentionally unsound cast. All that matters is that it's a number
	-- and it represents a batch of work. Could make a helper function instead,
	-- but meh this is fine for now.
	return lane * 1000 + root.interactionThreadID
end

exports.markSpawnedWork = function(lane: Lane | Lanes)
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end
	if spawnedWorkDuringRender == nil then
		spawnedWorkDuringRender = { lane }
	else
		-- FIXME Luau: depends on Luau type states
		table.insert(spawnedWorkDuringRender :: Array<number>, lane)
	end
end

function scheduleInteractions(root: FiberRoot, lane: Lane | Lanes, interactions: Set<Interaction>)
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	if interactions.size > 0 then
		local pendingInteractionMap = root.pendingInteractionMap
		local pendingInteractions = pendingInteractionMap:get(lane)
		if pendingInteractions ~= nil then
			interactions:forEach(function(interaction)
				if not pendingInteractions:has(interaction) then
					-- Update the pending async work count for previously unscheduled interaction.
					interaction.__count += 1
				end

				pendingInteractions:add(interaction)
			end)
		else
			pendingInteractionMap:set(lane, Set.new(interactions))

			-- Update the pending async work count for the current interactions.
			for _, interaction in interactions do
				interaction.__count += 1
			end
		end

		local subscriber = __subscriberRef.current
		if subscriber ~= nil then
			local threadID = computeThreadID(root, lane)
			subscriber.onWorkScheduled(interactions, threadID)
		end
	end
end

mod.schedulePendingInteractions = function(root: FiberRoot, lane: Lane | Lanes)
	-- This is called when work is scheduled on a root.
	-- It associates the current interactions with the newly-scheduled expiration.
	-- They will be restored when that expiration is later committed.
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	scheduleInteractions(root, lane, __interactionsRef.current)
end

mod.startWorkOnPendingInteractions = function(root: FiberRoot, lanes: Lanes)
	-- This is called when new work is started on a root.
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	-- Determine which interactions this batch of work currently includes, So that
	-- we can accurately attribute time spent working on it, And so that cascading
	-- work triggered during the render phase will be associated with it.
	local interactions: Set<Interaction> = Set.new()
	root.pendingInteractionMap:forEach(function(scheduledInteractions, scheduledLane)
		if includesSomeLane(lanes, scheduledLane) then
			scheduledInteractions:forEach(function(interaction)
				interactions:add(interaction)
			end)
		end
	end)

	-- Store the current set of interactions on the ReactInternalTypes.FiberRoot for a few reasons:
	-- We can re-use it in hot functions like performConcurrentWorkOnRoot()
	-- without having to recalculate it. We will also use it in commitWork() to
	-- pass to any Profiler onRender() hooks. This also provides DevTools with a
	-- way to access it when the onCommitRoot() hook is called.
	-- FIXME: manual type check to workaround Luau analyze bug "Type 'Set<Interaction>' could not be converted into 'Set<Interaction>'"
	root.memoizedInteractions = interactions :: any

	if interactions.size > 0 then
		local subscriber = __subscriberRef.current
		if subscriber ~= nil then
			local threadID = computeThreadID(root, lanes)
			local ok, error_ = xpcall(subscriber.onWorkStarted, describeError, interactions, threadID)
			if not ok then
				-- If the subscriber throws, rethrow it in a separate task
				scheduleCallback(ImmediateSchedulerPriority, function()
					error(error_)
				end)
			end
		end
	end
end

mod.finishPendingInteractions = function(root: FiberRoot, committedLanes)
	if not ReactFeatureFlags.enableSchedulerTracing then
		return
	end

	local remainingLanesAfterCommit = root.pendingLanes

	local subscriber

	-- try
	local ok = true
	local error_
	if subscriber ~= nil and root.memoizedInteractions.size > 0 then
		-- FIXME: More than one lane can finish in a single commit.
		-- performance: hoist non-throwable things out of the pcall() so we can remove an anon function
		local threadID = computeThreadID(root, committedLanes)
		subscriber = __subscriberRef.current
		-- deviation: helper for raw table set/map size > 0
		ok, error_ = xpcall(subscriber.onWorkStopped, describeError, root.memoizedInteractions, threadID)
	end

	-- finally
	-- Clear completed interactions from the pending Map.
	-- Unless the render was suspended or cascading work was scheduled,
	-- In which case– leave pending interactions until the subsequent render.
	local pendingInteractionMap = root.pendingInteractionMap
	pendingInteractionMap:forEach(function(scheduledInteractions, lane)
		-- Only decrement the pending interaction count if we're done.
		-- If there's still work at the current priority,
		-- That indicates that we are waiting for suspense data.
		if not includesSomeLane(remainingLanesAfterCommit, lane) then
			pendingInteractionMap:delete(lane)
			scheduledInteractions:forEach(function(interaction)
				interaction.__count -= 1

				if subscriber ~= nil and interaction.__count == 0 then
					local ok_, error__ =
						xpcall(subscriber.onInteractionScheduledWorkCompleted, describeError, interaction)
					if not ok_ then
						-- If the subscriber throws, rethrow it in a separate task
						scheduleCallback(ImmediateSchedulerPriority, function()
							error(error__)
						end)
					end
				end
			end)
		end
	end)

	-- catch
	if not ok then
		-- If the subscriber throws, rethrow it in a separate task
		scheduleCallback(ImmediateSchedulerPriority, function()
			error(error_)
		end)
	end
end

-- `act` testing API
--
-- TODO: This is mostly a copy-paste from the legacy `act`, which does not have
-- access to the same internals that we do here. Some trade offs in the
-- implementation no longer make sense.
local isFlushingAct = false
local isInsideThisAct = false

local flushMockScheduler = Scheduler.unstable_flushAllWithoutAsserting
local isSchedulerMocked = typeof(flushMockScheduler) == "function"

-- Returns whether additional work was scheduled. Caller should keep flushing
-- until there's no work left.
local function flushActWork(): boolean
	if flushMockScheduler ~= nil then
		local prevIsFlushing = isFlushingAct
		isFlushingAct = true
		local ok, result = xpcall(flushMockScheduler, describeError)

		-- finally
		isFlushingAct = prevIsFlushing

		if not ok then
			error(result)
		else
			return result
		end
	else
		-- No mock scheduler available. However, the only type of pending work is
		-- passive effects, which we control. So we can flush that.
		local prevIsFlushing = isFlushingAct
		isFlushingAct = true
		-- performance? rewrite this loop to eliminate anon function?
		local ok, result = xpcall(function()
			local didFlushWork = false
			while exports.flushPassiveEffects() do
				didFlushWork = true
			end
			return didFlushWork
		end, describeError)

		-- finally
		isFlushingAct = prevIsFlushing

		if not ok then
			error(result)
		else
			return result
		end
	end
end

local function flushWorkAndMicroTasks(onDone: (any?) -> ())
	-- performance: split into two pcall to eliminate anonymous func allocation per call
	local ok, result = xpcall(flushActWork, describeError)
	if ok then
		ok, result = xpcall(enqueueTask, describeError, function()
			if flushActWork() then
				flushWorkAndMicroTasks(onDone)
			else
				onDone()
			end
		end)
	end

	if not ok then
		onDone(result)
	end
end

exports.act = function(callback: () -> Thenable<any>): Thenable<any>
	-- It's only viable to export `act` when we're using mocked scheduling logic.
	-- Since there are numerous testing scenarios in which we call `require` on
	-- the Roact library _before_ we bootstrap tests, we expose a global to toggle
	-- this explicilty
	if not (__DEV__ or _G.__ROACT_17_MOCK_SCHEDULER__) then
		if didWarnAboutUsingActInProd == false then
			didWarnAboutUsingActInProd = true
			-- eslint-disable-next-line react-internal/no-production-logging
			console.error("act(...) is not supported in production builds of React, and might not behave as expected.")
		end
	end

	local previousActingUpdatesScopeDepth = actingUpdatesScopeDepth
	actingUpdatesScopeDepth += 1

	local previousIsSomeRendererActing = IsSomeRendererActing.current
	local previousIsThisRendererActing = exports.IsThisRendererActing.current
	local previousIsInsideThisAct = isInsideThisAct
	IsSomeRendererActing.current = true
	exports.IsThisRendererActing.current = true
	isInsideThisAct = true

	local function onDone()
		actingUpdatesScopeDepth -= 1
		IsSomeRendererActing.current = previousIsSomeRendererActing
		exports.IsThisRendererActing.current = previousIsThisRendererActing
		isInsideThisAct = previousIsInsideThisAct
		if __DEV__ then
			if actingUpdatesScopeDepth > previousActingUpdatesScopeDepth then
				-- if it's _less than_ previousActingUpdatesScopeDepth, then we can assume the 'other' one has warned
				console.error(
					"You seem to have overlapping act() calls, this is not supported. "
						.. "Be sure to await previous act() calls before making a new one. "
				)
			end
		end
	end

	local ok, result = xpcall(exports.batchedUpdates, describeError, callback)
	if not ok then
		onDone()
		error(result)
	end

	if result ~= nil and typeof(result) == "table" and typeof(result.andThen) == "function" then
		-- setup a boolean that gets set to true only
		-- once this act() call is await-ed
		local called = false
		if __DEV__ then
			if typeof(Promise) ~= nil then
				--eslint-disable-next-line no-undef
				Promise.resolve():andThen(function() end):andThen(function()
					if called == false then
						-- FIXME (roblox): We should replace this with proper Lua promise
						-- logic
						console.error(
							"You called act(Promise.new(function() --[[ ... ]] end)) without :await() or :expect(). "
								.. "This could lead to unexpected testing behaviour, interleaving multiple act "
								.. "calls and mixing their scopes. You should - act(function() Promise.new(function() --[[ ... ]] end):await() end);"
						)
					end
				end)
			end
		end

		-- in the async case, the returned thenable runs the callback, flushes
		-- effects and microtasks in a loop until flushPassiveEffects() == false,
		-- and cleans up
		return {
			-- FIXME Luau: have to explicitly annotate the unused generic arg: CLI-49996
			andThen = function<U>(self, resolve, reject)
				called = true
				return result:andThen(function()
					if
						actingUpdatesScopeDepth > 1
						or (isSchedulerMocked == true and previousIsSomeRendererActing == true)
					then
						onDone()
						resolve()
						return
					end
					-- we're about to exit the act() scope,
					-- now's the time to flush tasks/effects
					flushWorkAndMicroTasks(function(err: any?)
						onDone()
						if err then
							reject(err)
						else
							resolve()
						end
					end)
				end, function(err)
					onDone()
					reject(err)
				end)
			end,
		}
	else
		if __DEV__ then
			if result ~= nil then
				-- deviation: use Lua syntax
				console.error(
					"The callback passed to act(...) function " .. "must return nil, or a Promise. You returned %s",
					tostring(result)
				)
			end
		end

		-- flush effects until none remain, and cleanup
		local flushOk, flushResult = xpcall(function()
			if
				actingUpdatesScopeDepth == 1
				and (isSchedulerMocked == false or previousIsSomeRendererActing == false)
			then
				-- we're about to exit the act() scope,
				-- now's the time to flush effects
				flushActWork()
			end
			onDone()
		end, describeError)

		if not flushOk then
			onDone()
			error(flushResult)
		end

		-- in the sync case, the returned thenable only warns *if* await-ed
		return {
			-- FIXME Luau: have to explicitly annotate the unused generic arg: CLI-49996
			andThen = function<U>(self, resolve, reject_)
				if __DEV__ then
					console.error("Do not await the result of calling act(...) with sync logic, it is not a Promise.")
				end
				resolve()
			end,
		}
	end
end

mod.detachFiberAfterEffects = function(fiber: Fiber)
	-- Null out fields to improve GC for references that may be lingering (e.g. DevTools).
	-- Note that we already cleared the return pointer in detachFiberMutation().
	fiber.child = nil
	fiber.deletions = nil
	fiber.dependencies = nil
	fiber.memoizedProps = nil
	fiber.memoizedState = nil
	fiber.pendingProps = nil
	fiber.sibling = nil
	fiber.stateNode = nil
	fiber.updateQueue = nil

	if __DEV__ then
		fiber._debugOwner = nil
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006123</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1B31BADE91A34CA4B95FC30989753B2D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactHookEffectTags</string>
								<string name="ScriptGuid">{5A628998-57B1-4534-B965-6F3EF9198C33}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactHookEffectTags.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

export type HookFlags = number

return {
	--[[  ]]
	NoFlags = 0b000,

	-- Represents whether effect should fire.
	--[[ ]]
	HasEffect = 0b001,

	-- Represents the phase in which the effect (not the clean-up) fires.
	--[[    ]]
	Layout = 0b010,
	--[[   ]]
	Passive = 0b100,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006124</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4CE8B2EA64A54E6E901DC7F656922586">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactInternalTypes</string>
								<string name="ScriptGuid">{CAA08007-C486-43F5-BDBD-A8749158E0D6}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/7baf9d4128d41903de125527b50285ea9862cf9a/packages/react-reconciler/src/ReactInternalTypes.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Map<K, V> = LuauPolyfill.Map<K, V>
type Object = { [string]: any }
type SimpleSet<T> = { [T]: boolean }
type SimpleMap<K, V> = { [K]: V }
type Set<T> = LuauPolyfill.Set<T>

local ReactTypes = require(Packages.Shared)
-- deviation: ReactElement is defined at the top level of Shared along
-- with the rest of the ReactTypes
type Source = ReactTypes.Source
type RefObject = ReactTypes.RefObject
type ReactContext<T> = ReactTypes.ReactContext<T>
type MutableSourceVersion = ReactTypes.MutableSourceVersion
type MutableSource<Source> = ReactTypes.MutableSource<Source>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<Source, Snapshot>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>

-- deviation START: These are 'mixed' by default, and specialized by the renderer, need complicated dynamic resolution to do this properly
-- local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
-- type SuspenseInstance = ReactFiberHostConfig.SuspenseInstance
type SuspenseInstance = any
-- deviation END
local ReactWorkTags = require(script.Parent.ReactWorkTags)
type WorkTag = ReactWorkTags.WorkTag
local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
type TypeOfMode = ReactTypeOfMode.TypeOfMode
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
type Flags = ReactFiberFlags.Flags
-- deviation: FiberLane types are defined and exported from here to avoid
-- cyclical requires
export type LanePriority = number
export type Lanes = number
export type Lane = number
export type LaneMap<T> = { [number]: T }

-- deviation: Update<>, SharedQueue<>, UpdateQueue<> transplanted from ReactUpdateQueue for use by createReactNoop
export type Update<State> = {
	-- TODO: Temporary field. Will remove this by storing a map of
	-- transition -> event time on the root.
	eventTime: number,
	lane: Lane,

	-- FIXME Luau: revert when luau supports singleton integers
	-- tag: 0 | 1 | 2 | 3,
	tag: number,
	payload: any,
	callback: (() -> ...any)?,

	next: Update<State>?,
}

export type SharedQueue<State> = {
	pending: Update<State>?,
}

export type UpdateQueue<State> = {
	baseState: State,
	firstBaseUpdate: Update<State>?,
	lastBaseUpdate: Update<State>?,
	shared: SharedQueue<State>,
	effects: Array<Update<State>>?,
}

export type HookType =
	"useState"
	| "useReducer"
	| "useContext"
	| "useRef"
	-- deviation: Bindings are a feature unique to Roact
	| "useBinding"
	| "useEffect"
	| "useLayoutEffect"
	| "useCallback"
	| "useMemo"
	| "useImperativeHandle"
	| "useDebugValue"
	| "useDeferredValue"
	| "useTransition"
	| "useMutableSource"
	| "useOpaqueIdentifier"
local ReactRootTags = require(script.Parent.ReactRootTags)
type RootTag = ReactRootTags.RootTag
-- deviation: we can't import types for dynamic imports like HostConfig files
-- type TimeoutHandle = ReactFiberHostConfig.TimeoutHandle;
-- type NoTimeout = ReactFiberHostConfig.NoTimeout;
type TimeoutHandle = any
type NoTimeout = any
-- deviation: type forwarded to top-level export
local Shared = require(Packages.Shared)
type Wakeable = Shared.Wakeable
-- deviation: Interaction type forwarded to top-level export
local Scheduler = require(Packages.Scheduler)
type Interaction = Scheduler.Interaction

-- deviation: Luau doesn't support type literals:  99 | 98 | 97 | 96 | 95 | 90
export type ReactPriorityLevel = number

export type ContextDependency<T> = {
	context: ReactContext<T>,
	observedBits: number,
	-- TODO: upstream only parameterizes this type with `mixed`, so avoid Luau recursive type constraint. upstream this change later.
	next: ContextDependency<T> | nil,
	-- deviation START: don't allow for extension unless we have to
	-- ...
	-- deviation END
}

export type Dependencies = {
	lanes: Lanes,
	firstContext: ContextDependency<any> | nil,
	-- deviation START: don't allow for extension unless we have to
	-- ...
	-- deviation END
}

-- deviation: Roact stable keys - slightly widen the type definition of a
-- stable key so that it's likely to work with existing Roact code. Includes
-- numbers for mixed/sparse tables
export type RoactStableKey = string | number

-- A Fiber is work on a Component that needs to be done or was done. There can
-- be more than one per component.
export type Fiber = {
	-- These first fields are conceptually members of an Instance. This used to
	-- be split into a separate type and intersected with the other Fiber fields,
	-- but until Flow fixes its intersection bugs, we've merged them into a
	-- single type.

	-- An Instance is shared between all versions of a component. We can easily
	-- break this out into a separate object to avoid copying so much to the
	-- alternate versions of the tree. We put this on a single object for now to
	-- minimize the number of objects created during the initial render.

	-- Tag identifying the type of fiber.
	tag: WorkTag,

	-- deviation: Use a slightly more permissive key type to allow for
	-- sparse arrays, which will still be distinct from actual arrays.
	-- Unique identifier of this child.
	key: RoactStableKey?,

	-- The value of element.type which is used to preserve the identity during
	-- reconciliation of this child.
	elementType: any,

	-- The resolved function/class/ associated with this fiber.
	type: any,

	-- The local state associated with this fiber.
	stateNode: any,

	-- Conceptual aliases
	-- parent : Instance -> return The parent happens to be the same as the
	-- return fiber since we've merged the fiber and instance.

	-- Remaining fields belong to Fiber

	-- The Fiber to return to after finishing processing this one.
	-- This is effectively the parent, but there can be multiple parents (two)
	-- so this is only the parent of the thing we're currently processing.
	-- It is conceptually the same as the return address of a stack frame.
	return_: Fiber | nil,

	-- Singly Linked List Tree Structure.
	child: Fiber?,
	sibling: Fiber?,
	index: number,

	-- The ref last used to attach this node.
	-- I'll avoid adding an owner field for prod and model that as functions.
	-- deviation: Lua doesn't allow fields on functions
	-- ref: (((any) -> ()) & {_stringRef: string?, [string]: any}) | RefObject,
	ref: nil | ((handle: any) -> ()) | { _stringRef: string?, [string]: any } | RefObject,

	-- Input is the data coming into process this fiber. Arguments. Props.
	pendingProps: any, -- This type will be more specific once we overload the tag.
	memoizedProps: any, -- The props used to create the output.

	-- A queue of state updates and callbacks.
	updateQueue: any,

	-- The state used to create the output
	memoizedState: any,

	-- Dependencies (contexts, events) for this fiber, if it has any
	dependencies: Dependencies?,

	-- Bitfield that describes properties about the fiber and its subtree. E.g.
	-- the ConcurrentMode flag indicates whether the subtree should be async-by-
	-- default. When a fiber is created, it inherits the mode of its
	-- parent. Additional flags can be set at creation time, but after that the
	-- value should remain unchanged throughout the fiber's lifetime, particularly
	-- before its child fibers are created.
	mode: TypeOfMode,

	-- Effect
	flags: Flags,
	subtreeFlags: Flags,
	deletions: Array<Fiber>?,

	-- Singly linked list fast path to the next fiber with side-effects.
	nextEffect: Fiber?,

	-- The first and last fiber with side-effect within this subtree. This allows
	-- us to reuse a slice of the linked list when we reuse the work done within
	-- this fiber.
	firstEffect: Fiber?,
	lastEffect: Fiber?,

	lanes: Lanes,
	childLanes: Lanes,

	-- This is a pooled version of a Fiber. Every fiber that gets updated will
	-- eventually have a pair. There are cases when we can clean up pairs to save
	-- memory if we need to.
	alternate: Fiber?,

	-- Time spent rendering this Fiber and its descendants for the current update.
	-- This tells us how well the tree makes use of sCU for memoization.
	-- It is reset to 0 each time we render and only updated when we don't bailout.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	actualDuration: number?,

	-- If the Fiber is currently active in the "render" phase,
	-- This marks the time at which the work began.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	actualStartTime: number?,

	-- Duration of the most recent render time for this Fiber.
	-- This value is not updated when we bailout for memoization purposes.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	selfBaseDuration: number?,

	-- Sum of base times for all descendants of this Fiber.
	-- This value bubbles up during the "complete" phase.
	-- This field is only set when the enableProfilerTimer flag is enabled.
	treeBaseDuration: number?,

	-- Conceptual aliases
	-- workInProgress : Fiber ->  alternate The alternate used for reuse happens
	-- to be the same as work in progress.
	-- _G.__DEV__ only
	_debugID: number?,
	_debugSource: Source?,
	_debugOwner: Fiber?,
	_debugIsCurrentlyTiming: boolean?,
	_debugNeedsRemount: boolean?,

	-- Used to verify that the order of hooks does not change between renders.
	_debugHookTypes: Array<HookType>?,
}

export type SuspenseHydrationCallbacks = {
	onHydrated: ((SuspenseInstance) -> ())?,
	onDeleted: ((SuspenseInstance) -> ())?,
	-- deviation START: don't allow for extension unless we have to
	-- ...
	-- deviation END
}

-- deviation: Instead of combining all these props after the fact, we define
-- them all in one to allow Luau's syntax

-- Exported FiberRoot type includes all properties,
-- To avoid requiring potentially error-prone :any casts throughout the project.
-- Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
-- The types are defined separately within this file to ensure they stay in sync.
-- (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
export type FiberRoot = {
	-- ...BaseFiberRootProperties,
	-- The type of root (legacy, batched, concurrent, etc.)
	tag: RootTag,

	-- Any additional information from the host associated with this root.
	containerInfo: any,
	-- Used only by persistent updates.
	pendingChildren: any,
	-- The currently active root fiber. This is the mutable root of the tree.
	current: Fiber,

	-- deviation START: we use a lightweight unordered set for performance
	pingCache: SimpleMap<Wakeable, (SimpleSet<any> | SimpleMap<Wakeable, SimpleSet<any>>)> | nil,
	-- deviation END

	-- A finished work-in-progress HostRoot that's ready to be committed.
	finishedWork: Fiber?,
	-- Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
	-- it's superseded by a new one.
	timeoutHandle: TimeoutHandle | NoTimeout,
	-- Top context object, used by renderSubtreeIntoContainer
	context: Object?,
	pendingContext: Object?,
	-- Determines if we should attempt to hydrate on the initial mount
	hydrate: boolean,

	-- Used by useMutableSource hook to avoid tearing during hydration.
	mutableSourceEagerHydrationData: Array<MutableSource<any> | MutableSourceVersion>?,

	-- Node returned by Scheduler.scheduleCallback. Represents the next rendering
	-- task that the root will work on.
	callbackNode: any,
	callbackPriority: LanePriority,
	eventTimes: LaneMap<number>,
	expirationTimes: LaneMap<number>,

	pendingLanes: Lanes,
	suspendedLanes: Lanes,
	pingedLanes: Lanes,
	expiredLanes: Lanes,
	mutableReadLanes: Lanes,

	finishedLanes: Lanes,

	entangledLanes: Lanes,
	entanglements: LaneMap<Lanes>,

	-- ...ProfilingOnlyFiberRootProperties,
	-- The following attributes are only used by interaction tracing builds.
	-- They enable interactions to be associated with their async work,
	-- And expose interaction metadata to the React DevTools Profiler plugin.
	-- Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
	interactionThreadID: number,
	memoizedInteractions: Set<Interaction>,
	pendingInteractionMap: Map<Lane | Lanes, Set<Interaction>>,

	-- ...SuspenseCallbackOnlyFiberRootProperties,
	-- The follow fields are only used by enableSuspenseCallback for hydration.
	hydrationCallbacks: SuspenseHydrationCallbacks?,

	-- deviation START: don't allow for extension unless we have to
	-- ...
	-- deviation END
}

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

-- deviation: Dispatcher is defined in Shared to avoid circular deps
export type Dispatcher = Shared.Dispatcher

-- deviation: Return something so that the module system is happy
return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006125</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX654DB3697D314EAC9D3937C5E1346384">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactMutableSource.new</string>
								<string name="ScriptGuid">{D4C60818-52F0-473E-88AE-C62DC3D5F74C}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react-reconciler/src/ReactMutableSource.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

type Array<T> = { [number]: T }
local exports = {}

local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceVersion = ReactTypes.MutableSourceVersion

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type FiberRoot = ReactInternalTypes.FiberRoot

local isPrimaryRenderer = require(script.Parent.ReactFiberHostConfig).isPrimaryRenderer

-- Work in progress version_ numbers only apply to a single render,
-- and should be reset before starting a new render.
-- This tracks which mutable sources need to be reset after a render.
local workInProgressSources: Array<MutableSource<any>> = {}

local rendererSigil
if _G.__DEV__ then
	-- Used to detect multiple renderers using the same mutable source.
	rendererSigil = {}
end

exports.markSourceAsDirty = function(mutableSource: MutableSource<any>)
	table.insert(workInProgressSources, mutableSource)
end

exports.resetWorkInProgressVersions = function()
	for i, mutableSource in workInProgressSources do
		if isPrimaryRenderer then
			mutableSource._workInProgressVersionPrimary = nil
		else
			mutableSource._workInProgressVersionSecondary = nil
		end
	end
	table.clear(workInProgressSources)
end

exports.getWorkInProgressVersion = function(mutableSource: MutableSource<any>): nil | MutableSourceVersion
	if isPrimaryRenderer then
		return mutableSource._workInProgressVersionPrimary
	else
		return mutableSource._workInProgressVersionSecondary
	end
end

exports.setWorkInProgressVersion = function(mutableSource: MutableSource<any>, version_: MutableSourceVersion)
	if isPrimaryRenderer then
		mutableSource._workInProgressVersionPrimary = version_
	else
		mutableSource._workInProgressVersionSecondary = version_
	end
	table.insert(workInProgressSources, mutableSource)
end

exports.warnAboutMultipleRenderersDEV = function(mutableSource: MutableSource<any>)
	if _G.__DEV__ then
		if isPrimaryRenderer then
			if mutableSource._currentPrimaryRenderer == nil then
				mutableSource._currentPrimaryRenderer = rendererSigil
			elseif mutableSource._currentPrimaryRenderer ~= rendererSigil then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same mutable source. This is currently unsupported."
				)
			end
		else
			if mutableSource._currentSecondaryRenderer == nil then
				mutableSource._currentSecondaryRenderer = rendererSigil
			elseif mutableSource._currentSecondaryRenderer ~= rendererSigil then
				console.error(
					"Detected multiple renderers concurrently rendering the "
						.. "same mutable source. This is currently unsupported."
				)
			end
		end
	end
end

-- Eager reads the version of a mutable source and stores it on the root.
-- This ensures that the version used for server rendering matches the one
-- that is eventually read during hydration.
-- If they don't match there's a potential tear and a full deopt render is required.
exports.registerMutableSourceForHydration = function(root: FiberRoot, mutableSource: MutableSource<any>)
	local getVersion = mutableSource._getVersion
	local version_ = getVersion(mutableSource._source)

	-- TODO Clear this data once all pending hydration work is finished.
	-- Retaining it forever may interfere with GC.
	if root.mutableSourceEagerHydrationData == nil then
		root.mutableSourceEagerHydrationData = { mutableSource, version_ }
	else
		-- FIXME: having trouble with type coercion in this case
		-- table.insert(root.mutableSourceEagerHydrationData, mutableSource)
		-- table.insert(root.mutableSourceEagerHydrationData, version_)
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006126</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBFB804AE7FAC45EEBFA7562771AAD142">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactPortal</string>
								<string name="ScriptGuid">{7A1F40ED-B800-4C56-BD94-4E1315B4C3BE}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react-reconciler/src/ReactPortal.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent

local REACT_PORTAL_TYPE = require(Packages.Shared).ReactSymbols.REACT_PORTAL_TYPE

local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
type ReactPortal = ReactTypes.ReactPortal

local function createPortal(
	children: ReactNodeList,
	containerInfo: any,
	-- TODO: figure out the API for cross-renderer implementation.
	implementation: any,
	key: string?
): ReactPortal
	if key ~= nil then
		key = tostring(key)
	end
	return {
		-- This tag allow us to uniquely identify this as a React Portal
		["$$typeof"] = REACT_PORTAL_TYPE,
		key = key,
		children = children,
		containerInfo = containerInfo,
		implementation = implementation,
	}
end

return {
	createPortal = createPortal,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006127</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX505CFCEA48424E04BBF8456C6F180775">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactProfilerTimer.new</string>
								<string name="ScriptGuid">{E98B3303-76E4-4CE5-A6D4-397BB950756C}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react-reconciler/src/ReactProfilerTimer.new.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local Packages = script.Parent.Parent

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableProfilerTimer = ReactFeatureFlags.enableProfilerTimer
local enableProfilerCommitHooks = ReactFeatureFlags.enableProfilerCommitHooks

local ReactWorkTags = require(script.Parent.ReactWorkTags)
local Profiler = ReactWorkTags.Profiler

-- Intentionally not named imports because Rollup would use dynamic dispatch for
-- CommonJS interop named imports.
local Scheduler = require(Packages.Scheduler)

local now = Scheduler.unstable_now

export type ProfilerTimer = {
	getCommitTime: () -> number,
	recordCommitTime: () -> (),
	startProfilerTimer: (Fiber) -> (),
	stopProfilerTimerIfRunning: (Fiber) -> (),
	stopProfilerTimerIfRunningAndRecordDelta: (Fiber) -> (),
	-- ...
}

local commitTime: number = 0
local layoutEffectStartTime: number = -1
local profilerStartTime: number = -1
local passiveEffectStartTime: number = -1

function getCommitTime(): number
	return commitTime
end

function recordCommitTime(): ()
	if not enableProfilerTimer then
		return
	end
	commitTime = now()
end

function startProfilerTimer(fiber: Fiber): ()
	if not enableProfilerTimer then
		return
	end

	profilerStartTime = now()

	-- deviation: JS can compare null/undefined to 0, but Lua can't
	if fiber.actualStartTime ~= nil and (fiber.actualStartTime :: number) < 0 then
		fiber.actualStartTime = now()
	end
end

function stopProfilerTimerIfRunning(fiber: Fiber): ()
	if not enableProfilerTimer then
		return
	end
	profilerStartTime = -1
end

function stopProfilerTimerIfRunningAndRecordDelta(fiber: Fiber, overrideBaseTime: boolean): ()
	if not enableProfilerTimer then
		return
	end

	if profilerStartTime >= 0 then
		local elapsedTime_ = now() - profilerStartTime
		fiber.actualDuration += elapsedTime_
		if overrideBaseTime then
			fiber.selfBaseDuration = elapsedTime_
		end
		profilerStartTime = -1
	end
end

function recordLayoutEffectDuration(fiber: Fiber): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end

	if layoutEffectStartTime >= 0 then
		local elapsedTime_ = now() - layoutEffectStartTime

		layoutEffectStartTime = -1

		-- Store duration on the next nearest Profiler ancestor.
		local parentFiber = fiber.return_
		while parentFiber ~= nil do
			if parentFiber.tag == Profiler then
				local parentStateNode = parentFiber.stateNode
				parentStateNode.effectDuration += elapsedTime_
				break
			end
			parentFiber = parentFiber.return_
		end
	end
end

function recordPassiveEffectDuration(fiber: Fiber): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end

	if passiveEffectStartTime >= 0 then
		local elapsedTime_ = now() - passiveEffectStartTime

		passiveEffectStartTime = -1

		-- Store duration on the next nearest Profiler ancestor.
		local parentFiber = fiber.return_
		while parentFiber ~= nil do
			if parentFiber.tag == Profiler then
				local parentStateNode = parentFiber.stateNode
				if parentStateNode ~= nil then
					-- Detached fibers have their state node cleared out.
					-- In this case, the return pointer is also cleared out,
					-- so we won't be able to report the time spent in this Profiler's subtree.
					parentStateNode.passiveEffectDuration += elapsedTime_
				end
				break
			end
			parentFiber = parentFiber.return_
		end
	end
end

function startLayoutEffectTimer(): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end
	layoutEffectStartTime = now()
end

function startPassiveEffectTimer(): ()
	if not enableProfilerTimer or not enableProfilerCommitHooks then
		return
	end
	passiveEffectStartTime = now()
end

function transferActualDuration(fiber: Fiber): ()
	-- Transfer time spent rendering these children so we don't lose it
	-- after we rerender. This is used as a helper in special cases
	-- where we should count the work of multiple passes.
	local child = fiber.child
	while child do
		fiber.actualDuration += child.actualDuration
		child = child.sibling
	end
end

return {
	getCommitTime = getCommitTime,
	recordCommitTime = recordCommitTime,
	recordLayoutEffectDuration = recordLayoutEffectDuration,
	recordPassiveEffectDuration = recordPassiveEffectDuration,
	startLayoutEffectTimer = startLayoutEffectTimer,
	startPassiveEffectTimer = startPassiveEffectTimer,
	startProfilerTimer = startProfilerTimer,
	stopProfilerTimerIfRunning = stopProfilerTimerIfRunning,
	stopProfilerTimerIfRunningAndRecordDelta = stopProfilerTimerIfRunningAndRecordDelta,
	transferActualDuration = transferActualDuration,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006128</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAC4E72FC5E62455088780721F9B7F187">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactRootTags</string>
								<string name="ScriptGuid">{9F424580-C010-4EE1-9C20-187380AC5B70}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactRootTags.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

export type RootTag = number

return {
	LegacyRoot = 0,
	BlockingRoot = 1,
	ConcurrentRoot = 2,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006129</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX56A0DCB56D33464E963F9A7DC0331B72">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactStrictModeWarnings.new</string>
								<string name="ScriptGuid">{582D1767-99BB-4982-A889-6AE842E21ED5}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react-reconciler/src/ReactStrictModeWarnings.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
local ReactCurrentFiber = require(script.Parent.ReactCurrentFiber)
local resetCurrentDebugFiberInDEV = ReactCurrentFiber.resetCurrentFiber
local setCurrentDebugFiberInDEV = ReactCurrentFiber.setCurrentFiber
local getComponentName = require(Packages.Shared).getComponentName
local StrictMode = require(script.Parent.ReactTypeOfMode).StrictMode

type Set<T> = { [T]: boolean }
type Array<T> = { [number]: T }
type Map<K, V> = { [K]: V }
type FiberArray = Array<Fiber>
type FiberToFiberComponentsMap = Map<Fiber, FiberArray>

local ReactStrictModeWarnings = {
	recordUnsafeLifecycleWarnings = function(fiber: Fiber, instance: any) end,
	flushPendingUnsafeLifecycleWarnings = function() end,
	recordLegacyContextWarning = function(fiber: Fiber, instance: any) end,
	flushLegacyContextWarning = function() end,
	discardPendingWarnings = function() end,
}

if _G.__DEV__ then
	local findStrictRoot = function(fiber: Fiber): Fiber | nil
		local maybeStrictRoot = nil

		-- FIXME Luau: Luau needs to understand while not nil loops
		local node: Fiber? = fiber
		while node ~= nil do
			if bit32.band(node.mode, StrictMode) ~= 0 then
				maybeStrictRoot = node
			end
			node = node.return_
		end

		return maybeStrictRoot
	end

	local setToSortedString = function(set): string
		local array = {}
		for key, value in set do
			table.insert(array, key)
		end
		table.sort(array)
		return table.concat(array, ", ")
	end

	local pendingComponentWillMountWarnings: Array<Fiber> = {}
	local pendingUNSAFE_ComponentWillMountWarnings: Array<Fiber> = {}
	local pendingComponentWillReceivePropsWarnings: Array<Fiber> = {}
	local pendingUNSAFE_ComponentWillReceivePropsWarnings: Array<Fiber> = {}
	local pendingComponentWillUpdateWarnings: Array<Fiber> = {}
	local pendingUNSAFE_ComponentWillUpdateWarnings: Array<Fiber> = {}

	-- Tracks components we have already warned about.
	local didWarnAboutUnsafeLifecycles = {}

	ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber: Fiber, instance: any)
		-- Dedupe strategy: Warn once per component.
		if didWarnAboutUnsafeLifecycles[fiber.type] then
			return
		end

		if
			typeof(instance.componentWillMount) == "function"
			-- Don't warn about react-lifecycles-compat polyfilled components.
			-- deviation: Lua doesn't allow fields on function
			-- instance.componentWillMount.__suppressDeprecationWarning ~= true
		then
			table.insert(pendingComponentWillMountWarnings, fiber)
		end

		if bit32.band(fiber.mode, StrictMode) ~= 0 and typeof(instance.UNSAFE_componentWillMount) == "function" then
			table.insert(pendingUNSAFE_ComponentWillMountWarnings, fiber)
		end

		if
			typeof(instance.componentWillReceiveProps) == "function"
			-- deviation: Lua doesn't allow fields on function
			-- instance.componentWillReceiveProps.__suppressDeprecationWarning ~= true
		then
			table.insert(pendingComponentWillReceivePropsWarnings, fiber)
		end

		if
			bit32.band(fiber.mode, StrictMode) ~= 0
			and typeof(instance.UNSAFE_componentWillReceiveProps) == "function"
		then
			table.insert(pendingUNSAFE_ComponentWillReceivePropsWarnings, fiber)
		end

		if
			typeof(instance.componentWillUpdate) == "function"
			-- deviation: Lua doesn't allow fields on function
			-- instance.componentWillUpdate.__suppressDeprecationWarning ~= true
		then
			table.insert(pendingComponentWillUpdateWarnings, fiber)
		end

		if bit32.band(fiber.mode, StrictMode) ~= 0 and typeof(instance.UNSAFE_componentWillUpdate) == "function" then
			table.insert(pendingUNSAFE_ComponentWillUpdateWarnings, fiber)
		end
	end

	ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function()
		-- We do an initial pass to gather component names
		local componentWillMountUniqueNames = {}
		if #pendingComponentWillMountWarnings > 0 then
			for i, fiber in pendingComponentWillMountWarnings do
				componentWillMountUniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end
			table.clear(pendingComponentWillMountWarnings)
		end

		local UNSAFE_componentWillMountUniqueNames = {}
		if #pendingUNSAFE_ComponentWillMountWarnings > 0 then
			for i, fiber in pendingUNSAFE_ComponentWillMountWarnings do
				UNSAFE_componentWillMountUniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end
			table.clear(pendingUNSAFE_ComponentWillMountWarnings)
		end

		local componentWillReceivePropsUniqueNames = {}
		if #pendingComponentWillReceivePropsWarnings > 0 then
			for i, fiber in pendingComponentWillReceivePropsWarnings do
				componentWillReceivePropsUniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingComponentWillReceivePropsWarnings)
		end

		local UNSAFE_componentWillReceivePropsUniqueNames = {}
		if #pendingUNSAFE_ComponentWillReceivePropsWarnings > 0 then
			for i, fiber in pendingUNSAFE_ComponentWillReceivePropsWarnings do
				UNSAFE_componentWillReceivePropsUniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingUNSAFE_ComponentWillReceivePropsWarnings)
		end

		local componentWillUpdateUniqueNames = {}
		if #pendingComponentWillUpdateWarnings > 0 then
			for i, fiber in pendingComponentWillUpdateWarnings do
				componentWillUpdateUniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingComponentWillUpdateWarnings)
		end

		local UNSAFE_componentWillUpdateUniqueNames = {}
		if #pendingUNSAFE_ComponentWillUpdateWarnings > 0 then
			for i, fiber in pendingUNSAFE_ComponentWillUpdateWarnings do
				UNSAFE_componentWillUpdateUniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutUnsafeLifecycles[fiber.type] = true
			end

			table.clear(pendingUNSAFE_ComponentWillUpdateWarnings)
		end

		-- Finally, we flush all the warnings
		-- UNSAFE_ ones before the deprecated ones, since they'll be 'louder'
		-- deviation: use `next` to determine whether set is empty
		if next(UNSAFE_componentWillMountUniqueNames) ~= nil then
			local sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames)
			console.error(
				"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(UNSAFE_componentWillReceivePropsUniqueNames) ~= nil then
			local sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames)
			console.error(
				"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended "
					.. "and may indicate bugs in your code. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "* If you're updating state whenever props change, "
					.. "refactor your code to use memoization techniques or move it to "
					.. "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(UNSAFE_componentWillUpdateUniqueNames) ~= nil then
			local sortedNames = setToSortedString(UNSAFE_componentWillUpdateUniqueNames)
			console.error(
				"Using UNSAFE_componentWillUpdate in strict mode is not recommended "
					.. "and may indicate bugs in your code. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(componentWillMountUniqueNames) ~= nil then
			local sortedNames = setToSortedString(componentWillMountUniqueNames)

			-- TODO: Make decisions about whether or not we'll support these
			-- methods in the first place
			-- deviation: Remove some non-applicable information
			console.warn(
				"componentWillMount has been renamed, and is not recommended for use. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move code with side effects to componentDidMount, and set initial state in the constructor.\n"
					.. "* Rename componentWillMount to UNSAFE_componentWillMount to suppress "
					.. "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(componentWillReceivePropsUniqueNames) ~= nil then
			local sortedNames = setToSortedString(componentWillReceivePropsUniqueNames)

			-- TODO: Make decisions about whether or not we'll support these
			-- methods in the first place
			-- deviation: Remove some non-applicable information
			console.warn(
				"componentWillReceiveProps has been renamed, and is not recommended for use. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "* If you're updating state whenever props change, refactor your "
					.. "code to use memoization techniques or move it to "
					.. "static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n"
					.. "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress "
					.. "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end

		-- deviation: use `next` to determine whether set is empty
		if next(componentWillUpdateUniqueNames) ~= nil then
			local sortedNames = setToSortedString(componentWillUpdateUniqueNames)

			-- TODO: Make decisions about whether or not we'll support these
			-- methods in the first place
			-- deviation: Remove some non-applicable information
			console.warn(
				"componentWillUpdate has been renamed, and is not recommended for use. "
					.. "See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n"
					.. "* Move data fetching code or side effects to componentDidUpdate.\n"
					.. "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress "
					.. "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work.\n"
					.. "\nPlease update the following components: %s",
				sortedNames
			)
		end
	end

	local pendingLegacyContextWarning: FiberToFiberComponentsMap = {}

	-- Tracks components we have already warned about.
	local didWarnAboutLegacyContext = {}

	ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber: Fiber, instance: any)
		local strictRoot = findStrictRoot(fiber)
		if strictRoot == nil then
			console.error(
				"Expected to find a StrictMode component in a strict mode tree. "
					.. "This error is likely caused by a bug in React. Please file an issue."
			)
			return
		end

		-- Dedup strategy: Warn once per component.
		if didWarnAboutLegacyContext[fiber.type] then
			return
		end

		-- FIXME Luau: Luau should narrow based on the nil guard
		local warningsForRoot = pendingLegacyContextWarning[strictRoot :: Fiber]

		-- deviation: Lua can't have fields on functions
		if
			typeof(fiber.type) ~= "function"
			and (
				fiber.type.contextTypes ~= nil
				or fiber.type.childContextTypes ~= nil
				or (instance ~= nil and typeof(instance.getChildContext) == "function")
			)
		then
			if warningsForRoot == nil then
				warningsForRoot = {}
				-- FIXME Luau: Luau should narrow based on the nil guard
				pendingLegacyContextWarning[strictRoot :: Fiber] = warningsForRoot
			end
			table.insert(warningsForRoot, fiber)
		end
	end

	ReactStrictModeWarnings.flushLegacyContextWarning = function()
		for strictRoot, fiberArray in pendingLegacyContextWarning do
			if #fiberArray == 0 then
				return
			end
			local firstFiber = fiberArray[1]

			local uniqueNames = {}
			for i, fiber in fiberArray do
				uniqueNames[getComponentName(fiber.type) or "Component"] = true
				didWarnAboutLegacyContext[fiber.type] = true
			end

			local sortedNames = setToSortedString(uniqueNames)

			local ok, error_ = pcall(function()
				setCurrentDebugFiberInDEV(firstFiber)
				console.error(
					"Legacy context API has been detected within a strict-mode tree."
						.. "\n\nThe old API will be supported in all 16.x releases, but applications "
						.. "using it should migrate to the new version."
						.. "\n\nPlease update the following components: %s"
						.. "\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context",
					sortedNames
				)
			end)

			-- finally
			resetCurrentDebugFiberInDEV()

			if not ok then
				error(error_)
			end
		end
	end

	ReactStrictModeWarnings.discardPendingWarnings = function()
		-- performance? use table.clear instead of assigning new array
		table.clear(pendingComponentWillMountWarnings)
		table.clear(pendingUNSAFE_ComponentWillMountWarnings)
		table.clear(pendingComponentWillReceivePropsWarnings)
		table.clear(pendingUNSAFE_ComponentWillReceivePropsWarnings)
		table.clear(pendingComponentWillUpdateWarnings)
		table.clear(pendingUNSAFE_ComponentWillUpdateWarnings)
		table.clear(pendingLegacyContextWarning)
	end
end

return ReactStrictModeWarnings
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000612a</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE743B4433EFC4DBD9FA96E54B545976F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactTestSelectors</string>
								<string name="ScriptGuid">{938B8505-FAC8-4FBE-A50E-F324E4159FD5}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/3cde22a84e246fc5361f038bf0c23405b2572c22/packages/react-reconciler/src/ReactTestSelectors.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Set<T> = { [T]: boolean }
type Array<T> = LuauPolyfill.Array<T>
type Function = (...any) -> ...any
type Object = LuauPolyfill.Object

-- local type {Fiber} = require(Packages.react-reconciler/src/ReactInternalTypes'
-- local type {Instance} = require(Packages../ReactFiberHostConfig'

-- local invariant = require(Packages.shared/invariant'
-- local {HostComponent, HostText} = require(Packages.react-reconciler/src/ReactWorkTags'
-- local getComponentName = require(Packages.shared/getComponentName'

local ReactFiberHostConfig = require(script.Parent.ReactFiberHostConfig)
local supportsTestSelectors = ReactFiberHostConfig.supportsTestSelectors
-- local {
--   findFiberRoot,
--   getBoundingRect,
--   getInstanceFromNode,
--   getTextContent,
--   isHiddenSubtree,
--   matchAccessibilityRole,
--   setFocusIfFocusable,
--   setupIntersectionObserver,
--   ,
-- } = require(Packages../ReactFiberHostConfig'

-- local COMPONENT_TYPE = 0b000
-- local HAS_PSEUDO_CLASS_TYPE = 0b001
-- local ROLE_TYPE = 0b010
-- local TEST_NAME_TYPE = 0b011
-- local TEXT_TYPE = 0b100

-- if typeof Symbol == 'function' and Symbol.for)
--   local symbolFor = Symbol.for
--   COMPONENT_TYPE = symbolFor('selector.component')
--   HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class')
--   ROLE_TYPE = symbolFor('selector.role')
--   TEST_NAME_TYPE = symbolFor('selector.test_id')
--   TEXT_TYPE = symbolFor('selector.text')
-- end

-- type Type = Symbol | number

-- type ComponentSelector = {|
--   $$typeof: Type,
--   value: React$AbstractComponent<empty, mixed>,
-- |}

-- type HasPsuedoClassSelector = {|
--   $$typeof: Type,
--   value: Array<Selector>,
-- |}

-- type RoleSelector = {|
--   $$typeof: Type,
--   value: string,
-- |}

-- type TextSelector = {|
--   $$typeof: Type,
--   value: string,
-- |}

-- type TestNameSelector = {|
--   $$typeof: Type,
--   value: string,
-- |}

-- type Selector =
--   | ComponentSelector
--   | HasPsuedoClassSelector
--   | RoleSelector
--   | TextSelector
--   | TestNameSelector

local exports = {}

-- exports.createComponentSelector(
--   component: React$AbstractComponent<empty, mixed>,
-- ): ComponentSelector {
--   return {
--     $$typeof: COMPONENT_TYPE,
--     value: component,
--   }
-- end

-- exports.createHasPsuedoClassSelector(
--   selectors: Array<Selector>,
-- ): HasPsuedoClassSelector {
--   return {
--     $$typeof: HAS_PSEUDO_CLASS_TYPE,
--     value: selectors,
--   }
-- end

-- exports.createRoleSelector(role: string): RoleSelector {
--   return {
--     $$typeof: ROLE_TYPE,
--     value: role,
--   }
-- end

-- exports.createTextSelector(text: string): TextSelector {
--   return {
--     $$typeof: TEXT_TYPE,
--     value: text,
--   }
-- end

-- exports.createTestNameSelector(id: string): TestNameSelector {
--   return {
--     $$typeof: TEST_NAME_TYPE,
--     value: id,
--   }
-- end

-- function findFiberRootForHostRoot(hostRoot: Instance): Fiber {
--   local maybeFiber = getInstanceFromNode((hostRoot: any))
--   if maybeFiber ~= nil)
--     invariant(
--       typeof maybeFiber.memoizedProps['data-testname'] == 'string',
--       'Invalid host root specified. Should be either a React container or a node with a testname attribute.',
--     )
--     return ((maybeFiber: any): Fiber)
--   } else {
--     local fiberRoot = findFiberRoot(hostRoot)
--     invariant(
--       fiberRoot ~= nil,
--       'Could not find React container within specified host subtree.',
--     )
--     -- The Flow type for FiberRoot is a little funky.
--     -- createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.
--     return ((fiberRoot: any).stateNode.current: Fiber)
--   }
-- end

-- function matchSelector(fiber: Fiber, selector: Selector): boolean {
--   switch (selector.$$typeof)
--     case COMPONENT_TYPE:
--       if fiber.type == selector.value)
--         return true
--       }
--       break
--     case HAS_PSEUDO_CLASS_TYPE:
--       return hasMatchingPaths(
--         fiber,
--         ((selector: any): HasPsuedoClassSelector).value,
--       )
--     case ROLE_TYPE:
--       if fiber.tag == HostComponent)
--         local node = fiber.stateNode
--         if
--           matchAccessibilityRole(node, ((selector: any): RoleSelector).value)
--         )
--           return true
--         }
--       }
--       break
--     case TEXT_TYPE:
--       if fiber.tag == HostComponent or fiber.tag == HostText)
--         local textContent = getTextContent(fiber)
--         if
--           textContent ~= nil and
--           textContent.indexOf(((selector: any): TextSelector).value) >= 0
--         )
--           return true
--         }
--       }
--       break
--     case TEST_NAME_TYPE:
--       if fiber.tag == HostComponent)
--         local dataTestID = fiber.memoizedProps['data-testname']
--         if
--           typeof dataTestID == 'string' and
--           dataTestID.toLowerCase() ==
--             ((selector: any): TestNameSelector).value.toLowerCase()
--         )
--           return true
--         }
--       }
--       break
--     default:
--       invariant(null, 'Invalid selector type %s specified.', selector)
--       break
--   }

--   return false
-- end

-- function selectorToString(selector: Selector): string | nil {
--   switch (selector.$$typeof)
--     case COMPONENT_TYPE:
--       local displayName = getComponentName(selector.value) or 'Unknown'
--       return `<${displayName}>`
--     case HAS_PSEUDO_CLASS_TYPE:
--       return `:has(${selectorToString(selector) or ''})`
--     case ROLE_TYPE:
--       return `[role="${((selector: any): RoleSelector).value}"]`
--     case TEXT_TYPE:
--       return `"${((selector: any): TextSelector).value}"`
--     case TEST_NAME_TYPE:
--       return `[data-testname="${((selector: any): TestNameSelector).value}"]`
--     default:
--       invariant(null, 'Invalid selector type %s specified.', selector)
--       break
--   }

--   return nil
-- end

-- function findPaths(root: Fiber, selectors: Array<Selector>): Array<Fiber> {
--   local matchingFibers: Array<Fiber> = []

--   local stack = [root, 0]
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     local selectorIndex = ((stack[index++]: any): number)
--     local selector = selectors[selectorIndex]

--     if fiber.tag == HostComponent and isHiddenSubtree(fiber))
--       continue
--     } else {
--       while (selector ~= nil and matchSelector(fiber, selector))
--         selectorIndex++
--         selector = selectors[selectorIndex]
--       }
--     }

--     if selectorIndex == selectors.length)
--       matchingFibers.push(fiber)
--     } else {
--       local child = fiber.child
--       while (child ~= nil)
--         stack.push(child, selectorIndex)
--         child = child.sibling
--       }
--     }
--   }

--   return matchingFibers
-- end

-- -- Same as findPaths but with eager bailout on first match
-- function hasMatchingPaths(root: Fiber, selectors: Array<Selector>): boolean {
--   local stack = [root, 0]
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     local selectorIndex = ((stack[index++]: any): number)
--     local selector = selectors[selectorIndex]

--     if fiber.tag == HostComponent and isHiddenSubtree(fiber))
--       continue
--     } else {
--       while (selector ~= nil and matchSelector(fiber, selector))
--         selectorIndex++
--         selector = selectors[selectorIndex]
--       }
--     }

--     if selectorIndex == selectors.length)
--       return true
--     } else {
--       local child = fiber.child
--       while (child ~= nil)
--         stack.push(child, selectorIndex)
--         child = child.sibling
--       }
--     }
--   }

--   return false
-- end

-- exports.findAllNodes(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): Array<Instance> {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local root = findFiberRootForHostRoot(hostRoot)
--   local matchingFibers = findPaths(root, selectors)

--   local instanceRoots: Array<Instance> = []

--   local stack = Array.from(matchingFibers)
--   local index = 0
--   while (index < stack.length)
--     local node = ((stack[index++]: any): Fiber)
--     if node.tag == HostComponent)
--       if isHiddenSubtree(node))
--         continue
--       }
--       instanceRoots.push(node.stateNode)
--     } else {
--       local child = node.child
--       while (child ~= nil)
--         stack.push(child)
--         child = child.sibling
--       }
--     }
--   }

--   return instanceRoots
-- end

-- exports.getFindAllNodesFailureDescription(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): string | nil {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local root = findFiberRootForHostRoot(hostRoot)

--   local maxSelectorIndex: number = 0
--   local matchedNames = []

--   -- The logic of this loop should be kept in sync with findPaths()
--   local stack = [root, 0]
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     local selectorIndex = ((stack[index++]: any): number)
--     local selector = selectors[selectorIndex]

--     if fiber.tag == HostComponent and isHiddenSubtree(fiber))
--       continue
--     } else if matchSelector(fiber, selector))
--       matchedNames.push(selectorToString(selector))
--       selectorIndex++

--       if selectorIndex > maxSelectorIndex)
--         maxSelectorIndex = selectorIndex
--       }
--     }

--     if selectorIndex < selectors.length)
--       local child = fiber.child
--       while (child ~= nil)
--         stack.push(child, selectorIndex)
--         child = child.sibling
--       }
--     }
--   }

--   if maxSelectorIndex < selectors.length)
--     local unmatchedNames = []
--     for (local i = maxSelectorIndex; i < selectors.length; i++)
--       unmatchedNames.push(selectorToString(selectors[i]))
--     }

--     return (
--       'findAllNodes was able to match part of the selector:\n' +
--       `  ${matchedNames.join(' > ')}\n\n` +
--       'No matching component was found for:\n' +
--       `  ${unmatchedNames.join(' > ')}`
--     )
--   }

--   return nil
-- end

export type BoundingRect = {
	x: number,
	y: number,
	width: number,
	height: number,
}

-- exports.findBoundingRects(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): Array<BoundingRect> {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local instanceRoots = findAllNodes(hostRoot, selectors)

--   local boundingRects: Array<BoundingRect> = []
--   for (local i = 0; i < instanceRoots.length; i++)
--     boundingRects.push(getBoundingRect(instanceRoots[i]))
--   }

--   for (local i = boundingRects.length - 1; i > 0; i--)
--     local targetRect = boundingRects[i]
--     local targetLeft = targetRect.x
--     local targetRight = targetLeft + targetRect.width
--     local targetTop = targetRect.y
--     local targetBottom = targetTop + targetRect.height

--     for (local j = i - 1; j >= 0; j--)
--       if i ~= j)
--         local otherRect = boundingRects[j]
--         local otherLeft = otherRect.x
--         local otherRight = otherLeft + otherRect.width
--         local otherTop = otherRect.y
--         local otherBottom = otherTop + otherRect.height

--         -- Merging all rects to the minimums set would be complicated,
--         -- but we can handle the most common cases:
--         -- 1. completely overlapping rects
--         -- 2. adjacent rects that are the same width or height (e.g. items in a list)
--         --
--         -- Even given the above constraints,
--         -- we still won't end up with the fewest possible rects without doing multiple passes,
--         -- but it's good enough for this purpose.

--         if
--           targetLeft >= otherLeft and
--           targetTop >= otherTop and
--           targetRight <= otherRight and
--           targetBottom <= otherBottom
--         )
--           -- Complete overlapping rects; remove the inner one.
--           boundingRects.splice(i, 1)
--           break
--         } else if
--           targetLeft == otherLeft and
--           targetRect.width == otherRect.width and
--           !(otherBottom < targetTop) and
--           !(otherTop > targetBottom)
--         )
--           -- Adjacent vertical rects; merge them.
--           if otherTop > targetTop)
--             otherRect.height += otherTop - targetTop
--             otherRect.y = targetTop
--           }
--           if otherBottom < targetBottom)
--             otherRect.height = targetBottom - otherTop
--           }

--           boundingRects.splice(i, 1)
--           break
--         } else if
--           targetTop == otherTop and
--           targetRect.height == otherRect.height and
--           !(otherRight < targetLeft) and
--           !(otherLeft > targetRight)
--         )
--           -- Adjacent horizontal rects; merge them.
--           if otherLeft > targetLeft)
--             otherRect.width += otherLeft - targetLeft
--             otherRect.x = targetLeft
--           }
--           if otherRight < targetRight)
--             otherRect.width = targetRight - otherLeft
--           }

--           boundingRects.splice(i, 1)
--           break
--         }
--       }
--     }
--   }

--   return boundingRects
-- end

-- exports.focusWithin(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
-- ): boolean {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local root = findFiberRootForHostRoot(hostRoot)
--   local matchingFibers = findPaths(root, selectors)

--   local stack = Array.from(matchingFibers)
--   local index = 0
--   while (index < stack.length)
--     local fiber = ((stack[index++]: any): Fiber)
--     if isHiddenSubtree(fiber))
--       continue
--     }
--     if fiber.tag == HostComponent)
--       local node = fiber.stateNode
--       if setFocusIfFocusable(node))
--         return true
--       }
--     }
--     local child = fiber.child
--     while (child ~= nil)
--       stack.push(child)
--       child = child.sibling
--     }
--   }

--   return false
-- end

local commitHooks: Array<Function> = {}

exports.onCommitRoot = function(): ()
	if supportsTestSelectors then
		for i, commitHook in commitHooks do
			commitHook()
		end
	end
end

export type IntersectionObserverOptions = Object

export type ObserveVisibleRectsCallback = (intersections: Array<{ ratio: number, rect: BoundingRect }>) -> ()

-- exports.observeVisibleRects(
--   hostRoot: Instance,
--   selectors: Array<Selector>,
--   callback: (intersections: Array<{ratio: number, rect: BoundingRect}>) => void,
--   options?: IntersectionObserverOptions,
-- ): {|disconnect: () => void|} {
--   if !supportsTestSelectors)
--     invariant(false, 'Test selector API is not supported by this renderer.')
--   }

--   local instanceRoots = findAllNodes(hostRoot, selectors)

--   local {disconnect, observe, unobserve} = setupIntersectionObserver(
--     instanceRoots,
--     callback,
--     options,
--   )

--   -- When React mutates the host environment, we may need to change what we're listening to.
--   local commitHook = () => {
--     local nextInstanceRoots = findAllNodes(hostRoot, selectors)

--     instanceRoots.forEach(target => {
--       if nextInstanceRoots.indexOf(target) < 0)
--         unobserve(target)
--       }
--     })

--     nextInstanceRoots.forEach(target => {
--       if instanceRoots.indexOf(target) < 0)
--         observe(target)
--       }
--     })
--   }

--   commitHooks.push(commitHook)

--   return {
--     disconnect: () => {
--       -- Stop listening for React mutations:
--       local index = commitHooks.indexOf(commitHook)
--       if index >= 0)
--         commitHooks.splice(index, 1)
--       }

--       -- Disconnect the host observer:
--       disconnect()
--     },
--   }
-- end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000612b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXAACE0AAA4F9B441B9B3204E0E80D5686">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactTypeOfMode</string>
								<string name="ScriptGuid">{D8C0CDF0-3CB7-428C-8C8F-3DAD9030A555}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/22dc2e42bdc00d87fc19c5e75fc7c0b3fdcdc572/packages/react-reconciler/src/ReactTypeOfMode.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

export type TypeOfMode = number

return {
	NoMode = 0b00000,
	StrictMode = 0b00001,
	-- TODO: Remove BlockingMode and ConcurrentMode by reading from the root
	-- tag instead
	BlockingMode = 0b00010,
	ConcurrentMode = 0b00100,
	ProfileMode = 0b01000,
	DebugTracingMode = 0b10000,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000612c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5AE17128603B4BEFB4529BAC6CEF9005">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactUpdateQueue.new</string>
								<string name="ScriptGuid">{1AD8D258-66E0-4001-9067-3AD8DEC30AAB}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/16654436039dd8f16a63928e71081c7745872e8f/packages/react-reconciler/src/ReactUpdateQueue.new.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

-- UpdateQueue is a linked list of prioritized updates.
--
-- Like fibers, update queues come in pairs: a current queue, which represents
-- the visible state of the screen, and a work-in-progress queue, which can be
-- mutated and processed asynchronously before it is committed — a form of
-- double buffering. If a work-in-progress render is discarded before finishing,
-- we create a new work-in-progress by cloning the current queue.
--
-- Both queues share a persistent, singly-linked list structure. To schedule an
-- update, we append it to the end of both queues. Each queue maintains a
-- pointer to first update in the persistent list that hasn't been processed.
-- The work-in-progress pointer always has a position equal to or greater than
-- the current queue, since we always work on that one. The current queue's
-- pointer is only updated during the commit phase, when we swap in the
-- work-in-progress.
--
-- For example:
--
--   Current pointer:           A - B - C - D - E - F
--   Work-in-progress pointer:              D - E - F
--                                          ^
--                                          The work-in-progress queue has
--                                          processed more updates than current.
--
-- The reason we append to both queues is because otherwise we might drop
-- updates without ever processing them. For example, if we only add updates to
-- the work-in-progress queue, some updates could be lost whenever a work-in
-- -progress render restarts by cloning from current. Similarly, if we only add
-- updates to the current queue, the updates will be lost whenever an already
-- in-progress queue commits and swaps with the current queue. However, by
-- adding to both queues, we guarantee that the update will be part of the next
-- work-in-progress. (And because the work-in-progress queue becomes the
-- current queue once it commits, there's no danger of applying the same
-- update twice.)
--
-- Prioritization
-- --------------
--
-- Updates are not sorted by priority, but by insertion; new updates are always
-- appended to the end of the list.
--
-- The priority is still important, though. When processing the update queue
-- during the render phase, only the updates with sufficient priority are
-- included in the result. If we skip an update because it has insufficient
-- priority, it remains in the queue to be processed later, during a lower
-- priority render. Crucially, all updates subsequent to a skipped update also
-- remain in the queue *regardless of their priority*. That means high priority
-- updates are sometimes processed twice, at two separate priorities. We also
-- keep track of a base state, that represents the state before the first
-- update in the queue is applied.
--
-- For example:
--
--   Given a base state of '', and the following queue of updates
--
--     A1 - B2 - C1 - D2
--
--   where the number indicates the priority, and the update is applied to the
--   previous state by appending a letter, React will process these updates as
--   two separate renders, one per distinct priority level:
--
--   First render, at priority 1:
--     Base state: ''
--     Updates: [A1, C1]
--     Result state: 'AC'
--
--   Second render, at priority 2:
--     Base state: 'A'            <-  The base state does not include C1,
--                                    because B2 was skipped.
--     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
--     Result state: 'ABCD'
--
-- Because we process updates in insertion order, and rebase high priority
-- updates when preceding updates are skipped, the final result is deterministic
-- regardless of priority. Intermediate state may vary according to system
-- resources, but the final state is always the same.

local __DEV__ = _G.__DEV__
local __YOLO__ = _G.__YOLO__

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber
type Lane = ReactInternalTypes.Lane
type Lanes = ReactInternalTypes.Lanes

local ReactFiberLane = require(script.Parent.ReactFiberLane)
local NoLane = ReactFiberLane.NoLane
local NoLanes = ReactFiberLane.NoLanes
local isSubsetOfLanes = ReactFiberLane.isSubsetOfLanes
local mergeLanes = ReactFiberLane.mergeLanes

-- deviation: lazy instantiate to avoid circular require
local ReactFiberNewContext --= require(script.Parent["ReactFiberNewContext.new"])
-- local enterDisallowedContextReadInDEV = ReactFiberNewContext.enterDisallowedContextReadInDEV
-- local exitDisallowedContextReadInDEV = ReactFiberNewContext.exitDisallowedContextReadInDEV
local function enterDisallowedContextReadInDEV()
	if not ReactFiberNewContext then
		ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"]) :: any
	end
	ReactFiberNewContext.enterDisallowedContextReadInDEV()
end
local function exitDisallowedContextReadInDEV()
	if not ReactFiberNewContext then
		ReactFiberNewContext = require(script.Parent["ReactFiberNewContext.new"]) :: any
	end
	ReactFiberNewContext.exitDisallowedContextReadInDEV()
end
local ReactFiberFlags = require(script.Parent.ReactFiberFlags)
local Callback = ReactFiberFlags.Callback
local ShouldCapture = ReactFiberFlags.ShouldCapture
local DidCapture = ReactFiberFlags.DidCapture

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local debugRenderPhaseSideEffectsForStrictMode = ReactFeatureFlags.debugRenderPhaseSideEffectsForStrictMode

local ReactTypeOfMode = require(script.Parent.ReactTypeOfMode)
local StrictMode = ReactTypeOfMode.StrictMode
-- local ReactFiberWorkLoop = require(script.Parent["ReactFiberWorkLoop.new"])
local markSkippedUpdateLanes = require(script.Parent.ReactFiberWorkInProgress).markSkippedUpdateLanes

-- deviation START: use if-then-error, which avoid string format and function call overhead, as in React 18
-- local invariant = require(Packages.Shared).invariant
-- deviation END
local describeError = require(Packages.Shared).describeError

local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

-- deviation: Common types
type Array<T> = { [number]: T }

-- deviation: transplants UpdateQueue<> and SharedState<> types to ReactInternalTypes for export to createReactNoop
type Update<T> = ReactInternalTypes.Update<T>
type UpdateQueue<T> = ReactInternalTypes.UpdateQueue<T>
export type SharedQueue<T> = ReactInternalTypes.SharedQueue<T>

local exports = {}

local UpdateState = 0
exports.UpdateState = UpdateState
local ReplaceState = 1
exports.ReplaceState = ReplaceState
local ForceUpdate = 2
exports.ForceUpdate = ForceUpdate
local CaptureUpdate = 3
exports.CaptureUpdate = CaptureUpdate

-- Global state that is reset at the beginning of calling `processUpdateQueue`.
-- It should only be read right after calling `processUpdateQueue`, via
-- `checkHasForceUpdateAfterProcessing`.
local hasForceUpdate = false

local didWarnUpdateInsideUpdate
local currentlyProcessingQueue: SharedQueue<any>?
-- export local resetCurrentlyProcessingQueue
if __DEV__ then
	didWarnUpdateInsideUpdate = false
	currentlyProcessingQueue = nil
	exports.resetCurrentlyProcessingQueue = function()
		currentlyProcessingQueue = nil
	end
end

-- performance: use a recycle pool for update tables
local poolInitSize = 210 -- TODO: Tune to LuaApps
-- local poolAdditionalSize = 0
local updatePool = table.create(poolInitSize)
local updatePoolIndex = poolInitSize
for i = 1, poolInitSize do
	updatePool[i] = {
		eventTime = -1,
		lane = -1,
		tag = -1,
		payload = nil,
		callback = nil,
		next = nil,
	}
end

local function initializeUpdateQueue<State>(fiber: Fiber): ()
	local queue: UpdateQueue<State> = {
		baseState = fiber.memoizedState,
		firstBaseUpdate = nil,
		lastBaseUpdate = nil,
		shared = {
			pending = nil,
		},
		effects = nil,
	}
	fiber.updateQueue = queue
end
exports.initializeUpdateQueue = initializeUpdateQueue

local function cloneUpdateQueue<State>(current: Fiber, workInProgress: Fiber): ()
	-- Clone the update queue from current. Unless it's already a clone.
	local queue: UpdateQueue<State> = workInProgress.updateQueue :: any
	local currentQueue: UpdateQueue<State> = current.updateQueue :: any
	if queue == currentQueue then
		-- deviation START: use our queue method for hot path optimizations
		local clone: UpdateQueue<State> = table.clone(currentQueue)
		-- deviation END
		workInProgress.updateQueue = clone
	end
end
exports.cloneUpdateQueue = cloneUpdateQueue

-- deviation START: add extra parameters here so updates can be create in single table ctor
local function createUpdate(eventTime: number, lane: Lane, payload: any?, callback: (() -> ...any)?): Update<any>
	-- performance: Use pooled update object when available
	if updatePoolIndex > 0 then
		local update = updatePool[updatePoolIndex]
		updatePool[updatePoolIndex] = nil
		updatePoolIndex -= 1

		update.eventTime = eventTime
		update.lane = lane
		update.tag = UpdateState
		update.payload = payload
		update.callback = callback :: any

		return update :: Update<any>
	end
	-- deviation END

	-- performance FIXME: This warning is very noisy in practice and not
	-- actionable by Roact developers in any way. We should re-establish the
	-- warning once we've done some tuning and thought more about what messaging
	-- we want to convey to Roact users

	-- if __DEV__ then
	-- 	poolAdditionalSize += 1
	-- 	console.warn(
	-- 		"ReactUpdateQueue createUpdate's object pool exhausted, allocating fresh table."
	-- 			.. "\nConsider setting poolInitSize to " .. poolInitSize + poolAdditionalSize
	-- 			.. " to avoid this occurring in the future."
	-- 	)
	-- end

	local update = {
		eventTime = eventTime,
		lane = lane,

		tag = UpdateState,
		payload = payload,
		callback = callback :: any,

		next = nil,
	}
	return update :: Update<any>
end
exports.createUpdate = createUpdate

local function enqueueUpdate<State>(fiber: Fiber, update: Update<State>)
	local updateQueue = fiber.updateQueue
	if updateQueue == nil then
		-- Only occurs if the fiber has been unmounted.
		return
	end

	local sharedQueue: SharedQueue<State> = (updateQueue :: any).shared
	local pending = sharedQueue.pending
	if pending == nil then
		-- This is the first update. Create a circular list.
		update.next = update
	else
		update.next = pending.next
		pending.next = update
	end
	sharedQueue.pending = update

	if __DEV__ then
		if currentlyProcessingQueue == sharedQueue and not didWarnUpdateInsideUpdate then
			console.error(
				"An update (setState, replaceState, or forceUpdate) was scheduled "
					.. "from inside an update function. Update functions should be pure, "
					.. "with zero side-effects. Consider using componentDidUpdate or a "
					.. "callback."
			)
			didWarnUpdateInsideUpdate = true
		end
	end
end
exports.enqueueUpdate = enqueueUpdate

local function enqueueCapturedUpdate<State>(workInProgress: Fiber, capturedUpdate: Update<State>)
	-- Captured updates are updates that are thrown by a child during the render
	-- phase. They should be discarded if the render is aborted. Therefore,
	-- we should only put them on the work-in-progress queue, not the current one.
	local queue: UpdateQueue<State> = workInProgress.updateQueue :: any

	-- Check if the work-in-progress queue is a clone.
	local current = workInProgress.alternate
	if current ~= nil then
		local currentQueue: UpdateQueue<State> = current.updateQueue :: any
		if queue == currentQueue then
			-- The work-in-progress queue is the same as current. This happens when
			-- we bail out on a parent fiber that then captures an error thrown by
			-- a child. Since we want to append the update only to the work-in
			-- -progress queue, we need to clone the updates. We usually clone during
			-- processUpdateQueue, but that didn't happen in this case because we
			-- skipped over the parent when we bailed out.
			local newFirst = nil
			local newLast = nil
			local firstBaseUpdate = queue.firstBaseUpdate
			if firstBaseUpdate ~= nil then
				-- Loop through the updates and clone them.
				local update = firstBaseUpdate
				repeat
					local clone: Update<State> = {
						eventTime = update.eventTime,
						lane = update.lane,

						tag = update.tag,
						payload = update.payload,
						callback = update.callback,

						next = nil,
					}
					if newLast == nil then
						newLast = clone
						newFirst = clone
					else
						newLast.next = clone
						newLast = clone
					end
					-- FIXME Luau: Luau needs to support repeat until nil pattern
					update = update.next :: Update<State>
				until update == nil

				-- Append the captured update the end of the cloned list.
				if newLast == nil then
					newLast = capturedUpdate
					newFirst = capturedUpdate
				else
					newLast.next = capturedUpdate
					newLast = capturedUpdate
				end
			else
				-- There are no base updates.
				newLast = capturedUpdate
				newFirst = capturedUpdate
			end
			queue = {
				baseState = currentQueue.baseState,
				firstBaseUpdate = newFirst,
				lastBaseUpdate = newLast,
				shared = currentQueue.shared,
				effects = currentQueue.effects,
			}
			workInProgress.updateQueue = queue
			return
		end
	end

	-- Append the update to the end of the list.
	local lastBaseUpdate = queue.lastBaseUpdate
	if lastBaseUpdate == nil then
		queue.firstBaseUpdate = capturedUpdate
	else
		lastBaseUpdate.next = capturedUpdate
	end
	queue.lastBaseUpdate = capturedUpdate
end
exports.enqueueCapturedUpdate = enqueueCapturedUpdate

local function getStateFromUpdate<State>(
	workInProgress: Fiber,
	queue: UpdateQueue<State>,
	update: Update<State>,
	prevState: State,
	nextProps: any,
	instance: any
): any
	local updateTag = update.tag
	if updateTag == ReplaceState then
		local payload = update.payload
		if type(payload) == "function" then
			-- Updater function
			if __DEV__ then
				enterDisallowedContextReadInDEV()
			end
			-- deviation: Upstream binds this callback to the instance;
			-- in order for us to get the same behavior, we'd need to change the
			-- signature of the updater, which doesn't make sense for our case
			local nextState = payload(prevState, nextProps)
			if __DEV__ then
				if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
					disableLogs()
					-- deviation: YOLO flag for disabling pcall
					local ok, result
					if not __YOLO__ then
						ok, result = xpcall(payload, describeError, prevState, nextProps)
					else
						ok = true
						payload(prevState, nextProps)
					end
					-- finally
					reenableLogs()

					if not ok then
						error(result)
					end
				end
				exitDisallowedContextReadInDEV()
			end
			return nextState
		end
		-- State object
		return payload
	elseif updateTag == CaptureUpdate or updateTag == UpdateState then
		if updateTag == CaptureUpdate then
			workInProgress.flags = bit32.bor(bit32.band(workInProgress.flags, bit32.bnot(ShouldCapture)), DidCapture)
		end
		-- Intentional fallthrough
		local payload = update.payload
		local partialState
		if type(payload) == "function" then
			-- Updater function
			if __DEV__ then
				enterDisallowedContextReadInDEV()
			end
			-- deviation: Upstream binds this callback to the instance;
			-- in order for us to get the same behavior, we'd need to change the
			-- signature of the updater, which doesn't make sense for our case
			partialState = payload(prevState, nextProps)
			if __DEV__ then
				if debugRenderPhaseSideEffectsForStrictMode and bit32.band(workInProgress.mode, StrictMode) ~= 0 then
					disableLogs()
					-- deviation: YOLO flag for disabling pcall
					local ok, result
					if not __YOLO__ then
						ok, result = xpcall(payload, describeError, prevState, nextProps)
					else
						ok = true
						payload(prevState, nextProps)
					end
					-- finally
					reenableLogs()

					if not ok then
						error(result)
					end
				end
				exitDisallowedContextReadInDEV()
			end
		else
			-- Partial state object
			partialState = payload
		end
		if partialState == nil then
			-- Null and undefined are treated as no-ops.
			return prevState
		end
		-- Merge the partial state and the previous state.
		-- TODO: the below optimziation doesn't work because: invalid argument #1 to 'clone' (table has a protected metatable)
		-- local newState = if prevState ~= nil then table.clone(prevState :: any) else {}
		return Object.assign({}, prevState, partialState)
	elseif updateTag == ForceUpdate then
		hasForceUpdate = true
		return prevState
	end
	return prevState
end
exports.getStateFromUpdate = getStateFromUpdate

local function processUpdateQueue<State>(workInProgress: Fiber, props: any, instance: any, renderLanes: Lanes): ()
	-- This is always non-null on a ClassComponent or HostRoot
	local queue: UpdateQueue<State> = workInProgress.updateQueue :: any

	hasForceUpdate = false

	if __DEV__ then
		currentlyProcessingQueue = queue.shared
	end

	local firstBaseUpdate = queue.firstBaseUpdate
	local lastBaseUpdate = queue.lastBaseUpdate

	-- Check if there are pending updates. If so, transfer them to the base queue.
	local pendingQueue = queue.shared.pending
	if pendingQueue ~= nil then
		queue.shared.pending = nil

		-- The pending queue is circular. Disconnect the pointer between first
		-- and last so that it's non-circular.
		local lastPendingUpdate = pendingQueue
		local firstPendingUpdate = lastPendingUpdate.next
		lastPendingUpdate.next = nil
		-- Append pending updates to base queue
		if lastBaseUpdate == nil then
			firstBaseUpdate = firstPendingUpdate
		else
			lastBaseUpdate.next = firstPendingUpdate
		end
		lastBaseUpdate = lastPendingUpdate

		-- If there's a current queue, and it's different from the base queue, then
		-- we need to transfer the updates to that queue, too. Because the base
		-- queue is a singly-linked list with no cycles, we can append to both
		-- lists and take advantage of structural sharing.
		-- TODO: Pass `current` as argument
		local current = workInProgress.alternate
		if current ~= nil then
			-- This is always non-null on a ClassComponent or HostRoot
			local currentQueue: UpdateQueue<State> = current.updateQueue :: any
			local currentLastBaseUpdate = currentQueue.lastBaseUpdate
			if currentLastBaseUpdate ~= lastBaseUpdate then
				if currentLastBaseUpdate == nil then
					currentQueue.firstBaseUpdate = firstPendingUpdate
				else
					currentLastBaseUpdate.next = firstPendingUpdate
				end
				currentQueue.lastBaseUpdate = lastPendingUpdate
			end
		end
	end

	-- These values may change as we process the queue.
	if firstBaseUpdate ~= nil then
		-- Iterate through the list of updates to compute the result.
		local newState = queue.baseState
		-- TODO: Don't need to accumulate this. Instead, we can remove renderLanes
		-- from the original lanes.
		local newLanes = NoLanes

		local newBaseState = nil
		local newFirstBaseUpdate = nil
		local newLastBaseUpdate = nil

		local update = firstBaseUpdate
		while true do
			local updateLane = update.lane
			local updateEventTime = update.eventTime
			if not isSubsetOfLanes(renderLanes, updateLane) then
				-- Priority is insufficient. Skip this update. If this is the first
				-- skipped update, the previous update/state is the new base
				-- update/state.
				local clone: Update<State> = {
					eventTime = updateEventTime,
					lane = updateLane,

					tag = update.tag,
					payload = update.payload,
					callback = update.callback,

					next = nil,
				}
				if newLastBaseUpdate == nil then
					newFirstBaseUpdate = clone
					newLastBaseUpdate = clone
					newBaseState = newState
				else
					newLastBaseUpdate.next = clone
					newLastBaseUpdate = clone
				end
				-- Update the remaining priority in the queue.
				newLanes = mergeLanes(newLanes, updateLane)
			else
				-- This update does have sufficient priority.

				if newLastBaseUpdate ~= nil then
					local clone: Update<State> = {
						eventTime = updateEventTime,
						-- This update is going to be committed so we never want uncommit
						-- it. Using NoLane works because 0 is a subset of all bitmasks, so
						-- this will never be skipped by the check above.
						lane = NoLane,

						tag = update.tag,
						payload = update.payload,
						callback = update.callback,

						next = nil,
					}
					newLastBaseUpdate.next = clone
					newLastBaseUpdate = clone
				end

				-- Process this update.
				newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance)
				local callback = update.callback
				if
					callback ~= nil
					-- If the update was already committed, we should not queue its
					-- callback again.
					and update.lane ~= NoLane
				then
					workInProgress.flags = bit32.bor(workInProgress.flags, Callback)
					local effects = queue.effects
					if effects == nil then
						queue.effects = { update }
					else
						table.insert(effects, update)
					end
				end
			end
			-- FIXME Luau: Luau needs to support repeat until nil pattern
			update = update.next :: Update<State>
			if update == nil then
				pendingQueue = queue.shared.pending
				if pendingQueue == nil then
					break
				else
					-- An update was scheduled from inside a reducer. Add the new
					-- pending updates to the end of the list and keep processing.
					local lastPendingUpdate = pendingQueue
					-- Intentionally unsound. Pending updates form a circular list, but we
					-- unravel them when transferring them to the base queue.
					local firstPendingUpdate = (lastPendingUpdate.next :: any) :: Update<State>
					lastPendingUpdate.next = nil
					update = firstPendingUpdate
					queue.lastBaseUpdate = lastPendingUpdate
					queue.shared.pending = nil
				end
			end
		end

		if newLastBaseUpdate == nil then
			newBaseState = newState
		end

		queue.baseState = (newBaseState :: any) :: State
		queue.firstBaseUpdate = newFirstBaseUpdate
		queue.lastBaseUpdate = newLastBaseUpdate

		-- Set the remaining expiration time to be whatever is remaining in the queue.
		-- This should be fine because the only two other things that contribute to
		-- expiration time are props and context. We're already in the middle of the
		-- begin phase by the time we start processing the queue, so we've already
		-- dealt with the props. Context in components that specify
		-- shouldComponentUpdate is tricky; but we'll have to account for
		-- that regardless.
		markSkippedUpdateLanes(newLanes)
		workInProgress.lanes = newLanes
		workInProgress.memoizedState = newState
	end

	if __DEV__ then
		currentlyProcessingQueue = nil
	end
end
exports.processUpdateQueue = processUpdateQueue

local function callCallback(callback, context)
	-- deviation START: use if-then-error, which avoid string format and function call overhead, as in React 18
	if type(callback) ~= "function" then
		error(
			string.format(
				"Invalid argument passed as callback. Expected a function. Instead " .. "received: %s",
				tostring(callback)
			)
		)
		-- deviation END
	end
	callback(context)
end

exports.resetHasForceUpdateBeforeProcessing = function()
	hasForceUpdate = false
end

exports.checkHasForceUpdateAfterProcessing = function(): boolean
	return hasForceUpdate
end

local function commitUpdateQueue<State>(finishedWork: Fiber, finishedQueue: UpdateQueue<State>, instance: any): ()
	-- Commit the effects
	local effects = finishedQueue.effects
	finishedQueue.effects = nil
	if effects ~= nil then
		for _, effect in effects do
			local callback = effect.callback
			if callback ~= nil then
				callCallback(callback, instance)
			end

			-- performance: return this object to the pool
			table.clear(effect)
			table.insert(updatePool, effect :: any)
			updatePoolIndex += 1
		end
	end
end
exports.commitUpdateQueue = commitUpdateQueue

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000612d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC4573E59E0244660BBAE445FC0733ED6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactWorkTags</string>
								<string name="ScriptGuid">{B81D5000-21B3-472E-9B2E-DC64D259EE8B}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/ReactWorkTags.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

export type WorkTag = number

return {
	FunctionComponent = 0,
	ClassComponent = 1,
	IndeterminateComponent = 2, -- Before we know whether it is function or class
	HostRoot = 3, -- Root of a host tree. Could be nested inside another node.
	HostPortal = 4, -- A subtree. Could be an entry point to a different renderer.
	HostComponent = 5,
	HostText = 6,
	Fragment = 7,
	Mode = 8,
	ContextConsumer = 9,
	ContextProvider = 10,
	ForwardRef = 11,
	Profiler = 12,
	SuspenseComponent = 13,
	MemoComponent = 14,
	SimpleMemoComponent = 15,
	LazyComponent = 16,
	IncompleteClassComponent = 17,
	DehydratedFragment = 18,
	SuspenseListComponent = 19,
	FundamentalComponent = 20,
	ScopeComponent = 21,
	Block = 22,
	OffscreenComponent = 23,
	LegacyHiddenComponent = 24,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000612e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9D4BF89E84714D04B93D98476FE656DC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulerWithReactIntegration.new</string>
								<string name="ScriptGuid">{697F0AE2-2B21-48B7-84B9-7CCF27A7469A}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/d17086c7c813402a550d15a2f56dc43f1dbd1735/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
export type ReactPriorityLevel = ReactInternalTypes.ReactPriorityLevel

-- Intentionally not named imports because Rollup would use dynamic dispatch for
-- CommonJS interop named imports.
local Scheduler = require(Packages.Scheduler)
-- local __interactionsRef = require(Packages.Scheduler.tracing).__interactionsRef
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local decoupleUpdatePriorityFromScheduler = ReactFeatureFlags.decoupleUpdatePriorityFromScheduler
local invariant = require(Packages.Shared).invariant
local describeError = require(Packages.Shared).describeError
local ReactFiberLane = require(script.Parent.ReactFiberLane)
local SyncLanePriority = ReactFiberLane.SyncLanePriority
local getCurrentUpdateLanePriority = ReactFiberLane.getCurrentUpdateLanePriority
local setCurrentUpdateLanePriority = ReactFiberLane.setCurrentUpdateLanePriority

local Scheduler_runWithPriority = Scheduler.unstable_runWithPriority
local Scheduler_scheduleCallback = Scheduler.unstable_scheduleCallback
local Scheduler_cancelCallback = Scheduler.unstable_cancelCallback
local Scheduler_shouldYield = Scheduler.unstable_shouldYield
local Scheduler_requestPaint = Scheduler.unstable_requestPaint
local Scheduler_now = Scheduler.unstable_now
local Scheduler_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel
local Scheduler_ImmediatePriority = Scheduler.unstable_ImmediatePriority
local Scheduler_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority
local Scheduler_NormalPriority = Scheduler.unstable_NormalPriority
local Scheduler_LowPriority = Scheduler.unstable_LowPriority
local Scheduler_IdlePriority = Scheduler.unstable_IdlePriority

-- deviation: Instead of defining these here, we require them from a small file
-- with _just_ these constant definitions; it helps us avoid a circular require
-- issue with `ReactFiberLanes`
local ReactFiberSchedulerPriorities = require(script.Parent["ReactFiberSchedulerPriorities.roblox"])
local ImmediatePriority = ReactFiberSchedulerPriorities.ImmediatePriority
local UserBlockingPriority = ReactFiberSchedulerPriorities.UserBlockingPriority
local NormalPriority = ReactFiberSchedulerPriorities.NormalPriority
local LowPriority = ReactFiberSchedulerPriorities.LowPriority
local IdlePriority = ReactFiberSchedulerPriorities.IdlePriority
local NoPriority = ReactFiberSchedulerPriorities.NoPriority

-- deviation: common types
type Array<T> = { [number]: T }

-- deviation: pre-declare functions
local flushSyncCallbackQueueImpl

-- if enableSchedulerTracing)
--   -- Provide explicit error message when production+profiling bundle of e.g.
--   -- react-dom is used with production (non-profiling) bundle of
--   -- scheduler/tracing
--   invariant(
--     __interactionsRef ~= nil and __interactionsRef.current ~= nil,
--     'It is not supported to run the profiling version of a renderer (for ' +
--       'example, `react-dom/profiling`) without also replacing the ' +
--       '`scheduler/tracing` module with `scheduler/tracing-profiling`. Your ' +
--       'bundler might have a setting for aliasing both modules. Learn more at ' +
--       'https://reactjs.org/link/profiling',
--   )
-- end

export type SchedulerCallback = (isSync: boolean) -> SchedulerCallback | nil

-- deviation START: don't allow extension unless we need to
-- type SchedulerCallbackOptions = { timeout: number?, ... };
type SchedulerCallbackOptions = { timeout: number? }
-- deviation END
local fakeCallbackNode = {}

local shouldYield = Scheduler_shouldYield
local requestPaint
-- Fall back gracefully if we're running an older version of Scheduler.
if Scheduler_requestPaint ~= nil then
	requestPaint = Scheduler_requestPaint
else
	requestPaint = function() end
end

local syncQueue: Array<SchedulerCallback>? = nil
local immediateQueueCallbackNode: any? = nil
local isFlushingSyncQueue: boolean = false
local initialTimeMs: number = Scheduler_now()

-- -- If the initial timestamp is reasonably small, use Scheduler's `now` directly.
-- -- This will be the case for modern browsers that support `performance.now`. In
-- -- older browsers, Scheduler falls back to `Date.now`, which returns a Unix
-- -- timestamp. In that case, subtract the module initialization time to simulate
-- -- the behavior of performance.now and keep our times small enough to fit
-- -- within 32 bits.
-- -- TODO: Consider lifting this into Scheduler.
-- FIXME: properly account for ms vs s from tick
-- local now = initialTimeMs < 10000
--   and Scheduler_now
--   or function()
--     return Scheduler_now() - initialTimeMs
--   end

-- deviation: Roblox uses `tick` under the hood, which is more like the unix
-- timestamp behavior referenced above
local function now(): number
	return Scheduler_now() - initialTimeMs
end

local function getCurrentPriorityLevel(): ReactPriorityLevel
	local currentPriorityLevel = Scheduler_getCurrentPriorityLevel()
	if currentPriorityLevel == Scheduler_ImmediatePriority then
		return ImmediatePriority
	elseif currentPriorityLevel == Scheduler_UserBlockingPriority then
		return UserBlockingPriority
	elseif currentPriorityLevel == Scheduler_NormalPriority then
		return NormalPriority
	elseif currentPriorityLevel == Scheduler_LowPriority then
		return LowPriority
	elseif currentPriorityLevel == Scheduler_IdlePriority then
		return IdlePriority
	else
		invariant(false, "Unknown priority level.")
		-- deviation: FIXME: Luau needs explicit return here
		return NoPriority
	end
end

function reactPriorityToSchedulerPriority(reactPriorityLevel)
	if reactPriorityLevel == ImmediatePriority then
		return Scheduler_ImmediatePriority
	elseif reactPriorityLevel == UserBlockingPriority then
		return Scheduler_UserBlockingPriority
	elseif reactPriorityLevel == NormalPriority then
		return Scheduler_NormalPriority
	elseif reactPriorityLevel == LowPriority then
		return Scheduler_LowPriority
	elseif reactPriorityLevel == IdlePriority then
		return Scheduler_IdlePriority
	else
		invariant(false, "Unknown priority level.")
		-- deviation: return appeases Luau
		return nil
	end
end

-- FIXME Luau: should be T... but hits CLI-50289: failure to unify
local function runWithPriority<T...>(reactPriorityLevel: ReactPriorityLevel, fn: () -> T...): ...any
	local priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel)
	return Scheduler_runWithPriority(priorityLevel, fn)
end

local function scheduleCallback(
	reactPriorityLevel: ReactPriorityLevel,
	callback: SchedulerCallback,
	options: SchedulerCallbackOptions | nil
)
	local priorityLevel = reactPriorityToSchedulerPriority(reactPriorityLevel)
	return Scheduler_scheduleCallback(priorityLevel, callback, options)
end

local function scheduleSyncCallback(callback: SchedulerCallback)
	-- Push this callback into an internal queue. We'll flush these either in
	-- the next tick, or earlier if something calls `flushSyncCallbackQueue`.
	if syncQueue == nil then
		syncQueue = { callback }
		-- Flush the queue in the next tick, at the earliest.
		immediateQueueCallbackNode = Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueueImpl)
	else
		-- Push onto existing queue. Don't need to schedule a callback because
		-- we already scheduled one when we created the queue.
		local coercedSyncQueue = syncQueue
		table.insert(coercedSyncQueue, callback)
	end
	return fakeCallbackNode
end

local function cancelCallback(callbackNode: any)
	if callbackNode ~= fakeCallbackNode then
		Scheduler_cancelCallback(callbackNode)
	end
end

local function flushSyncCallbackQueue(): boolean
	if immediateQueueCallbackNode ~= nil then
		local node = immediateQueueCallbackNode
		immediateQueueCallbackNode = nil
		Scheduler_cancelCallback(node)
	end
	return flushSyncCallbackQueueImpl()
end

flushSyncCallbackQueueImpl = function()
	if not isFlushingSyncQueue and syncQueue ~= nil then
		-- Prevent re-entrancy.
		isFlushingSyncQueue = true
		local i = 1
		if decoupleUpdatePriorityFromScheduler then
			local previousLanePriority = getCurrentUpdateLanePriority()
			-- deviation: YOLO flag for disabling pcall
			local ok = true
			local result
			if not _G.__YOLO__ then
				-- performance: hoist non-throwables out of try{} to eliminate anon function
				local isSync = true
				local queue = syncQueue

				setCurrentUpdateLanePriority(SyncLanePriority)
				ok, result = xpcall(
					runWithPriority,
					describeError,
					ImmediatePriority,
					-- FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
					function(): ...any
						for index, callback in queue do
							i = index
							repeat
								-- FIXME Luau: Luau doesn't understand loop until nil construct
								callback = callback(isSync) :: any
							until callback == nil
						end
					end
				)
				syncQueue = nil
			else
				ok = true
				local isSync = true
				local queue = syncQueue

				setCurrentUpdateLanePriority(SyncLanePriority)
				-- FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
				runWithPriority(ImmediatePriority, function(): ...any
					for index, callback in queue do
						i = index
						repeat
							-- FIXME Luau: Luau doesn't understand loop until nil construct
							callback = callback(isSync) :: any
						until callback == nil
						i += 1
					end
				end)
				syncQueue = nil
			end

			-- finally
			setCurrentUpdateLanePriority(previousLanePriority)
			isFlushingSyncQueue = false

			if not ok then
				-- If something throws, leave the remaining callbacks on the queue.
				if syncQueue ~= nil then
					syncQueue = Array.slice(syncQueue, i + 1)
				end
				-- Resume flushing in the next tick
				Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue)
				error(result)
			end
		else
			-- deviation: YOLO flag for disabling pcall
			local ok, result
			if not _G.__YOLO__ then
				-- performance: hoist non-throwables out of try{} to eliminate anon function
				local isSync = true
				local queue = syncQueue

				ok, result = xpcall(
					runWithPriority,
					describeError,
					ImmediatePriority,
					-- FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
					function(): ...any
						for index, callback in queue do
							i = index
							repeat
								-- FIXME Luau: Luau doesn't understand loop until nil construct
								callback = callback(isSync) :: any
							until callback == nil
						end
					end
				)
				syncQueue = nil
			else
				ok = true
				local isSync = true
				local queue = syncQueue
				-- FIXME Luau: Luau sees this as returning void, but then sees an explicit return in runWithPriority and errors
				runWithPriority(ImmediatePriority, function(): ...any
					for index, callback in queue do
						i = index
						repeat
							-- FIXME Luau: Luau doesn't understand loop until nil construct
							callback = callback(isSync) :: any
						until callback == nil
					end
				end)
				syncQueue = nil
			end

			-- finally
			isFlushingSyncQueue = false

			if not ok then
				-- If something throws, leave the remaining callbacks on the queue.
				if syncQueue ~= nil then
					syncQueue = Array.slice(syncQueue, i + 1)
				end
				-- Resume flushing in the next tick
				Scheduler_scheduleCallback(Scheduler_ImmediatePriority, flushSyncCallbackQueue)
				error(result)
			end
		end
		return true
	else
		return false
	end
end

return {
	ImmediatePriority = ImmediatePriority,
	UserBlockingPriority = UserBlockingPriority,
	NormalPriority = NormalPriority,
	LowPriority = LowPriority,
	IdlePriority = IdlePriority,
	NoPriority = NoPriority,

	getCurrentPriorityLevel = getCurrentPriorityLevel,
	flushSyncCallbackQueue = flushSyncCallbackQueue,
	runWithPriority = runWithPriority,
	scheduleCallback = scheduleCallback,
	scheduleSyncCallback = scheduleSyncCallback,
	cancelCallback = cancelCallback,
	now = now,
	requestPaint = requestPaint,
	shouldYield = shouldYield,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000612f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX68857FAE9FF64606A2C1051A30727593">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulingProfiler</string>
								<string name="ScriptGuid">{D8712D4D-8A8A-4AC8-81DB-12AE81F1A992}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react-reconciler/src/SchedulingProfiler.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

local exports = {}
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local WeakMap = LuauPolyfill.WeakMap
type WeakMap<K, V> = LuauPolyfill.WeakMap<K, V>

local ReactFiberLane = require(script.Parent.ReactFiberLane)
type Lane = ReactFiberLane.Lane
type Lanes = ReactFiberLane.Lanes

local ReactInternalTypes = require(script.Parent.ReactInternalTypes)
type Fiber = ReactInternalTypes.Fiber

local ReactTypes = require(Packages.Shared)
type Wakeable = ReactTypes.Wakeable

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulingProfiler = ReactFeatureFlags.enableSchedulingProfiler
local ReactVersion = require(Packages.Shared).ReactVersion
local getComponentName = require(Packages.Shared).getComponentName

-- /**
--  * If performance exists and supports the subset of the User Timing API that we
--  * require.
--  */
local supportsUserTiming = _G.performance ~= nil
local performance = _G.performance or {
	mark = function(str)
		debug.profilebegin(str)
		debug.profileend()
	end,
}

function formatLanes(laneOrLanes: Lane | Lanes): string
	return tostring(laneOrLanes)
end

-- Create a mark on React initialization
if enableSchedulingProfiler then
	if supportsUserTiming then
		performance.mark("--react-init-" .. tostring(ReactVersion))
	end
end

exports.markCommitStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--commit-start-" .. formatLanes(lanes))
		end
	end
end

exports.markCommitStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--commit-stop")
		end
	end
end

-- deviation: we use our custom Map
-- local PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map

-- $FlowFixMe: Flow cannot handle polymorphic WeakMaps
local wakeableIDs: WeakMap<Wakeable, number> = WeakMap.new()
local wakeableID: number = 0
function getWakeableID(wakeable: Wakeable): number
	if not wakeableIDs:has(wakeable) then
		wakeableIDs:set(wakeable, wakeableID)
		wakeableID += 1
	end
	return wakeableIDs:get(wakeable)
end

exports.markComponentSuspended = function(fiber: Fiber, wakeable: Wakeable): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			local id = getWakeableID(wakeable)
			local componentName = getComponentName(fiber.type) or "Unknown"
			-- TODO Add component stack id
			performance.mark("--suspense-suspend-" .. tostring(id) .. "-" .. componentName)
			wakeable:andThen(function()
				performance.mark("--suspense-resolved-" .. tostring(id) .. "-" .. componentName)
			end, function()
				performance.mark("--suspense-rejected-" .. tostring(id) .. "-" .. componentName)
			end)
		end
	end
end

exports.markLayoutEffectsStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--layout-effects-start-" .. formatLanes(lanes))
		end
	end
end

exports.markLayoutEffectsStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--layout-effects-stop")
		end
	end
end

exports.markPassiveEffectsStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--passive-effects-start-" .. formatLanes(lanes))
		end
	end
end

exports.markPassiveEffectsStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--passive-effects-stop")
		end
	end
end

exports.markRenderStarted = function(lanes: Lanes): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--render-start-" .. formatLanes(lanes))
		end
	end
end

exports.markRenderYielded = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--render-yield")
		end
	end
end

exports.markRenderStopped = function(): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--render-stop")
		end
	end
end

exports.markRenderScheduled = function(lane: Lane): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			performance.mark("--schedule-render-" .. formatLanes(lane))
		end
	end
end

exports.markForceUpdateScheduled = function(fiber: Fiber, lane: Lane): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			local componentName = getComponentName(fiber.type) or "Unknown"
			-- TODO Add component stack id
			performance.mark("--schedule-forced-update-" .. formatLanes(lane) .. "-" .. componentName)
		end
	end
end

exports.markStateUpdateScheduled = function(fiber: Fiber, lane: Lane): ()
	if enableSchedulingProfiler then
		if supportsUserTiming then
			local componentName = getComponentName(fiber.type) or "Unknown"
			-- TODO Add component stack id
			performance.mark("--schedule-state-update-" .. formatLanes(lane) .. "-" .. componentName)
		end
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006130</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX8C31DB36C2B843E89B12ADA09B450727">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">forks</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006131</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXE954829292344717A73EEE473583724E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactFiberHostConfig.test</string>
									<string name="ScriptGuid">{0A2A92B5-70EA-4C5E-9ED1-5A3D9C9D9019}</string>
									<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react-reconciler/src/forks/ReactFiberHostConfig.test.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent.Parent

return require(Packages.Dev.ReactTestRenderer)
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006132</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXCC5211561B4B4069AF0507BC6C89DFF2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">pretty-react-hooks</string>
							<string name="ScriptGuid">{D272CA8E-F874-4439-8415-3FEFB928F326}</string>
							<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, TS.getModule(script, "@rbxts", "flipper").src) or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "utils", "binding") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "utils", "hoarcekat") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "utils", "math") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "utils", "motor") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "utils", "testez") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-async") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-async-callback") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-async-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-binding-listener") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-binding-state") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-camera") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-composed-ref") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-debounce-callback") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-debounce-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-debounce-state") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-defer-callback") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-defer-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-defer-state") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-event-listener") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-interval") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-key-press") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-latest") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-latest-callback") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-lifetime") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-motor") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-mount-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-mouse") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-previous") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-property") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-property-binding") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-throttle-callback") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-throttle-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-throttle-state") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-timeout") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-timer") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-unmount-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-update") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-update-effect") or {} do
	exports[_k] = _v
end
for _k, _v in TS.import(script, script, "use-viewport") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006168</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXF2AC00D7562841B4BB4A322668D84CAE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-async</string>
								<string name="ScriptGuid">{1D39C654-292D-4B91-8DE7-3A24090BB19C}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-async") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006169</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX17AC522956ED4488B9D87E5B8AB3C854">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-async</string>
									<string name="ScriptGuid">{5372638A-B4C6-4BEB-ACC6-8C2ABEBF0AF9}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
local useAsyncCallback = TS.import(script, script.Parent.Parent, "use-async-callback").useAsyncCallback
--[[
	*
	* Returns a tuple containing the result and status of a promise. When the
	* dependencies change, pending promises will be cancelled, and a new promise
	* will be started.
	* @param callback The async callback.
	* @param deps The dependencies to watch. Defaults to an empty array.
	* @returns The result and status of the promise.
]]
local function useAsync(callback, deps)
	if deps == nil then
		deps = {}
	end
	local state, asyncCallback = useAsyncCallback(callback)
	useEffect(function()
		asyncCallback()
	end, deps)
	return state.value, state.status, state.message
end
return {
	useAsync = useAsync,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000616a</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX5749762C2FB94BC3A848900CF3B30296">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-async-callback</string>
								<string name="ScriptGuid">{5061DA3B-E730-42EF-8EB4-AE6A11454D39}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-async-callback") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000616b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXB130BC02ABD64D02BC32C8206B7FD4DA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-async-callback</string>
									<string name="ScriptGuid">{27583DB5-2D3F-4E30-BF56-8ADF8E0AD2C8}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useRef = _roact.useRef
local useState = _roact.useState
local useUnmountEffect = TS.import(script, script.Parent.Parent, "use-unmount-effect").useUnmountEffect
--[[
	*
	* Returns a tuple containing the current state of the promise and a callback
	* to start a new promise. Calling it will cancel any previous promise.
	* @param callback The async callback.
	* @returns The state and a new callback.
]]
local function useAsyncCallback(callback)
	local currentPromise = useRef()
	local state, setState = useState({
		status = TS.Promise.Status.Started,
	})
	local execute = useCallback(function(...)
		local args = { ... }
		local _result = currentPromise.current
		if _result ~= nil then
			_result:cancel()
		end
		if state.status ~= TS.Promise.Status.Started then
			setState({
				status = TS.Promise.Status.Started,
			})
		end
		local promise = callback(unpack(args))
		local _arg0 = function(value)
			return setState({
				status = promise:getStatus(),
				value = value,
			})
		end
		local _arg1 = function(message)
			return setState({
				status = promise:getStatus(),
				message = message,
			})
		end
		promise:andThen(_arg0, _arg1)
		currentPromise.current = promise
		return currentPromise.current
	end, { callback })
	useUnmountEffect(function()
		local _result = currentPromise.current
		if _result ~= nil then
			_result:cancel()
		end
	end)
	return state, execute
end
return {
	useAsyncCallback = useAsyncCallback,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000616c</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX27172560FD4A47F2A5EDD0A18C932AAB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-async-effect</string>
								<string name="ScriptGuid">{ACFFB1DB-F9D7-481B-A4AE-EF07715D4358}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-async-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000616d</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX11C7C2154DF4405687A7B89FF49C4227">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-async-effect</string>
									<string name="ScriptGuid">{CFD313A3-CAC4-4014-BB15-78C35C67B049}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
--[[
	*
	* Runs an async effect and cancels the promise when unmounting the effect.
	* Note that effects paused by `await` still run while cancelled, so prefer
	* to use promise chaining instead.
	* @param effect The async effect to run.
	* @param deps The dependencies to run the effect on.
]]
local function useAsyncEffect(effect, deps)
	useEffect(function()
		local promise = effect()
		return function()
			promise:cancel()
		end
	end, deps)
end
return {
	useAsyncEffect = useAsyncEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000616e</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXC1DB37F3E6404729BF5A5518BD63E8BC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-binding-listener</string>
								<string name="ScriptGuid">{4DFD808A-3668-4AED-BAE5-C9B06D85FDBD}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-binding-listener") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000616f</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX96FA97083D9B4C648470BF053060CDC5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-binding-listener</string>
									<string name="ScriptGuid">{FCB1F9BD-1247-4EEC-B2C3-8569B242E6D5}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useEffect = _roact.useEffect
local useMemo = _roact.useMemo
local useLatestCallback = TS.import(script, script.Parent.Parent, "use-latest-callback").useLatestCallback
local _binding = TS.import(script, script.Parent.Parent, "utils", "binding")
local getBindingApi = _binding.getBindingApi
local isBinding = _binding.isBinding
--[[
	*
	* Subscribes to a binding and calls the given listener when the binding
	* updates. If the value passed is not a binding, the listener will be called
	* with the value.
	*
	* The `listener` function is safe to not be memoized, as it will only be
	* called when the binding updates.
	*
	* @param binding The binding to subscribe to.
	* @param listener The function to call when the binding updates.
]]
local function useBindingListener(binding, listener)
	local api = useMemo(function()
		return if isBinding(binding) then getBindingApi(binding) else nil
	end, { binding })
	local listenerCallback = useLatestCallback(listener)
	useEffect(function()
		if api then
			listenerCallback(api.getValue())
			return api.subscribe(listenerCallback)
		else
			listenerCallback(binding)
		end
	end, { binding })
end
return {
	useBindingListener = useBindingListener,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006170</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX10ACA1AF7A994D38AA697716BA992D30">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-binding-state</string>
								<string name="ScriptGuid">{B2D17A22-207C-4C7A-B576-BCEEF9C4C423}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-binding-state") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006171</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXBB3A6E8402D945DA95239662D955CED7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-binding-state</string>
									<string name="ScriptGuid">{608F7D33-A3F5-4035-AAFD-5172A561041D}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useState = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useState
local useBindingListener = TS.import(script, script.Parent.Parent, "use-binding-listener").useBindingListener
local getBindingValue = TS.import(script, script.Parent.Parent, "utils", "binding").getBindingValue
--[[
	*
	* Returns the value of a binding. If the binding updates, the component will
	* be re-rendered. Non-binding values will be returned as-is.
	* @param binding The binding to get the value of.
	* @returns The value of the binding.
]]
local function useBindingState(binding)
	local value, setValue = useState(function()
		return getBindingValue(binding)
	end)
	useBindingListener(binding, setValue)
	return value
end
return {
	useBindingState = useBindingState,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006172</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX872BF16741E2485E88EED0A78F36BC3B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-camera</string>
								<string name="ScriptGuid">{1F854BC1-193B-4330-AC9A-0618FFDEA2BA}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-camera") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006173</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX4F14A800CF434BA99DF026AB40E93332">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-camera</string>
									<string name="ScriptGuid">{D6E03DDF-4016-4D04-8EF4-AEB76175E338}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useState = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useState
local Workspace = TS.import(script, TS.getModule(script, "@rbxts", "services")).Workspace
local useEventListener = TS.import(script, script.Parent.Parent, "use-event-listener").useEventListener
--[[
	*
	* Returns the current camera. Updates when the current camera changes.
	* @returns A camera instance.
]]
local function useCamera()
	local camera, setCamera = useState(Workspace.CurrentCamera)
	useEventListener(Workspace:GetPropertyChangedSignal("CurrentCamera"), function()
		if Workspace.CurrentCamera then
			setCamera(Workspace.CurrentCamera)
		end
	end)
	return camera
end
return {
	useCamera = useCamera,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006174</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXAA29EAC5106E48FFAF1E3BCD5F542645">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-composed-ref</string>
								<string name="ScriptGuid">{B3EFE26B-74E0-4A43-ADDD-C566C433AFC9}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-composed-ref") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006175</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX1F338BD2B44A4B3592038BF23E1221BD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-composed-ref</string>
									<string name="ScriptGuid">{AFA219D3-880C-4A5B-A727-D8BD98CDBB0B}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useMemo = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useMemo
local useLatestCallback = TS.import(script, script.Parent.Parent, "use-latest-callback").useLatestCallback
--[[
	*
	* Composes multiple ref functions into a single ref function and memoizes
	* the result.
	*
	* To prevent excess ref calls, the composed ref is only created once on mount.
	* However, it will call the latest refs passed, so it is safe to pass in refs
	* that might change.
	*
	* @param refs The ref functions to compose.
	* @returns A ref function that calls all of the ref functions passed in.
]]
local composeRefs
local function useComposedRef(...)
	local refs = { ... }
	local composedRef = useMemo(function()
		return composeRefs(unpack(refs))
	end, refs)
	-- Make sure the function returned never changes when dependencies change.
	-- Otherwise, the ref will be called again, and might cause other problems.
	return useLatestCallback(composedRef)
end
--[[
	*
	* Composes multiple ref functions into a single ref function.
	* @param refs The ref functions to compose.
	* @returns A ref function that calls all of the ref functions passed in.
]]
function composeRefs(...)
	local refs = { ... }
	-- ▼ ReadonlyArray.filterUndefined ▼
	local _length = 0
	for _i in refs do
		if _i > _length then
			_length = _i
		end
	end
	local _result = {}
	local _resultLength = 0
	for _i = 1, _length do
		local _v = refs[_i]
		if _v ~= nil then
			_resultLength += 1
			_result[_resultLength] = _v
		end
	end
	-- ▲ ReadonlyArray.filterUndefined ▲
	local refsDefined = _result
	return function(rbx)
		for _, ref in refsDefined do
			ref(rbx)
		end
	end
end
return {
	useComposedRef = useComposedRef,
	composeRefs = composeRefs,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006176</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX43C40FEF421E45DF8E8F17AFF0F47AC6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-debounce-callback</string>
								<string name="ScriptGuid">{D49543BC-3389-490C-BFA2-3EC26BA3BE86}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-debounce-callback") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006177</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX1C5E696AD02943ADBA748ED47C07521D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-debounce-callback</string>
									<string name="ScriptGuid">{6C149DBB-FDEA-41D3-B2FB-3F5C02C888AC}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useMemo = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useMemo
local debounce = TS.import(script, TS.getModule(script, "@rbxts", "set-timeout").out).debounce
local useLatest = TS.import(script, script.Parent.Parent, "use-latest").useLatest
local useUnmountEffect = TS.import(script, script.Parent.Parent, "use-unmount-effect").useUnmountEffect
--[[
	*
	* Creates a debounced function that delays invoking `callback` until after `wait`
	* seconds have elapsed since the last time the debounced function was invoked.
	* The `callback` is invoked with the last arguments provided to the debounced
	* function. Subsequent calls to the debounced function return the result of
	* the last `callback` invocation.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `debounce` and `throttle`.
	*
	* @param callback The function to debounce.
	* @param options The options object.
	* @returns The new debounced function.
]]
local function useDebounceCallback(callback, options)
	if options == nil then
		options = {}
	end
	local callbackRef = useLatest(callback)
	local debounced = useMemo(function()
		return debounce(function(...)
			local args = { ... }
			return callbackRef.current(unpack(args))
		end, options.wait, options)
	end, {})
	useUnmountEffect(function()
		debounced.cancel()
	end)
	return {
		run = debounced,
		cancel = debounced.cancel,
		flush = debounced.flush,
		pending = debounced.pending,
	}
end
return {
	useDebounceCallback = useDebounceCallback,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006178</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXDE96D59D9DA54C0CB0B84F91574D8C79">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-debounce-effect</string>
								<string name="ScriptGuid">{1382DB1B-0CF7-4841-B2DE-ECCA4FE84F4D}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-debounce-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006179</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX40F2D8E8519940DC9297AE51C481321C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-debounce-effect</string>
									<string name="ScriptGuid">{BD3B0E63-D28D-4004-96D1-94B3043F942D}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
local useDebounceCallback = TS.import(script, script.Parent.Parent, "use-debounce-callback").useDebounceCallback
local useUpdate = TS.import(script, script.Parent.Parent, "use-update").useUpdate
local useUpdateEffect = TS.import(script, script.Parent.Parent, "use-update-effect").useUpdateEffect
--[[
	*
	* Creates a debounced effect that delays invoking `effect` until after `wait`
	* seconds have elapsed since the last time the debounced function was invoked.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `debounce` and `throttle`.
	*
	* @param effect The effect to debounce.
	* @param dependencies The dependencies array.
	* @param options The options object.
]]
local function useDebounceEffect(effect, dependencies, options)
	local update = useUpdate()
	local _binding = useDebounceCallback(update, options)
	local run = _binding.run
	useEffect(function()
		return run()
	end, dependencies)
	useUpdateEffect(effect, { update })
end
return {
	useDebounceEffect = useDebounceEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000617a</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXBFE761C85E444F07B93DA83DAA07E1F7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-debounce-state</string>
								<string name="ScriptGuid">{DB6F6F51-13E5-40E1-B148-B41220D339D2}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-debounce-state") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000617b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX3FDE3107944944B6B4B3E3B64EE39E2F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-debounce-state</string>
									<string name="ScriptGuid">{A210DC02-4784-4D7B-BB1B-89FA848A04ED}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useState = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useState
local useDebounceCallback = TS.import(script, script.Parent.Parent, "use-debounce-callback").useDebounceCallback
--[[
	*
	* Delays updating `state` until after `wait` seconds have elapsed since the
	* last time the debounced function was invoked. Set to the most recently passed
	* `state` after the delay.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `debounce` and `throttle`.
	*
	* @param initialState The value to debounce.
	* @param options The options object.
	* @returns A tuple containing the debounced value and a function to update it.
]]
local function useDebounceState(initialState, options)
	local state, setState = useState(initialState)
	return state, useDebounceCallback(setState, options).run
end
return {
	useDebounceState = useDebounceState,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000617c</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXB83BBBDB26D04918B40C11863F3AA443">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-defer-callback</string>
								<string name="ScriptGuid">{DBC52697-22CD-46DA-BB23-412CCBF6102C}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-defer-callback") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000617d</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXF5C3C75BF24D4E4791080F91BCBBFF4C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-defer-callback</string>
									<string name="ScriptGuid">{A2657B4C-A10B-4ECA-A319-F1BC2456001E}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useRef = _roact.useRef
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local useLatest = TS.import(script, script.Parent.Parent, "use-latest").useLatest
--[[
	*
	* Defers a callback to be executed on the next Heartbeat frame. Consecutive
	* calls to the returned `execute` function will cancel the previous call.
	* @param callback The callback to defer
	* @returns A tuple containing the `execute` and `cancel` functions
]]
local function useDeferCallback(callback)
	local callbackRef = useLatest(callback)
	local connectionRef = useRef()
	local cancel = useCallback(function()
		local _result = connectionRef.current
		if _result ~= nil then
			_result:Disconnect()
		end
		connectionRef.current = nil
	end, {})
	local execute = useCallback(function(...)
		local args = { ... }
		cancel()
		connectionRef.current = RunService.Heartbeat:Once(function()
			connectionRef.current = nil
			callbackRef.current(unpack(args))
		end)
	end, {})
	return execute, cancel
end
return {
	useDeferCallback = useDeferCallback,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000617e</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX9B183E2C546C4EAB859FA7CC67DF001D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-defer-effect</string>
								<string name="ScriptGuid">{313FB7C6-68B0-453E-9FDB-006A0450F621}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-defer-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000617f</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX7D57919A8E9C44FEAF5761CC08B16FDD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-defer-effect</string>
									<string name="ScriptGuid">{01F805FC-2683-4FED-BE66-78677D2337B3}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
local useDeferCallback = TS.import(script, script.Parent.Parent, "use-defer-callback").useDeferCallback
--[[
	*
	* Like `useEffect`, but the callback is deferred to the next Heartbeat frame.
	* @param callback The callback to run
	* @param dependencies Optional dependencies to trigger the effect
]]
local function useDeferEffect(callback, dependencies)
	local deferredCallback, cancel = useDeferCallback(callback)
	useEffect(function()
		deferredCallback()
		return cancel
	end, dependencies)
end
return {
	useDeferEffect = useDeferEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006180</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXA20306BD938D45C69244B734DC01EB19">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-defer-state</string>
								<string name="ScriptGuid">{9F37010D-A2CB-406C-BAFD-F4A66D1382CC}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-defer-state") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006181</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX86D3E2758431458D9D73E8F374B61311">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-defer-state</string>
									<string name="ScriptGuid">{CA7DC59F-595A-4F03-820C-C0BA41D493E5}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useState = _roact.useState
local useDeferCallback = TS.import(script, script.Parent.Parent, "use-defer-callback").useDeferCallback
local useLatest = TS.import(script, script.Parent.Parent, "use-latest").useLatest
local useUnmountEffect = TS.import(script, script.Parent.Parent, "use-unmount-effect").useUnmountEffect
local resolve = function(value, state)
	local _value = value
	return if type(_value) == "function" then value(state) else value
end
--[[
	*
	* Like `useState`, but `setState` will update the state on the next Heartbeat
	* frame. Only the latest update in a frame will run.
	*
	* This is useful for improving performance when updating state in response to
	* events that fire rapidly in succession.
	*
	* @param initialState Optional initial state
	* @returns A tuple containing the state and a function to update it
]]
local function useDeferState(initialState)
	local state, innerSetState = useState(initialState)
	local deferredSetState, cancel = useDeferCallback(innerSetState)
	local latestState = useLatest(state)
	-- Wrap 'deferState' to allow multiple changes to state in one frame through
	-- the `latestState` reference
	local setState = useCallback(function(value)
		latestState.current = resolve(value, latestState.current)
		deferredSetState(latestState.current)
	end, {})
	useUnmountEffect(cancel)
	return state, setState
end
return {
	useDeferState = useDeferState,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006182</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX2E2EF59FC98D4A7FBE331542C220D6C7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-event-listener</string>
								<string name="ScriptGuid">{35BD0957-249E-450A-906B-243FB2959930}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-event-listener") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006183</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX2F7AB83A457B4147A0510584D7C20F72">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-event-listener</string>
									<string name="ScriptGuid">{5E62493B-E67A-4E65-85DA-322649809ADE}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
local useLatest = TS.import(script, script.Parent.Parent, "use-latest").useLatest
local connect = function(event, callback)
	local _event = event
	if typeof(_event) == "RBXScriptSignal" then
		-- With deferred events, a "hard disconnect" is necessary to avoid causing
		-- state updates after a component unmounts. Use 'Connected' to check if
		-- the connection is still valid before invoking the callback.
		-- https://devforum.roblox.com/t/deferred-engine-events/2276564/99
		local connection
		connection = event:Connect(function(...)
			local args = { ... }
			if connection.Connected then
				return callback(unpack(args))
			end
		end)
		return connection
	elseif event.Connect ~= nil then
		return event:Connect(callback)
	elseif event.connect ~= nil then
		return event:connect(callback)
	elseif event.subscribe ~= nil then
		return event:subscribe(callback)
	else
		error("Event-like object does not have a supported connect method.")
	end
end
local disconnect = function(connection)
	local _connection = connection
	if type(_connection) == "function" then
		connection()
	else
		local _connection_1 = connection
		local _condition = typeof(_connection_1) == "RBXScriptConnection"
		if not _condition then
			_condition = connection.Disconnect ~= nil
		end
		if _condition then
			connection:Disconnect()
		elseif connection.disconnect ~= nil then
			connection:disconnect()
		else
			error("Connection-like object does not have a supported disconnect method.")
		end
	end
end
--[[
	*
	* Subscribes to an event-like object. The subscription is automatically
	* disconnected when the component unmounts.
	*
	* If the event or listener is `undefined`, the event will not be subscribed to,
	* and the subscription will be disconnected if it was previously connected.
	*
	* The listener is memoized, so it is safe to pass a callback that is recreated
	* on every render.
	*
	* @param event The event-like object to subscribe to.
	* @param listener The listener to subscribe with.
	* @param options Options for the subscription.
]]
local function useEventListener(event, listener, options)
	if options == nil then
		options = {}
	end
	local _binding = options
	local once = _binding.once
	if once == nil then
		once = false
	end
	local connected = _binding.connected
	if connected == nil then
		connected = true
	end
	local listenerRef = useLatest(listener)
	useEffect(function()
		if not event or (not listener or not connected) then
			return nil
		end
		local canDisconnect = true
		local connection
		connection = connect(event, function(...)
			local args = { ... }
			if once then
				disconnect(connection)
				canDisconnect = false
			end
			local _result = listenerRef.current
			if _result ~= nil then
				_result(unpack(args))
			end
		end)
		return function()
			if canDisconnect then
				disconnect(connection)
			end
		end
	end, { event, connected, listener ~= nil })
end
return {
	useEventListener = useEventListener,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006184</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXB07914568D7D4F2F9E0F7BE603790ED1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-interval</string>
								<string name="ScriptGuid">{CD7BC757-1EB3-4208-9144-36E285063247}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-interval") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006185</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX871CAAFC3F07477E8DA68C5AF1741D01">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-interval</string>
									<string name="ScriptGuid">{F4872FE4-90C0-4619-88FE-C3D5376B1A31}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useEffect = _roact.useEffect
local useRef = _roact.useRef
local setInterval = TS.import(script, TS.getModule(script, "@rbxts", "set-timeout").out).setInterval
local useLatestCallback = TS.import(script, script.Parent.Parent, "use-latest-callback").useLatestCallback
--[[
	*
	* Sets an interval that runs the callback function every `delay` seconds. If
	* `delay` is `undefined`, the interval is cleared. If the delay changes, the
	* interval is reset.
	* @param callback The callback function to run.
	* @param delay The delay in seconds between each interval.
	* @param options The options for the interval.
	* @returns A function that clears the interval.
]]
local function useInterval(callback, delay, options)
	if options == nil then
		options = {}
	end
	local _binding = options
	local immediate = _binding.immediate
	if immediate == nil then
		immediate = false
	end
	local callbackMemo = useLatestCallback(callback)
	local cancel = useRef()
	local clear = useCallback(function()
		local _result = cancel.current
		if _result ~= nil then
			_result()
		end
	end, {})
	useEffect(function()
		if delay == nil then
			return nil
		end
		if immediate then
			callbackMemo()
		end
		cancel.current = setInterval(callbackMemo, delay)
		return clear
	end, { delay })
	return clear
end
return {
	useInterval = useInterval,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006186</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX72C5203603644D37A0CF5DEFED78919F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-key-press</string>
								<string name="ScriptGuid">{B5D81019-F0C9-4E03-AE7D-60AF9F3D0990}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-key-press") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006187</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX493A88A4792D4F0F92C37CC4BB2D480E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-key-press</string>
									<string name="ScriptGuid">{3147904F-8727-48F3-915A-20D8BDE4942D}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useEffect = _roact.useEffect
local useMemo = _roact.useMemo
local useState = _roact.useState
local _services = TS.import(script, TS.getModule(script, "@rbxts", "services"))
local ContextActionService = _services.ContextActionService
local HttpService = _services.HttpService
local UserInputService = _services.UserInputService
local useEventListener = TS.import(script, script.Parent.Parent, "use-event-listener").useEventListener
--[[
	*
	* A single key code name.
]]
--[[
	*
	* A single key code or a combination of key codes.
]]
--[[
	*
	* Returns whether the passed key or shortcut is pressed. The hook expects one
	* or more key code, which can be:
	*
	* - A single key code `"W"`
	* - A combination of key codes `"W+Space"`
	* - An array of key codes `["W", "Space"]`
	*
	* Each combination is treated as its own shortcut. If passed more than one
	* combination, the hook will return `true` if any of the combinations are
	* pressed.
	*
	* @param keyCodeCombos The key code or combination of key codes to listen for.
	* @returns Whether the key or combination of keys is pressed.
]]
local function useKeyPress(keyCodeCombos, _param)
	if _param == nil then
		_param = {}
	end
	local bindAction = _param.bindAction
	if bindAction == nil then
		bindAction = false
	end
	local actionPriority = _param.actionPriority
	if actionPriority == nil then
		actionPriority = Enum.ContextActionPriority.High.Value
	end
	local actionName = _param.actionName
	if actionName == nil then
		actionName = if bindAction then HttpService:GenerateGUID(false) else ""
	end
	local actionInputTypes = _param.actionInputTypes
	if actionInputTypes == nil then
		actionInputTypes = { Enum.UserInputType.Keyboard, Enum.UserInputType.Gamepad1 }
	end
	local pressed, setPressed = useState(false)
	local keyCombos = useMemo(function()
		local _keyCodeCombos = keyCodeCombos
		local _arg0 = function(keyCodes)
			local _keyCodes = keyCodes
			if type(_keyCodes) == "string" then
				return string.split(keyCodes, "+")
			else
				return keyCodes
			end
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_keyCodeCombos)
		for _k, _v in _keyCodeCombos do
			_newValue[_k] = _arg0(_v, _k - 1, _keyCodeCombos)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end, keyCodeCombos)
	local keySet = useMemo(function()
		local keySet = {}
		for _, keys in keyCombos do
			for _1, key in keys do
				keySet[key] = true
			end
		end
		return keySet
	end, keyCombos)
	local keysDown = useMemo(function()
		return {}
	end, keyCodeCombos)
	local updatePressed = function()
		local _arg0 = function(keys)
			local _keys = keys
			local _arg0_1 = function(key)
				local _key = key
				return keysDown[_key] ~= nil
			end
			-- ▼ ReadonlyArray.every ▼
			local _result = true
			for _k, _v in _keys do
				if not _arg0_1(_v, _k - 1, _keys) then
					_result = false
					break
				end
			end
			-- ▲ ReadonlyArray.every ▲
			return _result
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in keyCombos do
			if _arg0(_v, _k - 1, keyCombos) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		setPressed(_result)
	end
	useEventListener(UserInputService.InputBegan, function(input, gameProcessed)
		local _condition = not gameProcessed
		if _condition then
			local _name = input.KeyCode.Name
			_condition = keySet[_name] ~= nil
		end
		if _condition then
			local _name = input.KeyCode.Name
			keysDown[_name] = true
			updatePressed()
		end
	end)
	useEventListener(UserInputService.InputEnded, function(input)
		local _name = input.KeyCode.Name
		if keySet[_name] ~= nil then
			local _name_1 = input.KeyCode.Name
			keysDown[_name_1] = nil
			updatePressed()
		end
	end)
	useEffect(function()
		-- Prevents the game from processing the key
		if not bindAction then
			return nil
		end
		ContextActionService:BindActionAtPriority(actionName, function(_, state, input)
			local _name = input.KeyCode.Name
			local valid = keySet[_name] ~= nil
			if not valid then
				return Enum.ContextActionResult.Pass
			end
			if state == Enum.UserInputState.Begin then
				local _name_1 = input.KeyCode.Name
				keysDown[_name_1] = true
			elseif state == Enum.UserInputState.End then
				local _name_1 = input.KeyCode.Name
				keysDown[_name_1] = nil
			end
			updatePressed()
			return Enum.ContextActionResult.Sink
		end, false, actionPriority, unpack(actionInputTypes))
		return function()
			ContextActionService:UnbindAction(actionName)
		end
	end, { bindAction, actionName, actionPriority })
	return pressed
end
return {
	useKeyPress = useKeyPress,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006188</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX465829D84914454299AE465F37BBDCFA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-latest</string>
								<string name="ScriptGuid">{6FD00AEB-5B2A-41C9-859C-2DBAF518D5E3}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-latest") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006189</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX78AFE668C3B844E3A9A46AA14E7A48D5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-latest</string>
									<string name="ScriptGuid">{722435DF-EBA9-45A2-B140-4A0185E31C15}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useMemo = _roact.useMemo
local useRef = _roact.useRef
local isStrictEqual = TS.import(script, script.Parent.Parent, "use-previous").isStrictEqual
--[[
	*
	* Returns a mutable ref that points to the latest value of the input.
	*
	* Takes an optional `predicate` function as the second argument that receives
	* the previous and current value. If the predicate returns `false`, the values
	* are not equal, and the previous value is updated.
	*
	* @param value The value to track.
	* @returns A mutable reference to the value.
]]
local function useLatest(value, predicate)
	if predicate == nil then
		predicate = isStrictEqual
	end
	local ref = useRef(value)
	useMemo(function()
		if not predicate(ref.current, value) then
			ref.current = value
		end
	end, { value })
	return ref
end
return {
	useLatest = useLatest,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000618a</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX97578BF031934EBA8299F97644B8FF2F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-latest-callback</string>
								<string name="ScriptGuid">{DDDE3BC0-E00A-4D20-9665-F783DA6AC9AA}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-latest-callback") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000618b</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX77729D4CBC7C4B63BB7707A23B392AEA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-latest-callback</string>
									<string name="ScriptGuid">{523ACCCB-19DE-4A9C-98F5-52ACDAEE9DC3}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useRef = _roact.useRef
--[[
	*
	* Returns a memoized callback that wraps the latest version of the input
	* callback.
	* @param callback The callback to memoize.
	* @returns The memoized callback.
]]
local function useLatestCallback(callback)
	local callbackRef = useRef(callback)
	callbackRef.current = callback
	return useCallback(function(...)
		local args = { ... }
		return callbackRef.current(unpack(args))
	end, {})
end
return {
	useLatestCallback = useLatestCallback,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000618c</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX3EADB7708133413DAEE153FB252506E5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-lifetime</string>
								<string name="ScriptGuid">{C6385D7D-057D-42BE-9F0A-44261AAB7596}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-lifetime") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000618d</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX7E044784EB5648E3BC1C68C6D1EABECC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-lifetime</string>
									<string name="ScriptGuid">{E0D91874-352F-47FE-BDE5-64D5C70AE56C}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useBinding = _roact.useBinding
local useEffect = _roact.useEffect
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local useEventListener = TS.import(script, script.Parent.Parent, "use-event-listener").useEventListener
--[[
	*
	* Returns the lifetime of the component in seconds. Updates every frame on
	* the Heartbeat event.
	*
	* If the dependency array is provided, the lifetime timer will reset when
	* any of the dependencies change.
	*
	* @param dependencies An optional array of dependencies to reset the timer.
	* @returns A binding of the component's lifetime.
]]
local function useLifetime(dependencies)
	if dependencies == nil then
		dependencies = {}
	end
	local lifetime, setLifetime = useBinding(0)
	useEventListener(RunService.Heartbeat, function(deltaTime)
		setLifetime(lifetime:getValue() + deltaTime)
	end)
	useEffect(function()
		setLifetime(0)
	end, dependencies)
	return lifetime
end
return {
	useLifetime = useLifetime,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000618e</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX88FC63CF30E244E3B55E91E31813D1BA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-motor</string>
								<string name="ScriptGuid">{3E13370F-727D-4E8D-B493-DEDC444E0D2C}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-motor") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000618f</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5BBB08C5A10D45D3B90AC145020D4BCC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-motor</string>
									<string name="ScriptGuid">{E66D1484-67CE-442D-833F-128B068445A1}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _flipper = TS.import(script, TS.getModule(script, "@rbxts", "flipper").src)
local GroupMotor = _flipper.GroupMotor
local SingleMotor = _flipper.SingleMotor
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useBinding = _roact.useBinding
local useCallback = _roact.useCallback
local useEffect = _roact.useEffect
local useMemo = _roact.useMemo
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local _motor = TS.import(script, script.Parent.Parent, "utils", "motor")
local groupMotorGetState = _motor.groupMotorGetState
local groupMotorImpulse = _motor.groupMotorImpulse
local groupMotorSetState = _motor.groupMotorSetState
local motorGetState = _motor.motorGetState
local motorImpulse = _motor.motorImpulse
local motorSetState = _motor.motorSetState
--[[
	*
	* Creates a motor and returns a binding and a setter for the motor's goal.
	* Returns an additional API for changing the motor's state.
	* @param initialValue The initial value of the motor
	* @param useImplicitConnections Whether to use implicit connections
	* @returns A tuple containing the binding, setter, and API
]]
local useSingleMotor, useGroupMotor
local function useMotor(initialValue, useImplicitConnections)
	if useImplicitConnections == nil then
		useImplicitConnections = true
	end
	local _initialValue = initialValue
	if type(_initialValue) == "number" then
		return useSingleMotor(initialValue, useImplicitConnections)
	else
		return useGroupMotor(initialValue, useImplicitConnections)
	end
end
function useSingleMotor(initialValue, useImplicitConnections)
	if useImplicitConnections == nil then
		useImplicitConnections = true
	end
	local motor = useMemo(function()
		return SingleMotor.new(initialValue, false)
	end, {})
	local api = useMemo(function()
		return {
			motor = motor,
			setState = function(state)
				return motorSetState(motor, state)
			end,
			getState = function()
				return motorGetState(motor)
			end,
			impulse = function(impulse)
				return motorImpulse(motor, impulse)
			end,
		}
	end, {})
	local binding, setBinding = useBinding(initialValue)
	useEffect(function()
		if not useImplicitConnections then
			local connection = motor:onStep(setBinding)
			return function()
				connection:disconnect()
			end
		end
		local connection = RunService.Heartbeat:Connect(function(deltaTime)
			if not motor:step(deltaTime) then
				setBinding(motor:getValue())
			end
		end)
		local onComplete = motor:onComplete(function()
			setBinding(motor:getValue())
		end)
		return function()
			connection:Disconnect()
			onComplete:disconnect()
			motor:destroy()
		end
	end, { useImplicitConnections })
	local setGoal = useCallback(function(goal)
		motor:setGoal(goal)
	end, {})
	return binding, setGoal, api
end
function useGroupMotor(initialValue, useImplicitConnections)
	if useImplicitConnections == nil then
		useImplicitConnections = true
	end
	local motor = useMemo(function()
		return GroupMotor.new(initialValue, false)
	end, {})
	local api = useMemo(function()
		return {
			motor = motor,
			setState = function(states)
				return groupMotorSetState(motor, states)
			end,
			getState = function()
				return groupMotorGetState(motor)
			end,
			impulse = function(impulses)
				return groupMotorImpulse(motor, impulses)
			end,
		}
	end, {})
	local binding, setBinding = useBinding(initialValue)
	useEffect(function()
		if not useImplicitConnections then
			local connection = motor:onStep(setBinding)
			return function()
				connection:disconnect()
			end
		end
		local heartbeat = RunService.Heartbeat:Connect(function(deltaTime)
			if not motor:step(deltaTime) then
				setBinding(motor:getValue())
			end
		end)
		local onComplete = motor:onComplete(function()
			setBinding(motor:getValue())
		end)
		return function()
			heartbeat:Disconnect()
			onComplete:disconnect()
			motor:destroy()
		end
	end, { useImplicitConnections })
	local setGoal = useCallback(function(goal)
		motor:setGoal(goal)
	end, {})
	return binding, setGoal, api
end
return {
	useMotor = useMotor,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006190</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX2FB7ACD783374BE6A7043CAFD5ABC112">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-mount-effect</string>
								<string name="ScriptGuid">{0EC43C77-E6AC-4A20-B4D5-8792F2DB567A}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-mount-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006191</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX49CC01D599F84DEDAB11571C631FDB7C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-mount-effect</string>
									<string name="ScriptGuid">{1B748F1C-AC43-44D1-AF74-33CEE5177D83}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
--[[
	*
	* Runs a callback when the component is mounted.
	* @param callback The callback to run.
]]
local function useMountEffect(callback)
	useEffect(callback, {})
end
return {
	useMountEffect = useMountEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006192</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXFAD0BC2F77094AF2BC12CC961D266954">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-mouse</string>
								<string name="ScriptGuid">{55EC48CA-8053-4DED-89B0-76D3F55BA07B}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-mouse") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006193</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX07DBA331A85644008F465E594B0286F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-mouse</string>
									<string name="ScriptGuid">{091066D6-0A32-43FD-B690-1B66EB107560}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useBinding = _roact.useBinding
local useMemo = _roact.useMemo
local UserInputService = TS.import(script, TS.getModule(script, "@rbxts", "services")).UserInputService
local useEventListener = TS.import(script, script.Parent.Parent, "use-event-listener").useEventListener
local useMountEffect = TS.import(script, script.Parent.Parent, "use-mount-effect").useMountEffect
--[[
	*
	* Returns a binding to the mouse position.
	* @param listener Optional listener to be called when the mouse position changes.
	* @returns A binding to mouse position.
]]
local function useMouse(listener)
	local mouse, setMouse = useBinding(Vector2.one)
	useEventListener(UserInputService.InputChanged, function(input)
		if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
			setMouse(UserInputService:GetMouseLocation())
			local _result = listener
			if _result ~= nil then
				_result(UserInputService:GetMouseLocation())
			end
		end
	end)
	useMemo(function()
		setMouse(UserInputService:GetMouseLocation())
	end, {})
	useMountEffect(function()
		local _result = listener
		if _result ~= nil then
			_result(mouse:getValue())
		end
	end)
	return mouse
end
return {
	useMouse = useMouse,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006194</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX9E85A5B98EFB4FEA91895080740D5D3B">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-previous</string>
								<string name="ScriptGuid">{2D00BE13-AF6A-49AD-8ADE-0795CA5675F0}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-previous") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006195</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX4215AE433928474CACB7176EBD7825E1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-previous</string>
									<string name="ScriptGuid">{7C9A4FF3-77FF-4ECE-B241-ECA8F89CB115}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useMemo = _roact.useMemo
local useRef = _roact.useRef
local isStrictEqual = function(a, b)
	return a == b
end
--[[
	*
	* Returns the most recent value from the previous render. Returns `undefined`
	* on the first render.
	*
	* Takes an optional `predicate` function as the second argument that receives
	* the previous and current value. If the predicate returns `false`, the values
	* are not equal, and the previous value is updated.
	*
	* @param value The value to return on the next render if it changes.
	* @param predicate Optional function to determine whether the value changed.
	* Defaults to a strict equality check (`===`).
	* @returns The previous value.
]]
local function usePrevious(value, predicate)
	if predicate == nil then
		predicate = isStrictEqual
	end
	local previousRef = useRef()
	local currentRef = useRef()
	useMemo(function()
		if not predicate(currentRef.current, value) then
			previousRef.current = currentRef.current
			currentRef.current = value
		end
	end, { value })
	return previousRef.current
end
return {
	usePrevious = usePrevious,
	isStrictEqual = isStrictEqual,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006196</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXE1942DF0E90140B58F35BC3522051727">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-property</string>
								<string name="ScriptGuid">{8CEE6820-13F7-40E3-AF10-AC33F61A3261}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-property") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006197</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX134542BB01664ABB988B4C217A119637">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">types</string>
									<string name="ScriptGuid">{85A6D2D7-1D04-4F4E-93ED-D175F203D0C0}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
return nil
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006198</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6EF59FB590344B9CA7982D7F1C775811">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-property</string>
									<string name="ScriptGuid">{17760C3E-5877-4CF6-B7C3-30F2A5A59DE5}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useMemo = _roact.useMemo
local useState = _roact.useState
--[[
	*
	* Tracks the state of multiple properties on an Instance. Returns the values and
	* a Change object that can be spread into the `Change` property of an element.
	* @param propertyNames The names of the properties to track.
	* @returns A tuple containing the values of the properties and a ref callback.
]]
local function useProperty(...)
	local propertyNames = { ... }
	local values, setValues = useState({})
	local events = useMemo(function()
		local _propertyNames = propertyNames
		local _arg0 = function(events, property, index)
			events[property] = function(rbx)
				setValues(function(values)
					local update = table.clone(values)
					update[index + 1] = rbx[property]
					return update
				end)
			end
			return events
		end
		-- ▼ ReadonlyArray.reduce ▼
		local _result = {}
		local _callback = _arg0
		for _i = 1, #_propertyNames do
			_result = _callback(_result, _propertyNames[_i], _i - 1, _propertyNames)
		end
		-- ▲ ReadonlyArray.reduce ▲
		return _result
	end, propertyNames)
	return useMemo(function()
		local results = table.clone(values)
		results[#propertyNames + 1] = events
		return results
	end, { values, events })
end
return {
	useProperty = useProperty,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006199</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXA09DE1D64E4F4826B08B08019247DFAF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-property-binding</string>
								<string name="ScriptGuid">{6A76D880-9D4D-4A3D-92BD-49B4874B7BEB}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-property-binding") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000619a</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5D56BF7B38DC4A3CAD1A8B8B2753CEC3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-property-binding</string>
									<string name="ScriptGuid">{C57F05F6-111E-4B3D-ADB6-414CE1DB709A}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local createBinding = _roact.createBinding
local useMemo = _roact.useMemo
--[[
	*
	* Tracks the state of multiple properties on an Instance. Returns the values and
	* a Change object that can be spread into the `Change` property of an element.
	* @param propertyNames The names of the properties to track.
	* @returns A tuple containing the values of the properties and a ref callback.
]]
local function usePropertyBinding(...)
	local propertyNames = { ... }
	local _binding = useMemo(function()
		local bindings = {}
		local setBindings = {}
		local _propertyNames = propertyNames
		local _arg0 = function(property, index)
			local binding, setBinding = createBinding(nil)
			bindings[index + 1] = binding
			setBindings[index + 1] = setBinding
		end
		for _k, _v in _propertyNames do
			_arg0(_v, _k - 1, _propertyNames)
		end
		return { bindings, setBindings }
	end, propertyNames)
	local bindings = _binding[1]
	local bindingSetters = _binding[2]
	local events = useMemo(function()
		local _propertyNames = propertyNames
		local _arg0 = function(events, property, index)
			events[property] = function(rbx)
				bindingSetters[index + 1](rbx[property])
			end
			return events
		end
		-- ▼ ReadonlyArray.reduce ▼
		local _result = {}
		local _callback = _arg0
		for _i = 1, #_propertyNames do
			_result = _callback(_result, _propertyNames[_i], _i - 1, _propertyNames)
		end
		-- ▲ ReadonlyArray.reduce ▲
		return _result
	end, propertyNames)
	return useMemo(function()
		local results = table.clone(bindings)
		results[#propertyNames + 1] = events
		return results
	end, { bindings, events })
end
return {
	usePropertyBinding = usePropertyBinding,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000619b</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXC4B4DD6226544906A295BA1835E2A4B6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-throttle-callback</string>
								<string name="ScriptGuid">{B13757C0-7556-4DC5-AAAB-F40EE90E6F01}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-throttle-callback") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000619c</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX4C2DFC42F4D044E89E08C0F108C5FC82">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-throttle-callback</string>
									<string name="ScriptGuid">{E7D961FA-2050-4CC4-AC51-C92B802034CB}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useMemo = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useMemo
local throttle = TS.import(script, TS.getModule(script, "@rbxts", "set-timeout").out).throttle
local useLatest = TS.import(script, script.Parent.Parent, "use-latest").useLatest
local useUnmountEffect = TS.import(script, script.Parent.Parent, "use-unmount-effect").useUnmountEffect
--[[
	*
	* Creates a throttled function that only invokes `callback` at most once per
	* every `wait` seconds. The `callback` is invoked with the most recent arguments
	* provided to the throttled function. Subsequent calls to the throttled function
	* return the result of the last `callback` invocation.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `throttle` and `debounce`.
	*
	* @param callback The function to throttle.
	* @param options The options object.
	* @returns The new throttled function.
]]
local function useThrottleCallback(callback, options)
	if options == nil then
		options = {}
	end
	local callbackRef = useLatest(callback)
	local throttled = useMemo(function()
		return throttle(function(...)
			local args = { ... }
			return callbackRef.current(unpack(args))
		end, options.wait, options)
	end, {})
	useUnmountEffect(function()
		throttled.cancel()
	end)
	return {
		run = throttled,
		cancel = throttled.cancel,
		flush = throttled.flush,
		pending = throttled.pending,
	}
end
return {
	useThrottleCallback = useThrottleCallback,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000619d</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX43DA0EC85E2D46ABA74C208E78BC157D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-throttle-effect</string>
								<string name="ScriptGuid">{6EE7FCAA-73C2-45EB-B744-15531EDC7056}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-throttle-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000619e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX96006E9A90F34C1F885B6713F64B2811">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-throttle-effect</string>
									<string name="ScriptGuid">{6547287E-D1F9-4F5A-935A-8E92E1479C79}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
local useThrottleCallback = TS.import(script, script.Parent.Parent, "use-throttle-callback").useThrottleCallback
local useUpdate = TS.import(script, script.Parent.Parent, "use-update").useUpdate
local useUpdateEffect = TS.import(script, script.Parent.Parent, "use-update-effect").useUpdateEffect
--[[
	*
	* Creates a throttled effect that only runs at most once per every `wait`
	* seconds.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `debounce` and `throttle`.
	*
	* @param effect The effect to throttle.
	* @param dependencies The dependencies array.
	* @param options The options object.
]]
local function useThrottleEffect(effect, dependencies, options)
	local update = useUpdate()
	local _binding = useThrottleCallback(update, options)
	local run = _binding.run
	useEffect(function()
		return run()
	end, dependencies)
	useUpdateEffect(effect, { update })
end
return {
	useThrottleEffect = useThrottleEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000619f</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXF656C6F82F8B49E89965A32874C7EA26">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-throttle-state</string>
								<string name="ScriptGuid">{A7581ED0-D2ED-4593-B24E-E35D0B9F9F4A}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-throttle-state") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a0</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5E676CF7982645C8993F8CDA59C76E3D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-throttle-state</string>
									<string name="ScriptGuid">{FBA03F15-1AA4-4C78-920F-42E02A32CFF2}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useState = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useState
local useThrottleCallback = TS.import(script, script.Parent.Parent, "use-throttle-callback").useThrottleCallback
--[[
	*
	* Creates a throttled state that only updates at most once per every `wait`
	* seconds. Set to the most recently passed `state` after each interval.
	*
	* See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	* for details over the differences between `debounce` and `throttle`.
	*
	* @param value The value to throttle.
	* @param options The options object.
	* @returns The throttled value.
]]
local function useThrottleState(initialState, options)
	local state, setState = useState(initialState)
	return state, useThrottleCallback(setState, options).run
end
return {
	useThrottleState = useThrottleState,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a1</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXA35085B2FC12414E800B36119366C387">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-timeout</string>
								<string name="ScriptGuid">{133A9C6F-7087-4DEE-BC34-242F80D33474}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-timeout") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a2</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX019D432C684C48C6BAD257702AA0A732">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-timeout</string>
									<string name="ScriptGuid">{8556F3CB-2506-4983-A2D9-A438E5660B49}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useEffect = _roact.useEffect
local useRef = _roact.useRef
local setTimeout = TS.import(script, TS.getModule(script, "@rbxts", "set-timeout").out).setTimeout
local useLatestCallback = TS.import(script, script.Parent.Parent, "use-latest-callback").useLatestCallback
--[[
	*
	* Sets a timeout that runs the callback function after `delay` seconds. If
	* `delay` is `undefined`, the timeout is cleared. If the delay changes, the
	* timeout is reset.
	* @param callback The callback function to run.
	* @param delay The delay in seconds before the timeout.
	* @returns A function that clears the timeout.
]]
local function useTimeout(callback, delay)
	local callbackMemo = useLatestCallback(callback)
	local cancel = useRef()
	local clear = useCallback(function()
		local _result = cancel.current
		if _result ~= nil then
			_result()
		end
	end, {})
	useEffect(function()
		if delay == nil then
			return nil
		end
		cancel.current = setTimeout(callbackMemo, delay)
		return clear
	end, { delay })
	return clear
end
return {
	useTimeout = useTimeout,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a3</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX69A186FFD2EC4B33B344F98C35C6D0B8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-timer</string>
								<string name="ScriptGuid">{4879AB87-9882-44A1-9AEE-61BAEC39E667}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-timer") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a4</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX9D293C7ACC964D7B8E641709F434F830">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-timer</string>
									<string name="ScriptGuid">{1977E13D-9E13-4875-8C47-4FA44BC823E8}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useBinding = _roact.useBinding
local useCallback = _roact.useCallback
local useRef = _roact.useRef
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local useEventListener = TS.import(script, script.Parent.Parent, "use-event-listener").useEventListener
--[[
	*
	* Creates a timer that can be used to track a value over time.
	* @param initialValue The initial value of the timer.
	* @returns A timer object.
]]
local function useTimer(initialValue)
	if initialValue == nil then
		initialValue = 0
	end
	local value, setValue = useBinding(initialValue)
	local started = useRef(true)
	useEventListener(RunService.Heartbeat, function(deltaTime)
		if started.current then
			setValue(value:getValue() + deltaTime)
		end
	end)
	local start = useCallback(function()
		started.current = true
	end, {})
	local stop = useCallback(function()
		started.current = false
	end, {})
	local reset = useCallback(function()
		setValue(0)
	end, {})
	local set = useCallback(function(value)
		setValue(value)
	end, {})
	return {
		value = value,
		start = start,
		stop = stop,
		reset = reset,
		set = set,
	}
end
return {
	useTimer = useTimer,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a5</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX43215C90F53E4D378B24B71128D9FC07">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-unmount-effect</string>
								<string name="ScriptGuid">{D0346797-982E-42EE-8E41-4DD57538B515}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-unmount-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a6</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX7C1F605BA46246D4839823B391B38C92">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-unmount-effect</string>
									<string name="ScriptGuid">{E0F2DCBD-E661-4573-BE73-4676884472B0}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local useEffect = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS")).useEffect
local useLatest = TS.import(script, script.Parent.Parent, "use-latest").useLatest
--[[
	*
	* Calls the callback when the component unmounts.
	* @param callback The callback to call.
]]
local function useUnmountEffect(callback)
	local callbackRef = useLatest(callback)
	useEffect(function()
		return function()
			callbackRef.current()
		end
	end, {})
end
return {
	useUnmountEffect = useUnmountEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a7</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX01E33B0C429948DBB8A1E616F3174E3C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-update</string>
								<string name="ScriptGuid">{A1448070-01AE-476E-AA13-0458573F550B}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-update") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a8</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX0514FC6067E74444A04DBB6EB9E50358">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-update</string>
									<string name="ScriptGuid">{A4454FB3-6024-4678-AD61-652C35DA7B54}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useCallback = _roact.useCallback
local useState = _roact.useState
--[[
	*
	* Returns a function that can be used to force a component to update. The
	* function is recreated on the next render if called. This makes it useful as
	* a dependency for other hooks.
	* @returns A function that forces a rerender.
]]
local function useUpdate()
	local state, setState = useState({})
	return useCallback(function()
		setState({})
	end, { state })
end
return {
	useUpdate = useUpdate,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061a9</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX28B9434E4A674012B23D97FD349C9BA8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-update-effect</string>
								<string name="ScriptGuid">{F81D32CF-3E62-49E1-8E92-48BC2FBB97B9}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-update-effect") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061aa</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXA108FCB406964C3288563D65A700ED33">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-update-effect</string>
									<string name="ScriptGuid">{1F2F2007-D33E-432C-8EA5-B432A785411C}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useEffect = _roact.useEffect
local useRef = _roact.useRef
--[[
	*
	* Runs a callback when the component is re-rendered. Does not run on the
	* first render.
	* @param effect The callback to run.
	* @param dependencies The dependencies to watch for changes.
]]
local function useUpdateEffect(effect, dependencies)
	local isMounted = useRef(false)
	useEffect(function()
		if isMounted.current then
			return effect()
		else
			isMounted.current = true
		end
	end, dependencies)
end
return {
	useUpdateEffect = useUpdateEffect,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061ab</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXDE0CABA132BC4BB5BD21F40ECCF9EA05">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">use-viewport</string>
								<string name="ScriptGuid">{BB2413D0-5AE9-46F1-8B44-95FA9004DC29}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, script, "use-viewport") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061ac</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX89789B63B77F40D89C9B90131295A750">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">use-viewport</string>
									<string name="ScriptGuid">{523B24D5-CD9C-4551-B8ED-2995A5016E4A}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local useBinding = _roact.useBinding
local useEffect = _roact.useEffect
local useMemo = _roact.useMemo
local useCamera = TS.import(script, script.Parent.Parent, "use-camera").useCamera
local useEventListener = TS.import(script, script.Parent.Parent, "use-event-listener").useEventListener
--[[
	*
	* Returns the current viewport size of the camera.
	* @param listener Optional listener to be called when the viewport changes.
	* @returns A binding to the viewport size.
]]
local function useViewport(listener)
	local camera = useCamera()
	local viewport, setViewport = useBinding(Vector2.one)
	local _result = camera
	if _result ~= nil then
		_result = _result:GetPropertyChangedSignal("ViewportSize")
	end
	useEventListener(_result, function()
		setViewport(camera.ViewportSize)
		local _result_1 = listener
		if _result_1 ~= nil then
			_result_1(camera.ViewportSize)
		end
	end)
	useMemo(function()
		if camera then
			setViewport(camera.ViewportSize)
		end
	end, { camera })
	useEffect(function()
		local _result_1 = listener
		if _result_1 ~= nil then
			_result_1(viewport:getValue())
		end
	end, { camera })
	return viewport
end
return {
	useViewport = useViewport,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061ad</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXABEDF755B2444008BDBC83B2E027E7A6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">utils</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000061ae</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX044B7FD29FDE46369B7CB4FC5226BD5E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">binding</string>
									<string name="ScriptGuid">{D18F60CC-EED0-43D8-A927-154DA9811B75}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local createBinding = _roact.createBinding
local joinBindings = _roact.joinBindings
local lerp = TS.import(script, script.Parent, "math").lerp
--[[
	*
	* @see https://github.com/Roblox/roact/blob/master/src/Binding.lua
]]
--[[
	*
	* Returns whether the given value is a binding.
	* @param value The value to check.
	* @returns Whether the value is a binding.
]]
local function isBinding(value)
	local _value = value
	local _condition = type(_value) == "table"
	if _condition then
		_condition = value.getValue ~= nil and value.map ~= nil
	end
	return _condition
end
--[[
	*
	* Converts a value to a binding. If the given value is already a binding, it
	* will be returned as-is.
	* @param value The value to convert.
	* @returns The converted binding.
]]
local function toBinding(value)
	if isBinding(value) then
		return value
	else
		local result = createBinding(value)
		return result
	end
end
--[[
	*
	* Returns the value of a binding. If the given value is not a binding, it will
	* be returned as-is.
	* @param binding The binding to get the value of.
	* @returns The value of the binding.
]]
local function getBindingValue(binding)
	if isBinding(binding) then
		return binding:getValue()
	else
		return binding
	end
end
--[[
	*
	* Maps a binding to a new binding. If the given value is not a binding, it will
	* be passed to the mapper function and returned as a new binding.
	* @param binding The binding to map.
	* @param callback The mapper function.
	* @returns The mapped binding.
]]
local function mapBinding(binding, callback)
	if isBinding(binding) then
		return binding:map(callback)
	else
		local result = createBinding(callback(binding))
		return result
	end
end
--[[
	*
	* Joins a map of bindings into a single binding. If any of the given values
	* are not bindings, they will be wrapped in a new binding.
	* @param bindings The bindings to join.
	* @returns The joined binding.
]]
local function joinAnyBindings(bindings)
	local bindingsToMap = {}
	for k, v in pairs(bindings) do
		bindingsToMap[k] = toBinding(v)
	end
	return joinBindings(bindingsToMap)
end
--[[
	*
	* Gets the internal API of a binding. This is a hacky way to get access to the
	* `BindingInternalApi` object of a binding, which is not exposed by Roact.
	* @param binding The binding to get the internal API of.
	* @returns The binding's API.
]]
local function getBindingApi(binding)
	for key, value in pairs(binding) do
		local name = tostring(key)
		if name == "Symbol(BindingImpl)" or string.sub(name, 1, 12) == "RoactBinding" then
			return value
		end
	end
end
--[[
	*
	* Returns a binding that lerps between two values using the given binding as
	* the alpha.
	* @param binding The binding to use as the alpha.
	* @param from The value to lerp from.
	* @param to The value to lerp to.
	* @returns A binding that lerps between two values.
]]
local function lerpBinding(binding, from, to)
	return mapBinding(binding, function(alpha)
		local _from = from
		if type(_from) == "number" then
			return lerp(from, to, alpha)
		else
			return from:Lerp(to, alpha)
		end
	end)
end
--[[
	*
	* Composes multiple bindings or values together into a single binding.
	* Calls the combiner function with the values of the bindings when any
	* of the bindings change.
	* @param ...bindings A list of bindings or values.
	* @param combiner The function that maps the bindings to a new value.
	* @returns A binding that returns the result of the combiner.
]]
local function composeBindings(...)
	local values = { ... }
	-- ▼ Array.pop ▼
	local _length = #values
	local _result = values[_length]
	values[_length] = nil
	-- ▲ Array.pop ▲
	local combiner = _result
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#values)
	for _k, _v in values do
		_newValue[_k] = toBinding(_v, _k - 1, values)
	end
	-- ▲ ReadonlyArray.map ▲
	local bindings = _newValue
	return joinBindings(bindings):map(function(bindings)
		return combiner(unpack(bindings))
	end)
end
return {
	isBinding = isBinding,
	toBinding = toBinding,
	getBindingValue = getBindingValue,
	mapBinding = mapBinding,
	joinAnyBindings = joinAnyBindings,
	getBindingApi = getBindingApi,
	lerpBinding = lerpBinding,
	composeBindings = composeBindings,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061af</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF56EA4B6BADD4B02A3541EE2E68E0AB1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">hoarcekat</string>
									<string name="ScriptGuid">{3F112663-7A63-4B85-B1F4-74CACA75E24E}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local createRoot = TS.import(script, TS.getModule(script, "@rbxts", "ReactRoblox")).createRoot
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local Roact = _roact
local StrictMode = _roact.StrictMode
--[[
	*
	* Returns a function that can be used as a Hoarcekat story. This function will
	* mount the given component to the target instance and unmount it when the
	* story is unmounted.
	* @param TestComponent The component to mount.
	* @param options Optional options to pass to `withHookDetection`.
	* @returns A Hoarcekat story.
]]
local function hoarcekat(TestComponent)
	return function(target)
		local root = createRoot(target)
		root:render(Roact.createElement(StrictMode, {}, {
			Roact.createElement(TestComponent, {
				key = "story",
			}),
		}))
		return function()
			root:unmount()
		end
	end
end
return {
	hoarcekat = hoarcekat,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061b0</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX156BB3F685674A37A35DAFA6D99073AE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">math</string>
									<string name="ScriptGuid">{5AC25DFD-6B09-4E8A-884F-E87325EA0665}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
--[[
	*
	* Linearly interpolates between two numbers.
	* @param a The first number.
	* @param b The second number.
	* @param alpha The alpha value to use.
	* @returns The interpolated number.
]]
local function lerp(a, b, alpha)
	return a + (b - a) * alpha
end
--[[
	*
	* Maps a value from one range to another.
	* @param value The value to map.
	* @param fromMin The minimum of the input range.
	* @param fromMax The maximum of the input range.
	* @param toMin The minimum of the output range.
	* @param toMax The maximum of the output range.
	* @returns The mapped value.
]]
local function map(value, fromMin, fromMax, toMin, toMax)
	return ((value - fromMin) * (toMax - toMin)) / (fromMax - fromMin) + toMin
end
--[[
	*
	* Multiplies transparency values together. Normally, multiplying transparency
	* values requires inverting them (to get opacity), multiplying them, and then
	* inverting them again. This function does that for you.
	* @param transparencies The transparencies to multiply.
	* @returns The multiplied transparency.
]]
local function blend(...)
	local transparencies = { ... }
	local result = 1
	for _, transparency in transparencies do
		result *= 1 - transparency
	end
	return 1 - result
end
return {
	lerp = lerp,
	map = map,
	blend = blend,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061b1</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2DAE9AAEAFD14C17B50CB40085820D80">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">motor</string>
									<string name="ScriptGuid">{2C3349E4-5DAE-4720-AD20-181C986DAAA8}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
--[[
	*
	* Gets the internal state of the motor.
	* @param motor The motor to get the state of
	* @returns The motor's state
]]
local function motorGetState(motor)
	return motor._state
end
--[[
	*
	* Sets the internal state of the motor.
	* @param motor The motor to set the value of
	* @param state The state to set
]]
local function motorSetState(motor, state)
	local currentState = motor._state
	for key, value in pairs(state) do
		currentState[key] = value
	end
end
--[[
	*
	* Applies an impulse to the motor's velocity.
	* @param motor The motor to apply the impulse to
	* @param impulse The impulse to apply
]]
local function motorImpulse(motor, impulse)
	local currentState = motor._state
	local _condition = currentState.velocity
	if _condition == nil then
		_condition = 0
	end
	currentState.velocity = _condition + impulse
end
--[[
	*
	* Gets the state of every key in the group motor.
	* @param motor The group motor to get the state of
	* @returns The group motor's state
]]
local function groupMotorGetState(groupMotor)
	local state = {}
	for key, motor in groupMotor._motors do
		state[key] = motor._state
	end
	return state
end
--[[
	*
	* Sets the state with the given keys in the group motor.
	* @param motor The group motor to set the state of
	* @param state The state to set
]]
local function groupMotorSetState(groupMotor, states)
	for key, state in pairs(states) do
		local motor = groupMotor._motors[key]
		if motor then
			motorSetState(motor, state)
		end
	end
end
--[[
	*
	* Applies impulses to the motor's velocity.
	* @param motor The group motor to apply the impulses to
	* @param impulses The impulses to apply
]]
local function groupMotorImpulse(groupMotor, impulses)
	for key, state in pairs(impulses) do
		local motor = groupMotor._motors[key]
		if motor then
			local _condition = motor._state.velocity
			if _condition == nil then
				_condition = 0
			end
			motor._state.velocity = _condition + state
		end
	end
end
return {
	motorGetState = motorGetState,
	motorSetState = motorSetState,
	motorImpulse = motorImpulse,
	groupMotorGetState = groupMotorGetState,
	groupMotorSetState = groupMotorSetState,
	groupMotorImpulse = groupMotorImpulse,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061b2</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD8C4BEDA72574164A5DDC36EB3AE0421">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">shallow-equal</string>
									<string name="ScriptGuid">{A0F902CC-69FA-4999-8956-CE5D46D49098}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
--[[
	*
	* Compares two objects to see if they are shallowly equal.
	* @param objectA The first object to compare.
	* @param objectB The second object to compare.
	* @returns Whether or not the two objects are shallowly equal.
]]
local function shallowEqual(objectA, objectB)
	if objectA == objectB then
		return true
	end
	if objectA == nil or objectB == nil then
		return false
	end
	for key, value in pairs(objectA) do
		if objectB[key] ~= value then
			return false
		end
	end
	for key, value in pairs(objectB) do
		if objectA[key] ~= value then
			return false
		end
	end
	return true
end
return {
	shallowEqual = shallowEqual,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061b3</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5B616D3E1CC0486FACD1E82BAC33439D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">testez</string>
									<string name="ScriptGuid">{AEFB6116-A750-4D0D-80FC-5D05473AF521}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.1.1
local TS = _G[script]
local _roact = TS.import(script, TS.getModule(script, "@rbxts", "RoactTS"))
local Roact = _roact
local useEffect = _roact.useEffect
local useRef = _roact.useRef
--[[
	*
	* Allows you to render a hook within a test React component without having to
	* create that component yourself.
	* @see https://github.com/testing-library/react-testing-library
]]
local function renderHook(render, options)
	if options == nil then
		options = {}
	end
	local result = {
		current = nil,
	}
	local function TestComponent(_param)
		local initialProps = _param.initialProps
		local previousProps = useRef(initialProps)
		local _fn = render
		local _condition = initialProps
		if _condition == nil then
			_condition = previousProps.current
			if _condition == nil then
				_condition = ({})
			end
		end
		local pendingResult = _fn(_condition)
		useEffect(function()
			previousProps.current = initialProps
			result.current = pendingResult
		end)
		return nil
	end
	local handle = Roact.mount(Roact.createElement(TestComponent, {
		initialProps = options.initialProps,
	}), options.container)
	local rerender = function(props)
		Roact.update(handle, Roact.createElement(TestComponent, {
			initialProps = props,
		}))
	end
	local unmount = function()
		Roact.unmount(handle)
	end
	return {
		rerender = rerender,
		result = result,
		unmount = unmount,
	}
end
return {
	renderHook = renderHook,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000061b4</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX76C988E9778040F7BA996B3DB6A59F20">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">LuauPolyfill</string>
							<string name="ScriptGuid">{1749CB4C-11E2-4F17-AFAE-350CD116B099}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.LuauPolyfill)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006201</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX903AD718DDC746C99828ED7EB600B08F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Boolean</string>
								<string name="ScriptGuid">{022CF4AD-6451-47A1-8925-3A5F5FEA0BAA}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return {
	toJSBoolean = require(script.toJSBoolean),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006202</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX732FAC939E094F6A9854A2B698940834">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">toJSBoolean</string>
									<string name="ScriptGuid">{2F8CDCAA-8662-4CC7-9A2E-4F8E9CB0CE48}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent.Parent
local Number = require(Packages.Number)

-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean
return function(val: any): boolean
	return not not val and val ~= 0 and val ~= "" and not Number.isNaN(val)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006203</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX7DD00F5A74F84C91A7B5D7B2D7259A2C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Collections</string>
								<string name="ScriptGuid">{87CACCDD-4E9A-412C-9A15-0E2E94DC5953}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent

local Array = require(script.Array)
local Map = require(script.Map)
local Object = require(script.Object)
local Set = require(script.Set)
local WeakMap = require(script.WeakMap)
local inspect = require(script.inspect)

local types = require(Packages.ES7Types)

export type Array<T> = types.Array<T>
export type Map<T, V> = types.Map<T, V>
export type Object = types.Object
export type Set<T> = types.Set<T>
export type WeakMap<T, V> = types.WeakMap<T, V>

return {
	Array = Array,
	Object = Object,
	Map = Map.Map,
	coerceToMap = Map.coerceToMap,
	coerceToTable = Map.coerceToTable,
	Set = Set,
	WeakMap = WeakMap,
	inspect = inspect,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006204</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX210CF024A7EE4495B8FCF2095F86698B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Array</string>
									<string name="ScriptGuid">{2E9EEC6B-75DE-414C-BABD-870E041F38DE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent.Parent
local ES7Types = require(Packages.ES7Types)

export type Array<T> = ES7Types.Array<T>

return {
	concat = require(script.concat),
	every = require(script.every),
	filter = require(script.filter),
	find = require(script.find),
	findIndex = require(script.findIndex),
	flat = require(script.flat),
	flatMap = require(script.flatMap),
	forEach = require(script.forEach),
	from = require(script.from),
	includes = require(script.includes),
	indexOf = require(script.indexOf),
	isArray = require(script.isArray),
	join = require(script.join),
	map = require(script.map),
	reduce = require(script.reduce),
	reverse = require(script.reverse),
	shift = require(script.shift),
	slice = require(script.slice),
	some = require(script.some),
	sort = require(script.sort),
	splice = require(script.splice),
	unshift = require(script.unshift),
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006205</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX356DA751300144B7B321C2BF96E723BA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">concat</string>
										<string name="ScriptGuid">{3BF50F96-7A64-44F8-B1C9-206C1841404A}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

local RECEIVED_OBJECT_ERROR = "Array.concat(...) only works with array-like tables but "
	.. "it received an object-like table.\nYou can avoid this error by wrapping the "
	.. "object-like table into an array. Example: `concat({1, 2}, {a = true})` should "
	.. "be `concat({1, 2}, { {a = true} }`"

-- capture two separate generic arguments so that the type error in abuse cases is actionable, but needs CLI-49876 to avoid a false negative
local function concat<T, S>(source: Array<T> | T, ...: Array<S> | S): Array<T> & Array<S>
	local array
	local elementCount = 0

	if isArray(source) then
		array = table.clone(source :: Array<T>)
		elementCount = #(source :: Array<T>)
	else
		elementCount += 1
		array = {}
		array[elementCount] = source :: T
	end

	for i = 1, select("#", ...) do
		local value = select(i, ...)
		local valueType = typeof(value)

		-- selene:allow(empty_if)
		if value == nil then
			-- do not insert nil
		elseif valueType == "table" then
			-- deviation: assume that table is an array, to avoid the expensive
			-- `isArray` check. In DEV mode, we throw if it is given an object-like
			-- table.
			if __DEV__ then
				if not isArray(value) then
					error(RECEIVED_OBJECT_ERROR)
				end
			end
			for k = 1, #value do
				elementCount += 1
				array[elementCount] = value[k]
			end
		else
			elementCount += 1
			array[elementCount] = value
		end
	end

	return (array :: any) :: Array<T> & Array<S>
end

return concat
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006206</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE8850E64E9B64FAB830A89C26D9ABBC9">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">every</string>
										<string name="ScriptGuid">{864AF42C-358D-4250-A099-D3D3D58290FC}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> boolean
type callbackFnWithThisArg<T, U> = (self: U, element: T, index: number, array: Array<T>) -> boolean

-- Implements Javascript's `Array.prototype.every` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): boolean
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.every called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local k = 1

	while k <= len do
		local kValue = t[k]
		local testResult

		if kValue ~= nil then
			if thisArg ~= nil then
				testResult = (callback :: callbackFnWithThisArg<T, U>)(thisArg, kValue, k, t)
			else
				testResult = (callback :: callbackFn<T>)(kValue, k, t)
			end

			if not testResult then
				return false
			end
		end
		k += 1
	end
	return true
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006207</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX57554B7AA20547A3A8BACD2C44E7BBF3">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">filter</string>
										<string name="ScriptGuid">{5398FF7F-B604-49CA-B8AA-D98F994C7C05}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> boolean
type callbackFnWithThisArg<T, U> = (thisArg: U, element: T, index: number, array: Array<T>) -> boolean

-- Implements Javascript's `Array.prototype.filter` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): Array<T>
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.filter called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local res = {}
	local index = 1

	if thisArg == nil then
		for i = 1, len do
			local kValue = t[i]
			if kValue ~= nil then
				if (callback :: callbackFn<T>)(kValue, i, t) then
					res[index] = kValue
					index += 1
				end
			end
		end
	else
		for i = 1, len do
			local kValue = t[i]
			if kValue ~= nil then
				if (callback :: callbackFnWithThisArg<T, U>)(thisArg, kValue, i, t) then
					res[index] = kValue
					index += 1
				end
			end
		end
	end

	return res
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006208</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX38BC1AD076524A7F9BFE34583B7F3EEA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">find</string>
										<string name="ScriptGuid">{DD77709D-4DBF-47DB-8DB7-D94B3A805987}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type PredicateFunction<T> = (value: T, index: number, array: Array<T>) -> boolean

return function<T>(array: Array<T>, predicate: PredicateFunction<T>): T | nil
	for i = 1, #array do
		local element = array[i]
		if predicate(element, i, array) then
			return element
		end
	end
	return nil
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006209</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXBF589DB8F035439582D0F6EF817C5E70">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">findIndex</string>
										<string name="ScriptGuid">{9D426F09-DDAB-45C1-B90B-6E53839445A7}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type PredicateFunction<T> = (T, number, Array<T>) -> boolean

return function<T>(array: Array<T>, predicate: PredicateFunction<T>): number
	for i = 1, #array do
		local element = array[i]
		if predicate(element, i, array) then
			return i
		end
	end
	return -1
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000620a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1B5BE82C56C544129EA00BC241E00E83">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">flat</string>
										<string name="ScriptGuid">{D5DB1224-40A7-4DB5-882D-AA44463D9C1A}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local function flat<T>(array: Array<T>, depth_: number?): Array<T>
	if __DEV__ then
		if typeof(array) ~= "table" then
			error(string.format("Array.flat called on %s", typeof(array)))
		end
		if depth_ ~= nil and typeof(depth_) ~= "number" then
			error("depth is not a number or nil")
		end
	end
	local depth = depth_ or 1
	local newArray = {}

	for _, v in array do
		if isArray(v) then
			local vArray = (v :: any) :: Array<T>
			local innerArrFlat: Array<T> = if depth > 1 then flat(vArray, depth - 1) else vArray
			for _, innerValue in innerArrFlat do
				table.insert(newArray, innerValue)
			end
		else
			table.insert(newArray, v)
		end
	end

	return newArray
end

return flat
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000620b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXBF934E8F3AD64C21A9B28C25F5A0D57B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">flatMap</string>
										<string name="ScriptGuid">{99F789E9-700E-48D0-8BCD-1288D8852773}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local flat = require(Array.flat)
local map = require(Array.map)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type callbackFn<T, U> = (element: T, index: number, array: Array<T>) -> U
type callbackFnWithThisArg<T, U, V> = (thisArg: V, element: T, index: number, array: Array<T>) -> U

local function flatMap<T, U, V>(
	array: Array<T>,
	callback: callbackFn<T, U> | callbackFnWithThisArg<T, U, V>,
	thisArg: V?
): Array<U>
	if __DEV__ then
		if typeof(array) ~= "table" then
			error(string.format("Array.flatMap called on %s", typeof(array)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end
	return flat(map(array, callback, thisArg))
end

return flatMap
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000620c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2A609A558A8D413EBA0C9D79939E4808">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">forEach</string>
										<string name="ScriptGuid">{B9E74C7F-9950-4C42-802D-1775A089D2C0}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> ()
type callbackFnWithThisArg<T, U> = (thisArg: U, element: T, index: number, array: Array<T>) -> ()

-- Implements Javascript's `Array.prototype.forEach` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): ()
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.forEach called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local k = 1

	while k <= len do
		local kValue = t[k]

		if thisArg ~= nil then
			(callback :: callbackFnWithThisArg<T, U>)(thisArg, kValue, k, t)
		else
			(callback :: callbackFn<T>)(kValue, k, t)
		end

		if #t < len then
			-- don't iterate on removed items, don't iterate more than original length
			len = #t
		end
		k += 1
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000620d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2B6BC8CB09204700A906358EC36F234B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">from</string>
										<string name="ScriptGuid">{339F940D-605A-4A04-ACC2-CEFA4BACC6EC}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Collections = Array.Parent
local Packages = Collections.Parent
local Set = require(Collections.Set)
local Map = require(Collections.Map.Map)
local isArray = require(Array.isArray)
local instanceof = require(Packages.InstanceOf)
local types = require(Packages.ES7Types)

local fromString = require(script.fromString)
local fromSet = require(script.fromSet)
local fromMap = require(script.fromMap)
local fromArray = require(script.fromArray)

type Array<T> = types.Array<T>
type Object = types.Object
type Set<T> = types.Set<T>
type Map<K, V> = types.Map<K, V>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: string | Array<T> | Set<T> | Map<any, any>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	if value == nil then
		error("cannot create array from a nil value")
	end
	local valueType = typeof(value)

	local array: Array<U> | Array<T> | Array<string>

	if valueType == "table" and isArray(value) then
		array = fromArray(value :: Array<T>, mapFn, thisArg)
	elseif instanceof(value, Set) then
		array = fromSet(value :: Set<T>, mapFn, thisArg)
	elseif instanceof(value, Map) then
		array = fromMap(value :: Map<any, any>, mapFn, thisArg)
	elseif valueType == "string" then
		array = fromString(value :: string, mapFn, thisArg)
	else
		array = {}
	end

	return array
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000620e</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBX6FE11FBD9FCC4E42B637C649B33893BA">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">fromArray</string>
											<string name="ScriptGuid">{D2DD8334-F639-4551-8209-D58E87B5DB80}</string>
											<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object

type Array<T> = types.Array<T>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: Array<T>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	if mapFn then
		local arrayLength = #(value :: Array<T>)
		array = table.create(arrayLength)
		for i = 1, arrayLength do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, (value :: Array<T>)[i], i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)((value :: Array<T>)[i], i)
			end
		end
	else
		array = table.clone(value :: Array<T>)
	end

	return array
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">3a589e3654c30573064751ed0000620f</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX0DD715F1C06F470D88A3B6FB9A18D9F2">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">fromMap</string>
											<string name="ScriptGuid">{F769C0C8-E564-440C-95B9-E1CE1A86F53E}</string>
											<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>
type Map<K, V> = types.Map<K, V>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: Map<any, any>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	if mapFn then
		array = {}
		for i, v in value :: any do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, v, i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)(v, i)
			end
		end
	else
		array = {}
		for i, v in value :: any do
			(array :: Array<T>)[i] = v
		end
	end

	return array
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">3a589e3654c30573064751ed00006210</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXE73D6D6A28F546CE9A78D00B0D9E1E6F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">fromSet</string>
											<string name="ScriptGuid">{13521D32-4E17-46A3-89B6-4F7AB54693D8}</string>
											<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>
type Set<T> = types.Set<T>
type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: Set<T>,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	if mapFn then
		array = {}
		for i, v in value :: any do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, v, i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)(v, i)
			end
		end
	else
		array = table.clone((value :: any)._array)
	end

	return array
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">3a589e3654c30573064751ed00006211</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX30470C5E8B19492F9EAC45439614D74F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">fromString</string>
											<string name="ScriptGuid">{077FE8DB-1665-499E-8C01-E71C6A539761}</string>
											<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>

type mapFn<T, U> = (element: T, index: number) -> U
type mapFnWithThisArg<T, U> = (thisArg: any, element: T, index: number) -> U

return function<T, U>(
	value: string,
	mapFn: (mapFn<T, U> | mapFnWithThisArg<T, U>)?,
	thisArg: Object?
	-- FIXME Luau: need overloading so the return type on this is more sane and doesn't require manual casts
): Array<U> | Array<T> | Array<string>
	local array = {}

	local valueStringLength = #value
	array = table.create(valueStringLength)
	if mapFn then
		for i = 1, valueStringLength do
			if thisArg ~= nil then
				(array :: Array<U>)[i] = (mapFn :: mapFnWithThisArg<T, U>)(thisArg, string.sub(value, i, i) :: any, i)
			else
				(array :: Array<U>)[i] = (mapFn :: mapFn<T, U>)(string.sub(value, i, i) :: any, i)
			end
		end
	else
		for i = 1, valueStringLength do
			(array :: Array<string>)[i] = string.sub(value, i, i)
		end
	end

	return array
end
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">3a589e3654c30573064751ed00006212</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBXAB11CBD83C164DBCB966B8DB413CA92D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">includes</string>
										<string name="ScriptGuid">{65905108-2BB6-48A5-8545-4F6BAE10E32F}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local indexOf = require(script.Parent.indexOf)

return function<T>(array: Array<T>, searchElement: T, fromIndex: number?): boolean
	return indexOf(array, searchElement, fromIndex) ~= -1
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006213</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDDF6857733CF4A368395A12B1A620927">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">indexOf</string>
										<string name="ScriptGuid">{80302F7D-7E85-44C0-B4A9-1050E1A1A6F2}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- Implements equivalent functionality to JavaScript's `array.indexOf`,
-- implementing the interface and behaviors defined at:
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
--
-- This implementation is loosely based on the one described in the polyfill
-- source in the above link
return function<T>(array: Array<T>, searchElement: T, fromIndex: number?): number
	local fromIndex_ = fromIndex or 1
	local length = #array

	-- In the JS impl, a negative fromIndex means we should use length - index;
	-- with Lua, of course, this means that 0 is still valid, but refers to the
	-- end of the array the way that '-1' would in JS
	if fromIndex_ < 1 then
		fromIndex_ = math.max(length - math.abs(fromIndex_), 1)
	end

	for i = fromIndex_, length do
		if array[i] == searchElement then
			return i
		end
	end

	return -1
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006214</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1FB98816D16C42F3BC2B6CAA01D224AB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">isArray</string>
										<string name="ScriptGuid">{7C36E5AA-28DF-4AE3-B567-A18F3B378CF0}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return function(value: any): boolean
	if typeof(value) ~= "table" then
		return false
	end
	if next(value) == nil then
		-- an empty table is an empty array
		return true
	end

	local length = #value

	if length == 0 then
		return false
	end

	local count = 0
	local sum = 0
	for key in pairs(value) do
		if typeof(key) ~= "number" then
			return false
		end
		if key % 1 ~= 0 or key < 1 then
			return false
		end
		count += 1
		sum += key
	end

	return sum == (count * (count + 1) / 2)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006215</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9CD70BC66BD445DE81F80BAFF3FDA873">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">join</string>
										<string name="ScriptGuid">{7403A894-C7AD-4199-AD4D-E7758BFA02C3}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local map = require(Array.map)

return function<T>(arr: Array<T>, separator: string?): string
	if #arr == 0 then
		return ""
	end
	-- JS does tostring conversion implicitely but in Lua we need to do that explicitely
	local stringifiedArray = map(arr, function(item)
		return tostring(item)
	end)

	return table.concat(stringifiedArray, separator or ",")
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006216</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX84430ABC14964E70A688A3582D9B97C0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">map</string>
										<string name="ScriptGuid">{3532CB9B-3864-4AA3-A1D1-01C9036A19CF}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object
type callbackFn<T, U> = (element: T, index: number, array: Array<T>) -> U
type callbackFnWithThisArg<T, U, V> = (thisArg: V, element: T, index: number, array: Array<T>) -> U

-- Implements Javascript's `Array.prototype.map` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
return function<T, U, V>(t: Array<T>, callback: callbackFn<T, U> | callbackFnWithThisArg<T, U, V>, thisArg: V?): Array<U>
	if __DEV__ then
		if typeof(t) ~= "table" then
			error(string.format("Array.map called on %s", typeof(t)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local len = #t
	local A = {}
	local k = 1

	while k <= len do
		local kValue = t[k]

		if kValue ~= nil then
			local mappedValue

			if thisArg ~= nil then
				mappedValue = (callback :: callbackFnWithThisArg<T, U, V>)(thisArg, kValue, k, t)
			else
				mappedValue = (callback :: callbackFn<T, U>)(kValue, k, t)
			end

			A[k] = mappedValue
		end
		k += 1
	end

	return A
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006217</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXD664214823EE4323896D0A1187CA46AA">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">reduce</string>
										<string name="ScriptGuid">{1CFFA938-EFF2-49E2-9B0E-F9EC4A3A01E5}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type reduceFn<T, U> = (previousValue: U, currentValue: T, currentIndex: number, array: Array<T>) -> U

-- Implements Javascript's `Array.prototype.reduce` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce
-- TODO Luau: when Luau supports overloads, use them here so that reduceFn can correctly use T when initialValue (U) isn't supplied
return function<T, U>(array: Array<T>, callback: reduceFn<T, U>, initialValue: U?): U
	if __DEV__ then
		if typeof(array) ~= "table" then
			error(string.format("Array.reduce called on %s", typeof(array)))
		end
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end

	local length = #array

	local value: T | U
	local initial = 1

	if initialValue ~= nil then
		value = initialValue
	else
		initial = 2
		if length == 0 then
			error("reduce of empty array with no initial value")
		end
		value = array[1]
	end

	for i = initial, length do
		value = callback(value :: U, array[i], i, array)
	end

	return value :: U
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006218</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX6096CD3F9C0F4A9F9B4BAA129C378417">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">reverse</string>
										<string name="ScriptGuid">{CF9055FF-9C08-4E5E-A550-17922F246576}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://programming-idioms.org/idiom/19/reverse-a-list/1314/lua
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

return function<T>(t: Array<T>): Array<T>
	local n = #t
	local i = 1
	while i < n do
		t[i], t[n] = t[n], t[i]
		i = i + 1
		n = n - 1
	end
	return t
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006219</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXD4FD4326D0B34555B8336F657F7DEC0B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">shift</string>
										<string name="ScriptGuid">{7B3F2395-E515-4D1E-A619-1DAF1784C585}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

return function<T>(value: Array<T>): T?
	if __DEV__ then
		if not isArray(value) then
			error(string.format("Array.shift called on non-array %s", typeof(value)))
		end
	end

	if #value > 0 then
		return table.remove(value, 1)
	else
		return nil
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000621a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX099D29C41361496C8A14C69CE582B808">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">slice</string>
										<string name="ScriptGuid">{5F0AFF14-0F6D-4B31-B6FC-A41ED952A2AD}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- Implements Javascript's `Array.prototype.slice` as defined below, but with 1-indexing
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
return function<T>(t: Array<T>, start_idx: number?, end_idx: number?): Array<T>
	if typeof(t) ~= "table" then
		error(string.format("Array.slice called on %s", typeof(t)))
	end
	local length = #t

	local start_idx_ = start_idx or 1
	local end_idx_
	if end_idx == nil or end_idx > length + 1 then
		end_idx_ = length + 1
	else
		end_idx_ = end_idx
	end

	if start_idx_ > length + 1 then
		return {}
	end

	local slice = {}

	if start_idx_ < 1 then
		start_idx_ = math.max(length - math.abs(start_idx_), 1)
	end
	if end_idx_ < 1 then
		end_idx_ = math.max(length - math.abs(end_idx_), 1)
	end

	local idx = start_idx_
	local i = 1
	while idx < end_idx_ do
		slice[i] = t[idx]
		idx = idx + 1
		i = i + 1
	end

	return slice
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000621b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX46F496B7BE4245DDB3FD243885EBCE97">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">some</string>
										<string name="ScriptGuid">{BDE420D6-6B85-49B3-AB76-2165A57C0C76}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

-- note: JS version can return anything that's truthy, but that won't work for us since Lua deviates (0 is truthy)
type callbackFn<T> = (element: T, index: number, array: Array<T>) -> boolean
type callbackFnWithThisArg<T, U> = (thisArg: U, element: T, index: number, array: Array<T>) -> boolean

-- Implements Javascript's `Array.prototype.map` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some
return function<T, U>(t: Array<T>, callback: callbackFn<T> | callbackFnWithThisArg<T, U>, thisArg: U?): boolean
	if typeof(t) ~= "table" then
		error(string.format("Array.some called on %s", typeof(t)))
	end
	if typeof(callback) ~= "function" then
		error("callback is not a function")
	end

	for i, value in t do
		if thisArg ~= nil then
			if value ~= nil and (callback :: callbackFnWithThisArg<T, U>)(thisArg, value, i, t) then
				return true
			end
		else
			if value ~= nil and (callback :: callbackFn<T>)(value, i, t) then
				return true
			end
		end
	end
	return false
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000621c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXC155C1AF391844CEAAE061A507A21A5C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">sort</string>
										<string name="ScriptGuid">{2E93BEF8-DBAF-49CF-8899-0BC29FF5B822}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Collections = Array.Parent
local Packages = Collections.Parent
local None = require(Collections.Object.None)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Comparable = (any, any) -> number
local defaultSort = function<T>(a: T, b: T): boolean
	return type(a) .. tostring(a) < type(b) .. tostring(b)
end

return function<T>(array: Array<T>, compare: Comparable?): Array<T>
	-- wrapperCompare interprets compare return value to be compatible with Lua's table.sort
	local wrappedCompare = defaultSort
	if compare ~= nil and compare ~= None then
		if typeof(compare :: any) ~= "function" then
			error("invalid argument to Array.sort: compareFunction must be a function")
		end
		wrappedCompare = function<T>(a: T, b: T)
			local result = compare(a, b)
			if typeof(result) ~= "number" then
				-- deviation: throw an error because
				-- it's not clearly defined what is
				-- the behavior when the compare function
				-- does not return a number
				error(("invalid result from compare function, expected number but got %s"):format(typeof(result)))
			end
			return result < 0
		end
	end
	table.sort(array, wrappedCompare)
	return array
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000621d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX1D4086A1C45146BDB9F3483578C5001F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">splice</string>
										<string name="ScriptGuid">{2CA07479-AA3A-4FB7-94DD-20A481194CCF}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Array = script.Parent
local Packages = Array.Parent.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- Implements equivalent functionality to JavaScript's `array.splice`, including
-- the interface and behaviors defined at:
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
return function<T>(array: Array<T>, start: number, deleteCount: number?, ...: T): Array<T>
	-- Append varargs without removing anything
	if start > #array then
		local varargCount = select("#", ...)
		for i = 1, varargCount do
			local toInsert = select(i, ...)
			table.insert(array, toInsert)
		end
		return {}
	else
		local length = #array
		-- In the JS impl, a negative fromIndex means we should use length -
		-- index; with Lua, of course, this means that 0 is still valid, but
		-- refers to the end of the array the way that '-1' would in JS
		if start < 1 then
			start = math.max(length - math.abs(start), 1)
		end

		local deletedItems = {} :: Array<T>
		-- If no deleteCount was provided, we want to delete the rest of the
		-- array starting with `start`
		local deleteCount_: number = deleteCount or length
		if deleteCount_ > 0 then
			local lastIndex = math.min(length, start + math.max(0, deleteCount_ - 1))

			for _ = start, lastIndex do
				local deleted = table.remove(array, start) :: T
				table.insert(deletedItems, deleted)
			end
		end

		local varargCount = select("#", ...)
		-- Do this in reverse order so we can always insert in the same spot
		for i = varargCount, 1, -1 do
			local toInsert = select(i, ...)
			table.insert(array, start, toInsert)
		end

		return deletedItems
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000621e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXAAB86C10FC004E3299CFAEDFB2683C2B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">unshift</string>
										<string name="ScriptGuid">{A6A72549-80B8-492D-BD18-007E3BAD90E9}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Array = script.Parent
local Packages = Array.Parent.Parent
local isArray = require(Array.isArray)
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

return function<T>(array: Array<T>, ...: T): number
	if __DEV__ then
		if not isArray(array) then
			error(string.format("Array.unshift called on non-array %s", typeof(array)))
		end
	end

	local numberOfItems = select("#", ...)
	if numberOfItems > 0 then
		for i = numberOfItems, 1, -1 do
			local toInsert = select(i, ...)
			table.insert(array, 1, toInsert)
		end
	end

	return #array
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000621f</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXE2CEF2E2A03844F68B6E9A0176BB938B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Map</string>
									<string name="ScriptGuid">{E8A08B29-5B29-4DD8-B72A-2ADE8706E67E}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent.Parent

local ES7Types = require(Packages.ES7Types)

local Map = require(script.Map)
local coerceToMap = require(script.coerceToMap)
local coerceToTable = require(script.coerceToTable)

export type Map<K, V> = ES7Types.Map<K, V>

return {
	Map = Map,
	coerceToMap = coerceToMap,
	coerceToTable = coerceToTable,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006220</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX59E066AB53324D70AE72AAABFDE2B66E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Map</string>
										<string name="ScriptGuid">{80CD12E9-B243-4E85-AFC3-CBDE9A2F3F32}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Collections = script.Parent.Parent
local Packages = Collections.Parent

local arrayForEach = require(Collections.Array.forEach)
local arrayMap = require(Collections.Array.map)
local isArray = require(Collections.Array.isArray)
local instanceof = require(Packages.InstanceOf)
local types = require(Packages.ES7Types)
type Object = types.Object
type Array<T> = types.Array<T>
type Table<T, V> = types.Table<T, V>
type Tuple<T, V> = types.Tuple<T, V>
type mapCallbackFn<K, V> = types.mapCallbackFn<K, V>
type mapCallbackFnWithThisArg<K, V> = types.mapCallbackFnWithThisArg<K, V>
type Map<K, V> = types.Map<K, V>

type Map_Statics = {
	new: <K, V>(iterable: Array<Array<any>>?) -> Map<K, V>,
}

local Map: Map<any, any> & Map_Statics = ({} :: any) :: Map<any, any> & Map_Statics

function Map.new<K, V>(iterable: (Array<Array<any>> | Map<K, V>)?): Map<K, V>
	local array
	local map
	if iterable == nil then
		array = {}
		map = {}
	elseif isArray(iterable) then
		if __DEV__ then
			if #(iterable :: Array<Array<any>>) > 0 and typeof((iterable :: Array<Array<any>>)[1]) ~= "table" then
				error(
					"Value `"
						.. typeof((iterable :: Array<Array<any>>)[1])
						.. "` is not an entry object.\n "
						.. "Cannot create Map from {K, V} form, it must be { {K, V}... }"
				)
			end
		end
		array = table.create(#(iterable :: Array<Array<any>>))
		map = {}
		for _, entry in iterable :: Array<Array<any>> do
			local key = entry[1]
			if __DEV__ then
				if key == nil then
					error("cannot create Map from a table that isn't an array.")
				end
			end
			local val = entry[2]
			-- only add to array if new
			if map[key] == nil then
				table.insert(array, key)
			end
			-- always assign
			map[key] = val
		end
	elseif instanceof(iterable, Map) then
		array = table.clone((iterable :: Map<K, V>)._array)
		map = table.clone((iterable :: Map<K, V>)._map)
	else
		error(("`%s` `%s` is not iterable, cannot make Map using it"):format(typeof(iterable), tostring(iterable)))
	end

	return (setmetatable({
		size = #array,
		_map = map,
		_array = array,
	}, Map) :: any) :: Map<K, V>
end

-- TODO Luau: annoying type erasure here, probably needs the new Records language feature
function Map:set(key: any, value: any): Map<any, any>
	-- preserve initial insertion order
	if self._map[key] == nil then
		-- Luau FIXME: analyze should know self is Map<K, V> which includes size as a number
		self.size = self.size :: number + 1
		table.insert(self._array, key)
	end
	-- always update value
	self._map[key] = value
	return self
end

function Map:get(key)
	return self._map[key]
end

function Map:clear()
	local table_: any = table
	self.size = 0
	table_.clear(self._map)
	table_.clear(self._array)
end

function Map:delete(key): boolean
	if self._map[key] == nil then
		return false
	end
	-- Luau FIXME: analyze should know self is Map<K, V> which includes size as a number
	self.size = self.size :: number - 1
	self._map[key] = nil
	local index = table.find(self._array, key)
	if index then
		table.remove(self._array, index)
	end
	return true
end

-- Implements Javascript's `Map.prototype.forEach` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach
function Map:forEach(callback: mapCallbackFn<any, any> | mapCallbackFnWithThisArg<any, any>, thisArg: Object?): ()
	if __DEV__ then
		if typeof(callback) ~= "function" then
			error("callback is not a function")
		end
	end
	-- note: we can't turn this into a simple for-in loop, because the callbacks can modify the table and React, GQL, and Jest rely on JS behavior in that scenario
	arrayForEach(self._array, function(key)
		local value = self._map[key]

		if thisArg ~= nil then
			(callback :: mapCallbackFnWithThisArg<any, any>)(thisArg, value, key, self)
		else
			(callback :: mapCallbackFn<any, any>)(value, key, self)
		end
	end)
end

function Map:has(key): boolean
	return self._map[key] ~= nil
end

function Map:keys()
	return self._array
end

function Map:values()
	return arrayMap(self._array, function(key)
		return self._map[key]
	end)
end

function Map:entries()
	return arrayMap(self._array, function(key)
		return { key, self._map[key] }
	end)
end

function Map:ipairs()
	if __DEV__ then
		warn(
			debug.traceback(
				"`for _,_ in myMap:ipairs() do` is deprecated and will be removed in a future release, please use `for _,_ in myMap do` instead\n",
				2
			)
		)
	end
	return ipairs(self:entries())
end

function Map.__iter(self: Map<any, any>)
	return next, self:entries()
end

function Map.__index(self: Map<any, any>, key)
	local mapProp = rawget(Map, key)
	if mapProp ~= nil then
		return mapProp
	end
	if __DEV__ then
		assert(
			-- FIXME Luau: shouldn't need this cast, the self param is annotated already
			rawget(self :: any, "_map"),
			"Map has been corrupted, and is missing private state! Did you accidentally call table.clear() instead of map:clear()?"
		)
	end

	return Map.get(self, key)
end

function Map.__newindex(self: Map<any, any>, key, value)
	self:set(key, value)
end

return Map
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006221</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF728767C019C437A89456089DDD12710">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">coerceToMap</string>
										<string name="ScriptGuid">{1C95BF13-C1CD-4D9C-AB0E-ED5EFBF5CB78}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local MapModule = script.Parent
local Collections = MapModule.Parent
local Packages = Collections.Parent

local Map = require(MapModule.Map)
local Object = require(Collections.Object)
local instanceOf = require(Packages.InstanceOf)
local types = require(Packages.ES7Types)

type Map<K, V> = types.Map<K, V>
type Table<K, V> = types.Table<K, V>

local function coerceToMap(mapLike: Map<any, any> | Table<any, any>): Map<any, any>
	return instanceOf(mapLike, Map) and mapLike :: Map<any, any> -- ROBLOX: order is preserved
		or Map.new(Object.entries(mapLike)) -- ROBLOX: order is not preserved
end

return coerceToMap
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006222</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7E5CFAC9D8984D088B74D38330F8EA8E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">coerceToTable</string>
										<string name="ScriptGuid">{E0BC4924-B67D-4CA6-B78A-80DBC809AFA2}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local MapModule = script.Parent
local Collections = MapModule.Parent
local Packages = Collections.Parent

local Map = require(MapModule.Map)
local instanceOf = require(Packages.InstanceOf)
local arrayReduce = require(Collections.Array.reduce)
local types = require(Packages.ES7Types)

type Map<K, V> = types.Map<K, V>
type Table<K, V> = types.Table<K, V>

local function coerceToTable(mapLike: Map<any, any> | Table<any, any>): Table<any, any>
	if not instanceOf(mapLike, Map) then
		return mapLike :: Table<any, any>
	end

	-- create table from map
	return arrayReduce(mapLike:entries(), function(tbl, entry)
		tbl[entry[1]] = entry[2]
		return tbl
	end, {})
end

return coerceToTable
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006223</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXB8A74BB25AD3448E8F43CE7231293C64">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Object</string>
									<string name="ScriptGuid">{5D8110D7-4B78-41CA-910C-F5882D4AD015}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return {
	assign = require(script.assign),
	entries = require(script.entries),
	freeze = require(script.freeze),
	is = require(script.is),
	isFrozen = require(script.isFrozen),
	keys = require(script.keys),
	preventExtensions = require(script.preventExtensions),
	seal = require(script.seal),
	values = require(script.values),
	-- Special marker type used in conjunction with `assign` to remove values
	-- from tables, since nil cannot be stored in a table
	None = require(script.None),
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006224</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX3EF0CC72C91E49A9BC29696384A8DC9C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">None</string>
										<string name="ScriptGuid">{142D2663-3AB1-44C7-9DEB-E0C15707E6EA}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!nonstrict
-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = newproxy(true)
local mt = getmetatable(None)
mt.__tostring = function()
	return "Object.None"
end

return None
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006225</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX384FEF15FE1C49EA905ED0830FA0A2F0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">assign</string>
										<string name="ScriptGuid">{B29D7BC7-5B8A-4CD2-A919-24372F235FE5}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Packages = Object.Parent.Parent

local None = require(Object.None)
local types = require(Packages.ES7Types)
type Object = types.Object

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
-- Luau TODO: no way to strongly type this accurately, it doesn't eliminate deleted keys of T, and Luau won't do intersections of type packs: <T, ...U>(T, ...: ...U): T & ...U
return function<T, U, V, W>(target: T, source0: U?, source1: V?, source2: W?, ...): T & U & V & W
	if source0 ~= nil and typeof(source0 :: any) == "table" then
		for key, value in pairs(source0 :: any) do
			if value == None then
				(target :: any)[key] = nil
			else
				(target :: any)[key] = value
			end
		end
	end

	if source1 ~= nil and typeof(source1 :: any) == "table" then
		for key, value in pairs(source1 :: any) do
			if value == None then
				(target :: any)[key] = nil
			else
				(target :: any)[key] = value
			end
		end
	end

	if source2 ~= nil and typeof(source2 :: any) == "table" then
		for key, value in pairs(source2 :: any) do
			if value == None then
				(target :: any)[key] = nil
			else
				(target :: any)[key] = value
			end
		end
	end

	for index = 1, select("#", ...) do
		local rest = select(index, ...)

		if rest ~= nil and typeof(rest) == "table" then
			for key, value in pairs(rest) do
				if value == None then
					(target :: any)[key] = nil
				else
					(target :: any)[key] = value
				end
			end
		end
	end

	-- TODO? we can add & Object to this, if needed by real-world code, once CLI-49825 is fixed
	return (target :: any) :: T & U & V & W
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006226</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB1B0ACEA0EDC41A5AFF9EF7DC0A22813">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">entries</string>
										<string name="ScriptGuid">{8BC433B0-D862-4E60-87BD-5759CE1FE5BB}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Map<K, V> = types.Map<K, V>
type Tuple<T, V> = types.Tuple<T, V>

return function<T>(value: string | { [string]: T } | Array<T> | Map<any, T>): Array<Tuple<string, T>>
	assert(value :: any ~= nil, "cannot get entries from a nil value")
	local valueType = typeof(value)

	local entries: Array<Tuple<string, T>> = {}
	if valueType == "table" then
		for key, keyValue in pairs(value :: { [string]: T } | Array<T>) do
			-- Luau FIXME: Luau should see entries as Array<any>, given object is [string]: any, but it sees it as Array<Array<string>> despite all the manual annotation
			table.insert(entries, { key, keyValue })
		end
	elseif valueType == "string" then
		-- TODO: should we be using utf8.len?
		for i = 1, string.len(value :: string) do
			entries[i] = { tostring(i), string.sub(value :: string, i, i) }
		end
	end

	return entries
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006227</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX43B7DCD6D2B14CD1BBA5ACC2FA659BEF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">freeze</string>
										<string name="ScriptGuid">{F82BFC75-48E6-455C-AEA6-F674B67ACF34}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

return function<T>(t: T & (Object | Array<any>)): T
	-- Luau FIXME: model freeze better so it passes through the type constraint and doesn't erase
	return (table.freeze(t :: any) :: any) :: T
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006228</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA08A98E22B224965B1FC107FCBEA8071">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">is</string>
										<string name="ScriptGuid">{63F23BEE-E739-41C0-ACFB-7A2584D1308B}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- Implements Javascript's `Object.is` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
return function(value1: any, value2: any): boolean
	if value1 == value2 then
		return value1 ~= 0 or 1 / value1 == 1 / value2
	else
		return value1 ~= value1 and value2 ~= value2
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006229</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA59DBA7A1E444E719711607BA22D1FFB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">isFrozen</string>
										<string name="ScriptGuid">{52B64488-FED5-43FF-9F36-AC29AD17A797}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

return function(t: Object | Array<any>): boolean
	if __DEV__ then
		print("Luau now has a direct table.isfrozen call that can save the overhead of this library function call")
	end
	return table.isfrozen(t)
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000622a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX45D3FBC51462423ABC25DF1F6C0A93F1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">keys</string>
										<string name="ScriptGuid">{E43C60F7-8786-4F75-A5DE-448C2097E1F2}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Collections = Object.Parent
local Packages = Object.Parent.Parent

local Set = require(Collections.Set)
local types = require(Packages.ES7Types)
local instanceOf = require(Packages.InstanceOf)
type Array<T> = types.Array<T>
type Set<T> = types.Set<T>
type Table = { [any]: any }

return function(value: Set<any> | Table | string): Array<string>
	if value == nil then
		error("cannot extract keys from a nil value")
	end

	local valueType = typeof(value)

	local keys
	if valueType == "table" then
		keys = {}
		if instanceOf(value, Set) then
			return keys
		end

		for key in pairs(value :: Table) do
			table.insert(keys, key)
		end
	elseif valueType == "string" then
		local length = (value :: string):len()
		keys = table.create(length)
		for i = 1, length do
			keys[i] = tostring(i)
		end
	end

	return keys
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000622b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX982338183C7D425EB995B334F4880E68">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">preventExtensions</string>
										<string name="ScriptGuid">{B9DF7FC4-065C-4C8B-908C-A519CF222E48}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

-- FIXME: This should be updated to be closer to the actual
-- `Object.preventExtensions` functionality in JS. This requires additional
-- support from the VM
local function preventExtensions<T>(t: T & (Object | Array<any>)): T
	local name = tostring(t)

	return (
		setmetatable(t :: any, {
			__newindex = function(_self, key, _value)
				local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), name)

				error(message, 2)
			end,
			__metatable = false,
		}) :: any
	) :: T
end

return preventExtensions
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000622c</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE2928C9C64B84F49859F6D4DEB35737C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">seal</string>
										<string name="ScriptGuid">{03225050-81D1-41A3-BAF2-60E62A2C9245}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
type Object = types.Object

return function<T>(t: T & (Object | Array<any>)): T
	-- Luau FIXME: model freeze better so it passes through the type constraint and doesn't erase
	return (table.freeze(t :: any) :: any) :: T
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000622d</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX4E3B5B8AAF5041B4833A8B9C87F12D3D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">values</string>
										<string name="ScriptGuid">{227C18A6-83D7-4F3C-8AB0-9D4D104F4D6C}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Object = script.Parent
local Packages = Object.Parent.Parent

local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>

-- TODO Luau: needs overloads to model this more correctly
return function<T>(value: { [string]: T } | Array<T> | string): Array<T> | Array<string>
	if value == nil then
		error("cannot extract values from a nil value")
	end
	local valueType = typeof(value)

	local array: Array<T> | Array<string>
	if valueType == "table" then
		array = {} :: Array<T>
		for _, keyValue in pairs(value :: { [string]: T } | Array<T>) do
			table.insert(array, keyValue)
		end
	elseif valueType == "string" then
		-- optimization to avoid rehashing/growth
		local valueStringLength = (value :: string):len()
		array = table.create(valueStringLength)
		for i = 1, valueStringLength do
			(array :: Array<string>)[i] = (value :: string):sub(i, i)
		end
	end

	return array
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000622e</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX6B921DC801D94323AB65D85372A4AA6B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Set</string>
									<string name="ScriptGuid">{4F50995F-8EB7-4780-92E7-B34345D191B4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!nonstrict
local __DEV__ = _G.__DEV__
local Collections = script.Parent
local Packages = Collections.Parent

local inspect = require(Collections.inspect)
local isArray = require(Collections.Array.isArray)
local arrayForEach = require(Collections.Array.forEach)
local arrayFromString = require(Collections.Array.from.fromString)

local types = require(Packages.ES7Types)

type Array<T> = types.Array<T>
type Object = types.Object
type setCallbackFn<T> = types.setCallbackFn<T>
type setCallbackFnWithThisArg<T> = types.setCallbackFnWithThisArg<T>
export type Set<T> = types.Set<T>

type Set_Statics = {
	new: <T>(iterable: Array<T> | Set<T> | string | nil) -> Set<T>,
}

local Set: Set<any> & Set_Statics = (
	{
		__iter = function(self)
			return next, self._array
		end,
		__tostring = function(self)
			local result = "Set "
			if #self._array > 0 then
				result ..= "(" .. tostring(#self._array) .. ") "
			end
			result ..= inspect(self._array)
			return result
		end,
	} :: any
) :: Set<any> & Set_Statics;
(Set :: any).__index = Set

function Set.new<T>(iterable: Array<T> | Set<T> | string | nil): Set<T>
	local array
	local map = {}
	if iterable ~= nil then
		local arrayIterable

		if typeof(iterable) == "table" then
			if isArray(iterable) then
				arrayIterable = table.clone(iterable)
			else
				local mt = getmetatable(iterable :: any)
				if mt and rawget(mt, "__iter") then
					arrayIterable = iterable :: Set<T>
				elseif __DEV__ then
					error("cannot create array from an object-like table")
				end
			end
		elseif typeof(iterable) == "string" then
			-- TODO Luau: need overloads for `from` to avoid needing the manual cast
			arrayIterable = arrayFromString(iterable :: string) :: Array<string>
		else
			error(("cannot create array from value of type `%s`"):format(typeof(iterable)))
		end

		if arrayIterable then
			array = table.create(#arrayIterable)
			for _, element in arrayIterable do
				if not map[element] then
					map[element] = true
					table.insert(array, element)
				end
			end
		else
			array = {}
		end
	else
		array = {}
	end

	return (setmetatable({
		size = #array,
		_map = map,
		_array = array,
	}, Set) :: any) :: Set<T>
end

function Set:add(value)
	if not self._map[value] then
		-- Luau FIXME: analyze should know self is Set<T> which includes size as a number
		self.size = self.size :: number + 1
		self._map[value] = true
		table.insert(self._array, value)
	end
	return self
end

function Set:clear()
	self.size = 0
	table.clear(self._map)
	table.clear(self._array)
end

function Set:delete(value): boolean
	if not self._map[value] then
		return false
	end
	-- Luau FIXME: analyze should know self is Map<K, V> which includes size as a number
	self.size = self.size :: number - 1
	self._map[value] = nil
	local index = table.find(self._array, value)
	if index then
		table.remove(self._array, index)
	end
	return true
end

-- Implements Javascript's `Map.prototype.forEach` as defined below
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach
function Set:forEach(callback: setCallbackFn<any> | setCallbackFnWithThisArg<any>, thisArg: Object?): ()
	if typeof(callback) ~= "function" then
		error("callback is not a function")
	end

	-- note: we can't turn this into a simple for-in loop, because the callbacks can modify the table and React, GQL, and Jest rely on JS behavior in that scenario
	arrayForEach(self._array, function(value)
		if thisArg ~= nil then
			(callback :: setCallbackFnWithThisArg<any>)(thisArg, value, value, self)
		else
			(callback :: setCallbackFn<any>)(value, value, self)
		end
	end)
end

function Set:has(value): boolean
	return self._map[value] ~= nil
end

function Set:ipairs()
	if __DEV__ then
		warn(
			debug.traceback(
				"`for _,_ in mySet:ipairs() do` is deprecated and will be removed in a future release, please use `for _,_ in mySet do` instead\n",
				2
			)
		)
	end
	return ipairs(self._array)
end

return Set
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000622f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX25E38165CF80403C9A4515BD26F9AA3D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WeakMap</string>
									<string name="ScriptGuid">{51D63DA6-7F0E-499C-A5A7-BFA8FD209AD4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Collections = script.Parent
local Packages = Collections.Parent

local ES7Types = require(Packages.ES7Types)

type WeakMap<K, V> = ES7Types.WeakMap<K, V>

type WeakMapPrivate<K, V> = {
	_weakMap: { [K]: V },
	-- method definitions
	get: (self: WeakMapPrivate<K, V>, K) -> V,
	set: (self: WeakMapPrivate<K, V>, K, V) -> WeakMapPrivate<K, V>,
	has: (self: WeakMapPrivate<K, V>, K) -> boolean,
}
type WeakMap_Statics = {
	new: <K, V>() -> WeakMap<K, V>,
}

local WeakMap: WeakMapPrivate<any, any> & WeakMap_Statics = {} :: any;
(WeakMap :: any).__index = WeakMap

function WeakMap.new<K, V>(): WeakMap<K, V>
	local weakMap = setmetatable({}, { __mode = "k" })
	return setmetatable({ _weakMap = weakMap }, WeakMap) :: any
end

function WeakMap:get(key)
	return self._weakMap[key]
end

function WeakMap:set(key, value)
	self._weakMap[key] = value
	return self
end

function WeakMap:has(key): boolean
	return self._weakMap[key] ~= nil
end

return WeakMap :: WeakMap<any, any> & WeakMap_Statics
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006230</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB55C638A30894793AAE9353F03BB8613">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">inspect</string>
									<string name="ScriptGuid">{BA9B43E1-5733-4BAC-A12E-1B0384C17442}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- derived from these upstream sources:
-- https://github.com/graphql/graphql-js/blob/1951bce42092123e844763b6a8e985a8a3327511/src/jsutils/inspect.js
local HttpService = game:GetService("HttpService")

local Collections = script.Parent
local Packages = Collections.Parent

local isArray = require(Collections.Array.isArray)
local ES7Types = require(Packages.ES7Types)

type Array<T> = ES7Types.Array<T>
-- local NULL = require(srcWorkspace.luaUtils.null)

-- Support for options partial implementation
-- see: https://nodejs.org/dist/latest-v16.x/docs/api/util.html#utilinspectobject-options
export type InspectOptions = {
	depth: number?,
}

type FormatOptions = {
	depth: number,
}

local MAX_ARRAY_LENGTH = 10
local DEFAULT_RECURSIVE_DEPTH = 2

-- deviation: pre-declare functions
local formatValue
local formatObjectValue
local formatArray
local formatObject
local getObjectTag

--[[
 * Used to print values in error messages.
 ]]
local function inspect(value, options: InspectOptions?): string
	local inspectOptions: InspectOptions = options or { depth = DEFAULT_RECURSIVE_DEPTH }
	local depth = inspectOptions.depth or DEFAULT_RECURSIVE_DEPTH
	inspectOptions.depth = if depth >= 0 then depth else DEFAULT_RECURSIVE_DEPTH
	return formatValue(value, {}, inspectOptions :: FormatOptions)
end

local function isIndexKey(k, contiguousLength)
	return type(k) == "number"
		and k <= contiguousLength -- nothing out of bounds
		and 1 <= k -- nothing illegal for array indices
		and math.floor(k) == k -- no float keys
end

local function getTableLength(tbl)
	local length = 1
	local value = rawget(tbl, length)
	while value ~= nil do
		length += 1
		value = rawget(tbl, length)
	end
	return length - 1
end

local function sortKeysForPrinting(a: any, b)
	local typeofA = type(a)
	local typeofB = type(b)

	-- strings and numbers are sorted numerically/alphabetically
	if typeofA == typeofB and (typeofA == "number" or typeofA == "string") then
		return a < b
	end

	-- sort the rest by type name
	return typeofA < typeofB
end

local function rawpairs(t)
	return next, t, nil
end

local function getFragmentedKeys(tbl)
	local keys = {}
	local keysLength = 0
	local tableLength = getTableLength(tbl)
	for key, _ in rawpairs(tbl) do
		if not isIndexKey(key, tableLength) then
			keysLength = keysLength + 1
			keys[keysLength] = key
		end
	end
	table.sort(keys, sortKeysForPrinting)
	return keys, keysLength, tableLength
end

function formatValue(value, seenValues, options: FormatOptions)
	local valueType = typeof(value)
	if valueType == "string" then
		return HttpService:JSONEncode(value)
		-- deviation: format numbers like in JS
	elseif valueType == "number" then
		if value ~= value then
			return "NaN"
		elseif value == math.huge then
			return "Infinity"
		elseif value == -math.huge then
			return "-Infinity"
		else
			return tostring(value)
		end
	elseif valueType == "function" then
		local result = "[function"
		local functionName = debug.info(value :: (any) -> any, "n")
		if functionName ~= nil and functionName ~= "" then
			result ..= " " .. functionName
		end
		return result .. "]"
	elseif valueType == "table" then
		-- ROBLOX TODO: parameterize inspect with the library-specific NULL sentinel. maybe function generics?
		-- if value == NULL then
		-- 	return 'null'
		-- end
		return formatObjectValue(value, seenValues, options)
	else
		return tostring(value)
	end
end

function formatObjectValue(value, previouslySeenValues, options: FormatOptions)
	if table.find(previouslySeenValues, value) ~= nil then
		return "[Circular]"
	end

	local seenValues = { unpack(previouslySeenValues) }
	table.insert(seenValues, value)

	if typeof(value.toJSON) == "function" then
		local jsonValue = value:toJSON(value)

		if jsonValue ~= value then
			if typeof(jsonValue) == "string" then
				return jsonValue
			else
				return formatValue(jsonValue, seenValues, options)
			end
		end
	elseif isArray(value) then
		return formatArray(value, seenValues, options)
	end

	return formatObject(value, seenValues, options)
end

function formatObject(object, seenValues, options: FormatOptions)
	local result = ""
	local mt = getmetatable(object)
	if mt and rawget(mt, "__tostring") then
		return tostring(object)
	end

	local fragmentedKeys, fragmentedKeysLength, keysLength = getFragmentedKeys(object)

	if keysLength == 0 and fragmentedKeysLength == 0 then
		result ..= "{}"
		return result
	end
	if #seenValues > options.depth then
		result ..= "[" .. getObjectTag(object) .. "]"
		return result
	end

	local properties = {}
	for i = 1, keysLength do
		local value = formatValue(object[i], seenValues, options)

		table.insert(properties, value)
	end

	for i = 1, fragmentedKeysLength do
		local key = fragmentedKeys[i]
		local value = formatValue(object[key], seenValues, options)

		table.insert(properties, key .. ": " .. value)
	end

	result ..= "{ " .. table.concat(properties, ", ") .. " }"
	return result
end

function formatArray(array: Array<any>, seenValues: Array<any>, options: FormatOptions): string
	local length = #array
	if length == 0 then
		return "[]"
	end
	if #seenValues > options.depth then
		return "[Array]"
	end

	local len = math.min(MAX_ARRAY_LENGTH, length)
	local remaining = length - len
	local items = {}

	for i = 1, len do
		items[i] = (formatValue(array[i], seenValues, options))
	end

	if remaining == 1 then
		table.insert(items, "... 1 more item")
	elseif remaining > 1 then
		table.insert(items, ("... %s more items"):format(tostring(remaining)))
	end

	return "[" .. table.concat(items, ", ") .. "]"
end

function getObjectTag(_object): string
	-- local tag = Object.prototype.toString
	-- 	.call(object)
	-- 	.replace("")
	-- 	.replace("")

	-- if tag == "Object" and typeof(object.constructor) == "function" then
	-- 	local name = object.constructor.name

	-- 	if typeof(name) == "string" and name ~= "" then
	-- 		return name
	-- 	end
	-- end

	-- return tag
	return "Object"
end

return inspect
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006231</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX8D116164D9AC40BBAA1A955527EE4D2D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Console</string>
								<string name="ScriptGuid">{D96D5E74-7CE1-48E1-9E75-F4F385111810}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local makeConsoleImpl = require(script.makeConsoleImpl)

return makeConsoleImpl()
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006232</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX3F81707558B44E0B99D2D0A80614A564">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">makeConsoleImpl</string>
									<string name="ScriptGuid">{9D378573-A385-4237-876D-CBC40E493F49}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local root = script.Parent
local Packages = root.Parent
local inspect = require(Packages.Collections).inspect

local INDENT = "  "

return function()
	local console = {}
	local indentDepth = 0

	local function indent()
		return string.rep(INDENT, indentDepth)
	end

	function console.log(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
	end

	function console.debug(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
	end

	function console.info(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
	end

	function console.warn(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		warn(indent() .. message)
	end

	function console.error(content, ...)
		-- JS' `console.error` doesn't interrupt execution like Lua's `error`,
		-- which is more similar to throwing an exception in JS.
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		warn(indent() .. message)
	end

	function console.group(content, ...)
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
		indentDepth = indentDepth + 1
	end

	function console.groupCollapsed(content, ...)
		-- There's no smart console, so this is equivalent to `console.group`
		local message
		if typeof(content) == "string" then
			message = string.format(content, ...)
		else
			message = inspect(content)
		end
		print(indent() .. message)
		indentDepth = indentDepth + 1
	end

	function console.groupEnd()
		if indentDepth > 0 then
			indentDepth = indentDepth - 1
		end
	end

	return console
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006233</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX1AB647F61A8740F89D19B49BE0F498CF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ES7Types</string>
								<string name="ScriptGuid">{9B1F3F3A-C925-4FB5-89B1-E0422E8D3261}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
export type Object = { [string]: any }
export type Array<T> = { [number]: T }
export type Function = (...any) -> ...any
export type Table<T, V> = { [T]: V }
export type Tuple<T, V> = Array<T | V>
export type mapCallbackFn<K, V> = (element: V, key: K, map: Map<K, V>) -> ()
export type mapCallbackFnWithThisArg<K, V> = (thisArg: Object, value: V, key: K, map: Map<K, V>) -> ()

export type Map<K, V> = typeof(setmetatable(
	{} :: {
		size: number,
		-- method definitions
		set: (self: Map<K, V>, K, V) -> Map<K, V>,
		get: (self: Map<K, V>, K) -> V | nil,
		clear: (self: Map<K, V>) -> (),
		delete: (self: Map<K, V>, K) -> boolean,
		forEach: (
			self: Map<K, V>,
			callback: mapCallbackFn<K, V> | mapCallbackFnWithThisArg<K, V>,
			thisArg: Object?
		) -> (),
		[K]: V,
		has: (self: Map<K, V>, K) -> boolean,
		keys: (self: Map<K, V>) -> Array<K>,
		values: (self: Map<K, V>) -> Array<V>,
		entries: (self: Map<K, V>) -> Array<Tuple<K, V>>,
		ipairs: (self: Map<K, V>) -> any,
		_map: { [K]: V },
		_array: { [number]: K },
		__index: (self: Map<K, V>, key: K) -> V,
		__iter: (self: Map<K, V>) -> (<K, V>({ [K]: V }, K?) -> (K?, V), V),
		__newindex: (self: Map<K, V>, key: K, value: V) -> (),
	},
	{} :: {
		__index: Map<K, V>,
		__iter: (self: Map<K, V>) -> (<K, V>({ [K]: V }, K?) -> (K, V), V),
		__newindex: (self: Map<K, V>, key: K, value: V) -> (),
	}
))

export type WeakMap<K, V> = {
	-- method definitions
	get: (self: WeakMap<K, V>, K) -> V,
	set: (self: WeakMap<K, V>, K, V) -> WeakMap<K, V>,
	has: (self: WeakMap<K, V>, K) -> boolean,
}

export type setCallbackFn<T> = (value: T, key: T, set: Set<T>) -> ()
export type setCallbackFnWithThisArg<T> = (thisArg: Object, value: T, key: T, set: Set<T>) -> ()

export type Set<T> = typeof(setmetatable(
	{} :: {
		size: number,
		-- method definitions
		add: (self: Set<T>, T) -> Set<T>,
		clear: (self: Set<T>) -> (),
		delete: (self: Set<T>, T) -> boolean,
		forEach: (self: Set<T>, callback: setCallbackFn<T> | setCallbackFnWithThisArg<T>, thisArg: Object?) -> (),
		has: (self: Set<T>, T) -> boolean,
		ipairs: (self: Set<T>) -> any,
	},
	{} :: {
		__index: Set<T>,
		__iter: (self: Set<T>) -> (<K, V>({ [K]: V }, K?) -> (K, V), T),
	}
))
return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006234</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6AD87899F322492C87F1B187DAF0ABD8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">InstanceOf</string>
								<string name="ScriptGuid">{45AF893C-69E5-4BA7-898A-2EEBF5412EF5}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local instanceof = require(script.instanceof)

return instanceof
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006235</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX34F05BC04DDA491CBB7E977E96FC9BE3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">instanceof</string>
									<string name="ScriptGuid">{C1B77B04-12F4-48BF-A33E-E9597882852B}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- polyfill for https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
local __DEV__ = _G.__DEV__

-- FIXME Luau: typing class as Object gives: Type '{ @metatable {| __call: <a>(a, ...any) -> Error, __tostring: <b, c>({+ message: b, name: c +}) -> string |}, Error }' could not be converted into 'table'
local function instanceof(tbl: any, class: any): boolean
	if __DEV__ then
		assert(typeof(class) == "table", "Received a non-table as the second argument for instanceof")
	end

	if typeof(tbl) ~= "table" then
		return false
	end

	local ok, hasNew = pcall(function()
		return class.new ~= nil and tbl.new == class.new
	end)
	if ok and hasNew then
		return true
	end

	local seen = { [tbl] = true }

	while tbl and typeof(tbl) == "table" do
		tbl = getmetatable(tbl)
		if typeof(tbl) == "table" then
			tbl = tbl.__index

			if tbl == class then
				return true
			end
		end

		-- if we still have a valid table then check against seen
		if typeof(tbl) == "table" then
			if seen[tbl] then
				return false
			end
			seen[tbl] = true
		end
	end

	return false
end

return instanceof
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006236</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXAFDF39EE5D744B8F848FA019F1807A88">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LuauPolyfill</string>
								<string name="ScriptGuid">{9926B469-9DBB-44F6-BFD9-4BFDF5209CB6}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent

local Boolean = require(Packages.Boolean)
local Collections = require(Packages.Collections)
local Console = require(Packages.Console)
local Math = require(Packages.Math)
local Number = require(Packages.Number)
local String = require(Packages.String)
local Symbol = require(Packages.Symbol)
local Timers = require(Packages.Timers)
local types = require(Packages.ES7Types)

local AssertionError = require(script.AssertionError)
local Error = require(script.Error)
local PromiseModule = require(script.Promise)
local extends = require(script.extends)
local instanceof = require(Packages.InstanceOf)

export type Array<T> = types.Array<T>
export type AssertionError = AssertionError.AssertionError
export type Error = Error.Error
export type Map<T, V> = types.Map<T, V>
export type Object = types.Object

export type PromiseLike<T> = PromiseModule.PromiseLike<T>
export type Promise<T> = PromiseModule.Promise<T>

export type Set<T> = types.Set<T>
export type Symbol = Symbol.Symbol
export type Timeout = Timers.Timeout
export type Interval = Timers.Interval
export type WeakMap<T, V> = Collections.WeakMap<T, V>

return {
	Array = Collections.Array,
	AssertionError = AssertionError,
	Boolean = Boolean,
	console = Console,
	Error = Error,
	extends = extends,
	instanceof = instanceof,
	Math = Math,
	Number = Number,
	Object = Collections.Object,
	Map = Collections.Map,
	coerceToMap = Collections.coerceToMap,
	coerceToTable = Collections.coerceToTable,
	Set = Collections.Set,
	WeakMap = Collections.WeakMap,
	String = String,
	Symbol = Symbol,
	setTimeout = Timers.setTimeout,
	clearTimeout = Timers.clearTimeout,
	setInterval = Timers.setInterval,
	clearInterval = Timers.clearInterval,
	util = {
		inspect = Collections.inspect,
	},
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006237</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXA7EDCC878EE24FFAA5C5E8FF54F04CDB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">AssertionError</string>
									<string name="ScriptGuid">{6867B9B0-EB3E-483F-AEFD-3ED229DBC302}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local AssertionErrorModule = require(script["AssertionError.global"])

export type AssertionError = AssertionErrorModule.AssertionError

return AssertionErrorModule.AssertionError
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006238</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX443BADD3D84147F2817D8A694C76B4EF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">AssertionError.global</string>
										<string name="ScriptGuid">{85DCDB50-3C5C-4DAB-A8CC-353D954FEEE7}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- ROBLOX upstream: https://github.com/nodejs/node/blob/v18.1.0/lib/internal/assert/assertion_error.js
--[[
	Copyright Node.js contributors. All rights reserved.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
	IN THE SOFTWARE.
]]

local LuauPolyfill = script.Parent.Parent
local Packages = LuauPolyfill.Parent

local Collections = require(Packages.Collections)
local Array = Collections.Array
local Object = Collections.Object
local Boolean = require(Packages.Boolean)
local String = require(Packages.String)
local types = require(Packages.ES7Types)
local inspect = Collections.inspect

local Error = require(LuauPolyfill.Error)
local instanceof = require(Packages.InstanceOf)

type Error = Error.Error
type Array<T> = types.Array<T>
type Object = types.Object
type Function = types.Function

-- ROBLOX deviation START: mock process to not change AssertionError internals
local process = {
	stderr = {
		isTTY = false,
		columns = 0,
		hasColors = function(_)
			return true
		end,
	},
}
-- ROBLOX deviation END
-- ROBLOX TODO START: implement ErrorCaptureStackTrace correctly
function ErrorCaptureStackTrace(err, ...)
	Error.captureStackTrace(err, ...)
end
-- ROBLOX TODO END
-- ROBLOX TODO START: use real remove colors
local function removeColors(str)
	return str
end
-- local removeColors = require_("internal/util").removeColors
-- ROBLOX TODO END
-- local validateObject = require_("internal/validators").validateObject
-- ROBLOX deviation START: isErrorStackTraceLimitWritable is not necessary ATM
-- local isErrorStackTraceLimitWritable = require_("internal/errors").isErrorStackTraceLimitWritable
-- ROBLOX deviation END
local blue = ""
local green = ""
local red = ""
local white = ""
local kReadableOperator = {
	deepStrictEqual = "Expected values to be strictly deep-equal:",
	strictEqual = "Expected values to be strictly equal:",
	strictEqualObject = 'Expected "actual" to be reference-equal to "expected":',
	deepEqual = "Expected values to be loosely deep-equal:",
	notDeepStrictEqual = 'Expected "actual" not to be strictly deep-equal to:',
	notStrictEqual = 'Expected "actual" to be strictly unequal to:',
	notStrictEqualObject = 'Expected "actual" not to be reference-equal to "expected":',
	notDeepEqual = 'Expected "actual" not to be loosely deep-equal to:',
	notIdentical = "Values have same structure but are not reference-equal:",
	notDeepEqualUnequal = "Expected values not to be loosely deep-equal:",
}
-- Comparing short primitives should just show === / !== instead of using the
-- diff.
local kMaxShortLength = 12
local function copyError(source: Object)
	local keys = Object.keys(source)
	-- ROBLOX TODO:
	local target = {} -- ObjectCreate(ObjectGetPrototypeOf(source))
	for _, key in keys do
		target[key] = source[key]
	end
	target.message = source.message
	return target
end

local function inspectValue(val)
	-- The util.inspect default values could be changed. This makes sure the
	-- error messages contain the necessary information nevertheless.
	return inspect(val, {
		compact = false,
		customInspect = false,
		depth = 1000,
		maxArrayLength = math.huge, -- Assert compares only enumerable properties (with a few exceptions).
		showHidden = false, -- Assert does not detect proxies currently.
		showProxy = false,
		sorted = true, -- Inspect getters as we also check them when comparing entries.
		getters = true,
	})
end

local function createErrDiff(actual, expected, operator)
	local other = ""
	local res = ""
	local end_ = ""
	local skipped = false
	local actualInspected = inspectValue(actual)
	local actualLines = String.split(actualInspected, "\n")
	local expectedLines = String.split(inspectValue(expected), "\n")

	local i = 0
	local indicator = ""

	-- In case both values are objects or functions explicitly mark them as not
	-- reference equal for the `strictEqual` operator.
	if
		operator == "strictEqual"
		and (
			typeof(actual) == "table" and actual ~= nil and typeof(expected) == "table" and expected ~= nil
			or typeof(actual) == "function" and typeof(expected) == "function"
		)
	then
		operator = "strictEqualObject"
	end

	-- If "actual" and "expected" fit on a single line and they are not strictly
	-- equal, check further special handling.
	if #actualLines == 1 and #expectedLines == 1 and actualLines[1] ~= expectedLines[1] then
		-- Check for the visible length using the `removeColors()` function, if
		-- appropriate.
		-- ROBLOX TODO START
		local c = false
		-- local c = inspect.defaultOptions.colors
		-- ROBLOX TODO END
		local actualRaw = if c then removeColors(actualLines[1]) else actualLines[1]
		local expectedRaw = if Boolean.toJSBoolean(c) then removeColors(expectedLines[1]) else expectedLines[1]
		local inputLength = string.len(actualRaw) + string.len(expectedRaw)
		-- If the character length of "actual" and "expected" together is less than
		-- kMaxShortLength and if neither is an object and at least one of them is
		-- not `zero`, use the strict equal comparison to visualize the output.
		if inputLength <= kMaxShortLength then
			if
				(typeof(actual) ~= "table" or actual == nil)
				and (typeof(expected) ~= "table" or expected == nil)
				and (actual ~= 0 or expected ~= 0)
			then
				-- -0 === +0
				return ("%s\n\n"):format(kReadableOperator[operator])
					.. ("%s !== %s\n"):format(actualLines[1], expectedLines[1])
			end
		elseif operator ~= "strictEqualObject" then
			-- If the stderr is a tty and the input length is lower than the current
			-- columns per line, add a mismatch indicator below the output. If it is
			-- not a tty, use a default value of 80 characters.
			local maxLength = if process.stderr.isTTY then process.stderr.columns else 80
			if inputLength < maxLength then
				while string.sub(actualRaw, i + 1, i + 1) == string.sub(expectedRaw, i + 1, i + 1) do
					i += 1
				end
				-- Ignore the first characters.
				if i > 2 then
					-- Add position indicator for the first mismatch in case it is a
					-- single line and the input length is less than the column length.
					indicator = ("\n  %s^"):format(string.rep(" ", i))
					i = 0
				end
			end
		end
	end

	-- Remove all ending lines that match (this optimizes the output for
	-- readability by reducing the number of total changed lines).
	local a = actualLines[#actualLines]
	local b = expectedLines[#expectedLines]
	while a == b do
		local i_ = i
		i += 1
		if i_ < 3 then
			end_ = ("\n  %s%s"):format(a, end_)
		else
			other = a
		end
		table.remove(actualLines)
		table.remove(expectedLines)
		if #actualLines == 0 or #expectedLines == 0 then
			break
		end
		a = actualLines[#actualLines]
		b = expectedLines[#expectedLines]
	end

	local maxLines = math.max(#actualLines, #expectedLines)
	-- Strict equal with identical objects that are not identical by reference.
	-- E.g., assert.deepStrictEqual({ a: Symbol() }, { a: Symbol() })
	if maxLines == 0 then
		-- We have to get the result again. The lines were all removed before.
		local actualLines_ = String.split(actualInspected, "\n")

		-- Only remove lines in case it makes sense to collapse those.
		-- TODO: Accept env to always show the full error.
		if #actualLines_ > 50 then
			actualLines_[47] = ("%s...%s"):format(blue, white)
			while #actualLines_ > 47 do
				table.remove(actualLines_)
			end
		end

		return ("%s\n\n"):format(kReadableOperator.notIdentical) .. ("%s\n"):format(Array.join(actualLines_, "\n"))
	end

	-- There were at least five identical lines at the end. Mark a couple of
	-- skipped.
	if i >= 5 then
		end_ = ("\n%s...%s%s"):format(blue, white, end_)
		skipped = true
	end
	if other ~= "" then
		end_ = ("\n  %s%s"):format(other, end_)
		other = ""
	end

	local printedLines = 0
	local identical = 0
	local msg = kReadableOperator[operator] .. ("\n%s+ actual%s %s- expected%s"):format(green, white, red, white)
	local skippedMsg = (" %s...%s Lines skipped"):format(blue, white)

	local lines = actualLines
	local plusMinus = ("%s+%s"):format(green, white)
	local maxLength = #expectedLines
	if #actualLines < maxLines then
		lines = expectedLines
		plusMinus = ("%s-%s"):format(red, white)
		maxLength = #actualLines
	end

	for ii = 1, maxLines do
		i = ii
		if maxLength < ii then
			-- If more than two former lines are identical, print them. Collapse them
			-- in case more than five lines were identical.
			if identical > 2 then
				if identical > 3 then
					if identical > 4 then
						if identical == 5 then
							res ..= ("\n  %s"):format(lines[(ii - 3)])
							printedLines += 1
						else
							res ..= ("\n%s...%s"):format(blue, white)
							skipped = true
						end
					end
					res ..= ("\n  %s"):format(lines[(ii - 2)])
					printedLines += 1
				end
				res ..= ("\n  %s"):format(lines[(ii - 1)])
				printedLines += 1
			end
			-- No identical lines before.
			identical = 0
			-- Add the expected line to the cache.
			if lines == actualLines then
				res ..= ("\n%s %s"):format(plusMinus, lines[ii])
			else
				other ..= ("\n%s %s"):format(plusMinus, lines[ii])
			end
			printedLines += 1
			-- Only extra actual lines exist
			-- Lines diverge
		else
			local expectedLine = expectedLines[ii]
			local actualLine = actualLines[ii]
			-- If the lines diverge, specifically check for lines that only diverge by
			-- a trailing comma. In that case it is actually identical and we should
			-- mark it as such.
			local divergingLines = actualLine ~= expectedLine
				and (
					not Boolean.toJSBoolean(String.endsWith(actualLine, ","))
					or String.slice(actualLine, 0, -1) ~= expectedLine
				)
			-- If the expected line has a trailing comma but is otherwise identical,
			-- add a comma at the end of the actual line. Otherwise the output could
			-- look weird as in:
			--
			--   [
			--     1         // No comma at the end!
			-- +   2
			--   ]
			--
			if
				divergingLines
				and String.endsWith(expectedLine, ",")
				and String.slice(expectedLine, 0, -1) == actualLine
			then
				divergingLines = false
				actualLine ..= ","
			end
			if divergingLines then
				-- If more than two former lines are identical, print them. Collapse
				-- them in case more than five lines were identical.
				if identical > 2 then
					if identical > 3 then
						if identical > 4 then
							if identical == 5 then
								res ..= ("\n  %s"):format(actualLines[ii - 3])
								printedLines += 1
							else
								res ..= ("\n%s...%s"):format(blue, white)
								skipped = true
							end
						end
						res ..= ("\n  %s"):format(actualLines[ii - 2])
						printedLines += 1
					end
					res ..= ("\n  %s"):format(actualLines[ii - 1])
					printedLines += 1
				end
				-- No identical lines before.
				identical = 0
				-- Add the actual line to the result and cache the expected diverging
				-- line so consecutive diverging lines show up as +++--- and not +-+-+-.
				res ..= ("\n%s+%s %s"):format(green, white, actualLine)
				other ..= ("\n%s-%s %s"):format(red, white, expectedLine)
				printedLines += 2
				-- Lines are identical
			else
				-- Add all cached information to the result before adding other things
				-- and reset the cache.
				res ..= other
				other = ""
				identical += 1
				-- The very first identical line since the last diverging line is be
				-- added to the result.
				if identical <= 2 then
					res ..= ("\n  %s"):format(actualLine)
					printedLines += 1
				end
			end
		end
		-- Inspected object to big (Show ~50 rows max)
		if printedLines > 50 and ii < maxLines - 2 then
			return ("%s%s\n%s\n%s...%s%s\n"):format(msg, skippedMsg, res, blue, white, other)
				.. ("%s...%s"):format(blue, white)
		end
	end

	return ("%s%s\n%s%s%s%s"):format(msg, if skipped then skippedMsg else "", res, other, end_, indicator)
end
-- ROBLOX deviation START: skipped as it is only needed in [inspect.custom] method
-- local function addEllipsis(string_)
-- 	local lines = String.split(string_, "\n", 11)
-- 	if #lines.length > 10 then
-- 		lines = Array.slice(lines, 0, 10)
-- 		return ("%s\n..."):format(Array.join(lines, "\n"))
-- 	elseif string.len(string_) > 512 then
-- 		return ("%s..."):format(String.slice(string_, 512))
-- 	end
-- 	return string_
-- end
-- ROBLOX deviation END

export type AssertionError = Error & {
	actual: any,
	expected: any,
	operator: string?,
	generatedMessage: boolean,
	code: "ERR_ASSERTION",
	toString: (self: AssertionError) -> any,
	-- ROBLOX deviation: skipped [inpect.custom] method
	-- [inspect.custom]: (self: AssertionError, recurseTimes: any, ctx: any) -> any,
}

type AssertionErrorStatics = {
	new: (options: AssertionErrorOptions) -> AssertionError,
	__index: AssertionError,
	__tostring: (self: AssertionError) -> string,
}

local AssertionError: AssertionError & AssertionErrorStatics = (
	setmetatable({}, { __index = Error }) :: any
) :: AssertionError & AssertionErrorStatics
AssertionError.__index = AssertionError
AssertionError.__tostring = function(self: AssertionError)
	return self:toString()
end

type AssertionErrorOptions = {
	message: string?,
	actual: any?,
	expected: any?,
	-- ROBLOX note: this is optional in definitely-typed, but we always use it in Lua and it's only nil when details is non-nil
	operator: string?,
	stackStartFn: Function?,
}

function AssertionError.new(options: AssertionErrorOptions): AssertionError
	local self: AssertionError
	-- validateObject(options, "options")
	-- stylua: ignore
	local message, operator, stackStartFn =
		options.message,
		options.operator,
		options.stackStartFn
	local actual, expected = options.actual, options.expected
	-- ROBLOX deviation START: Error.stackTraceLimit not available in Luau port
	-- local limit = Error.stackTraceLimit
	-- if isErrorStackTraceLimitWritable() then
	-- 	Error.stackTraceLimit = 0
	-- end
	-- ROBLOX deviation END
	if message ~= nil then
		self = (setmetatable(Error.new(tostring(message)), AssertionError) :: any) :: AssertionError
	else
		if process.stderr.isTTY then
			-- Reset on each call to make sure we handle dynamically set environment
			-- variables correct.
			if process.stderr:hasColors() then
				blue = "\u{001b}[34m"
				green = "\u{001b}[32m"
				white = "\u{001b}[39m"
				red = "\u{001b}[31m"
			else
				blue = ""
				green = ""
				white = ""
				red = ""
			end
		end
		-- Prevent the error stack from being visible by duplicating the error
		-- in a very close way to the original in case both sides are actually
		-- instances of Error.
		if
			typeof(actual) == "table"
			and actual ~= nil
			and typeof(expected) == "table"
			and expected ~= nil
			and Array.indexOf(Object.keys(actual), "stack") ~= -1
			and instanceof(actual, Error)
			and Array.indexOf(Object.keys(expected), "stack") ~= -1
			and instanceof(expected, Error)
		then
			actual = copyError(actual)
			expected = copyError(expected)
		end
		if operator == "deepStrictEqual" or operator == "strictEqual" then
			self = (
				setmetatable(Error.new(createErrDiff(actual, expected, operator)), AssertionError) :: any
			) :: AssertionError
		elseif operator == "notDeepStrictEqual" or operator == "notStrictEqual" then
			-- In case the objects are equal but the operator requires unequal, show
			-- the first object and say A equals B
			local base = kReadableOperator[operator]
			local res = String.split(inspectValue(actual), "\n")

			-- In case "actual" is an object or a function, it should not be
			-- reference equal.
			if
				operator == "notStrictEqual"
				and (typeof(actual) == "table" and actual ~= nil or typeof(actual) == "function")
			then
				base = kReadableOperator.notStrictEqualObject
			end

			-- Only remove lines in case it makes sense to collapse those.
			-- TODO: Accept env to always show the full error.
			if #res > 50 then
				res[47] = ("%s...%s"):format(blue, white)
				while #res > 47 do
					table.remove(res)
				end
			end

			-- Only print a single input.
			if #res == 1 then
				self = (
					setmetatable(
						Error.new(("%s%s%s"):format(base, if string.len(res[1]) > 5 then "\n\n" else " ", res[1])),
						AssertionError
					) :: any
				) :: AssertionError
			else
				self = (
					setmetatable(Error.new(("%s\n\n%s\n"):format(base, Array.join(res, "\n"))), AssertionError) :: any
				) :: AssertionError
			end
		else
			local res = inspectValue(actual)
			local other = inspectValue(expected)
			local knownOperator = kReadableOperator[tostring(operator)]
			if operator == "notDeepEqual" and res == other then
				res = ("%s\n\n%s"):format(knownOperator, res)
				if string.len(res) > 1024 then
					res = ("%s..."):format(String.slice(res, 0, 1021))
				end
				self = (setmetatable(Error.new(res), AssertionError) :: any) :: AssertionError
			else
				if string.len(res) > 512 then
					res = ("%s..."):format(String.slice(res, 0, 509))
				end
				if string.len(other) > 512 then
					other = ("%s..."):format(String.slice(other, 0, 509))
				end
				if operator == "deepEqual" then
					res = ("%s\n\n%s\n\nshould loosely deep-equal\n\n"):format(knownOperator, res)
				else
					local newOp = kReadableOperator[("%sUnequal"):format(tostring(operator))]
					if Boolean.toJSBoolean(newOp) then
						res = ("%s\n\n%s\n\nshould not loosely deep-equal\n\n"):format(newOp, res)
					else
						other = (" %s %s"):format(tostring(operator), other)
					end
				end
				self = (setmetatable(Error.new(("%s%s"):format(res, other)), AssertionError) :: any) :: AssertionError
			end
		end
	end
	-- ROBLOX deviation START: Error.stackTraceLimit not available in Luau port
	-- if Boolean.toJSBoolean(isErrorStackTraceLimitWritable()) then
	-- 	Error.stackTraceLimit = limit
	-- end
	-- ROBLOX deviation END
	self.generatedMessage = not Boolean.toJSBoolean(message)
	--[[
		ROBLOX deviation: not using ObjectDefineProperty:
		original code:
		ObjectDefineProperty(self, "name", {
			value = "AssertionError [ERR_ASSERTION]",
			enumerable = false,
			writable = true,
			configurable = true,
		})
	]]
	self.name = "AssertionError [ERR_ASSERTION]"
	self.code = "ERR_ASSERTION"
	-- ROBLOX deviation START: details field not in public API docs, nodejs test suite, or in definitely-typed
	-- if details ~= nil then
	-- 	self.actual = nil
	-- 	self.expected = nil
	-- 	self.operator = ""
	-- 	for i = 1, #details do
	-- 		self["message " .. tostring(i)] = details[i].message
	-- 		self["actual " .. tostring(i)] = details[i].actual
	-- 		self["expected " .. tostring(i)] = details[i].expected
	-- 		self["operator " .. tostring(i)] = details[i].operator
	-- 		self["stack trace " .. tostring(i)] = details[i].stack
	-- 	end
	-- else
	self.actual = actual
	self.expected = expected
	self.operator = operator
	-- end
	-- ROBLOX deviation END
	ErrorCaptureStackTrace(self, stackStartFn or AssertionError.new)
	-- Create error message including the error code in the name.
	--[[
		ROBLOX deviation: Lua doesn't support 'LuaMemberExpression' as a standalone type
		original code:
		this.stack
	]]
	-- Reset the name.
	self.name = "AssertionError"
	return (self :: any) :: AssertionError
end

function AssertionError:toString()
	return ("%s [%s]: %s"):format(self.name, self.code, self.message)
end

AssertionError.name = "AssertionError"

return { AssertionError = AssertionError }
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006239</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX40B8D3B985F54A15829110726ECFA85C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Error</string>
									<string name="ScriptGuid">{FBADF0C6-CE3F-4FA9-A3D3-C95741D6F088}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Error = require(script["Error.global"])
export type Error = Error.Error
return Error
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000623a</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX4544018E178449B99DE967368BBEEA3B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Error.global</string>
										<string name="ScriptGuid">{B3B2A427-1F12-4751-9C58-C41A2D21D353}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local LuauPolyfill = script.Parent.Parent
local Packages = LuauPolyfill.Parent

local types = require(Packages.ES7Types)

type Function = types.Function

export type Error = { name: string, message: string, stack: string? }
type Error_private = Error & { __stack: string? }

local Error = {}

local DEFAULT_NAME = "Error"
Error.__index = Error
Error.__tostring = function(self)
	-- Luau FIXME: I can't cast to Error or Object here: Type 'Object' could not be converted into '{ @metatable *unknown*, {|  |} }'
	return getmetatable(Error :: any).__tostring(self)
end

-- ROBLOX NOTE: extracted __createError function so that both Error.new() and Error() can capture the stack trace at the same depth
local function __createError(message: string?): Error
	local self = (setmetatable({
		name = DEFAULT_NAME,
		message = message or "",
	}, Error) :: any) :: Error
	Error.__captureStackTrace(self, 4)
	return self
end

function Error.new(message: string?): Error
	return __createError(message)
end

function Error.captureStackTrace(err: Error, options: Function?)
	Error.__captureStackTrace(err, 3, options)
end

function Error.__captureStackTrace(err_: Error, level: number, options: Function?)
	local err = err_ :: Error_private
	if typeof(options) == "function" then
		local stack = debug.traceback(nil, level)
		local functionName: string = debug.info(options, "n")
		local sourceFilePath: string = debug.info(options, "s")

		local espacedSourceFilePath = string.gsub(sourceFilePath, "([%(%)%.%%%+%-%*%?%[%^%$])", "%%%1")
		local stacktraceLinePattern = espacedSourceFilePath .. ":%d* function " .. functionName
		local beg = string.find(stack, stacktraceLinePattern)
		local end_ = nil
		if beg ~= nil then
			beg, end_ = string.find(stack, "\n", beg + 1)
		end
		if end_ ~= nil then
			stack = string.sub(stack, end_ + 1)
		end
		err.__stack = stack
	else
		err.__stack = debug.traceback(nil, level)
	end
	Error.__recalculateStacktrace(err)
end

function Error.__recalculateStacktrace(err_: Error)
	local err = err_ :: Error_private
	local message = err.message
	local name = err.name or DEFAULT_NAME

	local errName = name .. (if message ~= nil and message ~= "" then (": " .. message) else "")
	local stack = if err.__stack then err.__stack else ""

	err.stack = errName .. "\n" .. stack
end

return setmetatable(Error, {
	__call = function(_, ...)
		return __createError(...)
	end,
	__tostring = function(self)
		if self.name ~= nil then
			if self.message and self.message ~= "" then
				return string.format("%s: %s", tostring(self.name), tostring(self.message))
			end
			return tostring(self.name)
		end
		return tostring(DEFAULT_NAME)
	end,
})
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed0000623b</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX8F33D143E7554A04A7A5CE81956E9693">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Promise</string>
									<string name="ScriptGuid">{B9AAC511-F047-47CD-A157-029A15C7A574}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- this maps onto community promise libraries which won't support Luau, so we inline
export type PromiseLike<T> = {
	andThen: (
		self: PromiseLike<T>,
		resolve: ((T) -> ...(nil | T | PromiseLike<T>))?,
		reject: ((any) -> ...(nil | T | PromiseLike<T>))?
	) -> PromiseLike<T>,
}

type PromiseStatus = "Started" | "Resolved" | "Rejected" | "Cancelled"

export type Promise<T> = {
	andThen: (
		self: Promise<T>,
		resolve: ((T) -> ...(nil | T | PromiseLike<T>))?,
		reject: ((any) -> ...(nil | T | PromiseLike<T>))?
	) -> Promise<T>,

	catch: (Promise<T>, ((any) -> ...(nil | T | PromiseLike<nil>))) -> Promise<T>,

	onCancel: (Promise<T>, () -> ()?) -> boolean,

	expect: (Promise<T>) -> ...T,

	-- FIXME Luau: need union type packs to parse  (...T) | () | PromiseLike<T> here
	await: (Promise<T>) -> (boolean, ...(T | any)),

	getStatus: (self: Promise<T>) -> PromiseStatus,
	-- FIXME Luau: need union type packs to parse  (...T) | () | PromiseLike<T> here
	awaitStatus: (self: Promise<T>) -> (PromiseStatus, ...(T | any)),
}

return {}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000623c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD5A0C4F935CE4D1688FC2DD963AD9292">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">encodeURIComponent</string>
									<string name="ScriptGuid">{2D17D90D-433D-4EB9-B298-0400485B2A9F}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- reference documentation: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
local HttpService = game:GetService("HttpService")

local root = script.Parent
local Packages = root.Parent

local String = require(Packages.String)
local charCodeAt = String.charCodeAt
local Error = require(script.Parent.Error)

local function encodeURIComponent(value: string): string
	local valueLength = utf8.len(value)
	if valueLength == 0 or valueLength == nil then
		return ""
	end
	-- we don't exhaustively test the whole string for invalid characters like ECMA-262 15.1.3 says
	local check = charCodeAt(value, 1)
	if valueLength == 1 then
		if check == 0xD800 then
			error(Error.new("URI malformed"))
		end
		if check == 0xDFFF then
			error(Error.new("URI malformed"))
		end
	end
	if check >= 0xDC00 and check < 0xDFFF then
		error(Error.new("URI malformed"))
	end
	local encoded = HttpService:UrlEncode(value)
	-- reverting encoded chars which are not encoded by JS
	local result = encoded
		:gsub("%%2D", "-")
		:gsub("%%5F", "_")
		:gsub("%%2E", ".")
		:gsub("%%21", "!")
		:gsub("%%7E", "~")
		:gsub("%%2A", "*")
		:gsub("%%27", "'")
		:gsub("%%28", "(")
		:gsub("%%29", ")")
	return result
end

return encodeURIComponent
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000623d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3091AC3E2E624D3FA3A5D2AB0BB59887">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">extends</string>
									<string name="ScriptGuid">{0A60EBA6-1162-4E34-A570-AF73B7F37B2E}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!nonstrict
--[[
	deviation: Our constructors currently have no notion of 'super' so any
	such behavior in upstream JS must be implemented manually by setting fields

	A constructor passed to this class would typically look along the lines of:
	function(self, arg, otherArg)
		self.arg = arg
		self.otherArg = otherArg
	end

	But even something like function() end can be passed in as the constructor
	if no fields need to be set. In upstream JS, the equivalent would be
	returning an empty object from the constructor.
]]
return function(parent, childName, constructor)
	local Child = {}
	Child.__index = Child
	Child.__tostring = function(self)
		return getmetatable(parent).__tostring(self)
	end

	local mt = {}

	Child.new = function(...)
		local self = {}
		constructor(self, ...)
		return setmetatable(self, Child)
	end

	if typeof(getmetatable(parent)) == "table" and getmetatable(parent).__call then
		mt.__call = function(_, ...)
			return Child.new(...)
		end
	end

	mt.__index = parent
	mt.__tostring = function(self)
		-- Printing class name
		if self == Child then
			return tostring(childName)
		end
		return getmetatable(parent).__tostring(self)
	end

	setmetatable(Child, mt)

	return Child
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000623e</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX637AE6CB6DB049569325FFCF1E853D72">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Math</string>
								<string name="ScriptGuid">{F6DB4B81-18C5-4B4F-AF70-66776984CEC5}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return {
	clz32 = bit32.countlz,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000623f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFC480E06172444B2ADD71EBE1B1B3B15">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Number</string>
								<string name="ScriptGuid">{2DC98DEF-68C6-4268-8DB5-C0CE21F3995B}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return {
	isFinite = require(script.isFinite),
	isInteger = require(script.isInteger),
	isNaN = require(script.isNaN),
	isSafeInteger = require(script.isSafeInteger),
	MAX_SAFE_INTEGER = require(script.MAX_SAFE_INTEGER),
	MIN_SAFE_INTEGER = require(script.MIN_SAFE_INTEGER),
	NaN = 0 / 0,
	toExponential = require(script.toExponential),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006240</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX99FA95604B7744938CABBF3F110DB1F6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MAX_SAFE_INTEGER</string>
									<string name="ScriptGuid">{69E20D94-7F3E-4835-A40D-68C4EF5C248D}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
return 9007199254740991
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006241</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEB4AF532D8CA431196AC98BBE7537251">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MIN_SAFE_INTEGER</string>
									<string name="ScriptGuid">{7B6142A2-0C8B-4372-865C-A60072154CE6}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER
return -9007199254740991
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006242</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX31C6E7C9C0F747B7BEAC6C2291D21873">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isFinite</string>
									<string name="ScriptGuid">{81A4DFD8-E768-4C44-AD19-8B839FD82F00}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return function(value)
	return typeof(value) == "number" and value == value and value ~= math.huge and value ~= -math.huge
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006243</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA21515EC2830439E8ED2CA5E723EBD65">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isInteger</string>
									<string name="ScriptGuid">{3F1CE892-6A34-4D87-A229-5617619A28B2}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
return function(value)
	return type(value) == "number" and value ~= math.huge and value == math.floor(value)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006244</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX428D6881F3D14C2D946539B873902B9A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isNaN</string>
									<string name="ScriptGuid">{ADF00DC9-F295-4EA1-B614-CD4C670D1A51}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN
return function(value)
	return type(value) == "number" and value ~= value
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006245</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA75F087EC47A404788E335AC8C5F95F0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">isSafeInteger</string>
									<string name="ScriptGuid">{72E7EF3B-BB6B-4BC7-A038-1A70EEDE59E7}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger
local isInteger = require(script.Parent.isInteger)
local MAX_SAFE_INTEGER = require(script.Parent.MAX_SAFE_INTEGER)

return function(value)
	return isInteger(value) and math.abs(value) <= MAX_SAFE_INTEGER
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006246</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAF20815CEBAA4F92BF732432EC4D87D4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">toExponential</string>
									<string name="ScriptGuid">{C8274590-EFEA-4319-8EF8-3CC011F02D9B}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toExponential
return function(value: string | number, fractionDigits: number?): string | nil
	local num = value
	if typeof(value) == "string" then
		-- ROBLOX FIXME: add parseInt to encapsulate this logic and use it here
		local NaN = 0 / 0
		num = tonumber(value) or NaN -- works because 0 is truthy in Lua
	end
	-- returns nil for invalid input instead of nan to be more lua-native
	if typeof(num) ~= "number" then
		return "nan"
	end

	if fractionDigits ~= nil then
		if typeof(fractionDigits) ~= "number" then
			error("TypeError: fractionDigits must be a number between 0 and 100")
		end
		if fractionDigits < 0 or fractionDigits > 100 then
			error("RangeError: fractionDigits must be between 0 and 100")
		end
	end

	local formatString
	if fractionDigits == nil then
		formatString = "%e"
	else
		formatString = "%." .. tostring(fractionDigits) .. "e"
	end

	local retval = string.format(formatString, num):gsub("%+0", "+"):gsub("%-0", "-"):gsub("0*e", "e")

	return retval
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006247</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXDE4C2156D3C64AD7B5C58477659632CA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">String</string>
								<string name="ScriptGuid">{F4600DB4-14F2-40EC-8C56-B14B85743A61}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return {
	charCodeAt = require(script.charCodeAt),
	endsWith = require(script.endsWith),
	findOr = require(script.findOr),
	includes = require(script.includes),
	indexOf = require(script.indexOf),
	lastIndexOf = require(script.lastIndexOf),
	slice = require(script.slice),
	split = require(script.split),
	startsWith = require(script.startsWith),
	substr = require(script.substr),
	trim = require(script.trim),
	trimEnd = require(script.trimEnd),
	trimStart = require(script.trimStart),
	-- aliases for trimEnd and trimStart
	trimRight = require(script.trimEnd),
	trimLeft = require(script.trimStart),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006248</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXE439E47086BE473287B5A02D6C3089D2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">charCodeAt</string>
									<string name="ScriptGuid">{6F5EF625-7111-4F61-BE11-EA5B05C5C614}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local String = script.Parent
local Packages = String.Parent
local Number = require(Packages.Number)

local NaN = Number.NaN

-- js  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt
-- lua http://www.lua.org/manual/5.4/manual.html#pdf-utf8.codepoint
return function(str: string, index: number): number
	if type(index) ~= "number" then
		index = 1
	end
	--[[
		Initial bounds check. Checking string.len is not an exhaustive upper bound,
		but it is cheaper to check string.len and handle utf8.offset than to check
		utf.len, which iterates over all codepoints.
	]]
	local length = string.len(str)
	if index < 1 or index > length then
		return NaN
	end

	-- utf8.offset returns nil for out of bounds
	local offset = utf8.offset(str, index)

	-- check that offset is not greater than the length of the string
	if offset == nil or offset > length then
		return NaN
	end

	local value = utf8.codepoint(str, offset, offset)

	if value == nil then
		return NaN
	end

	return value
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006249</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC1DA248F2E304597B03536FFEFD26A00">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">endsWith</string>
									<string name="ScriptGuid">{2C25777E-84AF-4AF2-B6B9-A84DC8166A68}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local function endsWith(value: string, substring: string, optionalLength: number?): boolean
	local substringLength = substring:len()
	if substringLength == 0 then
		return true
	end
	local valueLength = value:len()
	local length = optionalLength or valueLength
	if length > valueLength then
		length = valueLength
	end
	if length < 1 then
		return false
	end
	local position = length - substringLength + 1
	return value:find(substring, position, true) == position
end

return endsWith
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000624a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5FE276A5068A43D7BAA54DD2FA1A5558">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">findOr</string>
									<string name="ScriptGuid">{1432C862-3C3A-45E9-B2ED-7F7E200292C4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
type Match = {
	index: number,
	match: string,
}

-- excluding the `+` and `*` character, since findOr tests and graphql use them explicitly
local luaPatternCharacters = "([" .. ("$%^()-[].?"):gsub("(.)", "%%%1") .. "])"

local function findOr(str: string, patternTable: { string }, initIndex: number?): Match | nil
	-- loop through all options in patern patternTable

	local init = utf8.offset(str, initIndex or 1)
	local matches = {}
	for _, value in patternTable do
		value = value:gsub(luaPatternCharacters, "%%%1")
		local iStart, iEnd = string.find(str, value, init)
		if iStart then
			local prefix = string.sub(str, 1, iStart - 1)
			local prefixEnd, invalidBytePosition = utf8.len(prefix)
			if prefixEnd == nil then
				error(("string `%s` has an invalid byte at position %s"):format(prefix, tostring(invalidBytePosition)))
			end
			local iStartIndex = prefixEnd :: number + 1
			local match = {
				index = iStartIndex,
				match = string.sub(str, iStart, iEnd),
			}
			table.insert(matches, match)
		end
	end

	-- if no matches, return nil
	if #matches == 0 then
		return nil
	end

	-- find the first matched index (after the init param)
	-- for each, if we get a hit, return the earliest index and matched term

	local firstMatch
	for _, value in matches do
		-- load first condition
		if firstMatch == nil then
			firstMatch = value
		end
		-- identify if current match comes before first match
		if value.index < firstMatch.index then
			firstMatch = value
		end
	end

	-- return first match
	return firstMatch
end

return findOr
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000624b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB6C252F36EF54C1BB4131670CC12FC49">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">includes</string>
									<string name="ScriptGuid">{7DD04543-74BF-4A51-BB0A-A301C8FD7925}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- excluding the `+` and `*` character, since findOr tests and graphql use them explicitly
local luaPatternCharacters = "([" .. ("$%^()-[].?"):gsub("(.)", "%%%1") .. "])"

local function includes(str: string, substring: string, position: (string | number)?): boolean
	local strLen, invalidBytePosition = utf8.len(str)
	assert(strLen ~= nil, ("string `%s` has an invalid byte at position %s"):format(str, tostring(invalidBytePosition)))
	if strLen == 0 then
		return false
	end

	if #substring == 0 then
		return true
	end

	local startIndex = 1
	if position ~= nil then
		startIndex = tonumber(position) or 1
		if startIndex > strLen then
			return false
		end
	end

	if startIndex < 1 then
		startIndex = 1
	end

	local init = utf8.offset(str, startIndex)
	local value = substring:gsub(luaPatternCharacters, "%%%1")
	local iStart, _ = string.find(str, value, init)
	return iStart ~= nil
end

return includes
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000624c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX71BF9BF3159A4A27B2231200D5CB11EC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">indexOf</string>
									<string name="ScriptGuid">{61317889-1ECF-40C4-B338-0610E85FE7CB}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- excluding the `+` and `*` character, since findOr tests and graphql use them explicitly
local luaPatternCharacters = "([" .. ("$%^()-[].?"):gsub("(.)", "%%%1") .. "])"

-- Implements equivalent functionality to JavaScript's `String.indexOf`,
-- implementing the interface and behaviors defined at:
-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf
return function(str: string, searchElement: string, fromIndex: number?): number
	local length = #str
	local fromIndex_ = if fromIndex ~= nil then if fromIndex < 1 then 1 else fromIndex :: number else 1

	if #searchElement == 0 then
		return if fromIndex_ > length then length else fromIndex_
	end

	if fromIndex_ > length then
		return -1
	end

	searchElement = searchElement:gsub(luaPatternCharacters, "%%%1")
	local searchElementLength = #searchElement

	for i = fromIndex_, length do
		if string.sub(str, i, i + searchElementLength - 1) == searchElement then
			return i
		end
	end

	return -1
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000624d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBEA638FE3FA64BBF9E299EFAF2E62B46">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lastIndexOf</string>
									<string name="ScriptGuid">{89651FD8-9414-4DDB-B12C-A7CBC9A0AEDB}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local function lastIndexOf(str: string, searchValue: string, fromIndex: number?): number
	local strLength = string.len(str)
	local calculatedFromIndex
	if fromIndex then
		calculatedFromIndex = fromIndex
	else
		calculatedFromIndex = strLength
	end
	if fromIndex and fromIndex < 1 then
		calculatedFromIndex = 1
	end
	if fromIndex and fromIndex > strLength then
		calculatedFromIndex = strLength
	end
	if searchValue == "" then
		-- FIXME: Luau DFA doesn't understand that
		return calculatedFromIndex :: number
	end

	local lastFoundStartIndex, foundStartIndex
	-- Luau FIXME: Luau doesn't look beyond assignment for type, it should infer number? from loop bound
	local foundEndIndex: number? = 0
	repeat
		lastFoundStartIndex = foundStartIndex
		-- Luau FIXME: DFA doesn't understand until clause means foundEndIndex is never nil within loop
		foundStartIndex, foundEndIndex = string.find(str, searchValue, foundEndIndex :: number + 1, true)
	until foundStartIndex == nil or foundStartIndex > calculatedFromIndex

	if lastFoundStartIndex == nil then
		return -1
	end
	-- Luau FIXME: Luau should see the predicate above and known the line below can only be a number
	return lastFoundStartIndex :: number
end

return lastIndexOf
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000624e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX672ECC8B5EFF496D9DCF6CBCCCC8886F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">slice</string>
									<string name="ScriptGuid">{FA05F142-3A46-4780-8C92-8FA838CFE8B2}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local function slice(str: string, startIndexStr: string | number, lastIndexStr: (string | number)?): string
	local strLen, invalidBytePosition = utf8.len(str)
	assert(strLen ~= nil, ("string `%s` has an invalid byte at position %s"):format(str, tostring(invalidBytePosition)))
	local startIndex = tonumber(startIndexStr)
	assert(typeof(startIndex) == "number", "startIndexStr should be a number")

	if startIndex + strLen < 0 then
		-- then |start index| is greater than string length
		startIndex = 1
	end

	if startIndex > strLen then
		return ""
	end

	-- if no last index length set, go to str length + 1
	local lastIndex = strLen + 1
	if lastIndexStr ~= nil then
		-- ROBLOX FIXME: add parseInt to encapsulate this logic and use it here
		local NaN = 0 / 0
		lastIndex = tonumber(lastIndexStr) or NaN -- this works because 0 is truthy in Lua
	end
	assert(typeof(lastIndex) == "number", "lastIndexStr should convert to number")

	if lastIndex > strLen then
		lastIndex = strLen + 1
	end

	local startIndexByte = assert(utf8.offset(str, startIndex), "startIndexByte should be a number")

	-- get char length of charset returned at offset
	local lastIndexByte = assert(utf8.offset(str, lastIndex), "lastIndexByte should be a number") - 1

	return string.sub(str, startIndexByte, lastIndexByte)
end

return slice
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000624f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8DD50AE66625463DB976BCBCC09F2CF9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">split</string>
									<string name="ScriptGuid">{A171A08B-7E8E-48B0-B70B-458F96FCC612}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local String = script.Parent
local findOr = require(String.findOr)
local slice = require(String.slice)

local Packages = String.Parent
local types = require(Packages.ES7Types)
type Array<T> = types.Array<T>
local MAX_SAFE_INTEGER = require(Packages.Number).MAX_SAFE_INTEGER

type Pattern = string | Array<string>

local function split(str: string, _pattern: Pattern?, _limit: number?): Array<string>
	if _pattern == nil then
		return { str }
	end
	if _limit == 0 then
		return {}
	end
	local limit = if _limit == nil or _limit < 0 then MAX_SAFE_INTEGER else _limit
	local pattern = _pattern
	local patternList: Array<string>
	if typeof(pattern) == "string" then
		if pattern == "" then
			local result = {}
			for c in str:gmatch(".") do
				table.insert(result, c)
			end
			return result
		end
		patternList = { pattern }
	else
		patternList = pattern :: Array<string>
	end
	local init = 1
	local result = {}
	local lastMatch
	local strLen, invalidBytePosition = utf8.len(str)
	assert(strLen ~= nil, ("string `%s` has an invalid byte at position %s"):format(str, tostring(invalidBytePosition)))

	repeat
		local match = findOr(str, patternList, init)
		if match ~= nil then
			table.insert(result, slice(str, init, match.index))
			local matchLength = utf8.len(match.match)
			-- Luau FIXME? Luau doesn't understand that str has already been shown to be valid utf8 on line 26 and therefore won't be nil
			init = match.index + matchLength :: number
		else
			table.insert(result, slice(str, init, nil))
		end
		if match ~= nil then
			lastMatch = match
		end
	until match == nil or init > strLen or #result >= limit
	if lastMatch ~= nil then
		local lastMatchLength, invalidBytePosition_ = utf8.len(lastMatch.match)
		assert(
			lastMatchLength ~= nil,
			("string `%s` has an invalid byte at position %s"):format(lastMatch.match, tostring(invalidBytePosition_))
		)
		if lastMatch.index + lastMatchLength == strLen + 1 then
			table.insert(result, "")
		end
	end
	return result
end

return split
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006250</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX2B3398FB774D4F9986AF178005C2BCDB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">startsWith</string>
									<string name="ScriptGuid">{48501869-A634-4D4F-8FC1-914EDC7A7FAF}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local function startsWith(value: string, substring: string, position: number?): boolean
	if string.len(substring) == 0 then
		return true
	end
	-- Luau FIXME: we have to use a tmp variable, as Luau doesn't understand the logic below narrow position to `number`
	local position_
	if position == nil or position < 1 then
		position_ = 1
	else
		position_ = position
	end

	if position_ > string.len(value) then
		return false
	end
	return value:find(substring, position_, true) == position_
end

return startsWith
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006251</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC0B76FE953C844BAA5E10C93762E4B54">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">substr</string>
									<string name="ScriptGuid">{6BB942BC-06A9-42B4-9DFB-F45CFB01D2E7}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return function(s: string, startIndex: number, numberOfCharacters: number?): string
	if numberOfCharacters and numberOfCharacters <= 0 then
		return ""
	end
	return string.sub(s, startIndex, numberOfCharacters and startIndex + numberOfCharacters - 1 or nil)
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006252</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5CF26E01190842178C93A1CA1B97C526">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">trim</string>
									<string name="ScriptGuid">{F0C9F178-790E-4CBB-A14F-4D69286CCEFE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local trimStart = require(script.Parent.trimStart)
local trimEnd = require(script.Parent.trimEnd)

return function(source: string): string
	return trimStart(trimEnd(source))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006253</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3F7C3AEF06A547AB8D3EA88CA887484C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">trimEnd</string>
									<string name="ScriptGuid">{C26227CE-51F8-4988-A6BF-4DBC70BB48F9}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return function(source: string): string
	return (source:gsub("[%s]+$", ""))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006254</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE7FF23840A2F4FD0AAA5961C552AE7EE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">trimStart</string>
									<string name="ScriptGuid">{19419F0A-9ABB-4B58-A702-65DC3F2DEFC0}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
return function(source: string): string
	return (source:gsub("^[%s]+", ""))
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006255</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX83FDB98E6C3343B78955DB90FF9D5B57">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Symbol</string>
								<string name="ScriptGuid">{3BAC0AD4-608D-48BE-92C6-A6B714C434F1}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	A 'Symbol' is an opaque marker type, implemented to behave similarly to JS:
	https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol
]]
local Symbol = require(script.Symbol)
export type Symbol = Symbol.Symbol
local GlobalRegistry = require(script["Registry.global"])

local SymbolObject = setmetatable({}, {
	--[[
		Creates a new symbol, using the given name when printed. Symbols are
		opaque, so this will always create a new, unique object
	]]
	__call = function(_, name: string?): Symbol.Symbol
		return Symbol.new(name)
	end,
})

SymbolObject.for_ = GlobalRegistry.getOrInit

return SymbolObject
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006256</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX379F4A02C8D34FF2A6D5A365CC70F3CB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">GlobalRegistry</string>
									<string name="ScriptGuid">{A9B3F616-F964-4D6F-85BA-CEBE300F677A}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Symbol = require(script.Parent.Symbol)

local GlobalRegistry: { [string]: Symbol.Symbol } = {}

return {
	getOrInit = function(name: string): Symbol.Symbol
		if GlobalRegistry[name] == nil then
			GlobalRegistry[name] = Symbol.new(name)
		end

		return GlobalRegistry[name]
	end,
	-- Used for testing
	__clear = function()
		GlobalRegistry = {}
	end,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006257</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX53D916A6C678477E9FC7C65BE3D5E3C0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Registry.global</string>
									<string name="ScriptGuid">{43549E86-AD2E-4E96-96B6-31FC5370BDB4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Symbol = require(script.Parent.Symbol)

local GlobalRegistry: { [string]: Symbol.Symbol } = {}

return {
	getOrInit = function(name: string): Symbol.Symbol
		if GlobalRegistry[name] == nil then
			GlobalRegistry[name] = Symbol.new(name)
		end

		return GlobalRegistry[name]
	end,
	-- Used for testing
	__clear = function()
		GlobalRegistry = {}
	end,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006258</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX0D7437B6AF214A05A48F21C5F635025A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Symbol</string>
									<string name="ScriptGuid">{1C24C572-5351-4F33-ACDB-9512A504CA5E}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Symbols have the type 'userdata', but when printed or coerced to a string,
	the symbol will turn into the string given as its name.

	**This implementation provides only the `Symbol()` constructor and the
	global registry via `Symbol.for_`.**

	Other behaviors, including the ability to find all symbol properties on
	objects, are not implemented.
]]
export type Symbol = typeof(newproxy(true)) & { [string]: any }

return {
	new = function(name: string?): Symbol
		local self = newproxy(true) :: any

		local wrappedName = "Symbol()"
		if name then
			wrappedName = ("Symbol(%s)"):format(name)
		end

		getmetatable(self).__tostring = function()
			return wrappedName
		end

		return (self :: any) :: Symbol
	end,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006259</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX665EF8211713420F880CB31F990B8A64">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Timers</string>
								<string name="ScriptGuid">{688B8B97-C241-4B56-9A57-293318420A7D}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Packages = script.Parent

local Object = require(Packages.Collections).Object

local makeTimerImpl = require(script.makeTimerImpl)
local makeIntervalImpl = require(script.makeIntervalImpl)

export type Timeout = makeTimerImpl.Timeout
export type Interval = makeIntervalImpl.Interval

return Object.assign({}, makeTimerImpl(task.delay), makeIntervalImpl(task.delay))
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000625a</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXE49EF9D6FA9B469EB859158C53C65A30">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">makeIntervalImpl</string>
									<string name="ScriptGuid">{D55AB424-8B00-49DF-85C7-2BF6EB30CDEE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Status = newproxy(false)

type TaskStatus = number
export type Interval = { [typeof(Status)]: TaskStatus }

local SCHEDULED = 1
local CANCELLED = 3

return function(delayImpl)
	local function setInterval(callback, intervalTime: number, ...): Interval
		local args = { ... }
		local task = {
			[Status] = SCHEDULED,
		}

		-- delayTime is an optional parameter
		if intervalTime == nil then
			intervalTime = 0
		end

		-- To mimic the JS interface, we're expecting delayTime to be in ms
		local intervalTimeMs = intervalTime / 1000
		local delay_
		delay_ = function()
			delayImpl(intervalTimeMs, function()
				if task[Status] == SCHEDULED then
					callback(unpack(args))
					delay_()
				end
			end)
		end

		delay_()

		return task
	end

	local function clearInterval(task: Interval)
		if task == nil then
			return
		end

		if task[Status] == SCHEDULED then
			task[Status] = CANCELLED
		end
	end

	return {
		setInterval = setInterval,
		clearInterval = clearInterval,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000625b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF923E80638404DE197B9810E0E32D066">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">makeTimerImpl</string>
									<string name="ScriptGuid">{C69B23BD-25A6-4FB9-98F0-728317BBA687}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local Status = newproxy(false)

type TaskStatus = number
export type Timeout = { [typeof(Status)]: TaskStatus }

local SCHEDULED = 1
local DONE = 2
local CANCELLED = 3

return function(delayImpl)
	local function setTimeout(callback, delayTime: number?, ...): Timeout
		local args = { ... }
		local task = {
			[Status] = SCHEDULED,
		}

		-- delayTime is an optional parameter
		if delayTime == nil then
			delayTime = 0
		end

		-- To mimic the JS interface, we're expecting delayTime to be in ms
		local delayTimeMs = delayTime :: number / 1000
		delayImpl(delayTimeMs, function()
			if task[Status] == SCHEDULED then
				callback(unpack(args))
				task[Status] = DONE
			end
		end)

		return task
	end

	local function clearTimeout(task: Timeout)
		if task == nil then
			return
		end
		if task[Status] == SCHEDULED then
			task[Status] = CANCELLED
		end
	end

	return {
		setTimeout = setTimeout,
		clearTimeout = clearTimeout,
	}
end
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000625c</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX54D69565F40649D6A6B31968EA507EA1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Shared</string>
							<string name="ScriptGuid">{C7A23A25-00C4-4126-8F67-2DDE0FF91188}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

-- deviation: Promote `shared` to an actual unpublished package with a
-- real interface instead of just a bag of loose source code
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local ReactTypes = require(script.ReactTypes)
local flowtypes = require(script["flowtypes.roblox"])
local ReactElementType = require(script.ReactElementType)
local ReactFiberHostConfig = require(script.ReactFiberHostConfig)
local ReactSharedInternals = require(script.ReactSharedInternals)
local ErrorHandling = require(script["ErrorHandling.roblox"])

-- Re-export all top-level public types
export type ReactEmpty = ReactTypes.ReactEmpty
export type ReactFragment = ReactTypes.ReactFragment
export type ReactNodeList = ReactTypes.ReactNodeList
export type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
export type ReactConsumer<T> = ReactTypes.ReactConsumer<T>
export type ReactProvider<T> = ReactTypes.ReactProvider<T>
export type ReactContext<T> = ReactTypes.ReactContext<T>
export type ReactPortal = ReactTypes.ReactPortal
export type RefObject = ReactTypes.RefObject
export type EventPriority = ReactTypes.EventPriority
export type ReactFundamentalComponentInstance<C, H> = ReactTypes.ReactFundamentalComponentInstance<C, H>
export type ReactFundamentalImpl<C, H> = ReactTypes.ReactFundamentalImpl<C, H>
export type ReactFundamentalComponent<C, H> = ReactTypes.ReactFundamentalComponent<C, H>
export type ReactScope = ReactTypes.ReactScope
export type ReactScopeQuery = ReactTypes.ReactScopeQuery
export type ReactScopeInstance = ReactTypes.ReactScopeInstance
-- deviation START: Re-export bindings types
export type ReactBinding<T> = ReactTypes.ReactBinding<T>
export type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- deviation END
export type MutableSourceVersion = ReactTypes.MutableSourceVersion
export type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>
export type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<Source, Snapshot>
export type MutableSourceGetVersionFn = ReactTypes.MutableSourceGetVersionFn
export type MutableSource<Source> = ReactTypes.MutableSource<Source>
export type Wakeable = ReactTypes.Wakeable
export type Thenable<R> = ReactTypes.Thenable<R>
export type Source = ReactElementType.Source
export type ReactElement<P = Object, T = any> = ReactElementType.ReactElement<P, T>
export type OpaqueIDType = ReactFiberHostConfig.OpaqueIDType
export type Dispatcher = ReactSharedInternals.Dispatcher

-- re-export flowtypes from here. I wonder if this should be a separate 'package'?
export type React_Ref<ElementType> = flowtypes.React_Ref<ElementType>
export type React_Context<T> = flowtypes.React_Context<T>
export type React_AbstractComponent<Config, Instance> = flowtypes.React_AbstractComponent<Config, Instance>
export type React_ComponentType<Config> = flowtypes.React_ComponentType<Config>
export type React_PureComponent<Props, State = nil> = flowtypes.React_PureComponent<Props, State>
export type React_Component<Props, State> = flowtypes.React_Component<Props, State>
export type React_ElementProps<ElementType> = flowtypes.React_ElementProps<ElementType>
export type React_StatelessFunctionalComponent<Props> = flowtypes.React_StatelessFunctionalComponent<Props>
export type React_Node = flowtypes.React_Node
export type React_Element<ElementType> = flowtypes.React_Element<ElementType>
export type React_ElementType = flowtypes.React_ElementType
export type React_ElementConfig<C> = flowtypes.React_ElementConfig<C>
export type React_ElementRef<C> = flowtypes.React_ElementRef<C>
export type React_Portal = flowtypes.React_Portal
export type React_Key = flowtypes.React_Key

return {
	checkPropTypes = require(script.checkPropTypes),
	console = require(script.console),
	ConsolePatchingDev = require(script["ConsolePatchingDev.roblox"]),
	consoleWithStackDev = require(script.consoleWithStackDev),
	enqueueTask = require(script["enqueueTask.roblox"]),
	ExecutionEnvironment = require(script.ExecutionEnvironment),
	formatProdErrorMessage = require(script.formatProdErrorMessage),
	getComponentName = require(script.getComponentName),
	invariant = require(script.invariant),
	invokeGuardedCallbackImpl = require(script.invokeGuardedCallbackImpl),
	isValidElementType = require(script.isValidElementType),
	objectIs = require(script.objectIs),
	ReactComponentStackFrame = require(script.ReactComponentStackFrame),
	ReactElementType = require(script.ReactElementType),
	ReactErrorUtils = require(script.ReactErrorUtils),
	ReactFeatureFlags = require(script.ReactFeatureFlags),
	ReactInstanceMap = require(script.ReactInstanceMap),
	-- deviation: Instead of re-exporting from here, Shared actually owns
	-- these files itself
	ReactSharedInternals = ReactSharedInternals,
	-- deviation: Instead of extracting these out of the reconciler and
	-- then re-injecting the host config _into_ the reconciler, export these
	-- from shared for easier reuse
	ReactFiberHostConfig = ReactFiberHostConfig,

	ReactSymbols = require(script.ReactSymbols),
	ReactVersion = require(script.ReactVersion),
	shallowEqual = require(script.shallowEqual),
	UninitializedState = require(script["UninitializedState.roblox"]),
	ReactTypes = ReactTypes,

	-- deviation: export error-stack-preserving utilities for use in
	-- scheduler and reconciler, and parsing function for use in public API
	describeError = ErrorHandling.describeError,
	errorToString = ErrorHandling.errorToString,
	parseReactError = ErrorHandling.parseReactError,

	-- deviation: export Symbol and Type from Shared
	Symbol = require(script["Symbol.roblox"]),
	Type = require(script["Type.roblox"]),

	-- deviation: export propmarkers from Shared
	Change = require(script.PropMarkers.Change),
	Event = require(script.PropMarkers.Event),
	Tag = require(script.PropMarkers.Tag),
}
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed000062b9</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXD07EBFB211584EB5B2AD3384CC0B2E6D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ConsolePatchingDev.roblox</string>
								<string name="ScriptGuid">{C9802909-9F80-474B-8C03-AB485B985E92}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/checkPropTypes.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

-- deviation: Lua objects don't have any special properties the way that JS
-- Objects do; this has been modified from the JS, which uses
-- `Object.defineProperties` to ensure that properties are modifiable. In Lua,
-- these operations are as simple as assigning to functions.
-- NOTE: use patched console from shared
local console = require(script.Parent.console)

-- Helpers to patch console.logs to avoid logging during side-effect free
-- replaying on render function. This currently only patches the object
-- lazily which won't cover if the log function was extracted eagerly.
-- We could also eagerly patch the method.
local disabledDepth = 0
local prevLog
local prevInfo
local prevWarn
local prevError
local prevGroup
local prevGroupCollapsed
local prevGroupEnd

local disabledLog = function() end

local exports = {}

-- deviation: console.log's name property is checked in SchedulerHostConfig.
-- But since Lua functions don't carry properties, we export this and import it there
-- for a reference equality.
exports.disabledLog = disabledLog

exports.disableLogs = function()
	if _G.__DEV__ then
		if disabledDepth == 0 then
			prevLog = console.log
			prevInfo = console.info
			prevWarn = console.warn
			prevError = console.error
			prevGroup = console.group
			prevGroupCollapsed = console.groupCollapsed
			prevGroupEnd = console.groupEnd

			console.info = disabledLog
			console.log = disabledLog
			console.warn = disabledLog
			console.error = disabledLog
			console.group = disabledLog
			console.groupCollapsed = disabledLog
			console.groupEnd = disabledLog
		end

		disabledDepth = disabledDepth + 1
	end
end

exports.reenableLogs = function()
	if _G.__DEV__ then
		disabledDepth = disabledDepth - 1

		if disabledDepth == 0 then
			console.log = prevLog
			console.info = prevInfo
			console.warn = prevWarn
			console.error = prevError
			console.group = prevGroup
			console.groupCollapsed = prevGroupCollapsed
			console.groupEnd = prevGroupEnd
		end

		if disabledDepth < 0 then
			console.error("disabledDepth fell below zero. " .. "This is a bug in React. Please file an issue.")
		end
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062ba</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5E16E6DB842A4574B4DC4EF1B0D33EBE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ErrorHandling.roblox</string>
								<string name="ScriptGuid">{88D64849-101E-47DF-BB47-D7A1A3C8FFF3}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Array<T> = LuauPolyfill.Array<T>
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect

local DIVIDER = "\n------ Error caught by React ------\n"

--[[
	React does a lot of catching, retrying, and rethrowing errors that would
	typically result in loss of meaningful stack information.

	We use xpcall combined with this error function to capture and rethrow in a
	way that retains some stack information.
]]
local function describeError(e: string | Error): Error
	if typeof(e) == "string" then
		local _, endOfStackFrame = string.find(e, ":[%d]+: ")
		local message = if endOfStackFrame then string.sub(e, endOfStackFrame + 1) else e

		local err = LuauPolyfill.Error.new(message)
		err.stack = debug.traceback(nil, 2)
		return err
	end
	return e :: Error
end

--[[
	Even though Luau can catch and rethrow arbitrary objects, only string errors
	are supported by the ScriptContext.ErrorDetailed signal (the mechanism used
	to catch unhandled errors at the top level).

	This function turns an arbitrary error object into a detailed string message
	to avoid any loss of information.
]]
local function errorToString(error_: Error | Object | string | Array<any>): string
	local errorString
	if typeof(error_) == "table" then
		if (error_ :: Error).message and (error_ :: Error).stack then
			-- Adding these clear dividers helps us split this error back up
			-- into pieces later. We include one at the beginning so that the
			-- final stack frame added by rethrowing can be carved off
			errorString = DIVIDER .. (error_ :: Error).message .. DIVIDER .. tostring((error_ :: Error).stack)
		else
			errorString = inspect(error_)
		end
	else
		errorString = inspect(error_)
	end

	return errorString
end

--[[
	If an error string was generated from an Error object via the errorToString
	function above, it can be easily split back out into an informative error
	object.
]]
local function parseReactError(error_: string): (Error, string)
	local split = string.split(error_, DIVIDER)

	if #split == 3 then
		local rethrow, message, stack = table.unpack(split)

		local newError = Error.new(message)
		newError.stack = stack

		return newError, rethrow
	else
		-- This error was not in the expected format, so we use the whole string
		-- as the 'message' value and nil out the stack (it would be misleading
		-- if we included the one generated here)
		local newError = Error.new(error_)
		newError.stack = nil

		return newError, ""
	end
end

return {
	describeError = describeError,
	errorToString = errorToString,
	parseReactError = parseReactError,
	-- Used only by tests
	__ERROR_DIVIDER = DIVIDER,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062bb</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC8C135D1A12F48BE9EADE9CBF19AB863">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ExecutionEnvironment</string>
								<string name="ScriptGuid">{4C23E8CF-AE9E-429C-8A6A-5476D9D44FC1}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/ExecutionEnvironment.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
local exports = {}

exports.canUseDOM = function()
	-- deviation START
	return false
	-- deviation END
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062bc</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX0DC5A7D8D47D476F9616C903C017B503">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">PropMarkers</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062bd</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX93B1D31AE5F746E6A7388AE9A897B1C3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Change</string>
									<string name="ScriptGuid">{CD508690-D198-4A63-8692-675E3988EDC5}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent["Type.roblox"])

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return string.format("RoactHostChangeEvent(%s)", self.name)
	end,
}

setmetatable(Change, {
	__index = function(self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062be</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX530BAE49865545E4806A13350555FDCE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Event</string>
									<string name="ScriptGuid">{30EFECD2-D7EF-40B6-9351-2AFC080AEB3F}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent["Type.roblox"])

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return string.format("RoactHostEvent(%s)", self.name)
	end,
}

setmetatable(Event, {
	__index = function(self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062bf</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX50C5A81082A846C3B86EBE1D5575B055">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tag</string>
									<string name="ScriptGuid">{300788F9-17C6-4455-A898-FCB71AF77B33}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Special value for assigning tags to roblox instances via Roact
]]
local Symbol = require(script.Parent.Parent["Symbol.roblox"])

local Tag = Symbol.named("RobloxTag")

return Tag
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c0</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXEF444787BC284B8F90555620CC2F2DD0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactComponentStackFrame</string>
								<string name="ScriptGuid">{5548B9BD-EB32-4C7E-9D8D-7F33960F4659}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/shared/ReactComponentStackFrame.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

type Object = { [string]: any }
type Function = (...any) -> ...any

local ReactElementType = require(script.Parent.ReactElementType)
type Source = ReactElementType.Source

-- deviation: Needed to properly type class components
local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_StatelessFunctionalComponent<P> = flowtypes.React_StatelessFunctionalComponent<P>
type React_ComponentType<P> = flowtypes.React_ComponentType<P>
type ReactComponent<P> = React_StatelessFunctionalComponent<P> | React_ComponentType<P>

-- deviation: Ignore enableComponentStackLocations
-- local ReactFeatureFlags = require(script.Parent.ReactFeatureFlags)
-- local enableComponentStackLocations = ReactFeatureFlags.enableComponentStackLocations

local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE

local ConsolePatchingDev = require(script.Parent["ConsolePatchingDev.roblox"])
local disableLogs = ConsolePatchingDev.disableLogs
local reenableLogs = ConsolePatchingDev.reenableLogs

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)
local ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher

-- deviation: the prefix is constant because the console prints the stack
-- frames the same way on every platform.
local prefix = "    in "

-- deviation: declare these now because of scoping differences between in
-- Lua and JS
local describeComponentFrame
local describeFunctionComponentFrame

-- deviation: since owner could be a function or a class component, we
-- need to do additional handling to get its name. It's easier to make this a
-- reusable function
local function describeOwner(owner: nil | ReactComponent<any>): string?
	if type(owner) == "function" then
		return debug.info(owner :: (any) -> any, "n")
	elseif type(owner) == "table" then
		return tostring(owner)
	end
	return nil
end

local function describeBuiltInComponentFrame(
	name: string,
	source: Source | nil,
	-- deviation: owner could be a class component
	owner: nil | ReactComponent<any>
): string
	-- deviation START: for built-in components, we can provide the full
	-- description regardless of `enableStackLocations` since we don't actually
	-- need to do any callstack trickery to get it

	-- if enableComponentStackLocations then
	-- 	if prefix == nil then
	-- 		-- Extract the VM specific prefix used by each line.
	-- 		local _, x = pcall(error, debug.traceback())

	-- 		local match = x.stack.trim().match("\n00:00:00.000 - ")
	-- 		if match then
	-- 			prefix = match[1]
	-- 		else
	-- 			prefix = ''
	-- 		end
	-- 	end
	-- 	-- We use the prefix to ensure our stacks line up with native stack frames.
	-- 	return "\n" .. prefix .. name
	-- else
	-- 	local ownerName = nil
	-- 	if _G.__DEV__ and owner then
	-- 		ownerName = describeOwner(owner)
	-- 	end

	-- 	return describeComponentFrame(name, source, ownerName)
	-- end
	local ownerName = nil
	if _G.__DEV__ and owner then
		ownerName = describeOwner(owner)
	end

	return describeComponentFrame(name, source, ownerName)
	-- deviation END
end

local reentry = false
local componentFrameCache = nil
if _G.__DEV__ then
	componentFrameCache = setmetatable({}, { __mode = "k" })
end

local function describeNativeComponentFrame(
	fn: nil | ReactComponent<any>, -- TODO: only accept tables with __tostring metamethod overridden
	construct: boolean
): string
	-- // If something asked for a stack inside a fake render, it should get ignored.
	if not fn or reentry then
		return ""
	end

	if _G.__DEV__ then
		local frame = componentFrameCache[fn]

		if frame ~= nil then
			return frame
		end
	end

	local control
	reentry = true

	-- deviation: Error.prepareStackTrace is not implemented
	-- local previousPrepareStackTrace = Error.prepareStackTrace
	-- Error.prepareStackTrace = undefined
	local previousDispatcher

	if _G.__DEV__ then
		previousDispatcher = ReactCurrentDispatcher.current
		-- Set the dispatcher in DEV because this might be call in the render
		-- function for warnings.
		ReactCurrentDispatcher.current = nil
		disableLogs()
	end

	-- // This should throw.
	-- deviation: Lua does not have stack traces with errors, so we
	-- use xpcall to convert the error and append a stack trace.
	-- This will change the theorical stack trace we want, because of
	-- the function where we call 'debug.traceback()', but the control
	-- stack will have the same added frame.
	local traceback
	local _, sample = xpcall(function()
		if construct then
			-- deviation: since we can't have a meaningful stack trace when
			-- constructing from a component class (because it does not locate
			-- component definition), we skip this case.
		else
			local _, x = pcall(function()
				traceback = debug.traceback()
				error({
					stack = traceback,
				})
			end)
			control = x;
			-- FIXME: Luau flow analysis bug workaround
			(fn :: (...any) -> ...any)()
		end
	end, function(message)
		return {
			message = message,
			stack = traceback,
		}
	end)

	-- deviation: Lua does not have a structure that works like a try-catch-finally
	-- so we a variable to know if the catch block returns a value. If it returns,
	-- 'earlyOutValue' will be set and we can return its value after running the
	-- instructions in the finally block.
	local earlyOutValue = nil

	if sample and control and type(sample.stack) == "string" then
		-- // This extracts the first frame from the sample that isn't also in the control.
		-- // Skipping one frame that we assume is the frame that calls the two.
		local sampleLines = string.split(sample.stack, "\n")
		local controlLines = string.split(control.stack, "\n")
		-- deviation: remove one because our array of lines contains an empty string
		-- at the end
		local sampleIndex = #sampleLines - 1
		local controlIndex = #controlLines - 1

		while sampleIndex >= 2 and controlIndex >= 0 and sampleLines[sampleIndex] ~= controlLines[controlIndex] do
			-- // We expect at least one stack frame to be shared.
			-- // Typically this will be the root most one. However, stack frames may be
			-- // cut off due to maximum stack limits. In this case, one maybe cut off
			-- // earlier than the other. We assume that the sample is longer or the same
			-- // and there for cut off earlier. So we should find the root most frame in
			-- // the sample somewhere in the control.
			controlIndex = controlIndex - 1
		end

		while sampleIndex >= 3 and controlIndex >= 1 do
			sampleIndex = sampleIndex - 1
			controlIndex = controlIndex - 1
			-- // Next we find the first one that isn't the same which should be the
			-- // frame that called our sample function and the control.
			if sampleLines[sampleIndex] ~= controlLines[controlIndex] then
				-- // In V8, the first line is describing the message but other VMs don't.
				-- // If we're about to return the first line, and the control is also on the same
				-- // line, that'sampleIndex a pretty good indicator that our sample threw at same line as
				-- // the control. I.e. before we entered the sample frame. So we ignore this result.
				-- // This can happen if you passed a class to function component, or non-function.
				if sampleIndex ~= 1 or controlIndex ~= 1 then
					repeat
						sampleIndex = sampleIndex - 1
						controlIndex = controlIndex - 1
						-- // We may still have similar intermediate frames from the construct call.
						-- // The next one that isn't the same should be our match though.
						if controlIndex < 0 or sampleLines[sampleIndex] ~= controlLines[controlIndex] then
							-- deviation: add the '    in ' prefix to format the component stack
							-- similar to React
							local frame = "\n" .. prefix .. sampleLines[sampleIndex]

							if _G.__DEV__ then
								componentFrameCache[fn] = frame
							end
							-- // Return the line we found.
							-- deviation: to mimic the behavior of the try-catch-finally
							-- we cannot return the value here.
							earlyOutValue = frame
						end
					until not (sampleIndex >= 3 and controlIndex >= 1)
				end

				break
			end
		end
	end

	reentry = false
	if _G.__DEV__ then
		ReactCurrentDispatcher.current = previousDispatcher
		reenableLogs()
	end

	-- deviation: Error.prepareStackTrace is not implemented
	-- Error.prepareStackTrace = previousPrepareStackTrace

	-- deviation: return here to micmic the end of the finally block
	if earlyOutValue ~= nil then
		return earlyOutValue
	end

	-- Fallback to just using the name if we couldn't make it throw.
	-- deviation START: Can't get displayName for functions, since fn can be a class, we can get the class name here
	local name = if type(fn) == "function"
		then debug.info(fn :: Function, "n")
		-- deviation :
		else if type(fn) == "table" then tostring(fn) else ""

	local syntheticFrame = ""
	if name ~= nil and name ~= "" then
		syntheticFrame = describeBuiltInComponentFrame(name)
	end

	if _G.__DEV__ then
		componentFrameCache[fn] = syntheticFrame
	end

	return syntheticFrame
end

-- deviation: Lua's patterns work slightly differently than regexes
local BEFORE_SLASH_PATTERN = "^(.*)[\\/]"

function describeComponentFrame(name: string | nil, source: Source | nil, ownerName: string | nil): string
	local sourceInfo = ""

	if _G.__DEV__ and source then
		local path = source.fileName
		local fileName = string.gsub(path, BEFORE_SLASH_PATTERN, "")

		-- // In DEV, include code for a common special case:
		-- // prefer "folder/index.js" instead of just "index.js".
		-- deviation: instead of having a special case for 'index.',
		-- we use 'init.'
		if string.match(fileName, "^init%.") then
			-- deviation: finding matching strings works differently in Lua
			local pathBeforeSlash = string.match(path, BEFORE_SLASH_PATTERN)

			if pathBeforeSlash and #pathBeforeSlash ~= 0 then
				local folderName = string.gsub(pathBeforeSlash, BEFORE_SLASH_PATTERN, "")
				fileName = folderName .. "/" .. fileName
			end
		end

		sourceInfo = " (at " .. fileName .. ":" .. source.lineNumber .. ")"
	elseif ownerName then
		sourceInfo = " (created by " .. ownerName .. ")"
	end

	return "\n    in " .. (name or "Unknown") .. sourceInfo
end

local function describeClassComponentFrame(
	-- deviation: React.Component<any>
	ctor: any,
	source: nil | Source,
	-- deviation: this could be a class component OR a function component
	owner: nil | ReactComponent<any>
): string
	-- deviation START: In Roact, class components are tables, so we
	-- jump directly to using the basic component description.

	-- if enableComponentStackLocations then
	-- 	return describeNativeComponentFrame(componentClass, true)
	-- else
	-- 	return describeFunctionComponentFrame(ctor, source, ownerFn);
	-- end
	local name = tostring(ctor)
	local ownerName = nil
	if _G.__DEV__ and owner then
		ownerName = describeOwner(owner)
	end
	return describeComponentFrame(name, source, ownerName)
	-- deviation END
end

function describeFunctionComponentFrame(
	-- TODO: this annotation is incorrect upstream, we fix it here
	fn: nil | Function,
	source: nil | Source,
	-- deviation: this could be a class component OR a function component
	ownerFn: nil | ReactComponent<any>
): string
	-- deviation Jump directly to using basic component description:
	-- if enableComponentStackLocations then
	-- 	return describeNativeComponentFrame(fn, false)
	-- else
	-- 	if not fn then
	-- 		return ""
	-- 	end
	-- 	-- deviation: use debug.info to discover function names
	-- 	local name = debug.info(fn :: Function, "n")
	-- 	local ownerName = nil
	-- 	if _G.__DEV__ and ownerFn then
	-- 		-- deviation: owner may be a function or a table
	-- 		ownerName = describeOwner(ownerFn)
	-- 	end
	-- 	return describeComponentFrame(name, source, ownerName)
	-- end
	if not fn then
		return ""
	end
	-- deviation: use debug.info to discover function names
	-- FIXME: find out how non-functions are getting into here, they pollute test output
	local name = if type(fn) == "function" then debug.info(fn :: Function, "n") else tostring(fn)
	local ownerName = nil
	if _G.__DEV__ and ownerFn then
		-- deviation: owner may be a function or a table
		ownerName = describeOwner(ownerFn)
	end
	return describeComponentFrame(name, source, ownerName)
end

-- deviation: because of deviations in other functions, this function is
-- not needed. If we need to bring it, it should return true if Component is a
-- class component, and false if a function component
-- local function shouldConstruct(Component)
-- 	local prototype = Component.prototype
-- 	return not not (prototype and prototype.isReactComponent)
-- end

local function describeUnknownElementTypeFrameInDEV(
	type_: any,
	source: nil | Source,
	-- deviation: owner could be a class component
	ownerFn: nil | ReactComponent<any>
): string
	if not _G.__DEV__ then
		return ""
	end
	if type_ == nil then
		return ""
	end

	-- deviation: in JavaScript, if `type` contains a class, typeof will
	-- return "function". We need to specifically check for the class.
	if type(type_) == "table" and type(type_.__ctor) == "function" then
		-- deviation: since Roact class components are tables, we can't
		-- count on describeClassComponent being a thin wrapper for
		-- describeFunctionComponent like upstream does implicitly
		return describeClassComponentFrame(type_, source, ownerFn)
	end

	if type(type_) == "function" then
		-- deviation: ignore enableComponentStackLocations
		-- if enableComponentStackLocations then
		-- 	-- deviation: since functions and classes have different
		-- 	-- types in Lua, we already know that shouldConstruct would return
		-- 	-- false
		-- 	return describeNativeComponentFrame(type, false)
		-- else
		-- 	return describeFunctionComponentFrame(type, source, ownerFn)
		-- end
		return describeFunctionComponentFrame(type_, source, ownerFn)
	end

	if type(type_) == "string" then
		return describeBuiltInComponentFrame(type_, source, ownerFn)
	end

	if type_ == REACT_SUSPENSE_TYPE then
		return describeBuiltInComponentFrame("Suspense", source, ownerFn)
	elseif type_ == REACT_SUSPENSE_LIST_TYPE then
		return describeBuiltInComponentFrame("SuspenseList", source, ownerFn)
	end

	if type(type_) == "table" then
		local typeProp = type_["$$typeof"]
		if typeProp == REACT_FORWARD_REF_TYPE then
			return describeFunctionComponentFrame(type_.render, source, ownerFn)
		elseif typeProp == REACT_MEMO_TYPE then
			-- // Memo may contain any component type so we recursively resolve it.
			return describeUnknownElementTypeFrameInDEV(type_.type, source, ownerFn)
		elseif typeProp == REACT_BLOCK_TYPE then
			return describeFunctionComponentFrame(type_._render, source, ownerFn)
		elseif typeProp == REACT_LAZY_TYPE then
			local lazyComponent = type_
			local payload = lazyComponent._payload
			local init = lazyComponent._init

			local ok, result = pcall(function()
				describeUnknownElementTypeFrameInDEV(
					-- // Lazy may contain any component type so we recursively resolve it.
					init(payload),
					source,
					ownerFn
				)
			end)

			if ok then
				return result
			end
		end
	end

	return ""
end

return {
	-- deviation: ReactShallowRenderer depends on this, but the upstream `react`
	-- repo doesn't expose it; instead, the shallow-renderer's copies of shared
	-- modules do so. Since we opted to reuse the shared modules in this repo
	-- instead of duplicating, we need to have them include this field
	describeComponentFrame = describeComponentFrame,

	describeBuiltInComponentFrame = describeBuiltInComponentFrame,
	describeNativeComponentFrame = describeNativeComponentFrame,
	describeClassComponentFrame = describeClassComponentFrame,
	describeFunctionComponentFrame = describeFunctionComponentFrame,
	describeUnknownElementTypeFrameInDEV = describeUnknownElementTypeFrameInDEV,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c1</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF9E97C5A114444BA9532ED5CB0763413">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactElementType</string>
								<string name="ScriptGuid">{F5C19913-6ECA-4BF8-BD12-D6001AF02D96}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_Element<ElementType> = flowtypes.React_Element<ElementType>
type React_StatelessFunctionalComponent<P> = flowtypes.React_StatelessFunctionalComponent<P>
type React_ComponentType<P> = flowtypes.React_ComponentType<P>

export type Source = {
	fileName: string,
	lineNumber: number,
}
type Key = string | number
-- deviation: we're using the TypeScript definition here, which is more strict
export type ReactElement<P = Object, T = any> = {
	["$$typeof"]: number,

	-- FIXME Luau: Luau has some trouble and inlining the type param from createElement doesn't help
	type: React_StatelessFunctionalComponent<P> | React_ComponentType<P> | string,
	-- type: T,
	key: Key | nil,
	ref: any,
	props: P,

	-- deviation: upstream has this as interface, which is extensible, Luau types are closed by default
	-- ReactFiber
	_owner: any,

	-- __DEV__
	_store: any?,
	_self: React_Element<any>?,
	_shadowChildren: any?,
	_source: Source?,
}

-- deviation: Return something so that the module system is happy
return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c2</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5864702E445446A29F935A2694CAA6B0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactErrorUtils</string>
								<string name="ScriptGuid">{F0DDDF87-31DC-4B74-8182-E15AA3A66278}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/shared/ReactErrorUtils.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local invariant = require(script.Parent.invariant)
local invokeGuardedCallbackImpl = require(script.Parent.invokeGuardedCallbackImpl)

-- deviation: preemptively declare function
local clearCaughtError

-- Used by Fiber to simulate a try-catch.
local hasError = false
local caughtError = nil

-- Used by event system to capture/rethrow the first error.
local hasRethrowError = false
local rethrowError = nil
local reporter = {
	onError = function(err)
		hasError = true
		caughtError = err
	end,
}
local exports = {}

--[[*
* Call a function while guarding against errors that happens within it.
* Returns an error if it throws, otherwise nil.
*
* In production, this is implemented using a try-catch. The reason we don't
* use a try-catch directly is so that we can swap out a different
* implementation in DEV mode.
*
* @param {String} name of the guard to use for logging or debugging
* @param {Function} func The function to invoke
* @param {*} context The context to use when calling the function
* @param {...*} args Arguments for function
]]
exports.invokeGuardedCallback = function(...)
	hasError = false
	caughtError = nil
	-- deviation: passing in reporter directly
	invokeGuardedCallbackImpl(reporter, ...)
end

--[[*
* Same as invokeGuardedCallback, but instead of returning an error, it stores
* it in a global so it can be rethrown by `rethrowCaughtError` later.
* TODO: See if caughtError and rethrowError can be unified.
*
* @param {String} name of the guard to use for logging or debugging
* @param {Function} func The function to invoke
* @param {*} context The context to use when calling the function
* @param {...*} args Arguments for function
]]
exports.invokeGuardedCallbackAndCatchFirstError = function(...)
	-- deviation: instead of the weird `this` indirection, pass varargs through
	exports.invokeGuardedCallback(...)

	if hasError then
		local err = clearCaughtError()

		if not hasRethrowError then
			hasRethrowError = true
			rethrowError = err
		end
	end
end

--[[*
* During execution of guarded functions we will capture the first error which
* we will rethrow to be handled by the top level error handler.
]]
exports.rethrowCaughtError = function()
	if hasRethrowError then
		local err = rethrowError
		hasRethrowError = false
		rethrowError = nil
		error(err)
	end
end

exports.hasCaughtError = function()
	return hasError
end

clearCaughtError = function()
	if hasError then
		local err = caughtError
		hasError = false
		caughtError = nil
		return err
	else
		invariant(
			false,
			"clearCaughtError was called but no error was captured. This error "
				.. "is likely caused by a bug in React. Please file an issue."
		)
		-- deviation: luau doesn't know that invariant throws, so we return nil
		return nil
	end
end
exports.clearCaughtError = clearCaughtError

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c3</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX316B1411B6F1444EBD835B2A827CB757">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFeatureFlags</string>
								<string name="ScriptGuid">{EA53BFC5-B6EA-42F6-9BEE-50D46DF11990}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/ba82eea3837e4aaeb5a30b7827b664a8c2128d2e/packages/shared/ReactFeatureFlags.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
-- Unknown globals fail type checking (see "Unknown symbols" section of
-- https://roblox.github.io/luau/typecheck.html)
local exports = {}

-- Filter certain DOM attributes (e.g. src, href) if their values are empty strings.
-- This prevents e.g. <img src=""> from making an unnecessary HTTP request for certain browsers.
exports.enableFilterEmptyStringAttributesDOM = true

-- Adds verbose console logging for e.g. state updates, suspense, and work loop stuff.
-- Intended to enable React core members to more easily debug scheduling issues in DEV builds.
exports.enableDebugTracing = false

-- Adds user timing marks for e.g. state updates, suspense, and work loop stuff,
-- for an experimental scheduling profiler tool.
exports.enableSchedulingProfiler = _G.__PROFILE__ and _G.__EXPERIMENTAL__

-- Helps identify side effects in render-phase lifecycle hooks and setState
-- reducers by double invoking them in Strict Mode.
-- TODO: we'll want to enable this for DEV app bundles
exports.debugRenderPhaseSideEffectsForStrictMode = _G.__DEV__

-- To preserve the "Pause on caught exceptions" behavior of the debugger, we
-- replay the begin phase of a failed component inside invokeGuardedCallback.
exports.replayFailedUnitOfWorkWithInvokeGuardedCallback = _G.__DEV__

-- Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
exports.warnAboutDeprecatedLifecycles = true

-- Gather advanced timing metrics for Profiler subtrees.
exports.enableProfilerTimer = _G.__PROFILE__

-- Record durations for commit and passive effects phases.
exports.enableProfilerCommitHooks = false

-- Trace which interactions trigger each commit.
exports.enableSchedulerTracing = _G.__PROFILE__

-- SSR experiments
exports.enableSuspenseServerRenderer = _G.__EXPERIMENTAL__
exports.enableSelectiveHydration = _G.__EXPERIMENTAL__

-- Flight experiments
exports.enableBlocksAPI = _G.__EXPERIMENTAL__
exports.enableLazyElements = _G.__EXPERIMENTAL__

-- Only used in www builds.
exports.enableSchedulerDebugging = false

-- Disable javascript: URL strings in href for XSS protection.
exports.disableJavaScriptURLs = false

-- Experimental Host Component support.
exports.enableFundamentalAPI = false

-- Experimental Scope support.
exports.enableScopeAPI = false

-- Experimental Create Event Handle API.
exports.enableCreateEventHandleAPI = false

-- New API for JSX transforms to target - https://github.com/reactjs/rfcs/pull/107

-- We will enforce mocking scheduler with scheduler/unstable_mock at some point. (v18?)
-- Till then, we warn about the missing mock, but still fallback to a legacy mode compatible version
exports.warnAboutUnmockedScheduler = false

-- Add a callback property to suspense to notify which promises are currently
-- in the update queue. This allows reporting and tracing of what is causing
-- the user to see a loading state.
-- Also allows hydration callbacks to fire when a dehydrated boundary gets
-- hydrated or deleted.
exports.enableSuspenseCallback = false

-- Part of the simplification of React.createElement so we can eventually move
-- from React.createElement to React.jsx
-- https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md
exports.warnAboutDefaultPropsOnFunctionComponents = false

exports.disableSchedulerTimeoutBasedOnReactExpirationTime = false

exports.enableTrustedTypesIntegration = false

-- Enables a warning when trying to spread a 'key' to an element
-- a deprecated pattern we want to get rid of in the future
exports.warnAboutSpreadingKeyToJSX = true

exports.enableComponentStackLocations = true

exports.enableNewReconciler = true

-- Errors that are thrown while unmounting (or after in the case of passive effects)
-- should bypass any error boundaries that are also unmounting (or have unmounted)
-- and be handled by the nearest still-mounted boundary.
-- If there are no still-mounted boundaries, the errors should be rethrown.
exports.skipUnmountedBoundaries = true

-- --------------------------
-- Future APIs to be deprecated
-- --------------------------

-- Prevent the value and checked attributes from syncing
-- with their related DOM properties
exports.disableInputAttributeSyncing = true

exports.warnAboutStringRefs = false

exports.disableLegacyContext = false

-- Disables children for <textarea> elements
exports.disableTextareaChildren = false

exports.disableModulePatternComponents = false

-- We should remove this flag once the above flag becomes enabled
exports.warnUnstableRenderSubtreeIntoContainer = false

-- Support legacy Primer support on internal FB www
exports.enableLegacyFBSupport = true

-- Updates that occur in the render phase are not officially supported. But when
-- they do occur, we defer them to a subsequent render by picking a lane that's
-- not currently rendering. We treat them the same as if they came from an
-- interleaved event. Remove this flag once we have migrated to the
-- new behavior.
exports.deferRenderPhaseUpdateToNextBatch = false

-- Replacement for runWithPriority in React internals.
exports.decoupleUpdatePriorityFromScheduler = true

exports.enableDiscreteEventFlushingChange = false

exports.enableEagerRootListeners = false

exports.enableDoubleInvokingEffects = false
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3D5006634D634F1CAF9E3B36B8380E4A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactFiberHostConfig</string>
								<string name="ScriptGuid">{B7218B85-2A82-4EA7-85D4-1992C77F0F3E}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	ROBLOX deviation: ReactFiberHostConfig captures singleton state across the
	whole workspace. This file and the modules it requires were moved from React
	to untangle a cyclic workspace member dependency.

	Before:
	* ReactFiberHostConfig (and the 5 associated modules) lived in React
	* React had a dependency on Shared
	* Shared reached into React source to re-export ReactFiberHostConfig (cycle)

	After:
	* ReactFiberHostConfig (and the 5 associated modules) live in Shared
	* React depends on Shared
	* Shared has no intra-workspace dependencies (no cycles)
]]

-- types that are common across ReactFiberHostConfig files, moved here to avoid circular deps
type Object = { [string]: any }
export type OpaqueIDType = string | Object

return {
	WithNoHydration = require(script.WithNoHydration),
	WithNoPersistence = require(script.WithNoPersistence),
	WithNoTestSelectors = require(script.WithNoTestSelectors),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c5</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX820B954D847B4C06AE80A43B6499ABC4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WithNoHydration</string>
									<string name="ScriptGuid">{3C1BF377-FE9D-4B2E-AC85-3B496A062320}</string>
									<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactFiberHostConfigWithNoHydration.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support hydration
-- can re-export everything from this module.

function shim(...)
	invariant(
		false,
		"The current renderer does not support hydration. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Hydration (when unsupported)
export type SuspenseInstance = any
return {
	supportsHydration = false,
	canHydrateInstance = shim,
	canHydrateTextInstance = shim,
	canHydrateSuspenseInstance = shim,
	isSuspenseInstancePending = shim,
	isSuspenseInstanceFallback = shim,
	registerSuspenseInstanceRetry = shim,
	getNextHydratableSibling = shim,
	getFirstHydratableChild = shim,
	hydrateInstance = shim,
	hydrateTextInstance = shim,
	hydrateSuspenseInstance = shim,
	getNextHydratableInstanceAfterSuspenseInstance = shim,
	commitHydratedContainer = shim,
	commitHydratedSuspenseInstance = shim,
	clearSuspenseBoundary = shim,
	clearSuspenseBoundaryFromContainer = shim,
	didNotMatchHydratedContainerTextInstance = shim,
	didNotMatchHydratedTextInstance = shim,
	didNotHydrateContainerInstance = shim,
	didNotHydrateInstance = shim,
	didNotFindHydratableContainerInstance = shim,
	didNotFindHydratableContainerTextInstance = shim,
	didNotFindHydratableContainerSuspenseInstance = shim,
	didNotFindHydratableInstance = shim,
	didNotFindHydratableTextInstance = shim,
	didNotFindHydratableSuspenseInstance = shim,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c6</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA981D26F03B54631AFA29041AE866136">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WithNoPersistence</string>
									<string name="ScriptGuid">{FB616B0C-8011-4198-B5C0-6E03092C4653}</string>
									<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/c5d2fc7127654e43de59fff865b74765a103c4a5/packages/react-reconciler/src/ReactFiberHostConfigWithNoPersistence.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support persistence
-- can re-export everything from this module.

local function shim(...)
	invariant(
		false,
		"The current renderer does not support persistence. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Persistence (when unsupported)
return {
	supportsPersistence = false,
	cloneInstance = shim,
	cloneFundamentalInstance = shim,
	createContainerChildSet = shim,
	appendChildToContainerChildSet = shim,
	finalizeContainerChildren = shim,
	replaceContainerChildren = shim,
	cloneHiddenInstance = shim,
	cloneHiddenTextInstance = shim,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c7</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXEF81AA67F3334540BCCB8DD23E3B51FC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">WithNoTestSelectors</string>
									<string name="ScriptGuid">{1C5281C5-5B1B-440F-9111-55381BADDC20}</string>
									<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/3cde22a84e246fc5361f038bf0c23405b2572c22/packages/react-reconciler/src/ReactFiberHostConfigWithNoTestSelectors.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local invariant = require(script.Parent.Parent.invariant)

-- Renderers that don't support test selectors
-- can re-export everything from this module.

local function shim(...)
	invariant(
		false,
		"The current renderer does not support test selectors. "
			.. "This error is likely caused by a bug in React. "
			.. "Please file an issue."
	)
end

-- Test selectors (when unsupported)
return {
	supportsTestSelectors = false,
	findFiberRoot = shim,
	getBoundingRect = shim,
	getTextContent = shim,
	isHiddenSubtree = shim,
	matchAccessibilityRole = shim,
	setFocusIfFocusable = shim,
	setupIntersectionObserver = shim,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c8</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX9343AAD64A884A7EAD50F1749D8701A5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactInstanceMap</string>
								<string name="ScriptGuid">{CB0CFA6C-027F-4C60-975F-8B8DB1A9F049}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/2ba43edc2675380a0f2222f351475bf9d750c6a9/packages/shared/ReactInstanceMap.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

--[[*
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 ]]

--[[*
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 ]]

local Shared = script.Parent
local Packages = Shared.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
local inspect = LuauPolyfill.util.inspect
local getComponentName = require(script.Parent.getComponentName)

local exports = {}

local function isValidFiber(fiber): boolean
	return fiber.tag ~= nil and fiber.subtreeFlags ~= nil and fiber.lanes ~= nil and fiber.childLanes ~= nil
end

exports.remove = function(key)
	key._reactInternals = nil
end

exports.get = function(key)
	local value = key._reactInternals

	-- deviation: we have a crash in production this will help catch
	-- TODO: wrap this in __DEV__
	if not isValidFiber(value) then
		error(
			Error.new(
				"invalid fiber in "
					.. (getComponentName(key) or "UNNAMED Component")
					.. " during get from ReactInstanceMap! "
					.. inspect(value)
			)
		)
	elseif value.alternate ~= nil and not isValidFiber(value.alternate) then
		error(
			Error.new(
				"invalid alternate fiber ("
					.. (getComponentName(key) or "UNNAMED alternate")
					.. ") in "
					.. (getComponentName(key) or "UNNAMED Component")
					.. " during get from ReactInstanceMap! "
					.. inspect(value.alternate)
			)
		)
	end

	return value
end

exports.has = function(key)
	return key._reactInternals ~= nil
end

exports.set = function(key, value)
	-- deviation: we have a crash in production this will help catch
	-- TODO: wrap this in __DEV__
	local parent = value
	local message
	while parent ~= nil do
		if not isValidFiber(parent) then
			message = "invalid fiber in "
				.. (getComponentName(key) or "UNNAMED Component")
				.. " being set in ReactInstanceMap! "
				.. inspect(parent)
				.. "\n"

			if value ~= parent then
				message ..= " (from original fiber " .. (getComponentName(key) or "UNNAMED Component") .. ")"
			end
			error(Error.new(message))
		elseif (parent :: any).alternate ~= nil and not isValidFiber((parent :: any).alternate) then
			message = "invalid alternate fiber ("
				.. (getComponentName(key) or "UNNAMED alternate")
				.. ") in "
				.. (getComponentName(key) or "UNNAMED Component")
				.. " being set in ReactInstanceMap! "
				.. inspect((parent :: any).alternate)
				.. "\n"

			if value ~= parent then
				message ..= " (from original fiber " .. (getComponentName(key) or "UNNAMED Component") .. ")"
			end
			error(Error.new(message))
		end
		parent = (parent :: any).return_
	end

	(key :: any)._reactInternals = value
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062c9</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX68334CACF5014A0DB315D334A30F938D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactSharedInternals</string>
								<string name="ScriptGuid">{F3A07D92-9CDC-42B1-9508-7DC2408A2ABA}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/607148673b3156d051d1fed17cd49e83698dce54/packages/react/src/ReactSharedInternals.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]

--[[
	ROBLOX deviation: ReactSharedInternals captures singleton state across the
	whole workspace. This file and the modules it requires were moved from React
	to untangle a cyclic workspace member dependency.

	Before:
	* ReactSharedInternals (and the 5 associated modules) lived in React
	* React had a dependency on Shared
	* Shared reached into React source to re-export ReactSharedInternals (cycle)

	After:
	* ReactSharedInternals (and the 5 associated modules) live in Shared
	* React depends on Shared
	* Shared has no intra-workspace dependencies (no cycles)
]]
local Packages = script.Parent.Parent
local console = require(Packages.LuauPolyfill).console
local function onlyInTestError(functionName: string)
	return function()
		console.error(functionName .. " is only available in tests, not in production")
	end
end

-- import assign from 'object-assign';
local ReactCurrentDispatcher = require(script.ReactCurrentDispatcher)
export type Dispatcher = ReactCurrentDispatcher.Dispatcher
local ReactCurrentBatchConfig = require(script.ReactCurrentBatchConfig)
local ReactCurrentOwner = require(script.ReactCurrentOwner)
local ReactDebugCurrentFrame = require(script.ReactDebugCurrentFrame)
local IsSomeRendererActing = require(script.IsSomeRendererActing)

local ReactSharedInternals = {
	ReactCurrentDispatcher = ReactCurrentDispatcher,
	ReactCurrentBatchConfig = ReactCurrentBatchConfig,
	ReactCurrentOwner = ReactCurrentOwner,
	IsSomeRendererActing = IsSomeRendererActing,
	-- deviation: Luau type checking requires us to have a consistent export shape regardless of __DEV__
	-- TODO: use if-expressions when all clients are on 503+
	ReactDebugCurrentFrame = if _G.__DEV__
		then ReactDebugCurrentFrame
		else {
			setExtraStackFrame = function(_: string?): ()
				onlyInTestError("setExtraStackFrame")
			end,
		},
	-- deviation: We shouldn't have to worry about duplicate bundling here
	-- Used by renderers to avoid bundling object-assign twice in UMD bundles:
	-- assign,
}

return ReactSharedInternals
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062ca</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXD3D18F76EA274800B4D0ED61C0017190">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">IsSomeRendererActing</string>
									<string name="ScriptGuid">{68532118-AFB2-42DA-B27C-17AD8A264831}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/a457e02ae3a2d3903fcf8748380b1cc293a2445e/packages/react/src/IsSomeRendererActing.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[*
 * Used by act() to track whether you're inside an act() scope.
 ]]

local IsSomeRendererActing = {
	current = false,
}
return IsSomeRendererActing
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062cb</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX36A22E82A99747928531DFD55EFAC543">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactCurrentBatchConfig</string>
									<string name="ScriptGuid">{83264212-D917-4B6E-BBF6-E1153D3FE0D4}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/92fcd46cc79bbf45df4ce86b0678dcef3b91078d/packages/react/src/ReactCurrentBatchConfig.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[*
 * Keeps track of the current batch's configuration such as how long an update
 * should suspend for if it needs to.
]]
local ReactCurrentBatchConfig = {
	transition = 0,
}

return ReactCurrentBatchConfig
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062cc</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX14ED048E10084766995F93D659B4EDA1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactCurrentDispatcher</string>
									<string name="ScriptGuid">{90A19039-62CF-41AD-96F0-93752B374CA2}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/376d5c1b5aa17724c5fea9412f8fcde14a7b23f1/packages/react/src/ReactCurrentDispatcher.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

--[[*
 * Keeps track of the current dispatcher.
]]
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>

-- deviation: we duplicate the Dispatcher type here because upstream has a circular dependency between Shared and Reconciler
local ReactElementType = require(script.Parent.Parent.ReactElementType)
type Source = ReactElementType.Source
local ReactTypes = require(script.Parent.Parent.ReactTypes)
type RefObject = ReactTypes.RefObject
type ReactContext<T> = ReactTypes.ReactContext<T>
-- deviation START: binding support
type ReactBinding<T> = ReactTypes.ReactBinding<T>
type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- deviation END: binding support
type MutableSourceVersion = ReactTypes.MutableSourceVersion
type MutableSource<Source> = ReactTypes.MutableSource<Source>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<Source, Snapshot>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

export type Dispatcher = {
	readContext: <T>(context: ReactContext<T>, observedBits: nil | number | boolean) -> T,
	useState: <S>(initialState: (() -> S) | S) -> (S, Dispatch<BasicStateAction<S>>),
	useReducer: <S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?) -> (S, Dispatch<A>),
	useContext: <T>(context: ReactContext<T>, observedBits: nil | number | boolean) -> T,
	-- deviation START: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
	useRef: <T>(initialValue: T) -> { current: T | nil },
	-- deviation END
	-- deviation START: Bindings are a feature unique to Roact
	useBinding: <T>(initialValue: T) -> (ReactBinding<T>, ReactBindingUpdater<T>),
	-- deviation END
	useEffect: (
		-- TODO: Luau needs union type packs for this type to translate idiomatically
		create: (() -> ()) | (() -> (() -> ())),
		deps: Array<any> | nil
	) -> (),
	useLayoutEffect: (
		-- TODO: Luau needs union type packs for this type to translate idiomatically
		create: (() -> ()) | (() -> (() -> ())),
		deps: Array<any> | nil
	) -> (),
	useCallback: <T>(callback: T, deps: Array<any> | nil) -> T,
	useMemo: <T...>(nextCreate: () -> T..., deps: Array<any> | nil) -> T...,
	useImperativeHandle: <T>(
		ref: { current: T | nil } | ((inst: T | nil) -> any) | nil,
		create: () -> T,
		deps: Array<any> | nil
	) -> (),
	useDebugValue: <T>(value: T, formatterFn: ((value: T) -> any)?) -> (),
	-- TODO: make these non-optional and implement them in the dispatchers
	useDeferredValue: (<T>(value: T) -> T)?,
	useTransition: (() -> ((() -> ()) -> (), boolean))?, -- deviation: Luau doesn't support jagged array types [(() -> ()) -> (), boolean],
	useMutableSource: <Source, Snapshot>(
		source: MutableSource<Source>,
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		subscribe: MutableSourceSubscribeFn<Source, Snapshot>
	) -> Snapshot,
	useOpaqueIdentifier: () -> any,

	unstable_isNewReconciler: boolean?,
	-- [string]: any,
}

local ReactCurrentDispatcher: { current: nil | Dispatcher } = {
	--[[
		* @internal
		* @type {ReactComponent}
		*/
	]]
	current = nil,
}

return ReactCurrentDispatcher
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062cd</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD550C16B26CB47579D2B6F3B9B405116">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactCurrentOwner</string>
									<string name="ScriptGuid">{8079710B-838B-4D05-B5B1-67EB8AA01980}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/376d5c1b5aa17724c5fea9412f8fcde14a7b23f1/packages/react/src/ReactCurrentOwner.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

--[[*
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
]]
local ReactCurrentOwner = {
	--[[*
   * @internal
   * @type {ReactComponent}
   ]]
	-- deviation START: upstream types this as Fiber, but that would incur a circular dependency between reconciler and shared
	current = nil :: any,
	-- deviation END
}

return ReactCurrentOwner
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062ce</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX3C4E222E3F8145298EFEFD4759C886AB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactDebugCurrentFrame</string>
									<string name="ScriptGuid">{8A584CA2-B8E7-45FB-8CA0-634C3EBDD8C6}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/98d410f5005988644d01c9ec79b7181c3dd6c847/packages/react/src/ReactDebugCurrentFrame.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

local ReactDebugCurrentFrame = {}

local currentExtraStackFrame = nil :: nil | string

function ReactDebugCurrentFrame.setExtraStackFrame(stack: string?): ()
	if _G.__DEV__ then
		currentExtraStackFrame = stack
	end
end

if _G.__DEV__ then
	-- deviation: in Lua, the implementation is duplicated
	-- function ReactDebugCurrentFrame.setExtraStackFrame(stack: string?)
	-- 	if _G.__DEV__ then
	-- 		currentExtraStackFrame = stack
	-- 	end
	-- end

	-- Stack implementation injected by the current renderer.
	ReactDebugCurrentFrame.getCurrentStack = nil :: nil | (() -> string)

	function ReactDebugCurrentFrame.getStackAddendum(): string
		local stack = ""

		-- Add an extra top frame while an element is being validated
		if currentExtraStackFrame then
			stack = stack .. currentExtraStackFrame
		end

		-- Delegate to the injected renderer-specific implementation
		local impl = ReactDebugCurrentFrame.getCurrentStack
		if impl then
			stack = stack .. (impl() or "")
		end

		return stack
	end
end

return ReactDebugCurrentFrame
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed000062cf</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX9835918842EC49418404D1520629BBD4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactSymbols</string>
								<string name="ScriptGuid">{736F9AB3-A57E-4759-B2BE-58A435702FAC}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/b61174fb7b09580c1ec2a8f55e73204b706d2935/packages/shared/ReactSymbols.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

-- ATTENTION
-- When adding new symbols to this file,
-- Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'

-- local Packages = script.Parent.Parent
-- local LuauPolyfill = require(Packages.LuauPolyfill)
-- local Symbol = LuauPolyfill.Symbol

local exports: { [string]: any } = {}

-- The Symbol used to tag the ReactElement-like types. If there is no native Symbol
-- nor polyfill, then a plain number is used for performance.
exports.REACT_ELEMENT_TYPE = 0xeac7
exports.REACT_PORTAL_TYPE = 0xeaca
exports.REACT_FRAGMENT_TYPE = 0xeacb
exports.REACT_STRICT_MODE_TYPE = 0xeacc
exports.REACT_PROFILER_TYPE = 0xead2
exports.REACT_PROVIDER_TYPE = 0xeacd
exports.REACT_CONTEXT_TYPE = 0xeace
exports.REACT_FORWARD_REF_TYPE = 0xead0
exports.REACT_SUSPENSE_TYPE = 0xead1
exports.REACT_SUSPENSE_LIST_TYPE = 0xead8
exports.REACT_MEMO_TYPE = 0xead3
exports.REACT_LAZY_TYPE = 0xead4
exports.REACT_BLOCK_TYPE = 0xead9
exports.REACT_SERVER_BLOCK_TYPE = 0xeada
exports.REACT_FUNDAMENTAL_TYPE = 0xead5
exports.REACT_SCOPE_TYPE = 0xead7
exports.REACT_OPAQUE_ID_TYPE = 0xeae0
exports.REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1
exports.REACT_OFFSCREEN_TYPE = 0xeae2
exports.REACT_LEGACY_HIDDEN_TYPE = 0xeae3
exports.REACT_BINDING_TYPE = 0xeae4

-- TODO: Use Symbol again once jest-mock knows to exclude the LuauPolyfill module from being reset
-- deviation: In Lua, Symbol will be a callable table, not a function
-- if typeof(Symbol) == "table" and Symbol.for_ ~= nil then
--   local symbolFor = Symbol.for_
--   exports.REACT_ELEMENT_TYPE = symbolFor('react.element')
--   exports.REACT_PORTAL_TYPE = symbolFor('react.portal')
--   exports.REACT_FRAGMENT_TYPE = symbolFor('react.fragment')
--   exports.REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode')
--   exports.REACT_PROFILER_TYPE = symbolFor('react.profiler')
--   exports.REACT_PROVIDER_TYPE = symbolFor('react.provider')
--   exports.REACT_CONTEXT_TYPE = symbolFor('react.context')
--   exports.REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref')
--   exports.REACT_SUSPENSE_TYPE = symbolFor('react.suspense')
--   exports.REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list')
--   exports.REACT_MEMO_TYPE = symbolFor('react.memo')
--   exports.REACT_LAZY_TYPE = symbolFor('react.lazy')
--   exports.REACT_BLOCK_TYPE = symbolFor('react.block')
--   exports.REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block')
--   exports.REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental')
--   exports.REACT_SCOPE_TYPE = symbolFor('react.scope')
--   exports.REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id')
--   exports.REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode')
--   exports.REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen')
--   exports.REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden')
-- end

-- deviation: short circuit for now
--local MAYBE_ITERATOR_SYMBOL = false -- deviation: typeof(Symbol) == 'function' and Symbol.iterator
--local FAUX_ITERATOR_SYMBOL = '@@iterator'

type Iterator<T> = {
	next: () -> {
		value: T,
		key: any,
		done: boolean,
	},
}
-- deviation: upstream type is incorrect, as returned function takes a parameter in reconcileChildrenIterator()
exports.getIteratorFn = function(maybeIterable): nil | (...any) -> Iterator<any>
	if typeof(maybeIterable) == "table" then
		-- deviation: Upstream understands that portal objects are not
		-- iterable; we need to check explicitly
		if maybeIterable["$$typeof"] == exports.REACT_PORTAL_TYPE then
			return nil
		end
		return function()
			local currentKey: any, currentValue: any
			return {
				next = function()
					currentKey, currentValue = next(maybeIterable, currentKey)
					return {
						done = currentValue == nil,
						-- deviation: To support Roact's table-keys-as-stable-keys feature,
						-- we need the iterator to return the key as well
						key = currentKey,
						value = currentValue,
					}
				end,
			}
		end
	end

	return nil
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d0</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEF753FD1B81444CABEB63E33FD2E3EA0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactTypes</string>
								<string name="ScriptGuid">{01775793-D960-4EAF-9031-3C36EB33C7F3}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object
type void = nil
type NonMaybeType<T> = T

local flowtypes = require(script.Parent["flowtypes.roblox"])
type React_Element<T> = flowtypes.React_Element<T>
type React_Node = flowtypes.React_Node
type SimpleMap<K, V> = { [K]: V }
type Iterable<T> = SimpleMap<string | number, T> | Array<T>

export type ReactNode<T = any> =
	React_Element<T>
	| ReactPortal
	-- | ReactText
	| ReactFragment
	| ReactProvider<T>
	| ReactConsumer<T>

export type ReactEmpty = nil | void | boolean

export type ReactFragment = ReactEmpty | Iterable<React_Node>

export type ReactNodeList = ReactEmpty | React_Node

-- deviation START: Roblox renderer doesn't support TextNode, only use of this type is in this file
-- export type ReactText = string | number;
-- deviation END
export type ReactProvider<T> = {
	["$$typeof"]: number,
	type: ReactProviderType<T>,
	key: nil | string,
	ref: nil,
	props: {
		value: T,
		children: ReactNodeList?,
		-- deviation START: only make this open to extension if absolutely necessary
		-- ...
		-- deviation END
	},
	-- deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- deviation END
}

export type ReactProviderType<T> = {
	["$$typeof"]: number,
	_context: ReactContext<T>,
	-- deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- deviation END
}

export type ReactConsumer<T> = {
	["$$typeof"]: number,
	type: ReactContext<T>, -- FIXME: Luau can't do <T> because:  Recursive type being used with different parameters
	key: nil | string,
	ref: nil,
	props: {
		children: (value: T) -> ReactNodeList,
		unstable_observedBits: number?,
		-- deviation START: only make this open to extension if absolutely necessary
		-- ...
		-- deviation END
	},
	-- deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- deviation END
}

export type ReactContext<T> = {
	["$$typeof"]: number,
	Consumer: ReactContext<T>,
	Provider: ReactProviderType<T>,
	_calculateChangedBits: ((T, T) -> number)?,
	_currentValue: T,
	_currentValue2: T,
	_threadCount: number,
	-- DEV only
	_currentRenderer: Object | nil,
	_currentRenderer2: Object | nil,
	-- This value may be added by application code
	-- to improve DEV tooling display names
	displayName: string?,
	-- deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- deviation END
}

export type ReactPortal = {
	["$$typeof"]: number,
	key: nil | string,
	containerInfo: any,
	children: ReactNodeList,
	-- TODO: figure out the API for cross-renderer implementation.
	implementation: any,
	-- deviation START: only make this open to extension if absolutely necessary
	-- ...
	-- deviation END
}

export type RefObject = { current: any }

-- deviation START: No Luau support for numeric literal types
-- export type EventPriority = 0 | 1 | 2;
export type EventPriority = number
-- deviation END

local exports = {}
exports.DiscreteEvent = 0
exports.UserBlockingEvent = 1
exports.ContinuousEvent = 2

export type ReactFundamentalComponentInstance<C, H> = {
	currentFiber: Object,
	instance: any,
	prevProps: Object?,
	props: Object,
	impl: ReactFundamentalImpl<C, H>,
	state: Object,
}

export type ReactFundamentalImpl<C, H> = {
	displayName: string,
	reconcileChildren: boolean,
	getInitialState: nil | (Object) -> Object,
	getInstance: (C, Object, Object) -> H,
	getServerSideString: nil | (C, Object) -> string,
	getServerSideStringClose: nil | (C, Object) -> string,
	onMount: (C, any, Object, Object) -> (),
	shouldUpdate: nil | (C, Object?, Object, Object) -> boolean,
	onUpdate: nil | (C, any, Object?, Object, Object) -> (),
	onUnmount: nil | (C, any, Object, Object) -> (),
	onHydrate: nil | (C, Object, Object) -> boolean,
	onFocus: nil | (C, Object, Object) -> boolean,
}
export type ReactFundamentalComponent<C, H> = {
	["$$typeof"]: number,
	impl: ReactFundamentalImpl<C, H>,
}

export type ReactScope = {
	["$$typeof"]: number,
}

export type ReactScopeQuery = (
	type: string,
	-- deviation START: leave closed to extension unless necessary
	props: { [string]: any? },
	-- deviation END
	instance: any
) -> boolean

export type ReactScopeInstance = {
	DO_NOT_USE_queryAllNodes: (ReactScopeQuery) -> nil | Array<Object>,
	DO_NOT_USE_queryFirstNode: (ReactScopeQuery) -> nil | Object,
	containsNode: (Object) -> boolean,
	getChildContextValues: <T>(context: ReactContext<T>) -> Array<T>,
}

-- deviation START: Bindings are unique to Roact
-- FIXME Luau: can't create recursive type with different parameters, so we
-- need to split the generic `map` method into a different type and then
-- re-combine those types together
type CoreReactBinding<T> = {
	getValue: (self: CoreReactBinding<T>) -> T,
	_source: string?,
}
type ReactBindingMap = {
	map: <T, U>(self: CoreReactBinding<T> & ReactBindingMap, (T) -> U) -> ReactBindingMap & CoreReactBinding<U>,
}

export type ReactBinding<T> = CoreReactBinding<T> & ReactBindingMap
export type ReactBindingUpdater<T> = (T) -> ()
-- deviation END

-- Mutable source version can be anything (e.g. number, string, immutable data structure)
-- so long as it changes every time any part of the source changes.
export type MutableSourceVersion = NonMaybeType<any>

export type MutableSourceGetSnapshotFn<Source, Snapshot> = (source: Source) -> Snapshot

export type MutableSourceSubscribeFn<Source, Snapshot> = (
	source: Source,
	callback: (snapshot: Snapshot) -> ()
) -> (() -> ())

export type MutableSourceGetVersionFn = (_source: NonMaybeType<any>) -> MutableSourceVersion

export type MutableSource<Source> = {
	_source: Source,

	_getVersion: MutableSourceGetVersionFn,

	-- Tracks the version of this source at the time it was most recently read.
	-- Used to determine if a source is safe to read from before it has been subscribed to.
	-- Version number is only used during mount,
	-- since the mechanism for determining safety after subscription is expiration time.
	--
	-- As a workaround to support multiple concurrent renderers,
	-- we categorize some renderers as primary and others as secondary.
	-- We only expect there to be two concurrent renderers at most:
	-- React Native (primary) and Fabric (secondary);
	-- React DOM (primary) and React ART (secondary).
	-- Secondary renderers store their context values on separate fields.
	-- We use the same approach for Context.
	_workInProgressVersionPrimary: nil | MutableSourceVersion,
	_workInProgressVersionSecondary: nil | MutableSourceVersion,

	-- DEV only
	-- Used to detect multiple renderers using the same mutable source.
	_currentPrimaryRenderer: Object | nil,
	_currentSecondaryRenderer: Object | nil,
}

-- The subset of a Thenable required by things thrown by Suspense.
-- This doesn't require a value to be passed to either handler.
export type Wakeable = {
	andThen: (
		self: Wakeable,
		onFulfill: () -> ...any,
		onReject: () -> ...any
		-- FIXME Luau: needs union type packs to parse () | Wakeable
	) -> nil | Wakeable,
	-- Special flag to opt out of tracing interactions across a Suspense boundary.
	__reactDoNotTraceInteractions: boolean?,
}

-- The subset of a Promise that React APIs rely on. This resolves a value.
-- This doesn't require a return value neither from the handler nor the
-- then function.
-- FIXME: workaround for Luau recursive type used with different parameters. delete this copy once that issue is resolved.
export type _Thenable<R> = {
	andThen: <U>(self: _Thenable<R>, onFulfill: (R) -> ...U, onReject: (error: any) -> ...U) -> (),
}

export type Thenable<R> = {
	andThen: <U>(
		self: Thenable<R>,
		onFulfill: (R) -> ...(_Thenable<U> | U),
		onReject: (error: any) -> ...(_Thenable<U> | U)
		-- FIXME Luau: need union type packs to parse () | Thenable<U>: CLI-49836
	) -> nil | _Thenable<U>,
}

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d1</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX87524FBCF31A4F7C8663B5330FF795EC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactVersion</string>
								<string name="ScriptGuid">{D39EFBAB-BC9D-43DC-BE16-785E566DF1CF}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/a89854bc936668d325cac9a22e2ebfa128c7addf/packages/shared/ReactVersion.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

-- TODO: this is special because it gets imported during build.
return "17.0.1"
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d2</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX5F173DDAC924418FA6891A8A120E6006">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Symbol.roblox</string>
								<string name="ScriptGuid">{2AC7C14D-F2EA-4816-9B03-C2DD1502B33A}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = string.format("Symbol(%s)", name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d3</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA5A20C2AB7B74D3082382CFCEC0610B8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Type.roblox</string>
								<string name="ScriptGuid">{68F78524-DA5B-46E6-A468-65D42667D08E}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent["Symbol.roblox"])

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("HostChangeEvent")
addType("HostEvent")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

return Type
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d4</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD9836959BF9547CABD318B2DCB9A21BA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">UninitializedState.roblox</string>
								<string name="ScriptGuid">{CE6C796C-03A8-4741-BF6B-D57F7796B002}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
--!strict
local console = require(script.Parent.console)

-- deviation: Initialize state to a singleton that warns on access and errors on assignment
-- initial state singleton
local UninitializedState = {}

setmetatable(UninitializedState, {
	__index = function(table, key)
		if _G.__DEV__ then
			console.warn("Attempted to access uninitialized state. Use setState to initialize state")
		end
		return nil
	end,
	__newindex = function(table, key)
		if _G.__DEV__ then
			console.error("Attempted to directly mutate state. Use setState to assign new values to state.")
		end
		return nil
	end,
	__tostring = function(self)
		return "<uninitialized component state>"
	end,
	__metatable = "UninitializedState",
})

return UninitializedState
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d5</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXFE0AE58070474D9BB5FA8747F77D91F1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">checkPropTypes</string>
								<string name="ScriptGuid">{B1F6ACB3-FA2E-4697-8E95-C9551F2967A7}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/55cb0b7eeb0e539d89858b8ed69beabf7fe2fb46/packages/shared/checkPropTypes.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object
type Function = (...any) -> ...any

-- NOTE: use patched console from shared
local console = require(script.Parent.console)

local loggedTypeFailures = {}

local ReactComponentStackFrame = require(script.Parent.ReactComponentStackFrame)
local describeUnknownElementTypeFrameInDEV = ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)

local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame

-- FIXME Luau: doesn't see `if element` as nilable table, so we get TypeError: Type 'any?' could not be converted into '{| _owner: {| type: nil |}, _source: Source?, type: any |}'
local function setCurrentlyValidatingElement(element: any?)
	if _G.__DEV__ then
		if element then
			local owner = element._owner
			local stack = describeUnknownElementTypeFrameInDEV(
				element.type,
				element._source,
				if owner ~= nil then owner.type else nil
			);
			-- FIXME Luau: Cannot call non-function ((string?) -> ()) | ((string?) -> ())
			(ReactDebugCurrentFrame.setExtraStackFrame :: any)(stack)
		else
			(ReactDebugCurrentFrame.setExtraStackFrame :: any)(nil)
		end
	end
end

local function checkPropTypes<P>(
	-- deviation START: also checks validateProps if present
	propTypes: Object?,
	validateProps: (P) -> (boolean, string?)?,
	props: P,
	-- deviation END
	location: string,
	componentName: string?,
	element: any?
): ()
	if _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		-- deviation: hasOwnProperty shouldn't be relevant to lua objects
		-- $FlowFixMe This is okay but Flow doesn't know it.
		-- local has = Function.call.bind(Object.prototype.hasOwnProperty)

		-- deviation: warns if both propType and validateProps defined.
		if propTypes and validateProps then
			console.warn("You've defined both propTypes and validateProps on " .. (componentName or "a component"))
		end

		-- deviation: also checks validateProps if present
		if validateProps then
			if typeof(validateProps) ~= "function" then
				console.error(
					("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
						typeof(validateProps),
						componentName or ""
					)
				)
			else
				local success, failureReason = validateProps(props)

				if not success then
					failureReason = failureReason or "<Validator function did not supply a message>"
					local message = string.format(
						"validateProps failed on a %s type in %s: %s",
						location,
						componentName or "<UNKNOWN Component>",
						tostring(failureReason)
					)
					-- deviation: In legacy Roact, prop validation
					-- failures throw. We replicate that behavior, even though
					-- it differs from propTypes (which only warns)
					-- FIXME: align with upstream behavior during React 18 Lua transition
					error(message)
				end
			end
		end

		if propTypes then
			-- deviation: since we can't constrain the generic, we assert so Luau knows propTypes is a table
			assert(typeof(propTypes) == "table", "propTypes needs to be a table")
			for typeSpecName, _ in propTypes do
				-- deviation: since our loop won't hit metatable members, we don't
				-- need to worry about encountering inherited properties here
				-- if has(propTypes, typeSpecName) then

				-- Prop type validation may throw. In case they do, we don't want to
				-- fail the render phase where it didn't fail before. So we log it.
				-- After these have been cleaned up, we'll local them throw.
				local _, result = xpcall(function()
					-- This is intentionally an invariant that gets caught. It's the same
					-- behavior as without this statement except with a better message.
					if typeof(propTypes[typeSpecName]) ~= "function" then
						local err = Error.new(
							(componentName or "React class")
								.. ": "
								.. location
								.. " type `"
								.. typeSpecName
								.. "` is invalid; "
								.. "it must be a function, usually from the `prop-types` package, but received `"
								.. typeof(propTypes[typeSpecName])
								.. "`."
								.. "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
						)
						err.name = "Invariant Violation"
						error(err)
					end

					return (propTypes[typeSpecName] :: Function)(
						props,
						typeSpecName,
						componentName,
						location,
						nil,
						"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
					)
				end, describeError)

				-- deviation: FIXME: Can we expose something from JSPolyfill that
				-- will let us verify that this is specifically the Error object
				-- defined there? if we check for result.message ~= nil, ReactNewContext.spec:1368 fails
				local isErrorObject = typeof(result) == "table"
				if result ~= nil and not isErrorObject then
					setCurrentlyValidatingElement(element)
					console.error(string.format(
						-- deviation: s/null/nil
						"%s: type specification of %s"
							.. " `%s` is invalid; the type checker "
							.. "function must return `nil` or an `Error` but returned a %s. "
							.. "You may have forgotten to pass an argument to the type checker "
							.. "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and "
							.. "shape all require an argument).",
						componentName or "React class",
						location,
						typeSpecName,
						typeof(result)
					))
					setCurrentlyValidatingElement(nil)
				end

				-- FIXME: Luau analyze doesn't understand isErrorObject's effect as a predicate meaning result ~= nil
				if isErrorObject and loggedTypeFailures[(result :: any).message] == nil then
					-- Only monitor this failure once because there tends to be a lot of the
					-- same error.
					loggedTypeFailures[tostring((result :: any).message)] = true
					setCurrentlyValidatingElement(element)
					console.warn(string.format("Failed %s type: %s", location, tostring((result :: any).message)))
					setCurrentlyValidatingElement(nil)
				end
			end
		end
	end
end

return checkPropTypes
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d6</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE96F8B7988B54356B50449CCB4F65D51">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">console</string>
								<string name="ScriptGuid">{75B6EE6E-85B6-481B-A138-470D7D80AE73}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

-- deviation: this lets us have the same functionality as in React, without
-- having something like Babel to inject a different implementation of
-- console.warn and console.error into the code
-- Instead of using `LuauPolyfill.console`, React internals should use this
-- wrapper to be able to use consoleWithStackDev in dev mode
local Shared = script.Parent
local Packages = Shared.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local consoleWithStackDev = require(Shared.consoleWithStackDev)

if _G.__DEV__ then
	local newConsole = setmetatable({
		warn = consoleWithStackDev.warn,
		error = consoleWithStackDev.error,
	}, {
		__index = console,
	})
	return newConsole
end

return console
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d7</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1E752A2540BD4696A6A16EF501650B35">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">consoleWithStackDev</string>
								<string name="ScriptGuid">{F812DDED-BB31-46D6-AD9A-A2B5A57C8E18}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/cb141681750c8221ac799074df09df2bb448c7a4/packages/shared/consoleWithStackDev.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local console = LuauPolyfill.console
local Array = LuauPolyfill.Array

local ReactSharedInternals = require(script.Parent.ReactSharedInternals)
-- In DEV, calls to console.warn and console.error get replaced
-- by calls to these methods by a Babel plugin.
--
-- In PROD (or in packages without access to React internals),
-- they are left as they are instead.

-- deviation: declare this ahead of time so that `warn` and `error` are able to
-- reference it
local printWarning

local exports = {}
exports.warn = function(format, ...)
	if _G.__DEV__ then
		printWarning("warn", format, { ... })
	end
end
exports.error = function(format, ...)
	if _G.__DEV__ then
		printWarning("error", format, { ... })
	end
end

function printWarning(level, format, args)
	-- When changing this logic, you might want to also
	-- update consoleWithStackDev.www.js as well.
	if _G.__DEV__ then
		local ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame
		local stack = ReactDebugCurrentFrame.getStackAddendum()

		if stack ~= "" then
			format ..= "%s"
			-- deviation: no array `concat` function in lua
			args = Array.slice(args, 1)
			table.insert(args, stack)
		end

		local argsWithFormat = Array.map(args, tostring)
		-- Careful: RN currently depends on this prefix
		table.insert(argsWithFormat, 1, "Warning: " .. format)
		-- We intentionally don't use spread (or .apply) directly because it
		-- breaks IE9: https://github.com/facebook/react/issues/13610
		-- eslint-disable-next-line react-internal/no-production-logging
		console[level](unpack(argsWithFormat))
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d8</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC029FE73074943129C707729D840010F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">enqueueTask.roblox</string>
								<string name="ScriptGuid">{E4BEE981-541C-4037-AD26-837DCA9E6103}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 ]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local setTimeout = LuauPolyfill.setTimeout

return function(task)
	-- deviation: Replace with setImmediate once we create an equivalent polyfill
	return setTimeout(task, 0)
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062d9</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX82222D2EB4C94C30AE9549635E96F8E7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">flowtypes.roblox</string>
								<string name="ScriptGuid">{85E58F53-1440-4833-BE81-2CF962EA5FB5}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
-- built-in flowtypes reverse engineered based on usage and enabling strict type checking on test suites
--!strict
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
type Array<T> = LuauPolyfill.Array<T>
type Object = { [string]: any }
-- duplicated from ReactElementType to avoid circular dep
type Source = {
	fileName: string,
	lineNumber: number,
}

-- deviation: alias for internal React$ flow types
export type React_Node =
	nil
	| boolean
	| number
	| string
	| React_Element<any>
	-- TODO: only include this once it's more specific than `any`
	-- | React_Portal
	| Array<React_Node?>
	-- TODO Luau: this more closely matches the upstream Iterable<>, hypothetically the UNIQUE_TAG field makes it so we don't unify with other tables and squad field resolution
	| { [string]: React_Node?, UNIQUE_TAG: any? }

export type React_Element<ElementType> = {
	type: ElementType,
	props: React_ElementProps<ElementType>?,
	key: React_Key | nil,
	ref: any,
}

export type React_PureComponent<Props, State = nil> = React_Component<Props, State>

-- NOTE: this flowtype built-in is derived from the object shape returned by forwardRef
export type React_AbstractComponent<Config, Instance> = {
	["$$typeof"]: number,
	render: ((props: Config, ref: React_Ref<Instance>) -> React_Node)?,
	displayName: string?,
	defaultProps: Config?,
	-- not in React flowtype, but is in definitelytyped and is used in ReactElement
	name: string?,
	-- allows methods to be hung on a component, used in forwardRef.spec regression test we added
	[string]: any,
}

-- TODO: ElementConfig: something like export type React_ElementConfig<React_Component<P>> = P
export type React_ElementConfig<C> = Object

-- deviation: this is a class export upstream, so optional overrides are nil-able, and it's extensible by default
export type React_Component<Props, State = nil> = {
	-- fields
	props: Props,
	state: State,

	-- action methods

	setState: (
		self: React_Component<Props, State>,
		partialState: State | ((State, Props) -> State?),
		callback: (() -> ())?
	) -> (),

	forceUpdate: (self: React_Component<Props, State>, callback: (() -> ())?) -> (),

	-- lifecycle methods

	init: ((self: React_Component<Props, State>, props: Props, context: any?) -> ())?,
	render: (self: React_Component<Props, State>) -> React_Node,
	componentWillMount: ((self: React_Component<Props, State>) -> ())?,
	UNSAFE_componentWillMount: ((self: React_Component<Props, State>) -> ())?,
	componentDidMount: ((self: React_Component<Props, State>) -> ())?,
	componentWillReceiveProps: ((self: React_Component<Props, State>, nextProps: Props, nextContext: any) -> ())?,
	UNSAFE_componentWillReceiveProps: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextContext: any
	) -> ())?,
	shouldComponentUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> boolean)?,
	componentWillUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> ())?,
	UNSAFE_componentWillUpdate: ((
		self: React_Component<Props, State>,
		nextProps: Props,
		nextState: State,
		nextContext: any
	) -> ())?,
	componentDidUpdate: ((
		self: React_Component<Props, State>,
		prevProps: Props,
		prevState: State,
		prevContext: any
	) -> ())?,
	componentWillUnmount: ((self: React_Component<Props, State>) -> ())?,
	componentDidCatch: ((
		self: React_Component<Props, State>,
		error: Error,
		info: {
			componentStack: string,
		}
	) -> ())?,
	getDerivedStateFromProps: ((props: Props, state: State) -> State?)?,
	getDerivedStateFromError: ((error: Error) -> State?)?,
	getSnapshotBeforeUpdate: ((props: Props, state: State) -> any)?,

	-- long tail of other stuff not modeled very well

	-- deviation START: these fields are mostly used internally including in ReactBaseClasses
	__refs: Object,
	__updater: any,
	-- deviation END

	-- deviation: this field is only used in relation to string refs, which we do not support
	-- refs: any,
	context: any,
	getChildContext: (self: React_Component<Props, State>) -> any,
	-- statics
	__componentName: string,
	displayName: string?,
	-- deviation: not in React flowtype, but is in definitelytyped and is used in ReactElement
	name: string?,
	childContextTypes: any?,
	contextTypes: any?,
	propTypes: any?,

	-- FIXME: this is a legacy Roact field and should be removed in React 18 Lua
	validateProps: ((Props) -> (boolean, string?))?,

	-- We don't add a type for `defaultProps` so that its type may be entirely
	-- inferred when we diff the type for `defaultProps` with `Props`. Otherwise
	-- the user would need to define a type (which would be redundant) to override
	-- the type we provide here in the base class.
	-- deviation: Luau doesn't do the inference above
	defaultProps: Props?,
	-- deviation: class export allows assigning additional custom instance fields
	[string]: any,
}

-- deviation: Lua doesn't allow fields on functions, and we haven't implemented callable tables as "function" components
export type React_StatelessFunctionalComponent<Props> = (props: Props, context: any) -> React_Node
export type React_ComponentType<Config> = React_Component<Config, any>

export type React_ElementType = string | React_Component<any, any>

-- This was reverse engineered from usage, no specific flowtype or TS artifact
export type React_ElementProps<ElementType> = {
	ref: React_Ref<ElementType>?,
	key: React_Key?,
	__source: Source?,
	children: any?,
}

-- deviation: this is a built-in flow type, and very complex. we fudge this with `any`
-- type ElementRef<
--   C extends keyof JSX.IntrinsicElements
--   | React.ForwardRefExoticComponent<any>
--   | (new (props: any) -> React.Component<any, {}, any>)
--   | ((props: any, context?: any) -> ReactElement | null)
--   > = "ref" extends keyof ComponentPropsWithRef<C>
--     ? NonNullable<ComponentPropsWithRef<C>["ref"]> extends Ref<infer Instance>
--       ? Instance
--       : never
--     : never

-- TODO: Not sure how to model this, upstream: https://github.com/facebook/flow/blob/main/tests/react_instance/class.js#L10
-- FIXME Luau: if I make this Object, we run into normalization issues: '{| current: React_ElementRef<any>? |}' could not be converted into '(((?) -> any) | {| current: ? |})?
export type React_ElementRef<C> = C

export type React_Ref<ElementType> =
	{ current: React_ElementRef<ElementType> | nil }
	| ((React_ElementRef<ElementType> | nil) -> ())
-- deviation: we don't support string refs, and this is unsound flowtype when used with ref param of useImperativeHandle
-- | string

export type React_Context<T> = {
	Provider: React_ComponentType<{ value: T, children: React_Node? }>,
	Consumer: React_ComponentType<{ children: (value: T) -> React_Node? }>,
}

-- TODO: declared as an opaque type in flowtype: https://github.com/facebook/flow/blob/422821fd42c09c3ef609c60516fe754b601ea205/lib/react.js#L182
export type React_Portal = any
export type React_Key = string | number

return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062da</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDD72E316CCB746F9A828E52C872E2246">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">formatProdErrorMessage</string>
								<string name="ScriptGuid">{53BC2FD2-83F7-4BD2-AED3-44B81AFCDBEB}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/75955bf1d7ff6c2c1f4052f4a84dd2ce6944c62e/packages/shared/formatProdErrorMessage.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 ]]

-- Do not require this module directly! Use normal `invariant` calls with
-- template literal strings. The messages will be replaced with error codes
-- during build.

local HttpService = game:GetService("HttpService")

local function formatProdErrorMessage(code, ...)
	local url = "https://reactjs.org/docs/error-decoder.html?invariant=" .. tostring(code)
	local argsLength = select("#", ...)
	for i = 1, argsLength, 1 do
		-- deviation: UrlEncode should be equivalent to encodeURIComponent
		url = url .. "&args[]=" .. HttpService:UrlEncode(select(i, ...))
	end
	return string.format(
		"Minified React error #%d; visit %s for the full message or "
			.. "use the non-minified dev environment for full errors and additional "
			.. "helpful warnings.",
		code,
		url
	)
end

return formatProdErrorMessage
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062db</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE4FA3D87E9394BB88B9A2151BC73C0E2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">getComponentName</string>
								<string name="ScriptGuid">{DE193524-9F65-439D-8750-62D1CFB8E5F7}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/a774502e0ff2a82e3c0a3102534dbc3f1406e5ea/packages/shared/getComponentName.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]
type Function = (...any) -> ...any
local console = require(script.Parent.console)

-- deviation: inline this typedef to avoid upstream's circular dependency
type LazyComponent<T, P> = {
	["$$typeof"]: number,
	_payload: P,
	_init: (payload: P) -> T,
}

local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local ReactTypes = require(script.Parent.ReactTypes)
type ReactContext<T> = ReactTypes.ReactContext<T>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>

local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

local function getWrappedName(outerType: any, innerType: any, wrapperName: string): string
	-- deviation: Account for indexing into function
	local functionName = "<function>"
	if typeof(innerType) == "table" then
		functionName = innerType.displayName or innerType.name or ""
	end
	return outerType.displayName
		or (functionName ~= "" and string.format("%s(%s)", wrapperName, functionName) or wrapperName)
end

local function getContextName(type: ReactContext<any>): string
	return type.displayName or "Context"
end

local function getComponentName(type: any): string | nil
	if type == nil then
		-- Host root, text node or just invalid type.
		return nil
	end
	local typeofType = typeof(type)

	if _G.__DEV__ then
		if typeofType == "table" and typeof(type.tag) == "number" then
			console.warn(
				"Received an unexpected object in getComponentName(). "
					.. "This is likely a bug in React. Please file an issue."
			)
		end
	end

	if typeofType == "function" then
		-- deviation: we can't deref functions in Lua, so get the name of the function and move logic to table section
		-- FIXME Luau: this line gets a bunch of bizarre errors in strict mode
		local name = debug.info((type :: any) :: Function, "n")
		-- deviation:when name = (null) we want it to be treated as nil, not as an empty (truthy) string
		if name and string.len(name) > 0 then
			return name
		else
			return nil
		end
	end

	if typeofType == "string" then
		return (type :: any) :: string
	end

	if type == REACT_FRAGMENT_TYPE then
		return "Fragment"
	elseif type == REACT_PORTAL_TYPE then
		return "Portal"
	elseif type == REACT_PROFILER_TYPE then
		return "Profiler"
	elseif type == REACT_STRICT_MODE_TYPE then
		return "StrictMode"
	elseif type == REACT_SUSPENSE_TYPE then
		return "Suspense"
	elseif type == REACT_SUSPENSE_LIST_TYPE then
		return "SuspenseList"
	end

	if typeofType == "table" then
		local typeProp = type["$$typeof"]
		if typeProp == REACT_CONTEXT_TYPE then
			local context: ReactContext<any> = type :: any
			return getContextName(context) .. ".Consumer"
		elseif typeProp == REACT_PROVIDER_TYPE then
			local provider: ReactProviderType<any> = type :: any
			return getContextName(provider._context) .. ".Provider"
		elseif typeProp == REACT_FORWARD_REF_TYPE then
			return getWrappedName(type, type.render, "ForwardRef")
		elseif typeProp == REACT_MEMO_TYPE then
			return getComponentName(type.type)
		elseif typeProp == REACT_BLOCK_TYPE then
			return getComponentName(type._render)
		elseif typeProp == REACT_LAZY_TYPE then
			local lazyComponent: LazyComponent<any, any> = type :: any
			local payload = lazyComponent._payload
			local init = lazyComponent._init

			-- performance: getComponentName won't throw, but init() might, extract it out to eliminate an anon function
			local ok, result = xpcall(init, describeError, payload)
			if ok then
				return getComponentName(result)
			else
				return nil
			end
		else
			-- deviation: Normally, the `typeofType == "function"` check would
			-- cover this case, but in Lua, class components are tables. We need
			-- to check for that here and use the name the component was
			-- assigned.
			if type.displayName then
				return type.displayName
			end
			if type.name then
				return type.name
			end
			-- NOTE: only use tostring() if its overridden to avoid "table: 0xabcd9012"
			local mt = getmetatable(type)
			if mt and rawget(mt, "__tostring") then
				return tostring(type)
			end
		end
	end

	return nil
end

return getComponentName
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062dc</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4191F88AE95143EDB3FDF7F126E6E6B7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">invariant</string>
								<string name="ScriptGuid">{F9F3B37B-3002-4765-BD29-EFB5B8F80BB1}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/42c3c967d1e4ca4731b47866f2090bc34caa086c/packages/shared/invariant.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
]]

--[[*
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
]]
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error

local function invariant(condition, format, ...)
	-- TODO: we should encapsulate all formatting compatibility here,
	-- rather than spreading workarounds throughout the codebase, eg this
	-- should print an array without the need for a table.concat on the consumer side
	if not condition then
		error(Error(string.format(format, ...)))
	end
end

return invariant
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062dd</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE8B25CB0B7A640418FF91453B0ED45F5">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">invokeGuardedCallbackImpl</string>
								<string name="ScriptGuid">{19DE5335-F80D-4453-85F4-1C088CD17BEC}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/shared/invokeGuardedCallbackImpl.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]
-- local invariant = require(script.Parent.invariant)
local describeError = require(script.Parent["ErrorHandling.roblox"]).describeError

-- deviation: with flow types stripped, it's easier to use varargs directly
local function invokeGuardedCallbackProd(reporter, name, func, context, ...)
	-- local funcArgs = Array.prototype.slice.call(arguments, 3)

	-- deviation: YOLO flag for disabling pcall
	local ok, result
	if not _G.__YOLO__ then
		-- deviation: Since functions in lua _explicitly_ accept 'self' as a
		-- first argument when they use it, it becomes incorrect for us to call
		-- a function with a nil "context", where context in this case is
		-- analogous to the implicit `self` that we get with a `:` call
		if context == nil then
			ok, result = xpcall(func, describeError, ...)
		else
			ok, result = xpcall(func, describeError, context, ...)
		end
	else
		ok = true
		if context == nil then
			func(...)
		else
			func(context, ...)
		end
	end

	if not ok then
		-- deviation: functions have no notion of "this"/"self", so we expect
		-- the first argument to be the reporter itself, in conjunction with
		-- deviations in `ReactErrorUtils`
		reporter.onError(result)
	end
end

local invokeGuardedCallbackImpl = invokeGuardedCallbackProd

if _G.__DEV__ then
	-- In DEV mode, we swap out invokeGuardedCallback for a special version
	-- that plays more nicely with the browser's DevTools. The idea is to preserve
	-- "Pause on exceptions" behavior. Because React wraps all user-provided
	-- functions in invokeGuardedCallback, and the production version of
	-- invokeGuardedCallback uses a try-catch, all user exceptions are treated
	-- like caught exceptions, and the DevTools won't pause unless the developer
	-- takes the extra step of enabling pause on caught exceptions. This is
	-- unintuitive, though, because even though React has caught the error, from
	-- the developer's perspective, the error is uncaught.
	--
	-- To preserve the expected "Pause on exceptions" behavior, we don't use a
	-- try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
	-- DOM node, and call the user-provided callback from inside an event handler
	-- for that fake event. If the callback throws, the error is "captured" using
	-- a global event handler. But because the error happens in a different
	-- event loop context, it does not interrupt the normal program flow.
	-- Effectively, this gives us try-catch behavior without actually using
	-- try-catch. Neat!
	-- Check that the browser supports the APIs we need to implement our special
	-- DEV version of invokeGuardedCallback

	-- deviation: `window` is not defined in our environment
	-- deviation: FIXME: should we define our own impl for invokeGuardedCallbackDev?
	--[[
	if typeof window ~= 'undefined' and typeof window.dispatchEvent == 'function' and typeof document ~= 'undefined' and typeof document.createEvent == 'function' then
		local fakeNode = document.createElement('react')

		invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
			-- If document doesn't exist we know for sure we will crash in this method
			-- when we call document.createEvent(). However this can cause confusing
			-- errors: https://github.com/facebookincubator/create-react-app/issues/3482
			-- So we preemptively throw with a better message instead.
			invariant(typeof document ~= 'undefined', 'The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.')
			local evt = document.createEvent('Event')
			local didCall = false; -- Keeps track of whether the user-provided callback threw an error. We
			-- set this to true at the beginning, then set it to false right after
			-- calling the function. If the function errors, `didError` will never be
			-- set to false. This strategy works even if the browser is flaky and
			-- fails to call our global error handler, because it doesn't rely on
			-- the error event at all.

			local didError = true; -- Keeps track of the value of window.event so that we can reset it
			-- during the callback to local user code access window.event in the
			-- browsers that support it.

			local windowEvent = window.event; -- Keeps track of the descriptor of window.event to restore it after event
			-- dispatching: https://github.com/facebook/react/issues/13688

			local windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event')

			function restoreAfterDispatch() {
				-- We immediately remove the callback from event listeners so that
				-- nested `invokeGuardedCallback` calls do not clash. Otherwise, a
				-- nested call would trigger the fake event handlers of any call higher
				-- in the stack.
				fakeNode.removeEventListener(evtType, callCallback, false); -- We check for window.hasOwnProperty('event') to prevent the
				-- window.event assignment in both IE <= 10 as they throw an error
				-- "Member not found" in strict mode, and in Firefox which does not
				-- support window.event.

				if typeof window.event ~= 'undefined' and window.hasOwnProperty('event') then
					window.event = windowEvent
				}
			} -- Create an event handler for our fake event. We will synchronously
			-- dispatch our fake event using `dispatchEvent`. Inside the handler, we
			-- call the user-provided callback.


			local funcArgs = Array.prototype.slice.call(arguments, 3)

			function callCallback() {
				didCall = true
				restoreAfterDispatch()
				func.apply(context, funcArgs)
				didError = false
			} -- Create a global error event handler. We use this to capture the value
			-- that was thrown. It's possible that this error handler will fire more
			-- than once; for example, if non-React code also calls `dispatchEvent`
			-- and a handler for that event throws. We should be resilient to most of
			-- those cases. Even if our error event handler fires more than once, the
			-- last error event is always used. If the callback actually does error,
			-- we know that the last error event is the correct one, because it's not
			-- possible for anything else to have happened in between our callback
			-- erroring and the code that follows the `dispatchEvent` call below. If
			-- the callback doesn't error, but the error event was fired, we know to
			-- ignore it because `didError` will be false, as described above.


			local error; -- Use this to track whether the error event is ever called.

			local didSetError = false
			local isCrossOriginError = false

			function handleWindowError(event) {
				error = event.error
				didSetError = true

				if error == nil and event.colno == 0 and event.lineno == 0 then
					isCrossOriginError = true
				}

				if event.defaultPrevented then
					-- Some other error handler has prevented default.
					-- Browsers silence the error report if this happens.
					-- We'll remember this to later decide whether to log it or not.
					if error ~= nil and typeof error == 'object' then
						try {
							error._suppressLogging = true
						} catch (inner) {-- Ignore.
						}
					}
				}
			} -- Create a fake event type.


			local evtType = `react-${function () {
				if name then
					return name
				}

				return 'invokeguardedcallback'
			}()}`; -- Attach our event handlers

			window.addEventListener('error', handleWindowError)
			fakeNode.addEventListener(evtType, callCallback, false); -- Synchronously dispatch our fake event. If the user-provided function
			-- errors, it will trigger our global error handler.

			evt.initEvent(evtType, false, false)
			fakeNode.dispatchEvent(evt)

			if windowEventDescriptor then
				Object.defineProperty(window, 'event', windowEventDescriptor)
			}

			if didCall and didError then
				if !didSetError then
					-- The callback errored, but the error event never fired.
					error = new Error('An error was thrown inside one of your components, but React ' + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.')
				} else if isCrossOriginError then
					error = new Error("A cross-origin error was thrown. React doesn't have access to " + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.')
				}

				this.onError(error)
			} -- Remove our event listeners


			window.removeEventListener('error', handleWindowError)

			if !didCall then
				-- Something went really wrong, and our event was not dispatched.
				-- https://github.com/facebook/react/issues/16734
				-- https://github.com/facebook/react/issues/16585
				-- Fall back to the production implementation.
				restoreAfterDispatch()
				return invokeGuardedCallbackProd.apply(this, arguments)
			}
		}
	}
]]
end

return invokeGuardedCallbackImpl
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062de</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF6C51DC7F315494681E53E0DBE6ECD30">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">isValidElementType</string>
								<string name="ScriptGuid">{B96C7669-C2C6-4AEA-8F8D-2564C3C778FB}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/b61174fb7b09580c1ec2a8f55e73204b706d2935/packages/shared/isValidElementType.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 ]]
local ReactSymbols = require(script.Parent.ReactSymbols)
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_PROFILER_TYPE = ReactSymbols.REACT_PROFILER_TYPE
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_DEBUG_TRACING_MODE_TYPE = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE
local REACT_STRICT_MODE_TYPE = ReactSymbols.REACT_STRICT_MODE_TYPE
local REACT_SUSPENSE_TYPE = ReactSymbols.REACT_SUSPENSE_TYPE
-- local REACT_SUSPENSE_LIST_TYPE = ReactSymbols.REACT_SUSPENSE_LIST_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE
local REACT_FUNDAMENTAL_TYPE = ReactSymbols.REACT_FUNDAMENTAL_TYPE
-- local REACT_SCOPE_TYPE = ReactSymbols.REACT_SCOPE_TYPE
local REACT_BLOCK_TYPE = ReactSymbols.REACT_BLOCK_TYPE
local REACT_SERVER_BLOCK_TYPE = ReactSymbols.REACT_SERVER_BLOCK_TYPE
local REACT_LEGACY_HIDDEN_TYPE = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE

-- local ReactFeatureFlags = require(script.Parent.ReactFeatureFlags)
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI

return function(type)
	local typeofType = typeof(type)
	if typeofType == "string" or typeofType == "function" then
		return true
	end

	-- NOTE: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).
	if
		type == REACT_FRAGMENT_TYPE
		or type == REACT_PROFILER_TYPE
		or type == REACT_DEBUG_TRACING_MODE_TYPE
		or type == REACT_STRICT_MODE_TYPE
		or type == REACT_SUSPENSE_TYPE
		or type == REACT_LEGACY_HIDDEN_TYPE
		-- performance: eliminate compares that will only be true in React 18
		-- or type == REACT_SUSPENSE_LIST_TYPE
		-- or (enableScopeAPI and type == REACT_SCOPE_TYPE)
	then
		return true
	end

	if typeofType == "table" then
		-- deviation: In React, component classes are of type 'function'; for
		-- us, they're tables with a special value on their metatable
		if type.isReactComponent then
			return true
		end

		if
			type["$$typeof"] == REACT_LAZY_TYPE
			or type["$$typeof"] == REACT_MEMO_TYPE
			or type["$$typeof"] == REACT_PROVIDER_TYPE
			or type["$$typeof"] == REACT_CONTEXT_TYPE
			or type["$$typeof"] == REACT_FORWARD_REF_TYPE
			or type["$$typeof"] == REACT_FUNDAMENTAL_TYPE
			or type["$$typeof"] == REACT_BLOCK_TYPE
			or type[1] == REACT_SERVER_BLOCK_TYPE
		then
			return true
		end
	end

	return false
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062df</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX3A1204BCD81447A6913B2326B2D49B6A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">objectIs</string>
								<string name="ScriptGuid">{8570966C-2223-4B58-8BDF-C4F54C2B47BE}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/6faf6f5eb1705eef39a1d762d6ee381930f36775/packages/shared/objectIs.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 ]]

--[[*
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 ]]
local function is(x: any, y: any): boolean
	return x == y and (x ~= 0 or 1 / x == 1 / y) or x ~= x and y ~= y -- eslint-disable-line no-self-compare
end

-- deviation: Object isn't a global in lua, so `Object.is` will never exist
local objectIs = is

return objectIs
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062e0</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDB5366E6D7FC421181251413CAC02759">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">shallowEqual</string>
								<string name="ScriptGuid">{5606BB48-1A5A-40B1-B7D9-3E5B7CE1EF7D}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/a9b035b0c2b8235405835beca0c4db2cc37f18d0/packages/shared/shallowEqual.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
]]
local is = require(script.Parent.objectIs)

--[[*
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
]]
local function shallowEqual(objA, objB)
	if is(objA, objB) then
		return true
	end

	if typeof(objA) ~= "table" or objA == nil or typeof(objB) ~= "table" or objB == nil then
		return false
	end

	-- deviation: `Object.keys` does not have an equivalent in Lua, so we
	-- iterate through each table instead
	for key, value in objA do
		if not is(objB[key], value) then
			return false
		end
	end

	for key, value in objB do
		if not is(objA[key], value) then
			return false
		end
	end

	return true
end

return shallowEqual
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed000062e1</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXAD524D24027543DEB549C84400B39816">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">React</string>
							<string name="ScriptGuid">{A31E4BF7-AFFE-40F2-BED8-B9D0BE57DD26}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react/src/index.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *]]

-- deviation: simulates `index.js` and exports React's public interface
local Packages = script.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local React = require(script.React)
-- deviation START: bindings support
export type Binding<T> = React.ReactBinding<T>
export type BindingUpdater<T> = React.ReactBindingUpdater<T>
-- deviation END

local ReactLazy = require(script.ReactLazy)
export type LazyComponent<T, P> = ReactLazy.LazyComponent<T, P>

local SharedModule = require(Packages.Shared)
export type StatelessFunctionalComponent<P> = SharedModule.React_StatelessFunctionalComponent<P>
-- deviation START: we use the definitely-typed version of this, which appears to work for flowtype in VirtualizedList, etc
export type ComponentType<P> = ComponentClass<P> | FC<P>
-- deviation END
export type AbstractComponent<Config, Instance> = SharedModule.React_AbstractComponent<Config, Instance>
export type ElementType = SharedModule.React_ElementType
export type Element<C> = SharedModule.React_Element<C>
export type Key = SharedModule.React_Key
export type Ref<ElementType> = SharedModule.React_Ref<ElementType>
export type Node = SharedModule.React_Node
export type Context<T> = SharedModule.ReactContext<T>
-- TODO: Portal
export type ElementProps<C> = SharedModule.React_ElementProps<C>
export type ElementConfig<T> = SharedModule.React_ElementConfig<T>
export type ElementRef<C> = SharedModule.React_ElementRef<C>
-- TODO: Config
-- TODO: ChildrenArray

-- deviation START: manual type exports since that's not free with 'return React'
export type ComponentClass<P> = SharedModule.React_ComponentType<P>
export type PureComponent<Props, State = nil> = React.PureComponent<Props, State>
-- deviation END

-- deviation START: definitelytyped typescript exports
export type ReactElement<Props = Object, ElementType = any> = SharedModule.ReactElement<Props, ElementType>
-- we don't include ReactText in ReactChild since roblox renderer doesn't support raw text nodes
export type ReactChild = SharedModule.ReactElement<any, string> | string | number
export type FC<P> = SharedModule.React_StatelessFunctionalComponent<P>
export type ReactNode = SharedModule.React_Node
-- deviation END

-- deviation START: export React types that are flowtype built-ins and used by VirtualizedList, etc
export type React_AbstractComponent<Props, Instance> = SharedModule.React_Component<Props, Instance>
export type React_Component<Props, State> = SharedModule.React_Component<Props, State>
export type React_ComponentType<P> = SharedModule.React_ComponentType<P>
export type React_Context<T> = SharedModule.React_Context<T>
export type React_Element<ElementType> = SharedModule.React_Element<ElementType>
export type React_ElementType = SharedModule.React_ElementType
export type React_Node = SharedModule.React_Node

-- deviation END

return React
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed0000630a</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX66F588358B0040B7BBA2C8D98831F6BE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">None.roblox</string>
								<string name="ScriptGuid">{1C63FD43-EC79-4FBC-8587-7AB0EB364C7C}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- code derived from https://github.com/Roblox/roact/blob/master/src/None.lua
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)

-- Roact uses `Object.assign` internally to assign new state values; the same
-- None value should give us the proper semantics. We can re-export this value
-- as React.None for easy use, and to mirror Roact.None in legacy Roact.
return LuauPolyfill.Object.None
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000630b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6F4C6438103A428C8DF7F04A98691FBD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">React</string>
								<string name="ScriptGuid">{84774CD1-32A4-40F3-A713-EC0E6DB7507E}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/56e9feead0f91075ba0a4f725c9e4e343bca1c67/packages/react/src/React.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *]]

local React = script.Parent
local Packages = React.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Object = LuauPolyfill.Object

local createMutableSource = require(React.ReactMutableSource)
local ReactSharedInternals = require(Packages.Shared).ReactSharedInternals
local ReactBaseClasses = require(React.ReactBaseClasses)
local ReactChildren = require(React.ReactChildren)
local ReactElementValidator = require(React.ReactElementValidator)
local ReactElement = require(React.ReactElement)
local ReactCreateRef = require(React.ReactCreateRef)
local ReactForwardRef = require(React.ReactForwardRef)
local ReactHooks = require(React.ReactHooks)
local ReactMemo = require(React.ReactMemo)
local ReactContext = require(React.ReactContext)
local ReactLazy = require(React.ReactLazy)
type LazyComponent<T, P> = ReactLazy.LazyComponent<T, P>

-- deviation: Bindings
local ReactBinding = require(React["ReactBinding.roblox"])
-- deviation: Re-export `None` marker
local ReactNone = require(React["None.roblox"])

local SharedModule = require(Packages.Shared)
local ReactSymbols = SharedModule.ReactSymbols

local shouldValidate = _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__
local ReactTypes = require(Packages.Shared)
export type React_StatelessFunctionalComponent<P> = ReactTypes.React_StatelessFunctionalComponent<P>
export type React_ComponentType<P> = ReactTypes.React_ComponentType<P>
type React_AbstractComponent<P, T> = ReactTypes.React_AbstractComponent<P, T>
export type React_ElementProps<ElementType> = ReactTypes.React_ElementProps<ElementType>
export type ReactElement<P = Object, T = any> = ReactTypes.ReactElement<P, T>
export type ReactContext<T> = ReactTypes.ReactContext<T>
export type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
export type React_Node = ReactTypes.React_Node
export type PureComponent<Props, State = nil> = ReactTypes.React_PureComponent<Props, State>
-- deviation START: bindings support
export type ReactBinding<T> = ReactTypes.ReactBinding<T>
export type ReactBindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>
-- deviation END

type createElementFn = <P, T>(
	type_: React_StatelessFunctionalComponent<P>
		| React_ComponentType<P>
		| React_AbstractComponent<P, T>
		| string
		| ReactContext<any>
		| ReactProviderType<any>
		| LazyComponent<T, P>,
	props: P?,
	...(React_Node | (...any) -> React_Node)
) -> ReactElement<P, T>

type cloneElementFn = <P, T>(element: ReactElement<P, T>, config: P?, ...React_Node) -> ReactElement<P, T>
-- FIXME Luau: these yield Cannot call non-function because the identical unions don't collapse
-- FIXME Luau: the next step is to add createElementFn here and work through issues, AFTER normalization and type packs work
local createElement = if shouldValidate
	then ReactElementValidator.createElementWithValidation :: createElementFn
	else ReactElement.createElement :: createElementFn
local cloneElement: cloneElementFn = if shouldValidate
	then ReactElementValidator.cloneElementWithValidation :: cloneElementFn
	else ReactElement.cloneElement :: cloneElementFn

return {
	Children = ReactChildren,
	createMutableSource = createMutableSource,
	createRef = ReactCreateRef.createRef,
	Component = ReactBaseClasses.Component,
	PureComponent = ReactBaseClasses.PureComponent,
	createContext = ReactContext.createContext,
	forwardRef = ReactForwardRef.forwardRef,
	lazy = ReactLazy.lazy,
	memo = ReactMemo.memo,
	useCallback = ReactHooks.useCallback,
	useContext = ReactHooks.useContext,
	useEffect = ReactHooks.useEffect,
	useImperativeHandle = ReactHooks.useImperativeHandle,
	useDebugValue = ReactHooks.useDebugValue,
	useLayoutEffect = ReactHooks.useLayoutEffect,
	useMemo = ReactHooks.useMemo,
	useMutableSource = ReactHooks.useMutableSource,
	useReducer = ReactHooks.useReducer,
	useRef = ReactHooks.useRef,
	-- deviation: bindings support
	useBinding = ReactHooks.useBinding,
	useState = ReactHooks.useState,
	Fragment = ReactSymbols.REACT_FRAGMENT_TYPE,
	Profiler = ReactSymbols.REACT_PROFILER_TYPE,
	StrictMode = ReactSymbols.REACT_STRICT_MODE_TYPE,
	unstable_DebugTracingMode = ReactSymbols.REACT_DEBUG_TRACING_MODE_TYPE,
	Suspense = ReactSymbols.REACT_SUSPENSE_TYPE,
	createElement = createElement,
	cloneElement = cloneElement,
	isValidElement = ReactElement.isValidElement,
	-- TODO: ReactVersion
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals,
	-- Deprecated behind disableCreateFactory
	-- TODO: createFactory,
	-- Concurrent Mode
	-- TODO: useTransition,
	-- TODO: startTransition,
	-- TODO: useDeferredValue,
	-- TODO: REACT_SUSPENSE_LIST_TYPE as SuspenseList,
	unstable_LegacyHidden = ReactSymbols.REACT_LEGACY_HIDDEN_TYPE,
	-- enableBlocksAPI
	-- TODO: block,
	-- enableFundamentalAPI
	-- TODO: createFundamental as unstable_createFundamental,
	-- enableScopeAPI
	-- TODO: REACT_SCOPE_TYPE as unstable_Scope,
	-- TODO: useOpaqueIdentifier as unstable_useOpaqueIdentifier,

	-- deviation START: bindings support
	createBinding = ReactBinding.create,
	joinBindings = ReactBinding.join,
	-- deviation END

	-- deviation: export the `None` placeholder for use with setState
	None = ReactNone,

	-- FIXME: These aren't supposed to be exposed, but they're needed by
	-- the renderer in order to update properly
	__subscribeToBinding = ReactBinding.subscribe,

	-- deviation: export Change, Event, and Tag from React
	Event = require(Packages.Shared).Event,
	Change = require(Packages.Shared).Change,
	Tag = require(Packages.Shared).Tag,

	-- deviation: used by error reporters to parse caught errors. React
	-- stringifies at its boundaries to maintain compatibility with
	-- ScriptContext signals that may ultimately catch them
	unstable_parseReactError = require(Packages.Shared).parseReactError,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000630c</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX86E4A182D5CB49758E240AF5687CF017">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactBaseClasses</string>
								<string name="ScriptGuid">{23C6EA6B-B70E-4C10-810C-416E43B6370C}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/0cf22a56a18790ef34c71bef14f64695c0498619/packages/react/src/ReactBaseClasses.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]
local __DEV__ = _G.__DEV__ :: boolean
local __COMPAT_WARNINGS__ = _G.__COMPAT_WARNINGS__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local SharedModule = require(Packages.Shared)
-- deviation START: we do boolean checks and error() like React 18 does to save functional call in hot path
-- local invariant = SharedModule.invariant
-- deviation END
type React_Component<Props, State = nil> = SharedModule.React_Component<Props, State>
local ReactNoopUpdateQueue = require(script.Parent.ReactNoopUpdateQueue)
local emptyObject = {}

if __DEV__ then
	Object.freeze(emptyObject)
end

-- deviation: Initialize state to a singleton that warns on access and
-- errors on assignment
local UninitializedState = require(Packages.Shared).UninitializedState

--[[*
 * Base class helpers for the updating state of a component.
]]
-- FIXME: Due to metatable inheritance, this field will be accessible and true
-- on class component _instances_ as well as class component definitions; this
-- is probably not correct
local componentClassPrototype = {
	isReactComponent = true,
}

-- deviation: logic to support old Roact lifecycle method names
-- FIXME: remove below table and function once we've formally stopped
-- supporting old Roact lifecycle method names.

-- FIXME Luau: have to annotate this function manually to suppress ReactBaseClasses.lua:55:3-13: (E001) TypeError: Expected to return 2 values, but 1 is returned here
local function trimPath(path: string): string
	-- TODO: The path splits files by . but file names can
	-- have . in them, so we use best guess heuristics to determine
	-- the file name breaks.
	-- Works for our codebase, but is pretty brittle.

	local pascalFile = string.match(path, "%.%u[%.%w]-$")
	if pascalFile then
		return string.gsub(pascalFile, "^%.", "")
	end

	return path
end

local function warnAboutExistingLifecycle(componentName, newName, existingName)
	console.warn(
		"%s already defined '%s', but it also defining the deprecated Roact method '%s'. %s should only implement one of these methods, preferably using the non-deprecated name.",
		componentName,
		existingName,
		newName,
		componentName
	)
end

local function warnAboutDeprecatedLifecycleName(componentName, newName, existingName)
	if __DEV__ and __COMPAT_WARNINGS__ then
		local path, linenum = debug.info(3, "sln")
		console.warn(
			"%s is using method '%s', which is no longer supported and should be updated to '%s'\nFile: %s:%s",
			componentName,
			newName,
			existingName,
			trimPath(path),
			tostring(linenum)
		)
	end
end

local lifecycleNames = {
	didMount = "componentDidMount",
	shouldUpdate = "shouldComponentUpdate",
	willUpdate = "UNSAFE_componentWillUpdate",
	didUpdate = "componentDidUpdate",
	willUnmount = "componentWillUnmount",
}

local function handleNewLifecycle(self, key, value)
	-- if we're defining a new lifecycle method using old naming convention
	if lifecycleNames[key] ~= nil then
		-- if the method we're defining was already defined under a different name
		if self[lifecycleNames[key]] ~= nil then
			warnAboutExistingLifecycle(self.__componentName, key, lifecycleNames[key])
		-- special case for willUpdate which can be defined properly with 2 different names
		elseif key == "willUpdate" and self["componentWillUpdate"] then
			warnAboutExistingLifecycle(self.__componentName, key, "UNSAFE_componentWillUpdate")
		-- otherwise if not previously defined, just warn about deprecated name
		else
			warnAboutDeprecatedLifecycleName(self.__componentName, key, lifecycleNames[key])
		end
		-- update key to proper name
		key = lifecycleNames[key]
	end
	rawset(self, key, value)
end

local componentClassMetatable = {
	__newindex = handleNewLifecycle,
	__index = componentClassPrototype,
	__tostring = function(self)
		return self.__componentName
	end,
}

-- deviation: Extend needs to be a table field for our top-level interface
type React_BaseComponent = React_Component<any, any> & {
	extend: (self: React_BaseComponent, name: string) -> React_Component<any, any>,
}

local Component = (
	setmetatable({ __componentName = "Component" }, componentClassMetatable) :: any
) :: React_BaseComponent

-- deviation: Lua doesn't expose inheritance in a class-syntax way
--[[
  A method called by consumers of Roact to create a new component class.
  Components can not be extended beyond this point, with the exception of
  PureComponent.
]]

-- performance: pool size tuned for benchmarks
local InstancePoolSize = if not _G.__TESTEZ_RUNNING_TEST__ then 900 else 0
local InstancePoolIndex = 1
local InstancePool = table.create(InstancePoolSize)
for i = 1, InstancePoolSize do
	table.insert(InstancePool, {
		-- pre-initialize instance fields with known static values
		props = nil,
		context = nil,
		state = UninitializedState,
		__refs = emptyObject,
		__updater = ReactNoopUpdateQueue,
	})
end

local function setStateInInit(componentInstance: React_Component<any, any>, statePayload: any, callback: nil): ()
	if __DEV__ and (callback :: any) ~= nil then
		console.warn(
			"Received a `callback` argument to `setState` during initialization of "
				.. '"%s". The callback behavior is not supported when using `setState` '
				.. "in `init`.\n\nConsider defining similar behavior in a "
				.. "`compontentDidMount` method instead.",
			componentInstance.__componentName
		)
	end

	-- Use the same warning as in the "real" `setState` below
	local typeStatePayload = statePayload and type(statePayload)
	if statePayload == nil or (typeStatePayload ~= "table" and typeStatePayload ~= "function") then
		error(
			"setState(...): takes an object of state variables to update or a "
				.. "function which returns an object of state variables."
		)
	end
	local prevState = componentInstance.state
	local partialState
	if typeStatePayload == "function" then
		-- Updater function
		partialState = statePayload(prevState, componentInstance.props)
	else
		-- Partial state object
		partialState = statePayload
	end
	-- TODO: can't use table.clone optimization here: invalid argument #1 to 'clone' (table has a protected metatable)
	-- local newState = if prevState then table.clone(prevState) else {}
	componentInstance.state = Object.assign({}, prevState, partialState)
end

function Component:extend(name): React_Component<any, any>
	-- NOTE: legacy Roact will accept nil here and default to empty string
	-- TODO: if name in "" in ReactComponentStack frame, we should try and get the variable name it was assigned to
	if name == nil then
		if __COMPAT_WARNINGS__ then
			console.warn(
				"Component:extend() accepting no arguments is deprecated, and will "
					.. "not be supported in a future version of Roact. Please provide an explicit name."
			)
		end
		name = ""
	elseif type(name) ~= "string" then
		error("Component class name must be a string")
	end

	-- performance? do table literal in one shot instead a field at a time in a pairs() loop
	local class = {
		__componentName = name,
		setState = self.setState,
		forceUpdate = self.forceUpdate,
		init = nil, -- NOTE: required to make Luau analyze happy, should be removed by bytecode compiler
	}
	-- for key, value in self do
	--   -- Roact opts to make consumers use composition over inheritance, which
	--   -- lines up with React.
	--   -- https://reactjs.org/docs/composition-vs-inheritance.html
	--   if key ~= "extend" then
	--     class[key] = value
	--   end
	-- end

	class.__index = class
	-- class.__componentName = name

	function class.__ctor<P>(props: P, context, updater): React_Component<P, any>
		local instance
		-- performance: use a pooled object
		if InstancePoolIndex <= InstancePoolSize then
			instance = InstancePool[InstancePoolIndex]
			-- fill in the dynamic fields
			-- FIXME Luau: TypeError: Type 'P' could not be converted into 'nil'
			instance.props = props :: any
			instance.context = context
			-- release the premade object from the pool -- we aren't recycling objects right now
			InstancePool[InstancePoolIndex] = nil
			InstancePoolIndex += 1
		else
			-- NOTE: uncomment to tune pool size for lua-apps
			-- print("!!!!! hit ReactBaseClass instance pool limit")
			instance = {
				-- FIXME Luau: TypeError: Type 'P' could not be converted into 'nil'
				props = props :: any,
				context = context,
				state = UninitializedState,
				__refs = emptyObject,
				__updater = updater or ReactNoopUpdateQueue,
			}

			-- instance.props = props
			-- instance.context = context
			-- deviation: Initialize state to a singleton that warns on attempts
			-- to access this pseudo-uninitialized state and errors on attempts to directly mutate
			-- state.
			-- instance.state = UninitializedState
			-- If a component has string refs, we will assign a different object later.
			-- deviation: Uses __refs instead of refs to avoid conflicts
			-- instance.refs = emptyObject
			-- instance.__refs = emptyObject
			-- We initialize the default updater but the real one gets injected by the
			-- renderer.
			-- instance.__updater = updater or ReactNoopUpdateQueue
		end

		-- TODO: We should consider using a more idiomatic Lua approach for
		-- warning/blocking lifecycle calls during initialization. For now,
		-- ReactNoopUpdateQueue accomplishes this, but we might be able to be more
		-- thorough if we use a dummy metamethod that warns precisely on all sorts
		-- of misbehavior
		instance = setmetatable(instance, class)

		-- performance: only do typeof if it's non-nil to begin with
		if class.init and type(class.init) == "function" then
			-- deviation: Override setState to allow it to be used in init.
			-- This maintains legacy Roact behavior and allows more consistent
			-- adherance to the "never assign directly to state" rule
			instance.setState = setStateInInit

			class.init(instance, props, context)

			-- deviation: Unbind specialized version of setState used in init
			instance.setState = nil :: any
		end

		return (instance :: any) :: React_Component<P, any>
	end

	setmetatable(class, getmetatable(self :: any))

	return (class :: any) :: React_Component<any, any>
end

--[[*
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `self.state` as immutable.
 *
 * There is no guarantee that `self.state` will be immediately updated, so
 * accessing `self.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from self.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to self.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 ]]
function Component:setState(partialState, callback)
	if partialState ~= nil and type(partialState) ~= "table" and type(partialState) ~= "function" then
		error(
			"setState(...): takes an object of state variables to update or a "
				.. "function which returns an object of state variables."
		)
	end
	self.__updater.enqueueSetState(self, partialState, callback, "setState")
end

--[[*
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 ]]

function Component:forceUpdate(callback)
	self.__updater.enqueueForceUpdate(self, callback, "forceUpdate")
end
--[[*
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 ]]

if __DEV__ then
	-- FIXME Luau: need CLI-53569 to remove the any cast
	local deprecatedAPIs = {
		isMounted = {
			"isMounted",
			"Instead, make sure to clean up subscriptions and pending requests in "
				.. "componentWillUnmount to prevent memory leaks.",
		},
		replaceState = {
			"replaceState",
			"Refactor your code to use setState instead (see " .. "https://github.com/facebook/react/issues/3236).",
		},
	} :: any

	local defineDeprecationWarning = function(methodName, info)
		(Component :: any)[methodName] = function()
			console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[1], info[2])
			return nil
		end
	end

	for fnName, _ in deprecatedAPIs do
		if deprecatedAPIs[fnName] ~= nil then
			defineDeprecationWarning(fnName, deprecatedAPIs[fnName])
		end
	end
end

--[[*
 * Convenience component with default shallow equality check for sCU.
 ]]
-- deviation START: work within the `extend` framework defined above to emulate JS's
-- class inheritance

-- FIXME Luau: this is so we get *some* type checking despite the FIXME Luau above
local PureComponent = Component:extend("PureComponent") :: React_BaseComponent;

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
-- FIXME Luau: this is so we get *some* type checking despite the FIXME Luau above
(PureComponent :: any).extend = Component.extend

-- NOTE: We copy members directly from the Component prototype above; we
-- don't need to redefine the constructor or do dummy function trickery to apply
-- it without jumping around
-- performance? inline (duplicate) explicit assignments to avoid loop overhead in hot path
-- Object.assign(pureComponentClassPrototype, componentClassPrototype)
local pureComponentClassPrototype = {
	isReactComponent = true,
	isPureReactComponent = true,
}

-- NOTE: FIXME: we should clean this up and align the implementations of
-- Component and PureComponent more clearly and explicitly
setmetatable(PureComponent, {
	__newindex = handleNewLifecycle,
	__index = pureComponentClassPrototype,
	__tostring = function(self)
		return self.__componentName
	end,
})
-- deviation END

return {
	Component = Component,
	PureComponent = PureComponent :: typeof(Component),
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000630d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX445B15CC08CB440CA3C7C659A80B5150">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactBinding.roblox</string>
								<string name="ScriptGuid">{895DBA41-23D3-486C-93F2-FCB982AE9C9B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

local Packages = script.Parent.Parent

local LuauPolyfill = require(Packages.LuauPolyfill)
local ReactSymbols = require(Packages.Shared).ReactSymbols

local ReactTypes = require(Packages.Shared)
type Binding<T> = ReactTypes.ReactBinding<T>
type BindingUpdater<T> = ReactTypes.ReactBindingUpdater<T>

local Symbol = LuauPolyfill.Symbol
local createSignal = require(script.Parent["createSignal.roblox"])

local BindingImpl = Symbol("BindingImpl")

type BindingInternal<T> = {
	["$$typeof"]: typeof(ReactSymbols.REACT_BINDING_TYPE),
	value: T,

	getValue: (BindingInternal<T>) -> T,
	-- FIXME Luau: can't define recursive types with different parameters
	map: <U>(BindingInternal<T>, (T) -> U) -> any,

	update: (T) -> (),
	subscribe: ((T) -> ()) -> (() -> ()),
}

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype.getValue<T>(binding: BindingInternal<T>): T
	return BindingInternalApi.getValue(binding)
end

function bindingPrototype.map<T, U>(binding: BindingInternal<T>, predicate: (T) -> U): Binding<U>
	return BindingInternalApi.map(binding, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update<T>(binding: any, newValue: T)
	return (binding[BindingImpl] :: BindingInternal<T>).update(newValue)
end

function BindingInternalApi.subscribe<T>(binding: any, callback: (T) -> ())
	return (binding[BindingImpl] :: BindingInternal<T>).subscribe(callback)
end

function BindingInternalApi.getValue<T>(binding: any): T
	return (binding[BindingImpl] :: BindingInternal<T>):getValue()
end

function BindingInternalApi.create<T>(initialValue: T): (Binding<T>, BindingUpdater<T>)
	local subscribe, fire = createSignal()
	local impl = {
		value = initialValue,
		subscribe = subscribe,
	}

	function impl.update(newValue: T)
		impl.value = newValue
		fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	local source
	if _G.__DEV__ then
		-- TODO: LUAFDN-619 - improve debug stacktraces for bindings
		source = debug.traceback("Binding created at:", 3)
	end

	return (setmetatable({
		["$$typeof"] = ReactSymbols.REACT_BINDING_TYPE,
		[BindingImpl] = impl,
		_source = source,
	}, BindingPublicMeta) :: any) :: Binding<T>,
		impl.update
end

function BindingInternalApi.map<T, U>(upstreamBinding: BindingInternal<T>, predicate: (T) -> U): Binding<U>
	if _G.__DEV__ then
		-- TODO: More informative error messages here
		assert(
			typeof(upstreamBinding) == "table" and upstreamBinding["$$typeof"] == ReactSymbols.REACT_BINDING_TYPE,
			"Expected `self` to be a binding"
		)
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	local source
	if _G.__DEV__ then
		-- TODO: LUAFDN-619 - improve debug stacktraces for bindings
		source = debug.traceback("Mapped binding created at:", 3)
	end

	return (
		setmetatable({
			["$$typeof"] = ReactSymbols.REACT_BINDING_TYPE,
			[BindingImpl] = impl,
			_source = source,
		}, BindingPublicMeta) :: any
	) :: Binding<U>
end

-- The `join` API is used statically, so the input will be a table with values
-- typed as the public Binding type
function BindingInternalApi.join<T>(upstreamBindings: { [string | number]: Binding<any> }): Binding<T>
	if _G.__DEV__ then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in upstreamBindings do
			if typeof(value) ~= "table" or (value :: any)["$$typeof"] ~= ReactSymbols.REACT_BINDING_TYPE then
				local message = ("Expected arg #1 to contain only bindings, but key %q had a non-binding value"):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		-- FIXME Luau: needs CLI-56711 resolved to eliminate ipairs()
		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		-- FIXME: type refinements
		local disconnects: any = {}

		for key, upstream in upstreamBindings do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in disconnects do
				disconnect()
			end

			disconnects = nil
		end
	end

	function impl.update(newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	local source
	if _G.__DEV__ then
		-- TODO: LUAFDN-619 - improve debug stacktraces for bindings
		source = debug.traceback("Joined binding created at:", 2)
	end

	return (
		setmetatable({
			["$$typeof"] = ReactSymbols.REACT_BINDING_TYPE,
			[BindingImpl] = impl,
			_source = source,
		}, BindingPublicMeta) :: any
	) :: Binding<T>
end

return BindingInternalApi
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000630e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC596B7368A484DB499C9B847A87F856C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactChildren</string>
								<string name="ScriptGuid">{2B931AF1-459A-4E4E-B5F2-B13CB9068A5B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/7516bdfce3f0f8c675494b5c5d0e7ae441bef1d9/packages/react/src/ReactChildren.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
type React_Node = ReactTypes.React_Node
type ReactElement<P, T> = ReactTypes.ReactElement<P, T>

local invariant = require(Packages.Shared).invariant

local ReactSymbols = require(Packages.Shared).ReactSymbols
local getIteratorFn = ReactSymbols.getIteratorFn
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local REACT_PORTAL_TYPE = ReactSymbols.REACT_PORTAL_TYPE

local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
-- local console = LuauPolyfill.console
type Array<T> = LuauPolyfill.Array<T>
type Object = LuauPolyfill.Object

local ReactElement = require(script.Parent.ReactElement)
local isValidElement = ReactElement.isValidElement
local cloneAndReplaceKey = ReactElement.cloneAndReplaceKey

local SEPARATOR = "."
local SUBSEPARATOR = ":"

-- --[[*
--  * Escape and wrap key so it is safe to use as a reactid
--  *
--  * @param {string} key to be escaped.
--  * @return {string} the escaped key.
--  ]]
-- deviation: use gsub instead of RegEx
local function escape(key: string): string
	local escapedString = string.gsub(key, "=", "=0")
	escapedString = string.gsub(escapedString, ":", "=2")
	return "$" .. escapedString
end

-- --[[*
--  * TODO: Test that a single child and an array with one item have the same key
--  * pattern.
--  ]]

-- deviation: There is currently no good way to warn about maps
-- local didWarnAboutMaps = false

-- local userProvidedKeyEscapeRegex = '/\\/+/g'
local function escapeUserProvidedKey(text: string): string
	-- deviation: just return the original string
	-- return text.replace(userProvidedKeyEscapeRegex, '$&/')
	return text
end

-- --[[*
--  * Generate a key string that identifies a element within a set.
--  *
--  * @param {*} element A element that could contain a manual key.
--  * @param {number} index Index that is used if a manual key is not provided.
--  * @return {string}
--  ]]
local function getElementKey(element: any, index: number): string
	-- Do some typechecking here since we call this blindly. We want to ensure
	-- that we don't block potential future ES APIs.
	if typeof(element) == "table" and element ~= nil and element.key ~= nil then
		-- Explicit key
		return escape(tostring(element.key))
	end
	-- Implicit key determined by the index in the set
	-- deviation: unsupported radix arg in tostring(number)
	-- return index.toString(36)
	return tostring(index)
end

local function mapIntoArray(
	children: ReactNodeList?,
	array: Array<React_Node>,
	escapedPrefix: string,
	nameSoFar: string,
	callback: (React_Node?) -> ReactNodeList?
): number
	local type = typeof(children)

	--[[
		ROBLOX DEVIATION: userdata type corresponds to React.None, which is perceived as nil. All
		userdata is treated as nil when passed as a child.
	]]
	if type == "nil" or type == "boolean" or type == "userdata" then
		-- All of the above are perceived as nil.
		children = nil
	end

	local invokeCallback = false

	if children == nil then
		invokeCallback = true
	else
		if type == "string" or type == "number" then
			invokeCallback = true
		elseif type == "table" then
			local childrenType = (children :: any)["$$typeof"]
			if childrenType == REACT_ELEMENT_TYPE or childrenType == REACT_PORTAL_TYPE then
				invokeCallback = true
			end
		end
	end

	if invokeCallback then
		local child = children
		local mappedChild = callback(child)
		-- If it's the only child, treat the name as if it was wrapped in an array
		-- so that it's consistent if the number of children grows:
		local childKey = if nameSoFar == "" then SEPARATOR .. getElementKey(child, 1) else nameSoFar
		if Array.isArray(mappedChild) then
			local escapedChildKey = ""
			if childKey ~= nil then
				escapedChildKey = escapeUserProvidedKey(childKey) .. "/"
			end
			mapIntoArray(mappedChild, array, escapedChildKey, "", function(c)
				return c
			end)
		elseif mappedChild ~= nil then
			if isValidElement(mappedChild :: any) then
				local mappedChildKey = (mappedChild :: ReactElement<Object, any>).key
				mappedChild = cloneAndReplaceKey(
					mappedChild :: ReactElement<Object, any>,
					-- Keep both the (mapped) and old keys if they differ, just as
					-- traverseAllChildren used to do for objects as children
					escapedPrefix
						-- $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
						.. (
							if mappedChildKey
									and (not child or (child :: ReactElement<Object, any>).key ~= mappedChildKey)
								-- $FlowFixMe Flow incorrectly thinks existing element's key can be a number
								then escapeUserProvidedKey(tostring(mappedChildKey)) .. "/"
								else ""
						)
						.. childKey
				)
			end
			table.insert(array, mappedChild)
		end
		return 1
	end

	local child
	local nextName
	local subtreeCount = 0 -- Count of children found in the current subtree.
	local nextNamePrefix = if nameSoFar == "" then SEPARATOR else nameSoFar .. SUBSEPARATOR

	if Array.isArray(children) then
		-- FIXME: Luau doesn't recognize this as non-nil without the `or {}`
		for i = 1, #(children :: Array<React_Node>) do
			child = (children :: Array<React_Node>)[i]
			nextName = nextNamePrefix .. getElementKey(child, i)
			subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback)
		end
	else
		local iteratorFn = getIteratorFn(children)
		if typeof(iteratorFn) == "function" then
			local iterableChildren: Object & {
				entries: any,
			} = children :: any

			-- deviation: No equivalent for checking if iterableChildren is a Map
			-- if _G.__DEV__ then
			-- 	-- Warn about using Maps as children
			-- 	if iteratorFn == iterableChildren.entries then
			-- 		if not didWarnAboutMaps then
			-- 			console.warn(
			-- 				"Using Maps as children is not supported. "
			-- 					.. "Use an array of keyed ReactElements instead."
			-- 			)
			-- 		end
			-- 		didWarnAboutMaps = true
			-- 	end
			-- end

			local iterator = iteratorFn(iterableChildren)
			local step
			local ii = 1
			step = iterator.next()
			while not step.done do
				child = step.value
				nextName = nextNamePrefix .. getElementKey(child, ii)
				ii += 1
				subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback)
				step = iterator.next()
			end
			--[[ DEVIATION: this condition will never be met with Roact iterator logic.
				getIteratorFn will always return a function when "children" is a table
			]]
			-- elseif type == 'table' then
			--   local childrenString = '' .. tostring(children)
			--   invariant(
			--     false,
			--     'Objects are not valid as a React child (found: %s). ' ..
			--       'If you meant to render a collection of children, use an array ' ..
			--       'instead.',
			--        if childrenString == '[object Object]'
			--          then 'object with keys {' .. Object.keys(children :: any).join(', ') .. '}'
			--          else childrenString
			--   )
		end
	end

	return subtreeCount
end

type MapFunc = (child: React_Node?, index: number) -> ReactNodeList?

--[[
	* Maps children that are typically specified as `props.children`.
	*
	* See https://reactjs.org/docs/react-api.html#reactchildrenmap
	*
	* The provided mapFunction(child, index) will be called for each
	* leaf child.
	*
	* @param {?*} children Children tree container.
	* @param {function(*, int)} func The map function.
	* @param {*} context Context for mapFunction.
	* @return {object} Object containing the ordered map of results.
]]
local function mapChildren(children: ReactNodeList?, func: MapFunc, context: any): Array<React_Node>?
	if children == nil then
		return nil
	end
	local result = {}
	local count = 1
	mapIntoArray(children, result, "", "", function(child)
		-- deviation: don't use context argument
		local mapFuncResult = func(child, count)
		count += 1
		return mapFuncResult
	end)
	return result
end

-- --[[*
--  * Count the number of children that are typically specified as
--  * `props.children`.
--  *
--  * See https://reactjs.org/docs/react-api.html#reactchildrencount
--  *
--  * @param {?*} children Children tree container.
--  * @return {number} The number of children.
--  ]]
local function countChildren(children: ReactNodeList?): number
	local n = 0
	mapChildren(children, function()
		n += 1
		-- Don't return anything
		return
	end)
	return n
end

type ForEachFunc = (child: React_Node?, index: number) -> ()

-- --[[*
--  * Iterates through children that are typically specified as `props.children`.
--  *
--  * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
--  *
--  * The provided forEachFunc(child, index) will be called for each
--  * leaf child.
--  *
--  * @param {?*} children Children tree container.
--  * @param {function(*, int)} forEachFunc
--  * @param {*} forEachContext Context for forEachContext.
--  ]]
local function forEachChildren(children: ReactNodeList?, forEachFunc: ForEachFunc, forEachContext: any)
	mapChildren(children, function(...)
		-- deviation: Don't use javascript apply
		forEachFunc(...)
		-- Don't return anything.
		return
	end, forEachContext)
end

-- --[[*
--  * Flatten a children object (typically specified as `props.children`) and
--  * return an array with appropriately re-keyed children.
--  *
--  * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
--  ]]
local function toArray(children: ReactNodeList?): Array<React_Node>
	return mapChildren(children, function(child)
		return child
	end) or {}
end

--[[*
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://reactjs.org/docs/react-api.html#reactchildrenonly
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
]]
-- deviation START: we skip generics here, because we can't explicitly constrain them. no annotation works as passthrough.
local function onlyChild(children)
	-- deviation END
	invariant(isValidElement(children), "React.Children.only expected to receive a single React element child.")
	return children
end

return {
	forEach = forEachChildren,
	map = mapChildren,
	count = countChildren,
	only = onlyChild,
	toArray = toArray,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000630f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX16F13AA355B8453D91B3DC5585A991BC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactContext</string>
								<string name="ScriptGuid">{9B71C9D1-7793-4B78-A313-00B4FE5B2BE0}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/7516bdfce3f0f8c675494b5c5d0e7ae441bef1d9/packages/react/src/ReactContext.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
]]
local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local Shared = require(Packages.Shared)
local console = Shared.console

local ReactSymbols = require(Packages.Shared).ReactSymbols
local REACT_PROVIDER_TYPE = ReactSymbols.REACT_PROVIDER_TYPE
local REACT_CONTEXT_TYPE = ReactSymbols.REACT_CONTEXT_TYPE
type ReactContext<T> = Shared.ReactContext<T>
type ReactProviderType<T> = Shared.ReactProviderType<T>

local exports = {}

exports.createContext = function<T>(defaultValue: T, calculateChangedBits: ((a: T, b: T) -> number)?): ReactContext<T>
	local context: ReactContext<any> = {
		["$$typeof"] = REACT_CONTEXT_TYPE,
		_calculateChangedBits = calculateChangedBits,
		-- As a workaround to support multiple concurrent renderers, we categorize
		-- some renderers as primary and others as secondary. We only expect
		-- there to be two concurrent renderers at most: React Native (primary) and
		-- Fabric (secondary); React DOM (primary) and React ART (secondary).
		-- Secondary renderers store their context values on separate fields.
		_currentValue = defaultValue,
		_currentValue2 = defaultValue,
		-- Used to track how many concurrent renderers this context currently
		-- supports within in a single renderer. Such as parallel server rendering.
		_threadCount = 0,
		-- These are circular
		Provider = (nil :: any) :: ReactProviderType<T>,
		Consumer = (nil :: any) :: ReactContext<T>,
		-- deviation: tables declared this way are considered sealed, so define we
		-- displayName as nil for it to be populated later
		displayName = nil,
		-- deviation: have to inline these optional fields to make Luau happy
		_currentRenderer = nil,
		_currentRenderer2 = nil,
	}
	context.Provider = {
		["$$typeof"] = REACT_PROVIDER_TYPE,
		_context = context,
	}

	local hasWarnedAboutDisplayNameOnConsumer = false

	if _G.__DEV__ then
		-- A separate object, but proxies back to the original context object for
		-- backwards compatibility. It has a different $$typeof, so we can properly
		-- warn for the incorrect usage of Context as a Consumer.
		local Consumer = {
			["$$typeof"] = REACT_CONTEXT_TYPE,
			_context = context,
			_calculateChangedBits = context._calculateChangedBits,
		}

		setmetatable(Consumer, {
			__index = function(self, key)
				-- deviation: don't implement already-deprecated things like Consumer.Provider, Consumer.Consumer, etc
				if key == "_currentValue" then
					return context._currentValue
				elseif key == "_currentValue2" then
					return context._currentValue2
				elseif key == "_threadCount" then
					return context._threadCount
				elseif key == "displayName" then
					return context.displayName
				end
				return nil
			end,
			__newindex = function(self, key, value)
				if key == "_currentValue" then
					context._currentValue = value
				elseif key == "_currentValue2" then
					context._currentValue2 = value
				elseif key == "_threadCount" then
					context._threadCount = value
				elseif key == "displayName" then
					if not hasWarnedAboutDisplayNameOnConsumer then
						console.warn(
							"Setting `displayName` on Context.Consumer has no effect. "
								.. "You should set it directly on the context with Context.displayName = "
								.. value
								.. "."
						)
						hasWarnedAboutDisplayNameOnConsumer = true
					end
				end
			end,
		})

		context.Consumer = (Consumer :: any) :: ReactContext<any>
	else
		context.Consumer = context
	end

	if _G.__DEV__ then
		context._currentRenderer = nil
		context._currentRenderer2 = nil
	end

	return context
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006310</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXE56131CAB7C646839F5B19273EA86F33">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactCreateRef</string>
								<string name="ScriptGuid">{06F52837-3168-4CC5-8622-34A3BD58885D}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/b87aabdfe1b7461e7331abb3601d9e6bb27544bc/packages/react/src/ReactCreateRef.js
--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * @flow
*]]

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type RefObject = ReactTypes.RefObject

-- deviation: In Roact, refs are implemented in terms of bindings
--[[
  A ref is nothing more than a binding with a special field 'current'
  that maps to the getValue method of the binding
]]
local Binding = require(script.Parent["ReactBinding.roblox"])

local exports = {}

-- an immutable object with a single mutable value
exports.createRef = function(): RefObject
	local binding, _ = Binding.create(nil)

	local ref = {}

	-- deviation: Since refs are used as bindings, they can often be
	-- assigned to fields of other Instances; we track creation here parallel to
	-- how we do with bindings created via `createBinding` to improve messaging
	-- when something goes wrong
	if _G.__DEV__ then
		-- TODO: LUAFDN-619 - improve debug stacktraces for refs
		binding._source = debug.traceback("Ref created at:", 1)
	end

	--[[
    A ref is just redirected to a binding via its metatable
  ]]
	setmetatable(ref, {
		__index = function(self, key)
			if key == "current" then
				return binding:getValue()
			else
				return (binding :: any)[key]
			end
		end,
		__newindex = function(self, key, value)
			if key == "current" then
				-- FIXME: Bindings - This is not allowed in Roact, but is okay in
				-- React. Lots of discussion at
				-- https://github.com/DefinitelyTyped/DefinitelyTyped/issues/31065
				-- error("Cannot assign to the 'current' property of refs", 2)
				Binding.update(binding, value)
			end

			(binding :: any)[key] = value
		end,
		__tostring = function(self)
			return string.format("Ref(%s)", tostring(binding:getValue()))
		end,
	})

	return (ref :: any) :: RefObject
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006311</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXF53A52ACC20F4ADCBDC6B93021D6FB6E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactElement</string>
								<string name="ScriptGuid">{F2FC00E6-0532-4DF6-9332-DD53E2A76463}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/702fad4b1b48ac8f626ed3f35e8f86f5ea728084/packages/react/src/ReactElement.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
]]
local __DEV__ = _G.__DEV__ :: boolean
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Error = LuauPolyfill.Error
type Object = LuauPolyfill.Object

-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local ReactTypes = require(Packages.Shared)
type React_StatelessFunctionalComponent<P> = ReactTypes.React_StatelessFunctionalComponent<P>
type React_ComponentType<P> = ReactTypes.React_ComponentType<P>
type React_AbstractComponent<P, T> = ReactTypes.React_AbstractComponent<P, T>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type React_ElementProps<ElementType> = ReactTypes.React_ElementProps<ElementType>
type React_Node = ReactTypes.React_Node
type ReactElement<P = Object, T = any> = ReactTypes.ReactElement<P, T>
type ReactContext<T> = ReactTypes.ReactContext<T>
type Source = ReactTypes.Source

local ReactLazy = require(script.Parent.ReactLazy)
type LazyComponent<T, P> = ReactLazy.LazyComponent<T, P>

local getComponentName = require(Packages.Shared).getComponentName
-- deviation START: we eliminate invariant like in React 18 to avoid string formatting and function call overhead
-- local invariant = require(Packages.Shared).invariant
-- deviation END
local REACT_ELEMENT_TYPE = require(Packages.Shared).ReactSymbols.REACT_ELEMENT_TYPE
local ReactCurrentOwner = require(Packages.Shared).ReactSharedInternals.ReactCurrentOwner
--local hasOwnProperty = Object.prototype.hasOwnProperty
-- deviation START: upstream iterates over this table, but we manually unroll those loops for hot path performance
-- IF THIS TABLE UPDATES, YOU MUST UPDATE THE UNROLLED LOOPS AS WELL
local RESERVED_PROPS = {
	key = true,
	ref = true,
	__self = true,
	__source = true,
}
-- deviation END

local specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs

if __DEV__ then
	didWarnAboutStringRefs = {}
end

local exports = {}

local function hasValidRef(config)
	if __DEV__ then
		-- deviation: instead of getters, use `__index` metamethod to
		-- detect if it's a warning object
		if config.ref ~= nil and type(config.ref) == "table" then
			if (config.ref :: any).isReactWarning then
				return false
			end
		end
	end

	return config.ref ~= nil
end

local function hasValidKey(config)
	if __DEV__ then
		-- deviation: instead of getters, use `__index` metamethod to
		-- detect if it's a warning object
		if config.key ~= nil and type(config.key) == "table" then
			if (config.key :: any).isReactWarning then
				return false
			end
		end
	end

	return config.key ~= nil
end

local reactWarning = { isReactWarning = true }

-- FIXME: These two warning 'getter' definitions both override the
-- metatable, and won't both work at the same time. The easy solution is to
-- define one metatable that does both instead of overwriting
local function defineKeyPropWarningGetter(props, displayName: string)
	local warnAboutAccessingKey = function()
		if __DEV__ then
			if not specialPropKeyWarningShown then
				specialPropKeyWarningShown = true
				console.error(
					"%s: `key` is not a prop. Trying to access it will result "
						.. "in `nil` being returned. If you need to access the same "
						.. "value within the child component, you should pass it as a different "
						.. "prop. (https://reactjs.org/link/special-props)",
					displayName
				)
			end
		end
	end

	-- deviation: clear key to ensure metamethod is called,
	-- then set key getter to call warnAboutAccessingKey
	props.key = nil
	setmetatable(props, {
		__index = function(t, k)
			if k == "key" then
				warnAboutAccessingKey()
				-- deviation: returns sentinel object that mimics upstream ability to check isReactWarning field
				return reactWarning
			end
			-- FIXME Luau: needs deferred constraint resolution
			return nil :: any
		end,
	})
end

local function defineRefPropWarningGetter(props, displayName: string)
	-- deviation: Use a __call metamethod here to make this function-like, but
	-- still able to have the `isReactWarning` flag defined on it
	local warnAboutAccessingRef = function()
		if __DEV__ then
			if not specialPropRefWarningShown then
				specialPropRefWarningShown = true
				console.error(
					"%s: `ref` is not a prop. Trying to access it will result "
						.. "in `nil` being returned. If you need to access the same "
						.. "value within the child component, you should pass it as a different "
						.. "prop. (https://reactjs.org/link/special-props)",
					displayName
				)
			end
		end
	end

	-- deviation: clear key to ensure metamethod is called,
	-- then set key getter to call warnAboutAccessingKey
	props.ref = nil
	setmetatable(props :: any, {
		__index = function(t, k)
			if k == "ref" then
				warnAboutAccessingRef()
				-- deviation: returns sentinel object that mimics upstream ability to check isReactWarning field
				return reactWarning
			end
			-- FIXME Luau: needs deferred constraint resolution
			return nil :: any
		end,
	})
end

local function warnIfStringRefCannotBeAutoConverted(config)
	if __DEV__ then
		if
			-- deviation: We removed support for string refs, so all stringrefs cannot be auto-converted regardless
			type(config.ref) == "string" and ReactCurrentOwner.current
			-- and config.__self
			-- and ReactCurrentOwner.current.stateNode ~= config.__self
		then
			local componentName = getComponentName(ReactCurrentOwner.current.type)

			-- deviation: we don't support string refs and hard error instead of warn
			if not didWarnAboutStringRefs[componentName] then
				error(
					string.format(
						'Component "%s" contains the string ref "%s". '
							.. "Support for string refs has been removed. "
							.. "We recommend using useRef() or createRef() instead. "
							.. "Learn more about using refs safely here: "
							.. "https://reactjs.org/link/strict-mode-string-ref",
						componentName or "Unknown",
						config.ref
					)
				)
				-- didWarnAboutStringRefs[componentName] = true
			end
		end
	end
end

--[[*
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, instanceof check
 * will not work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param *} type
 * @param *} props
 * @param *} key
 * @param string|object} ref
 * @param *} owner
 * @param *} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param *} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @internal
 ]]

-- deviation BEGIN: extra annotations here inspired by TS and flowtype to facilitate prop checking at analyze-time
local function ReactElement<P, T>(type_: T, key, ref, self, source: Source?, owner, props: P): ReactElement<P, T>
	-- deviation END
	local element = {
		-- Built-in properties that belong on the element
		type = type_,
		key = key,
		ref = ref,
		props = props,
		-- Record the component responsible for creating this element.
		_owner = owner,
	}

	-- This tag allows us to uniquely identify this as a React Element
	element["$$typeof"] = REACT_ELEMENT_TYPE

	if __DEV__ then
		-- The validation flag is currently mutative. We put it on
		-- an external backing store so that we can freeze the whole object.
		-- This can be replaced with a WeakMap once they are implemented in
		-- commonly used development environments.
		local nonEnumerable = {
			validated = false,
		}
		element._store = setmetatable({}, {
			-- To make comparing ReactElements easier for testing purposes, we
			-- make the validation flag non-enumerable (where possible, which
			-- should include every environment we run tests in), so the test
			-- framework ignores it.
			__index = nonEnumerable,
			__newindex = function(table, key, value)
				if key == "validated" then
					nonEnumerable.validated = value
				else
					rawset(table, key, value)
				end
			end,
		})
		-- self and source are DEV only properties.
		setmetatable(element, {
			__index = {
				_self = self,
				-- Two elements created in two different places should be considered
				-- equal for testing purposes and therefore we hide it from enumeration.
				_source = source,
			},
		})
	end

	-- FIXME Luau: this cast is needed until normalization lands
	return element :: any
end

----[[*
-- * https://github.com/reactjs/rfcs/pull/107
-- * @param *} type
-- * @param object} props
-- * @param string} key
-- ]]
--
--
exports.jsx = function(type, config, maybeKey)
	-- deviation START: skipping JSX for now, as it may never apply to Roblox
	error("JSX is currently unsupported")
	--  local propName; -- Reserved names are extracted
	--
	--  local props = }
	--  local key = nil
	--  local ref = nil; -- Currently, key can be spread in as a prop. This causes a potential
	--  -- issue if key is also explicitly declared (ie. <div ...props} key="Hi" />
	--  -- or <div key="Hi" ...props} /> ). We want to deprecate key spread,
	--  -- but as an intermediary step, we will use jsxDEV for everything except
	--  -- <div ...props} key="Hi" />, because we aren't currently able to tell if
	--  -- key is explicitly declared to be nil or not.
	--
	--  if maybeKey ~= nil)
	--    key = '' .. maybeKey
	--  end
	--
	--  if hasValidKey(config))
	--    key = '' .. config.key
	--  end
	--
	--  if hasValidRef(config))
	--    ref = config.ref
	--  } -- Remaining properties are added to a new props object
	--
	--
	--  for (propName in config)
	--    if hasOwnProperty.call(config, propName) and !RESERVED_PROPS.hasOwnProperty(propName))
	--      props[propName] = config[propName]
	--    end
	--  } -- Resolve default props
	--
	--
	--  if type and type.defaultProps)
	--    local defaultProps = type.defaultProps
	--
	--    for (propName in defaultProps)
	--      if props[propName] == nil)
	--        props[propName] = defaultProps[propName]
	--      end
	--    end
	-- end
	--
	--  return ReactElement(type, key, ref, nil, nil, ReactCurrentOwner.current, props)
	-- deviation END
end

--[[*
-- * https://github.com/reactjs/rfcs/pull/107
-- * @param *} type
-- * @param object} props
-- * @param string} key
-- ]]
--
exports.jsxDEV = function(type, config, maybeKey, source, self)
	-- deviation START: we may never support JSX
	error("JSX is currently unsupported")
	--  local propName; -- Reserved names are extracted
	--
	--  local props = }
	--  local key = nil
	--  local ref = nil; -- Currently, key can be spread in as a prop. This causes a potential
	--  -- issue if key is also explicitly declared (ie. <div ...props} key="Hi" />
	--  -- or <div key="Hi" ...props} /> ). We want to deprecate key spread,
	--  -- but as an intermediary step, we will use jsxDEV for everything except
	--  -- <div ...props} key="Hi" />, because we aren't currently able to tell if
	--  -- key is explicitly declared to be nil or not.
	--
	--  if maybeKey ~= nil)
	--    key = '' .. maybeKey
	--  end
	--
	--  if hasValidKey(config))
	--    key = '' .. config.key
	--  end
	--
	--  if hasValidRef(config))
	--    ref = config.ref
	--    warnIfStringRefCannotBeAutoConverted(config)
	--  } -- Remaining properties are added to a new props object
	--
	--
	--  for (propName in config)
	--    if hasOwnProperty.call(config, propName) and !RESERVED_PROPS.hasOwnProperty(propName))
	--      props[propName] = config[propName]
	--    end
	--  } -- Resolve default props
	--
	--
	--  if type and type.defaultProps)
	--    local defaultProps = type.defaultProps
	--
	--    for (propName in defaultProps)
	--      if props[propName] == nil)
	--        props[propName] = defaultProps[propName]
	--      end
	--    end
	--  end
	--
	--  if key or ref)
	--    local displayName = function ()
	--      if typeof type == 'function')
	--        return type.displayName or type.name or 'Unknown'
	--      end
	--
	--      return type
	--    }()
	--
	--    if key)
	--      defineKeyPropWarningGetter(props, displayName)
	--    end
	--
	--    if ref)
	--      defineRefPropWarningGetter(props, displayName)
	--    end
	--
	--  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props)
	return nil
	-- deviation END
end

--[[*
 * Create and return a new ReactElement of the given type.
 * See https://reactjs.org/docs/react-api.html#createelement
 ]]
-- deviation: this is TypeScript-derived annotation, but using flowtypes
--  function createElement<P extends {}>(
-- 	type: FunctionComponent<P> | ComponentClass<P> | string,
-- 	props?: Attributes & P | null,
-- 	...children: ReactNode[]): ReactElement<P>;
local function createElement<P, T>(
	type_: React_StatelessFunctionalComponent<P> | React_ComponentType<P> | React_AbstractComponent<P, T> | ReactContext<any> | LazyComponent<T, P> | ReactProviderType<any> | string,
	config: P?,
	...: React_Node | (...any) -> React_Node
): ReactElement<P, T>
	-- deviation START: extreme hot path, so manually unroll RESERVED_PROPS loop and use table.clone
	local props = if config ~= nil then table.clone(config :: any) :: any else {}
	-- deviation END
	local key: (string | number)? = nil
	local ref = nil
	local self = nil
	local source: Source? = nil

	if config ~= nil then
		-- deviation START: inline hasValidRef and hasValidKey success in hot path, still call in error case for warning
		-- FIXME Luau: needs normalization: Type 'P & React_ElementProps<T>' could not be converted into 'React_ElementProps<T>'; none of the intersection parts are compatible
		if hasValidRef(config :: any) then
			ref = ((config :: any) :: React_ElementProps<T>).ref

			if __DEV__ then
				warnIfStringRefCannotBeAutoConverted((config :: any) :: React_ElementProps<T>)
			end
		end

		-- FIXME Luau: when configKey is inline: Type 'P & React_ElementProps<T>' could not be converted into 'React_ElementProps<T>'; none of the intersection parts are compatible
		if hasValidKey(config :: any) then
			local configKey = (config :: any).key
			-- deviation: call tostring instead of concatenating with an
			-- empty string, which can throw in luau. If the string is a number,
			-- then do not use tostring
			if type(configKey) == "number" then
				key = configKey
			else
				-- FIXME Luau: narrowing bug: Type 'string' could not be converted into 'number'
				key = tostring(configKey :: any)
			end
		end
		-- deviation END

		-- deviation START: seemingly only used for string ref warnings, which we don't support
		-- self = if config.__self == nil then nil else config.__self
		-- deviation END

		source = if ((config :: any) :: React_ElementProps<T>).__source == nil
			then nil
			else ((config :: any) :: React_ElementProps<T>).__source

		-- Remaining properties are added to a new props object
		-- deviation START: extreme hot path, so manually unroll RESERVED_PROPS loop and use table.clone
		if props.key ~= nil then
			props.key = nil
		end
		if props.ref ~= nil then
			props.ref = nil
		end
		if props.__self ~= nil then
			props.__self = nil
		end
		if props.__source ~= nil then
			props.__source = nil
		end
		-- deviation END
	end

	-- Children can be more than one argument, and those are transferred onto
	-- the newly allocated props object.
	-- deviation START: we have a shortcut for capturing varargs into an array in Lua, which is more performant
	local childrenLength = select("#", ...)

	if childrenLength == 1 then
		props.children = select(1, ...)
	elseif childrenLength > 1 then
		-- TODO: there's a snapshot difference in storeOwners where key is 2 instead of 1 if we do `{...}`. does it matter?
		-- local childArray = {...}
		local childArray = table.create(childrenLength)
		for i = 1, childrenLength do
			local toInsert = select(i, ...)
			table.insert(childArray, toInsert)
		end

		-- deviation END

		if __DEV__ then
			table.freeze(childArray)
		end

		props.children = childArray
	end

	-- Resolve default props
	-- deviation START: Lua can't index defaultProps on a function
	-- FIXME Luau: should know this can be a table due to type_ intersection with React_ComponentType<>. needs normalization?
	if type(type_ :: any) == "table" and (type_ :: T & React_ComponentType<P>).defaultProps then
		-- deviation END
		-- FIXME Luau: defaultProps isn't narrowed by the guard above
		local defaultProps = (type_ :: T & React_ComponentType<P>).defaultProps :: P

		-- TODO Luau: defaultProps isn't known to be a table, since Luau doesn't allow us to do `<P extends {}>` yet
		for propName, _ in (defaultProps :: any) :: Object do
			if props[propName] == nil then
				props[propName] = ((defaultProps :: any) :: Object)[propName]
			end
		end
	end

	if __DEV__ then
		if key or ref then
			-- deviation START: Lua can't store fields like displayName on functions
			local displayName

			if type(type_) == "function" then
				-- displayName = (type_.displayName or type_.name) or "Unknown"
				displayName = debug.info(type_, "n") or "<function>"
			elseif type(type_) == "table" then
				displayName = (
					(type_ :: T & React_ComponentType<P>).displayName or (type_ :: T & React_ComponentType<P>).name
				) or "Unknown"
			else
				-- FIXME Luau: Luau should have narrowed type_ to string based on this above branches
				displayName = type_ :: string
			end
			-- deviation END

			if key then
				defineKeyPropWarningGetter(props, displayName)
			end

			if ref then
				defineRefPropWarningGetter(props, displayName)
			end
		end

		-- deviation START: In upstream, JSX transformation is what
		-- produces the `__source` field, so we'll just simulate it here for now
		if source == nil then
			-- go up one more because of ReactElementValidator indirection
			source = {
				fileName = debug.info(3, "s"),
				lineNumber = debug.info(3, "l"),
			}
		end
		-- deviation END
	end

	-- FIXME Luau: this cast is needed until normalization lands
	return ReactElement(type_, key, ref, self, source, ReactCurrentOwner.current, props) :: any
end
exports.createElement = createElement

----[[*
-- * Return a function that produces ReactElements of a given type.
-- * See https://reactjs.org/docs/react-api.html#createfactory
-- ]]
--
--export function createFactory(type)
--  local factory = createElement.bind(null, type); -- Expose the type on the factory and the prototype so that it can be
--  -- easily accessed on elements. E.g. `<Foo />.type == Foo`.
--  -- This should not be named `constructor` since this may not be the function
--  -- that created the element, and it may not even be a constructor.
--  -- Legacy hook: remove it
--
--  factory.type = type
--  return factory
--end
exports.cloneAndReplaceKey = function<P, T>(oldElement: ReactElement<P, T>, newKey: any): ReactElement<P, T>
	local newElement = ReactElement(
		oldElement.type,
		newKey,
		oldElement.ref,
		oldElement._self,
		oldElement._source,
		oldElement._owner,
		oldElement.props
	)
	return newElement
end

--[[*
* Clone and return a new ReactElement using element as the starting point.
* See https://reactjs.org/docs/react-api.html#cloneelement
]]

exports.cloneElement = function<P, T>(
	element: ReactElement<P, T>,
	config: (P & React_ElementProps<T>)?,
	...: React_Node
): ReactElement<P, T>
	-- deviation START: use if instead of variant to avoid error message formatting even when there's no problem
	if element == nil then
		error(
			Error.new(
				"React.cloneElement(...): The argument must be a React element, but you passed " .. tostring(element)
			)
		)
	end

	-- Original props are copied
	local elementProps = element.props
	local props: P & React_ElementProps<T> = if elementProps ~= nil
		then table.clone(elementProps :: P & React_ElementProps<T>) :: any
		else {} :: P & React_ElementProps<T>

	-- Reserved names are extracted
	local key = element.key
	local ref = element.ref

	-- Self is preserved since the owner is preserved.
	-- deviation: _self field only used for string ref checking
	-- local self = element._self

	-- Source is preserved since cloneElement is unlikely to be targeted by a
	-- transpiler, and the original source is probably a better indicator of the
	-- true owner.
	local source = element._source

	-- Owner will be preserved, unless ref is overridden
	local owner = element._owner

	if config ~= nil then
		-- deviation START: inline hasValidRef and hasValidKey success in hot path, still call in error case for warning
		local configRef = config.ref
		if configRef ~= nil then
			-- Silently steal the ref from the parent.
			ref = configRef
			owner = ReactCurrentOwner.current
		else
			hasValidRef(config)
		end

		local configKey = config.key
		-- FIXME Luau: needs normalization, generic subtype escaping scope
		if configKey ~= nil then
			if type(configKey) == "number" then
				key = configKey
			else
				-- FIXME Luau: narrowing bug: Type 'string' could not be converted into 'number'
				key = configKey :: any or "nil"
			end
		else
			hasValidKey((config :: any) :: React_ElementProps<T>)
		end
		-- deviation END
	end

	-- Remaining properties override existing props
	local elementType = element.type
	local defaultProps: P? = if type(elementType) == "table" then elementType.defaultProps else nil

	-- deviation: cannot call pairs on nil the way you can use `for...in`
	-- on nil in JS, so we check for nil before iterating
	if config ~= nil then
		for propName, _ in config :: any do
			if (config :: any)[propName] ~= nil and not RESERVED_PROPS[propName] then
				if (config :: any)[propName] == nil and defaultProps ~= nil then
					-- Resolve default props
					-- FIXME Luau: force-cast required to avoid TypeError: Expected type table, got 'P' instead
					(props :: any)[propName] = (defaultProps :: any)[propName]
				else
					(props :: any)[propName] = (config :: any)[propName]
				end
			end
		end
	end

	-- Children can be more than one argument, and those are transferred onto
	-- the newly allocated props object.
	-- deviation START: we have a shortcut for capturing varargs into an array in Lua, which is more performant
	local childrenLength = select("#", ...)

	if childrenLength == 1 then
		props.children = select(1, ...)
	elseif childrenLength > 1 then
		(props :: any).children = { ... }
	end
	-- deviation END

	-- FIXME Luau: this cast is needed until normalization lands
	return ReactElement(element.type, key, ref, nil, source, owner, (props :: any) :: P & React_ElementProps<T>) :: any
end
--[[*
 * Verifies the object is a ReactElement.
 * See https://reactjs.org/docs/react-api.html#isvalidelement
 * @param ?object} object
 * @return boolean} True if `object` is a ReactElement.
 * @final
 ]]

exports.isValidElement = function(object)
	return type(object) == "table" and object["$$typeof"] == REACT_ELEMENT_TYPE
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006312</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA9B6C61EB80E48F1A26115E82A10EF94">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactElementValidator</string>
								<string name="ScriptGuid">{FBF6D6B5-B320-4FA7-8650-8FAB7606996C}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/bc6b7b6b16f771bfc8048fe15e211ac777253b64/packages/react/src/ReactElementValidator.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * @flow
*]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
local Boolean = LuauPolyfill.Boolean
local Object = LuauPolyfill.Object
type Object = LuauPolyfill.Object
local console = require(Packages.Shared).console
local inspect = LuauPolyfill.util.inspect
type Function = (...any) -> ...any

-- deviation START: import extra types
local ReactTypes = require(Packages.Shared)
type React_StatelessFunctionalComponent<P> = ReactTypes.React_StatelessFunctionalComponent<P>
type React_ComponentType<P> = ReactTypes.React_ComponentType<P>
type React_Element<ElementType> = ReactTypes.React_Element<ElementType>
type React_ElementProps<ElementType> = ReactTypes.React_ElementProps<ElementType>
type ReactElement<P, T> = ReactTypes.ReactElement<P, T>
type React_Node = ReactTypes.React_Node
type Source = ReactTypes.Source
-- deviation END

local isValidElementType = require(Packages.Shared).isValidElementType
local getComponentName = require(Packages.Shared).getComponentName
local ReactSymbols = require(Packages.Shared).ReactSymbols
local getIteratorFn = ReactSymbols.getIteratorFn
local _REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local _REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_FRAGMENT_TYPE = ReactSymbols.REACT_FRAGMENT_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE

local warnAboutSpreadingKeyToJSX = require(Packages.Shared).ReactFeatureFlags.warnAboutSpreadingKeyToJSX
local checkPropTypes = require(Packages.Shared).checkPropTypes
local ReactCurrentOwner = require(Packages.Shared).ReactSharedInternals.ReactCurrentOwner

local ReactElement = require(script.Parent.ReactElement)
local isValidElement = ReactElement.isValidElement
local createElement = ReactElement.createElement
local cloneElement = ReactElement.cloneElement
local jsxDEV = ReactElement.jsxDEV

local setExtraStackFrame = require(Packages.Shared).ReactSharedInternals.ReactDebugCurrentFrame.setExtraStackFrame
local describeUnknownElementTypeFrameInDEV =
	require(Packages.Shared).ReactComponentStackFrame.describeUnknownElementTypeFrameInDEV

local exports = {}

-- FIXME Luau: annotation shouldn't be necessary
local function setCurrentlyValidatingElement(element: ReactElement<any, any> | nil)
	if _G.__DEV__ then
		if element then
			local owner = element._owner
			local ownerArgument = nil
			if owner then
				ownerArgument = owner.type
			end
			local stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, ownerArgument);
			-- FIXME Luau: needs normalization: Cannot call non-function (() -> ()) | ((string?) -> (...any))
			(setExtraStackFrame :: (...any) -> ())(stack)
		else
			-- FIXME Luau: needs normalization: Cannot call non-function (() -> ()) | ((string?) -> (...any))
			(setExtraStackFrame :: (...any) -> ())(nil)
		end
	end
end

local propTypesMisspellWarningShown

if _G.__DEV__ then
	propTypesMisspellWarningShown = false
end

local function hasOwnProperty(object, key)
	return object[key] ~= nil
end

local function getDeclarationErrorAddendum(): string
	if ReactCurrentOwner.current then
		local name = getComponentName(ReactCurrentOwner.current.type)
		if name then
			return "\n\nCheck the render method of `" .. name .. "`."
		end
	end
	return ""
end

-- FIXME Luau: annotation shouldn't be necessary
local function getSourceInfoErrorAddendum(source: Source | nil): string
	if source ~= nil then
		local fileName = string.gsub(source.fileName, "^.*[\\/]", "")
		local lineNumber = source.lineNumber
		return "\n\nCheck your code at " .. fileName .. ":" .. lineNumber .. "."
	end
	return ""
end

-- FIXME Luau: needs explicit annotation, even though call site and nil check should be enough
local function getSourceInfoErrorAddendumForProps(elementProps: React_ElementProps<any>?): string
	if elementProps ~= nil then
		return getSourceInfoErrorAddendum(elementProps.__source)
	end
	return ""
end

-- /**
--  * Warn if there's no key explicitly set on dynamic arrays of children or
--  * object keys are not valid. This allows us to keep track of children between
--  * updates.
--  */
local ownerHasKeyUseWarning = {}

-- FIXME Luau: shouldn't need this annotation on parentType
local function getCurrentComponentErrorInfo(parentType: React_ComponentType<any> | string | Function): string
	local info = getDeclarationErrorAddendum()

	if not Boolean.toJSBoolean(info) then
		local parentName = if typeof(parentType) == "string"
			then parentType
			else if typeof(parentType) == "table" then parentType.displayName or parentType.name else nil

		-- deviation: Lua doesn't store fields on functions, so try and get the name via reflection
		if not parentName and typeof(parentType) == "function" then
			local functionName = debug.info(parentType, "n")
			-- NOTE: unlike other places, upstream doesn't default the component name string in this message
			parentName = if functionName ~= "" then functionName else nil
		end

		if parentName then
			info = string.format("\n\nCheck the top-level render call using <%s>.", parentName)
		end
	end
	return info
end

-- /**
--  * Warn if the element doesn't have an explicit key assigned to it.
--  * This element is in an array. The array could grow and shrink or be
--  * reordered. All children that haven't already been validated are required to
--  * have a "key" property assigned to it. Error statuses are cached so a warning
--  * will only be shown once.
--  *
--  * @internal
--  * @param {ReactElement} element Element that requires a key.
--  * @param {*} parentType element's parent's type.
--  * @param {*} tableKey ROBLOX deviation: key provided by the children table
--  */
-- deviation START: add explicit optional table key parameter, move key check to after we mark it validated, since we may not have an explicit key (and will use tableKey to validate)
local function validateExplicitKey<P>(element: ReactElement<P, any>, parentType, tableKey: any?)
	if element._store == nil or element._store.validated then
		return
	end
	-- FIXME Luau: doesn't narrow based on branch above
	(element._store :: any).validated = true
	-- NOTE: Consider this element valid if only _one_ key is
	-- present, otherwise proceed and check for error states
	if (element.key ~= nil) ~= (tableKey ~= nil) then
		return
	end
	-- deviation END
	local currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType)
	if ownerHasKeyUseWarning[currentComponentErrorInfo] then
		return
	end
	ownerHasKeyUseWarning[currentComponentErrorInfo] = true

	-- // Usually the current owner is the offender, but if it accepts children as a
	-- // property, it may be the creator of the child that's responsible for
	-- // assigning it a key.
	local childOwner = ""
	if element and element._owner and element._owner ~= ReactCurrentOwner.current then
		-- // Give the component that originally created this child.
		childOwner = string.format(" It was passed a child from %s.", tostring(getComponentName(element._owner.type)))
	end

	if _G.__DEV__ then
		setCurrentlyValidatingElement(element)
		-- deviation START: Account for conflict between "key" prop and deviated table key behavior (in addition to missing key warnings)
		-- Both forms of key were provided
		if element.key ~= nil and tableKey ~= nil then
			-- TODO: Link to special Roact documentation that accounts
			-- for deviation instead of react docs
			console.error(
				'Child element received a "key" prop ("%s") in addition to a key in '
					.. 'the "children" table of its parent ("%s"). Please provide only '
					.. 'one key definition. When both are present, the "key" prop '
					.. "will take precedence."
					.. "%s%s See https://reactjs.org/link/warning-keys for more information.",
				tostring(element.key),
				tostring(tableKey),
				currentComponentErrorInfo,
				childOwner
			)
		-- No key was provided at all
		else
			console.error(
				'Each child in a list should have a unique "key" prop.'
					.. "%s%s See https://reactjs.org/link/warning-keys for more information.",
				currentComponentErrorInfo,
				childOwner
			)
		end
		-- deviation END
		setCurrentlyValidatingElement(nil)
	end
end

-- /**
--  * Ensure that every element either is passed in a static location, in an
--  * array with an explicit keys property defined, or in an object literal
--  * with valid key property.
--  *
--  * @internal
--  * @param {ReactNode} node Statically passed child of any type.
--  * @param {*} parentType node's parent's type.
--  */
local function validateChildKeys(node, parentType)
	if typeof(node) ~= "table" then
		return
	end

	if Array.isArray(node) then
		for i = 1, #node do
			local child = node[i]
			if isValidElement(child) then
				validateExplicitKey(child :: ReactElement<any, any>, parentType)
			end
		end
	elseif isValidElement(node) then
		-- // This element was passed in a valid location.
		if node._store then
			node._store.validated = true
		end
	elseif node then
		local iteratorFn = getIteratorFn(node)
		if typeof(iteratorFn) == "function" then
			-- // Entry iterators used to provide implicit keys,
			-- // but now we print a separate warning for them later.
			if iteratorFn ~= node.entries then
				local iterator = iteratorFn(node)
				local step = iterator.next()
				while not step.done do
					if isValidElement(step.value) then
						validateExplicitKey(step.value, parentType, step.key)
					end

					step = iterator.next()
				end
			end
		end
	end
end

-- /**
--  * Given an element, validate that its props follow the propTypes definition,
--  * provided by the type.
--  *
--  * @param {ReactElement} element
--  */
local function validatePropTypes<P>(element: ReactElement<P, any>)
	if _G.__DEV__ or _G.__DISABLE_ALL_WARNINGS_EXCEPT_PROP_VALIDATION__ then
		local type = element.type
		if type == nil or typeof(type) == "string" then
			return
		end

		local propTypes
		local validateProps
		if typeof(type) == "function" then
			-- deviation: function components can't have propTypes in Lua
			-- propTypes = type.propTypes
			return
		elseif typeof(type) == "table" then
			propTypes = type.propTypes
			validateProps = type.validateProps
		else
			return
		end

		if propTypes or validateProps then
			-- Intentionally inside to avoid triggering lazy initializers:
			local name = getComponentName(type)
			-- deviation: adds support for legacy Roact's validateProps()
			checkPropTypes(propTypes, validateProps, element.props, "prop", name, element)
			-- TODO: upstream this any, PropTypes is a bogus key check on purpose
		elseif (type :: any).PropTypes ~= nil and not propTypesMisspellWarningShown then
			propTypesMisspellWarningShown = true
			-- Intentionally inside to avoid triggering lazy initializers:
			local name = getComponentName(type)
			console.error(
				"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",
				name or "Unknown"
			)
		end
		-- TODO: upstream this any, PropTypes is a bogus key check on purpose
		-- deviation: we simplify this check since we never supported this in the first place
		if (type :: any).getDefaultProps ~= nil then
			console.error(
				"getDefaultProps is only used on classic React.createClass "
					.. "definitions. Use a static property named `defaultProps` instead."
			)
		end
	end
end

-- /**
--  * Given a fragment, validate that it can only be provided with fragment props
--  * @param {ReactElement} fragment
--  */
local function validateFragmentProps<P>(fragment: ReactElement<P & Object, any>)
	if _G.__DEV__ then
		local keys = Object.keys(fragment.props)
		for i = 1, #keys do
			local key = keys[i]
			if key ~= "children" and key ~= "key" then
				setCurrentlyValidatingElement(fragment)
				console.error(
					"Invalid prop `%s` supplied to `React.Fragment`. "
						.. "React.Fragment can only have `key` and `children` props.",
					key
				)
				setCurrentlyValidatingElement(nil)
				break
			end
		end

		if fragment.ref ~= nil then
			setCurrentlyValidatingElement(fragment)
			console.error("Invalid attribute `ref` supplied to `React.Fragment`.")
			setCurrentlyValidatingElement(nil)
		end
	end
end

-- deviation START: add strong types based on definitely-typed approach on createElement
local function jsxWithValidation<P, T>(
	type: T,
	props: P & React_ElementProps<T>,
	key: string | number,
	isStaticChildren,
	source: Source?,
	self: any?
)
	-- deviation END
	local validType = isValidElementType(type)

	-- // We warn in this case but don't throw. We expect the element creation to
	-- // succeed and there will likely be errors in render.
	if not validType then
		local info = ""
		if type == nil or (typeof(type) == "table" and #Object.keys(type) == 0) then
			info ..= (" You likely forgot to export your component from the file " .. "it's defined in, or you might have mixed up default and named imports.")
		end

		local sourceInfo = getSourceInfoErrorAddendum(source)
		if sourceInfo then
			info ..= sourceInfo
		else
			info ..= getDeclarationErrorAddendum()
		end

		local typeString
		if type == nil then
			typeString = "nil"
		elseif Array.isArray(type) then
			typeString = "array"
		elseif typeof(type) == "table" and type["$$typeof"] == REACT_ELEMENT_TYPE then
			typeString = string.format("<%s />", getComponentName(type.type) or "Unknown")
			info ..= " Did you accidentally export a JSX literal or Element instead of a component?"
		else
			typeString = typeof(type)
			info ..= "\n" .. inspect(type)
		end

		if _G.__DEV__ then
			console.error(
				"React.jsx: type is invalid -- expected a string (for "
					.. "built-in components) or a class/function (for composite "
					.. "components) but got: %s.%s",
				typeString,
				info
			)
		end
	end

	local element = jsxDEV(type, props, key, source, self)

	-- // The result can be nullish if a mock or a custom function is used.
	-- // TODO: Drop this when these are no longer allowed as the type argument.
	if element == nil then
		return element
	end

	-- // Skip key warning if the type isn't valid since our key validation logic
	-- // doesn't expect a non-string/function type and can throw confusing errors.
	-- // We don't want exception behavior to differ between dev and prod.
	-- // (Rendering will throw with a helpful message and as soon as the type is
	-- // fixed, the key warnings will appear.)

	if validType then
		local children = props.children
		if children ~= nil then
			if isStaticChildren then
				if Array.isArray(children) then
					for i = 1, #children do
						-- FIXME Luau: needs normalization
						validateChildKeys(children[i], type :: any)
					end

					-- deviation: Object.freeze always exist
					-- if Object.freeze then
					Object.freeze(children)
					-- end
				else
					if _G.__DEV__ then
						console.error(
							"React.jsx: Static children should always be an array. "
								.. "You are likely explicitly calling React.jsxs or React.jsxDEV. "
								.. "Use the Babel transform instead."
						)
					end
				end
			else
				-- FIXME Luau: needs normalization
				validateChildKeys(children, type :: any)
			end
		end
	end

	if _G.__DEV__ then
		if warnAboutSpreadingKeyToJSX then
			if hasOwnProperty(props, "key") then
				console.error(
					"React.jsx: Spreading a key to JSX is a deprecated pattern. "
						.. "Explicitly pass a key after spreading props in your JSX call. "
						.. "E.g. <%s {...props} key={key} />",
					getComponentName(type) or "ComponentName"
				)
			end
		end
	end

	if type == REACT_FRAGMENT_TYPE then
		-- FIXME Luau: luau doesn't understand narrowing of above branch
		validateFragmentProps((element :: any) :: ReactElement<any, any>)
	else
		validatePropTypes((element :: any) :: ReactElement<any, any>)
	end

	return element
end
exports.jsxWithValidation = jsxWithValidation

-- // These two functions exist to still get child warnings in dev
-- // even with the prod transform. This means that jsxDEV is purely
-- // opt-in behavior for better messages but that we won't stop
-- // giving you warnings if you use production apis.
exports.jsxWithValidationStatic = function(type, props, key)
	return jsxWithValidation(type, props, key, true)
end

exports.jsxWithValidationDynamic = function(type, props, key)
	return jsxWithValidation(type, props, key, false)
end

-- deviation START: add strong types based on definitely-typed approach on createElement
local function createElementWithValidation<P, T>(
	type_: React_StatelessFunctionalComponent<P> | React_ComponentType<P> | string,
	props: (P & React_ElementProps<T>)?,
	...: React_Node
): ReactElement<P, T>
	-- deviation END
	local validType = isValidElementType(type_)

	-- // We warn in this case but don't throw. We expect the element creation to
	-- // succeed and there will likely be errors in render.
	if not validType then
		local info = ""
		if type_ == nil or (typeof(type_) == "table" and #Object.keys(type_) == 0) then
			info ..= (" You likely forgot to export your component from the file " .. "it's defined in, or you might have mixed up default and named imports.")
		end

		local sourceInfo = getSourceInfoErrorAddendumForProps(props)
		if sourceInfo then
			info ..= sourceInfo
		else
			info ..= getDeclarationErrorAddendum()
		end

		local typeString
		if type_ == nil then
			typeString = "nil"
		elseif Array.isArray(type_) then
			typeString = "array"
		elseif type_ ~= nil and typeof(type_) == "table" and type_["$$typeof"] == REACT_ELEMENT_TYPE then
			typeString = string.format("<%s />", getComponentName((type_ :: any).type) or "Unknown")
			info ..= " Did you accidentally export a JSX literal or Element instead of a component?"
		else
			typeString = typeof(type_)
			if type_ ~= nil then
				-- deviation: print the table/string in readable form to give a clue, if no other info was gathered
				info ..= "\n" .. inspect(type_)
			end
		end

		if _G.__DEV__ then
			console.error(
				"React.createElement: type is invalid -- expected a string (for "
					.. "built-in components) or a class/function (for composite "
					.. "components) but got: %s.%s",
				typeString,
				info
			)
		end
	end

	-- FIXME Luau: hard cast to any, needs normalization to avoid 'React_ComponentType<P>' could not be converted into 'React_ComponentType<P>'
	local element = createElement(type_ :: any, props, ...)

	-- // The result can be nullish if a mock or a custom function is used.
	-- // TODO: Drop this when these are no longer allowed as the type argument.
	if element == nil then
		return element
	end

	-- // Skip key warning if the type isn't valid since our key validation logic
	-- // doesn't expect a non-string/function type and can throw confusing errors.
	-- // We don't want exception behavior to differ between dev and prod.
	-- // (Rendering will throw with a helpful message and as soon as the type is
	-- // fixed, the key warnings will appear.)
	if validType then
		-- deviation: skips (1) type and (2) props - starts from 3 to the end varargs (iterate through children)
		for i = 1, select("#", ...) do
			-- deviation: selects the ith child from this function's arguments to validate
			-- FIXME Luau: hard cast to any, needs normalization to avoid 'React_ComponentType<P>' could not be converted into 'React_ComponentType<P>'
			validateChildKeys(select(i, ...), type_ :: any)
		end
	end

	if type_ == REACT_FRAGMENT_TYPE then
		validateFragmentProps(element)
	else
		validatePropTypes(element)
	end

	return element
end
exports.createElementWithValidation = createElementWithValidation

-- devitation: createFactory is deprecated and will be removed
-- local didWarnAboutDeprecatedCreateFactory = false

-- exports.createFactoryWithValidation = function(type)
-- 	local validatedFactory = function(...)
-- 		createElementWithValidation(type, ...)
-- 	end
-- 	-- deviation: Lua can't assign fields to functions. The 'type'
-- 	-- property is deprecated so there is no need to port this over.
-- 	-- validatedFactory.type = type

-- 	if _G.__DEV__ then
-- 		if not didWarnAboutDeprecatedCreateFactory then
-- 			didWarnAboutDeprecatedCreateFactory = true
-- 			console.warn(
-- 				"React.createFactory() is deprecated and will be removed in " ..
-- 					"a future major release. Consider using JSX " ..
-- 					"or use React.createElement() directly instead."
-- 			)
-- 		end
-- 		-- // Legacy hook: remove it
-- 		-- deviation: no porting this behavior because it is deprecated
-- 		-- Object.defineProperty(validatedFactory, "type", {
-- 		-- 	enumerable = false,
-- 		-- 	get = function()
-- 		-- 		console.warn(
-- 		-- 			"Factory.type is deprecated. Access the class directly " ..
-- 		-- 				"before passing it to createFactory."
-- 		-- 		)
-- 		-- 		Object.defineProperty(this, "type", {
-- 		-- 			value = type,
-- 		-- 		})
-- 		-- 		return type
-- 		-- 	end,
-- 		-- })
-- 	end

-- 	return validatedFactory
-- end

-- deviation START: add strong types based on definitely-typed approach on createElement
exports.cloneElementWithValidation = function<P, T>(
	element: ReactElement<P, T>,
	props: (P & React_ElementProps<T>)?,
	...: React_Node
): ReactElement<P, T>
	-- deviation END
	local arguments = { element, props, ... } :: Array<any>
	local newElement = cloneElement(element, props, ...)
	for i = 3, #arguments do
		validateChildKeys(arguments[i], newElement.type)
	end
	validatePropTypes(newElement)
	return newElement
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006313</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8C9B264EBB894868BBB33839D8424859">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactForwardRef</string>
								<string name="ScriptGuid">{0F935C82-9159-45E9-AC7F-9AD668756981}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/41694201988c5e651f0c3bc69921d5c9717be88b/packages/react/src/ReactForwardRef.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactSymbols = require(Packages.Shared).ReactSymbols
local ReactTypes = require(Packages.Shared)
type React_Node = ReactTypes.React_Node
type React_Ref<ElementType> = ReactTypes.React_Ref<ElementType>
type React_AbstractComponent<Config, Instance> = ReactTypes.React_AbstractComponent<Config, Instance>
local REACT_FORWARD_REF_TYPE = ReactSymbols.REACT_FORWARD_REF_TYPE
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE

local exports = {}
-- TODO? should return Component's ELementType be REACT_FORWARD_REF_TYPE? probably, right?
exports.forwardRef = function<Props, ElementType>(
	render: (props: Props, ref: React_Ref<ElementType>) -> React_Node
): React_AbstractComponent<Props, ElementType>
	if _G.__DEV__ then
		-- deviation START: Lua functions can't have properties given a table (which we can index to see if it's the Memo type)
		if typeof(render :: any) == "table" and (render :: any)["$$typeof"] == REACT_MEMO_TYPE then
			-- deviation END
			console.error(
				"forwardRef requires a render function but received a `memo` "
					.. "component. Instead of forwardRef(memo(...)), use "
					.. "memo(forwardRef(...))."
			)
		elseif typeof(render) ~= "function" then
			console.error("forwardRef requires a render function but was given %s.", typeof(render))
		else
			local argumentCount, _variadic = debug.info(render, "a")
			if argumentCount ~= 0 and argumentCount ~= 2 then
				console.error(
					"forwardRef render functions accept exactly two parameters: props and ref. %s",
					(function()
						if argumentCount == 1 then
							return "Did you forget to use the ref parameter?"
						end
						return "Any additional parameter will be undefined."
					end)()
				)
			end
		end

		-- deviation: in Luau, functions cannot have fields; for now, we don't
		-- support defaultProps and propTypes on function components anyways, so
		-- this check can safely be a no-op

		-- if render ~= null then
		--   if (render.defaultProps != null || render.propTypes != null) {
		--     console.error(
		--       'forwardRef render functions do not support propTypes or defaultProps. ' +
		--         'Did you accidentally pass a React component?',
		--     );
		--   }
		-- }
	end

	local elementType = {
		["$$typeof"] = REACT_FORWARD_REF_TYPE,
		render = render,
	}
	if _G.__DEV__ then
		local ownName
		-- deviation: use metatables to approximate Object.defineProperty logic
		setmetatable(elementType, {
			__index = function(self, key)
				if key == "displayName" then
					return ownName
				end
				return rawget(self, key)
			end,
			__newindex = function(self, key, value)
				if key == "displayName" then
					ownName = value
					-- deviation: render is a function and cannot have properties
					-- if (render.displayName == null) {
					--   render.displayName = name;
					-- }
				else
					rawset(self, key, value)
				end
			end,
		})
	end
	-- FIXME Luau: making us explicitly add nilable (optional) fields: because the former is missing fields 'forceUpdate', 'getChildContext', 'props', 'setState', and 'state
	return (elementType :: any) :: React_AbstractComponent<Props, ElementType>
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006314</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX7630BCE84A1B4E39BD74E3993B37086A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactHooks</string>
								<string name="ScriptGuid">{7E8B58AD-D6DC-49C1-A36E-DEB7ADA9C305}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/ddd1faa1972b614dfbfae205f2aa4a6c0b39a759/packages/react/src/ReactHooks.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local ReactTypes = require(Packages.Shared)
-- TODO: we only pull in Dispatcher here for the typecheck, remove once Luau narrowing improves
type Dispatcher = ReactTypes.Dispatcher
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<Source, Snapshot>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<Source, Snapshot>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type ReactContext<T> = ReactTypes.ReactContext<T>
local ReactFiberHostConfig = require(Packages.Shared)
type OpaqueIDType = ReactFiberHostConfig.OpaqueIDType

-- local invariant = require(Packages.Shared).invariant

local ReactCurrentDispatcher = require(Packages.Shared).ReactSharedInternals.ReactCurrentDispatcher

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

-- FIXME Luau: we shouldn't need to explicitly annotate this
local function resolveDispatcher(): Dispatcher
	local dispatcher = ReactCurrentDispatcher.current
	-- performance: upstream main only does this check in DEV mode and then not as an invariant
	if _G.__DEV__ then
		if dispatcher == nil then
			console.error(
				"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for"
					.. " one of the following reasons:\n"
					.. "1. You might have mismatching versions of React and the renderer (such as React DOM)\n"
					.. "2. You might be breaking the Rules of Hooks\n"
					.. "3. You might have more than one copy of React in the same app\n"
					.. "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem."
			)
		end
	end
	-- Will result in a null access error if accessed outside render phase. We
	-- intentionally don't throw our own error because this is in a hot path.
	-- Also helps ensure this is inlined.
	return dispatcher :: Dispatcher
end

local exports = {}

local function useContext<T>(
	Context: ReactContext<T>,
	unstable_observedBits: number | boolean | nil,
	... -- deviation: Lua must specify ... here to capture additional args
): T
	local dispatcher = resolveDispatcher()
	if _G.__DEV__ then
		if unstable_observedBits ~= nil then
			console.error(
				"useContext() second argument is reserved for future "
					.. "use in React. Passing it is not supported. "
					.. "You passed: %s.%s",
				unstable_observedBits,
				(typeof(unstable_observedBits) == "number" and Array.isArray({ ... }))
						and "\n\nDid you call Array.map(useContext)? " .. "Calling Hooks inside a loop is not supported. " .. "Learn more at https://reactjs.org/link/rules-of-hooks"
					or ""
			)
		end

		-- TODO: add a more generic warning for invalid values.
		if (Context :: any)._context ~= nil then
			local realContext = (Context :: any)._context
			-- Don't deduplicate because this legitimately causes bugs
			-- and nobody should be using this in existing code.
			if realContext.Consumer == Context then
				console.error(
					"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be "
						.. "removed in a future major release. Did you mean to call useContext(Context) instead?"
				)
			elseif realContext.Provider == Context then
				console.error(
					"Calling useContext(Context.Provider) is not supported. "
						.. "Did you mean to call useContext(Context) instead?"
				)
			end
		end
	end
	return dispatcher.useContext(Context, unstable_observedBits)
end
exports.useContext = useContext

local function useState<S>(initialState: (() -> S) | S, ...): (S, Dispatch<BasicStateAction<S>>)
	local dispatcher = resolveDispatcher()
	return dispatcher.useState(initialState, ...)
end
exports.useState = useState

local function useReducer<S, I, A>(reducer: (S, A) -> S, initialArg: I, init: ((I) -> S)?): (S, Dispatch<A>)
	local dispatcher = resolveDispatcher()
	return dispatcher.useReducer(reducer, initialArg, init)
end
exports.useReducer = useReducer

-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
-- TODO: reconciling this with bindings and sharing any relevant Ref types (there may be different ones depending on whether it's just a loose ref, vs one being assigned to the ref prop
local function useRef<T>(initialValue: T): { current: T | nil }
	-- deviation END
	local dispatcher = resolveDispatcher()
	return dispatcher.useRef(initialValue)
end
exports.useRef = useRef

-- deviation: TS models this slightly differently, which is needed to have an initially empty ref and clear the ref, and still typecheck
local function useBinding<T>(initialValue: T): (ReactTypes.ReactBinding<T>, ReactTypes.ReactBindingUpdater<T>)
	-- deviation END
	local dispatcher = resolveDispatcher()
	return dispatcher.useBinding(initialValue)
end
exports.useBinding = useBinding

local function useEffect(
	-- TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useEffect(create, deps)
end
exports.useEffect = useEffect

local function useLayoutEffect(
	-- TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useLayoutEffect(create, deps)
end
exports.useLayoutEffect = useLayoutEffect

local function useCallback<T>(callback: T, deps: Array<any> | nil): T
	local dispatcher = resolveDispatcher()
	return dispatcher.useCallback(callback, deps)
end
exports.useCallback = useCallback

local function useMemo<T...>(create: () -> T..., deps: Array<any> | nil): T...
	local dispatcher = resolveDispatcher()
	return dispatcher.useMemo(create, deps)
end
exports.useMemo = useMemo

local function useImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useImperativeHandle(ref, create, deps)
end
exports.useImperativeHandle = useImperativeHandle

local function useDebugValue<T>(value: T, formatterFn: ((value: T) -> any)?): ()
	if _G.__DEV__ then
		local dispatcher = resolveDispatcher()
		return dispatcher.useDebugValue(value, formatterFn)
	end

	-- deviation: return nil explicitly for safety
	return nil
end
exports.useDebugValue = useDebugValue

exports.emptyObject = {}

-- TODO: enable useTransition later
-- exports.useTransition = function(): ((() -> ()) -> (), boolean)
-- 	local dispatcher = resolveDispatcher()
-- 	return dispatcher.useTransition()
-- end

-- TODO: enable useDeferredValue later
-- exports.useDeferredValue = function<T>(value: T): T
-- 	local dispatcher = resolveDispatcher()
-- 	return dispatcher.useDeferredValue(value)
-- end

exports.useOpaqueIdentifier = function(): OpaqueIDType | nil
	local dispatcher = resolveDispatcher()
	return dispatcher.useOpaqueIdentifier()
end

exports.useMutableSource = function<Source, Snapshot>(
	source: MutableSource<Source>,
	getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
	subscribe: MutableSourceSubscribeFn<Source, Snapshot>
): Snapshot
	local dispatcher = resolveDispatcher()
	return dispatcher.useMutableSource(source, getSnapshot, subscribe)
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006315</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX024AB43A4F1345728106466B66AACE9C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactLazy</string>
								<string name="ScriptGuid">{AA08E961-D3F3-4234-871E-FF13C0821AAB}</string>
								<ProtectedString name="Source"><![CDATA[--!nonstrict
-- upstream: https://github.com/facebook/react/blob/v17.0.2/packages/react/src/ReactLazy.js
--[[
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 *]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local Shared = require(Packages.Shared)
local console = Shared.console
local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect

local ReactTypes = require(Packages.Shared)
type Wakeable = ReactTypes.Wakeable
type Thenable<R> = ReactTypes.Thenable<R>
local ReactSymbols = require(Packages.Shared).ReactSymbols

local REACT_LAZY_TYPE = ReactSymbols.REACT_LAZY_TYPE

local Uninitialized = -1
local Pending = 0
local Resolved = 1
local Rejected = 2

type UninitializedPayload<T> = {
	-- deviation: Luau doesn't support literals
	--   _status: -1,
	_status: number,
	_result: () -> Thenable<{ default: T, [string]: any }>,
}

type PendingPayload = {
	-- deviation: Luau doesn't support literals
	-- _status: 0,
	_status: number,
	_result: Wakeable,
}

type ResolvedPayload<T> = {
	-- deviation: Luau doesn't support literals
	-- _status: 1,
	_status: number,
	_result: { default: T, [string]: any },
}

type RejectedPayload = {
	-- deviation: Luau doesn't support literals
	-- _status: 2,
	_status: number,
	_result: any,
}

type Payload<T> = UninitializedPayload<T> | PendingPayload | ResolvedPayload<T> | RejectedPayload

export type LazyComponent<T, P> = {
	["$$typeof"]: number,
	_payload: P,
	_init: (payload: P) -> T,
	--   ...
}

function lazyInitializer<T>(payload: Payload<T>): T
	if payload._status == Uninitialized then
		local ctor = payload._result
		local thenable = ctor()
		-- Transition to the next state.
		local pending: PendingPayload = payload :: any
		pending._status = Pending
		pending._result = thenable
		thenable:andThen(function(moduleObject)
			if payload._status == Pending then
				local defaultExport = moduleObject.default
				if _G.__DEV__ then
					if defaultExport == nil then
						console.error(
							"lazy: Expected the result of a dynamic import() call. "
								.. "Instead received: `%s`\n\nYour code should look like: \n  "
								-- Break up imports to avoid accidentally parsing them as dependencies.
								-- deviation: Lua syntax in message
								.. "local MyComponent = lazy(function() return req"
								.. "quire(script.Parent.MyComponent) end)",
							inspect(moduleObject)
						)
					end
				end
				-- Transition to the next state.
				local resolved: ResolvedPayload<T> = payload :: any
				resolved._status = Resolved
				resolved._result = defaultExport
			end
		end, function(error_)
			if payload._status == Pending then
				-- Transition to the next state.
				local rejected: RejectedPayload = payload :: any
				rejected._status = Rejected
				rejected._result = error_
			end
		end)
	end
	if payload._status == Resolved then
		return payload._result
	else
		error(payload._result)
	end
end

local exports = {}

exports.lazy = function<T>(ctor: () -> Thenable<{ default: T, [string]: any }>): LazyComponent<T, Payload<T>>
	local payload: Payload<T> = {
		-- We use these fields to store the result.
		_status = -1,
		_result = ctor,
	}

	local lazyType: LazyComponent<T, Payload<T>> = {
		["$$typeof"] = REACT_LAZY_TYPE,
		_payload = payload,
		-- FIXME Luau: needs something even beyond normalization to avoid Property '_init' is not compatible. Type '<T>(Payload<T>) -> T?' could not be converted into '(Payload<T>) -> T?'; different number of generic type parameters
		_init = lazyInitializer :: any,
	}

	if _G.__DEV__ then
		-- In production, this would just set it on the object.
		local defaultProps
		local propTypes
		-- $FlowFixMe
		setmetatable(lazyType, {
			__index = function(self, key)
				if key == "defaultProps" then
					return defaultProps
				end
				if key == "propTypes" then
					return propTypes
				end
				return
			end,
			__newindex = function(self, key, value)
				if key == "defaultProps" then
					console.error(
						"React.lazy(...): It is not supported to assign `defaultProps` to "
							.. "a lazy component import. Either specify them where the component "
							.. "is defined, or create a wrapping component around it."
					)
					defaultProps = value
					-- Match production behavior more closely:
					-- $FlowFixMe
					setmetatable(self, {
						__index = function() end,
						__newindex = function() end,
					})
				end
				if key == "propTypes" then
					console.error(
						"React.lazy(...): It is not supported to assign `propTypes` to "
							.. "a lazy component import. Either specify them where the component "
							.. "is defined, or create a wrapping component around it."
					)
					propTypes = value
					-- Match production behavior more closely:
					-- $FlowFixMe
					setmetatable(self, {
						__index = function() end,
						__newindex = function() end,
					})
				end
			end,
		})
	end

	return lazyType
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006316</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8BA7CAADAEB842A9ACA5B33A689ABB6D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactMemo</string>
								<string name="ScriptGuid">{F4808DE3-1B9A-46E5-BFDB-673D9DCFC21B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/41694201988c5e651f0c3bc69921d5c9717be88b/packages/react/src/ReactMemo.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local Shared = require(Packages.Shared)
local console = Shared.console
local LuauPolyfill = require(Packages.LuauPolyfill)
local Array = LuauPolyfill.Array
local Object = LuauPolyfill.Object
local inspect = LuauPolyfill.util.inspect
type React_StatelessFunctionalComponent<Props> = Shared.React_StatelessFunctionalComponent<Props>
type React_ElementType = Shared.React_ElementType
type React_Component<Props, State> = Shared.React_Component<Props, State>
type React_ComponentType<Props> = Shared.React_ComponentType<Props>
type React_AbstractComponent<Config, Instance> = Shared.React_AbstractComponent<Config, Instance>

local ReactSymbols = Shared.ReactSymbols
local REACT_MEMO_TYPE = ReactSymbols.REACT_MEMO_TYPE
local REACT_ELEMENT_TYPE = ReactSymbols.REACT_ELEMENT_TYPE
local isValidElementType = Shared.isValidElementType
local getComponentName = Shared.getComponentName

local exports = {}

exports.memo = function<Props, T>(
	-- deviation START: expanded type pulled from definitelytyped, not sure why upstream doesn't accept function component types
	-- TODO Luau: React_Component<Props, any> gave me  Type 'React_Component<any, any>' could not be converted into '((any, any) -> (Array<(Array<<CYCLE>> | React_Element<any> | boolean | number | string)?> | React_Element<any> | boolean | number | string)?) | string'; none of the union options are compatible
	type_: React_StatelessFunctionalComponent<Props> | React_AbstractComponent<Props, T> | string,
	-- deviation END
	compare: ((oldProps: Props, newProps: Props) -> boolean)?
): React_AbstractComponent<Props, any>
	if _G.__DEV__ then
		local validType = isValidElementType(type_)

		-- We warn in this case but don't throw. We expect the element creation to
		-- succeed and there will likely be errors in render.
		if not validType then
			local info = ""
			if type_ == nil or (typeof(type_) == "table" and #Object.keys(type_) == 0) then
				info = info
					.. (
						" You likely forgot to export your component from the file "
						.. "it's defined in, or you might have mixed up default and named imports."
					)
			end
			local typeString
			if type_ == nil then
				typeString = "nil"
			elseif Array.isArray(type_) then
				typeString = "array"
			elseif type_ ~= nil and typeof(type_) == "table" and (type_)["$$typeof"] == REACT_ELEMENT_TYPE then
				typeString = string.format("<%s />", getComponentName((type_ :: any).type) or "UNKNOWN")
				info = " Did you accidentally export a JSX literal or Element instead of a component?"
			else
				typeString = typeof(type_)
				if type_ ~= nil then
					-- deviation: print the table/string in readable form to give a clue, if no other info was gathered
					info = "\n" .. inspect(type_)
				end
			end
			console.error("memo: The first argument must be a component. Instead received: `%s`.%s", typeString, info)
		end
	end

	local elementType = {
		["$$typeof"] = REACT_MEMO_TYPE,
		type = type_,
		compare = compare or nil,
	}

	if _G.__DEV__ then
		local name
		-- deviation: use metatables to approximate Object.defineProperty logic
		setmetatable(elementType, {
			__index = function(self, key)
				if key == "displayName" then
					return name
				end
				return rawget(self, key)
			end,
			__newindex = function(self, key, value)
				if key == "displayName" then
					name = value
					-- deviation: render is a function and cannot have properties
					if typeof(type_) == "table" and (type_ :: React_AbstractComponent<Props, T>).displayName == nil then
						(type_ :: React_AbstractComponent<Props, T>).displayName = name
					end
				else
					rawset(self, key, value)
				end
			end,
		})
	end

	return elementType
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006317</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9B5689DA8BBE4630BB19111D724E3441">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactMutableSource</string>
								<string name="ScriptGuid">{DB1DA497-4EB2-4EE7-BA0A-ABD34CFB6D5B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/142d4f1c00c66f3d728177082dbc027fd6335115/packages/react/src/ReactMutableSource.js
-- [[
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
-- ]]

local Packages = script.Parent.Parent
local ReactTypes = require(Packages.Shared)
type MutableSourceGetVersionFn = ReactTypes.MutableSourceGetVersionFn
type MutableSource<T> = ReactTypes.MutableSource<T>

local function createMutableSource<Source>(source: Source, getVersion: MutableSourceGetVersionFn): MutableSource<Source>
	local mutableSource: MutableSource<Source> = {
		_getVersion = getVersion,
		_source = source,
		_workInProgressVersionPrimary = nil,
		_workInProgressVersionSecondary = nil,
	}

	if _G.__DEV__ then
		mutableSource._currentPrimaryRenderer = nil
		mutableSource._currentSecondaryRenderer = nil
	end

	return mutableSource
end

return createMutableSource
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006318</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXBD620371E7C7414AA0C26C8A662AD901">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactNoopUpdateQueue</string>
								<string name="ScriptGuid">{3CAEA2A2-9EE4-4F35-9A60-DCECB3404AD5}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/0cf22a56a18790ef34c71bef14f64695c0498619/packages/react/src/ReactNoopUpdateQueue.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 ]]

local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console

local didWarnStateUpdateForUnmountedComponent = {}

local function warnNoop(publicInstance: any, callerName: string)
	if _G.__DEV__ then
		-- local constructor = publicInstance.constructor
		-- local componentName = ((constructor and (constructor.displayName or constructor.name)) or 'ReactClass')
		-- deviation: For Lua Class components, the name comes from a property
		-- defined on the metatable
		local componentName = publicInstance.__componentName or "ReactClass"
		local warningKey = componentName .. "." .. callerName
		if didWarnStateUpdateForUnmountedComponent[warningKey] then
			return
		end
		-- deviation: message adjusted for accuracy with Lua class components
		console.error(
			"Can't call %s on a component that is not yet mounted. "
				.. "This is a no-op, but it might indicate a bug in your application. "
				.. "Instead, assign to `self.state` directly with the desired state in "
				.. "the %s component's `init` method.",
			callerName,
			componentName
		)
		didWarnStateUpdateForUnmountedComponent[warningKey] = true
	end
end

--[[*
 * This is the abstract API for an update queue.
 ]]
local ReactNoopUpdateQueue = {
	--[[*
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   ]]
	isMounted = function(publicInstance)
		return false
	end,
	--[[*
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   ]]
	enqueueForceUpdate = function(publicInstance, callback, callerName)
		warnNoop(publicInstance, "forceUpdate")
	end,
	--[[*
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} callerName name of the calling function in the public API.
   * @internal
   ]]
	enqueueReplaceState = function(publicInstance, completeState, callback, callerName)
		warnNoop(publicInstance, "replaceState")
	end,
	--[[*
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @param {?function} callback Called after component is updated.
   * @param {?string} Name of the calling function in the public API.
   * @internal
   ]]
	enqueueSetState = function(publicInstance, partialState, callback, callerName)
		warnNoop(publicInstance, "setState")
	end,
}

return ReactNoopUpdateQueue
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006319</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX561CC9E8DB644593868CF20A0A7EFBC2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">createSignal.roblox</string>
								<string name="ScriptGuid">{B146BB54-0E19-4BF3-8662-EB8E334E0604}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/Roblox/roact/blob/master/src/createSignal.lua
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

type Function = (...any) -> ...any
--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

type Connection = { callback: Function, disconnected: boolean }
type Map<K, V> = { [K]: V }

local function createSignal(): ((Function) -> (() -> ()), (...any) -> ())
	local connections: Map<Function, Connection> = {}
	local suspendedConnections = {}
	local firing = false

	local function subscribe(callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
			disconnected = false,
		}

		-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable
		-- the existing one.
		if firing and not connections[callback] then
			suspendedConnections[callback] = connection
		end

		connections[callback] = connection

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections[callback] = nil
			suspendedConnections[callback] = nil
		end

		return disconnect
	end

	local function fire(...)
		firing = true
		for callback, connection in connections do
			if not connection.disconnected and not suspendedConnections[callback] then
				callback(...)
			end
		end

		firing = false

		-- performance: use table.clear
		table.clear(suspendedConnections)
	end

	return subscribe, fire
end

return createSignal
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000631a</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXA229DC9910BA4C61907207B87892F5E4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ReactRoblox</string>
							<string name="ScriptGuid">{B11135C9-821B-4AC6-9609-E97583D4C5CE}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/index.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local HostTypes = require(script.client["ReactRobloxHostTypes.roblox"])
export type RootType = HostTypes.RootType
return require(script.client.ReactRoblox)
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed0000632c</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXC311AB35045942DC83427A8B6FECDDBA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ReactReconciler.roblox</string>
								<string name="ScriptGuid">{F1C7CECB-34F0-46DD-BCD7-4C0CADF23A08}</string>
								<ProtectedString name="Source"><![CDATA[-- NOTE: This file is too small and/or simple to be sufficiently rewritten under a new license. Assume MIT.
--!strict
-- deviation: Initializes the reconciler with this package's host
-- config and returns the resulting module

local Packages = script.Parent.Parent
local initializeReconciler = require(Packages.ReactReconciler)

local ReactRobloxHostConfig = require(script.Parent.client.ReactRobloxHostConfig)

return initializeReconciler(ReactRobloxHostConfig)
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000632d</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBXE10517BEF1AE407489636BB20FAA750C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">client</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000632e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXE727D842EA2F4A449B5E1AC91C173C91">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactRoblox</string>
									<string name="ScriptGuid">{BAA37EE8-A4A4-4811-8FBC-C7A33E5DA389}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOM.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local Packages = script.Parent.Parent.Parent

local ReactTypes = require(Packages.Shared)
type ReactNodeList = ReactTypes.ReactNodeList
local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type Container = ReactRobloxHostTypes.Container

-- local '../shared/checkReact'
-- local ReactRobloxLegacy = require(script.Parent.ReactRobloxLegacy)
-- local findDOMNode = ReactRobloxLegacy.findDOMNode
-- local render = ReactRobloxLegacy.render
-- local hydrate = ReactRobloxLegacy.hydrate
-- local unstable_renderSubtreeIntoContainer = ReactRobloxLegacy.unstable_renderSubtreeIntoContainer
-- local unmountComponentAtNode = ReactRobloxLegacy.unmountComponentAtNode

local ReactRobloxRoot
ReactRobloxRoot = require(script.Parent.ReactRobloxRoot)
local createRoot = ReactRobloxRoot.createRoot
local createBlockingRoot = ReactRobloxRoot.createBlockingRoot
local createLegacyRoot = ReactRobloxRoot.createLegacyRoot
local isValidContainer = ReactRobloxRoot.isValidContainer
-- local createEventHandle = require(script.Parent.ReactDOMEventHandle).createEventHandle

-- deviation: Use the config-injecting entry point for the reconciler
local ReactReconciler = require(script.Parent.Parent["ReactReconciler.roblox"])
-- local batchedEventUpdates = ReactReconciler.batchedEventUpdates
local batchedUpdates = ReactReconciler.batchedUpdates
-- local discreteUpdates = ReactReconciler.discreteUpdates
-- local flushDiscreteUpdates = ReactReconciler.flushDiscreteUpdates
-- local flushSync = ReactReconciler.flushSync
-- local flushControlled = ReactReconciler.flushControlled
local injectIntoDevTools = ReactReconciler.injectIntoDevTools
local flushPassiveEffects = ReactReconciler.flushPassiveEffects
local IsThisRendererActing = ReactReconciler.IsThisRendererActing
-- local attemptSynchronousHydration = ReactReconciler.attemptSynchronousHydration
-- local attemptUserBlockingHydration = ReactReconciler.attemptUserBlockingHydration
-- local attemptContinuousHydration = ReactReconciler.attemptContinuousHydration
-- local attemptHydrationAtCurrentPriority = ReactReconciler.attemptHydrationAtCurrentPriority
-- local runWithPriority = ReactReconciler.runWithPriority
-- local getCurrentUpdateLanePriority = ReactReconciler.getCurrentUpdateLanePriority

local createPortalImpl = ReactReconciler.createPortal
-- local canUseDOM = require(Packages.Shared).ExecutionEnvironment.canUseDOM
local ReactVersion = require(Packages.Shared).ReactVersion
local invariant = require(Packages.Shared).invariant
local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- local warnUnstableRenderSubtreeIntoContainer = ReactFeatureFlags.warnUnstableRenderSubtreeIntoContainer
local enableNewReconciler = ReactFeatureFlags.enableNewReconciler

local ReactRobloxComponentTree = require(script.Parent.ReactRobloxComponentTree)
local getInstanceFromNode = ReactRobloxComponentTree.getInstanceFromNode
local getNodeFromInstance = ReactRobloxComponentTree.getNodeFromInstance
local getFiberCurrentPropsFromNode = ReactRobloxComponentTree.getFiberCurrentPropsFromNode
local getClosestInstanceFromNode = ReactRobloxComponentTree.getClosestInstanceFromNode
-- local restoreControlledState = require(script.Parent.ReactRobloxComponent).restoreControlledState

-- local ReactDOMEventReplaying = require(Packages.Parent.Parent.events.ReactDOMEventReplaying)
-- local setAttemptSynchronousHydration = ReactDOMEventReplaying.setAttemptSynchronousHydration
-- local setAttemptUserBlockingHydration = ReactDOMEventReplaying.setAttemptUserBlockingHydration
-- local setAttemptContinuousHydration = ReactDOMEventReplaying.setAttemptContinuousHydration
-- local setAttemptHydrationAtCurrentPriority = ReactDOMEventReplaying.setAttemptHydrationAtCurrentPriority
-- local queueExplicitHydrationTarget = ReactDOMEventReplaying.queueExplicitHydrationTarget
-- local setGetCurrentUpdatePriority = ReactDOMEventReplaying.setGetCurrentUpdatePriority
-- local setAttemptHydrationAtPriority = ReactDOMEventReplaying.setAttemptHydrationAtPriority

-- local setBatchingImplementation = require(Packages.Parent.Parent.events.ReactDOMUpdateBatching).setBatchingImplementation
-- local ReactDOMControlledComponent = require(script.Parent.Parent.events.ReactDOMControlledComponent)
-- local setRestoreImplementation = ReactDOMControlledComponent.setRestoreImplementation
-- local enqueueStateRestore = ReactDOMControlledComponent.enqueueStateRestore
-- local restoreStateIfNeeded = ReactDOMControlledComponent.restoreStateIfNeeded

local Event = require(Packages.Shared).Event
local Change = require(Packages.Shared).Change
local Tag = require(Packages.Shared).Tag

-- setAttemptSynchronousHydration(attemptSynchronousHydration)
-- setAttemptUserBlockingHydration(attemptUserBlockingHydration)
-- setAttemptContinuousHydration(attemptContinuousHydration)
-- setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority)
-- setGetCurrentUpdatePriority(getCurrentUpdateLanePriority)
-- setAttemptHydrationAtPriority(runWithPriority)

-- local didWarnAboutUnstableCreatePortal = false
-- local didWarnAboutUnstableRenderSubtreeIntoContainer = false

-- deviation: Built-ins for maps and sets are not required
-- if _G.__DEV__ then
--   if
--     typeof Map ~= 'function' or
--     -- $FlowIssue Flow incorrectly thinks Map has no prototype
--     Map.prototype == nil or
--     typeof Map.prototype.forEach ~= 'function' or
--     typeof Set ~= 'function' or
--     -- $FlowIssue Flow incorrectly thinks Set has no prototype
--     Set.prototype == nil or
--     typeof Set.prototype.clear ~= 'function' or
--     typeof Set.prototype.forEach ~= 'function'
--   )
--     console.error(
--       'React depends on Map and Set built-in types. Make sure that you load a ' +
--         'polyfill in older browsers. https://reactjs.org/link/react-polyfills',
--     )
--   end
-- end

-- setRestoreImplementation(restoreControlledState)
-- setBatchingImplementation(
--   batchedUpdates,
--   discreteUpdates,
--   flushDiscreteUpdates,
--   batchedEventUpdates
-- )

local function createPortal(children: ReactNodeList, container: Container, key: string?): any
	-- ): React$Portal
	invariant(
		isValidContainer(container),
		-- deviation: Use roblox engine terminology
		"Target container is not a Roblox Instance."
	)
	-- TODO: pass ReactDOM portal implementation as third argument
	-- $FlowFixMe The Flow type is opaque but there's no way to actually create it.
	-- FIXME: luau doesn't realize that this function errors, and it's
	-- expecting us to return something. Can be removed when implementation is
	-- done.
	return createPortalImpl(children, container, nil, key)
end

-- local function scheduleHydration(target: any)
--   if target then
--     queueExplicitHydrationTarget(target)
--   end
-- end

-- local function renderSubtreeIntoContainer(
--   parentComponent: React$Component<any, any>,
--   element: React$Element<any>,
--   containerNode: Container,
--   callback: ?Function,
-- )
-- local function renderSubtreeIntoContainer(
--   parentComponent: any,
--   element: any,
--   containerNode: Container,
--   callback: any
-- )
--   if _G.__DEV__ then
--     if
--       warnUnstableRenderSubtreeIntoContainer and
--       not didWarnAboutUnstableRenderSubtreeIntoContainer
--     then
--       didWarnAboutUnstableRenderSubtreeIntoContainer = true
--       console.warn(
--         "ReactDOM.unstable_renderSubtreeIntoContainer() is deprecated " ..
--           "and will be removed in a future major release. Consider using " ..
--           "React Portals instead."
--       )
--     end
--   end
--   return unstable_renderSubtreeIntoContainer(
--     parentComponent,
--     element,
--     containerNode,
--     callback
--   )
-- end

-- local function unstable_createPortal(
--   children: ReactNodeList,
--   container: Container,
--   key: string?
-- )
--   if _G.__DEV__ then
--     if not didWarnAboutUnstableCreatePortal then
--       didWarnAboutUnstableCreatePortal = true
--       console.warn(
--         "The ReactDOM.unstable_createPortal() alias has been deprecated, " ..
--           "and will be removed in React 18+. Update your code to use " ..
--           "ReactDOM.createPortal() instead. It has the exact same API, " ..
--           "but without the \"unstable_\" prefix."
--       )
--     end
--   end
--   return createPortal(children, container, key)
-- end

local Internals = {
	-- Keep in sync with ReactTestUtils.js, and ReactTestUtilsAct.js.
	-- This is an array for better minification.
	Events = {
		getInstanceFromNode = getInstanceFromNode,
		getNodeFromInstance = getNodeFromInstance,
		getFiberCurrentPropsFromNode = getFiberCurrentPropsFromNode,
		-- enqueueStateRestore = enqueueStateRestore,
		-- restoreStateIfNeeded = restoreStateIfNeeded,
		flushPassiveEffects = flushPassiveEffects,
		-- TODO: This is related to `act`, not events. Move to separate key?
		IsThisRendererActing = IsThisRendererActing,
	},
}

local exports = {
	createPortal = createPortal,
	unstable_batchedUpdates = batchedUpdates,
	-- flushSync = flushSync,
	__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals,
	version = ReactVersion,
	-- Disabled behind disableLegacyReactDOMAPIs
	-- findDOMNode = findDOMNode,
	-- hydrate = hydrate,
	-- render = render,
	-- unmountComponentAtNode = unmountComponentAtNode,
	-- exposeConcurrentModeAPIs
	createRoot = createRoot,
	createBlockingRoot = createBlockingRoot,
	createLegacyRoot = createLegacyRoot,
	-- unstable_flushControlled = flushControlled,
	-- unstable_scheduleHydration = scheduleHydration,
	-- Disabled behind disableUnstableRenderSubtreeIntoContainer
	-- unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer,
	-- Disabled behind disableUnstableCreatePortal
	-- Temporary alias since we already shipped React 16 RC with it.
	-- TODO: remove in React 18.
	-- unstable_createPortal = unstable_createPortal,
	-- enableCreateEventHandleAPI
	-- unstable_createEventHandle = createEventHandle,
	-- TODO: Remove this once callers migrate to alternatives.
	-- This should only be used by React internals.
	-- unstable_runWithPriority = runWithPriority,

	-- deviation: Export logic attached from Roact

	-- FIXME: Is there a better way to provide this? Exposing these here
	-- means that a large number of react components that wouldn't otherwise need
	-- to import `ReactRoblox` will need to do so in order to set events/change
	Event = Event,
	Change = Change,
	Tag = Tag,
	unstable_isNewReconciler = enableNewReconciler,

	-- deviation: Export `act` function for testing purposes; in
	-- production (a.k.a. scheduler isn't mocked), give an instructive error
	act = function(_: () -> ()): ()
		error(
			"ReactRoblox.act is only available in testing environments, not "
				.. "production. Enable the `__ROACT_17_MOCK_SCHEDULER__` global in your "
				.. "test configuration in order to use `act`."
		)
	end,
}

if _G.__ROACT_17_MOCK_SCHEDULER__ then
	-- deviation: When the __ROACT_17_MOCK_SCHEDULER__ is enabled, we
	-- re-export the `act` function from ReactReconciler. The global will
	-- additionally force the scheduler to use the mock interface
	exports.act = ReactReconciler.act
end

-- deviation: we don't currently implement the logic below that uses this
-- value
local _foundDevTools = injectIntoDevTools({
	findFiberByHostInstance = getClosestInstanceFromNode,
	bundleType = if _G.__DEV__ then 1 else 0,
	version = ReactVersion,
	rendererPackageName = "ReactRoblox",
})

if _G.__DEV__ then
	-- if not foundDevTools and canUseDOM and window.top == window.self then
	--   If we're in Chrome or Firefox, provide a download link if not installed.
	--   if
	--     (navigator.userAgent.indexOf('Chrome') > -1 and
	--       navigator.userAgent.indexOf('Edge') == -1) or
	--     navigator.userAgent.indexOf('Firefox') > -1
	--   )
	--     local protocol = window.location.protocol
	--     -- Don't warn in exotic cases like chrome-extension://.
	--     if /^(https?|file):$/.test(protocol))
	--       -- eslint-disable-next-line react-internal/no-production-logging
	--       console.info(
	--         '%cDownload the React DevTools ' +
	--           'for a better development experience: ' +
	--           'https://reactjs.org/link/react-devtools' +
	--           (protocol == 'file:'
	--             ? '\nYou might need to use a local HTTP server (instead of file://): ' +
	--               'https://reactjs.org/link/react-devtools-faq'
	--             : ''),
	--         'font-weight:bold',
	--       )
	--     end
	--   end
	-- end
end

return exports
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed0000632f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX8A54AC8CD12942D2943298F8AC7B9ADD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactRobloxComponent</string>
									<string name="ScriptGuid">{5DB73FD2-25C3-45CD-B6C9-DD541CE0E874}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMComponent.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object

local RobloxComponentProps = require(script.Parent.roblox.RobloxComponentProps)

local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type HostInstance = ReactRobloxHostTypes.HostInstance

-- deviation: Essentially a placeholder for dom-specific logic, taking the place
-- of ReactDOMComponent. Most of the logic will differ pretty dramatically

type Array<T> = { [number]: T }
type Object = { [any]: any }

local exports: { [string]: any } = {}

exports.setInitialProperties = RobloxComponentProps.setInitialProperties

-- Calculate the diff between the two objects.
local function diffProperties(
	domElement: HostInstance,
	tag: string,
	lastRawProps: Object,
	nextRawProps: Object,
	rootContainerElement: HostInstance
): (nil | Array<any>)
	-- if _G.__DEV__ then
	--   validatePropertiesInDevelopment(tag, nextRawProps)
	-- end

	-- FIXME: Type refinement
	-- local updatePayload: nil | Array<any> = nil
	local updatePayload = nil

	local lastProps = lastRawProps
	local nextProps = nextRawProps
	-- local lastProps: Object
	-- local nextProps: Object
	-- switch (tag) {
	--   case 'input':
	--     lastProps = ReactDOMInputGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMInputGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   case 'option':
	--     lastProps = ReactDOMOptionGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMOptionGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   case 'select':
	--     lastProps = ReactDOMSelectGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMSelectGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   case 'textarea':
	--     lastProps = ReactDOMTextareaGetHostProps(domElement, lastRawProps);
	--     nextProps = ReactDOMTextareaGetHostProps(domElement, nextRawProps);
	--     updatePayload = [];
	--     break;
	--   default:
	--     lastProps = lastRawProps;
	--     nextProps = nextRawProps;
	--     if (
	--       typeof lastProps.onClick !== 'function' &&
	--       typeof nextProps.onClick === 'function'
	--     ) {
	--       // TODO: This cast may not be sound for SVG, MathML or custom elements.
	--       trapClickOnNonInteractiveElement(((domElement: any): HTMLElement));
	--     }
	--     break;
	-- }

	-- assertValidProps(tag, nextProps);

	-- let propKey;
	-- let styleName;
	-- let styleUpdates = null;
	for propKey, _ in lastProps do
		if nextProps[propKey] ~= nil then
			continue
		end
		-- if (propKey === STYLE) {
		--   const lastStyle = lastProps[propKey];
		--   for (styleName in lastStyle) {
		--     if (lastStyle.hasOwnProperty(styleName)) {
		--       if (!styleUpdates) {
		--         styleUpdates = {};
		--       }
		--       styleUpdates[styleName] = '';
		--     }
		--   }
		-- } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) {
		--   // Noop. This is handled by the clear text mechanism.
		-- } else if (
		--   propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
		--   propKey === SUPPRESS_HYDRATION_WARNING
		-- ) {
		--   // Noop
		-- } else if (propKey === AUTOFOCUS) {
		--   // Noop. It doesn't work on updates anyway.
		-- } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
		--   // This is a special case. If any listener updates we need to ensure
		--   // that the "current" fiber pointer gets updated so we need a commit
		--   // to update this element.
		--   if (!updatePayload) {
		--     updatePayload = [];
		--   }
		-- } else {
		-- For all other deleted properties we add it to the queue. We use
		-- the allowed property list in the commit phase instead.
		-- performance: prealloc table size 2 for these 2 items at least
		updatePayload = updatePayload or table.create(2)
		table.insert(updatePayload, propKey)
		table.insert(updatePayload, Object.None)
		-- }
	end
	for propKey, nextProp in nextProps do
		local lastProp = if lastProps ~= nil then lastProps[propKey] else nil
		if nextProp == lastProp then
			continue
		end
		-- if (propKey === STYLE) {
		--   if (__DEV__) {
		--     if (nextProp) {
		--       // Freeze the next style object so that we can assume it won't be
		--       // mutated. We have already warned for this in the past.
		--       Object.freeze(nextProp);
		--     }
		--   }
		--   if (lastProp) {
		--     // Unset styles on `lastProp` but not on `nextProp`.
		--     for (styleName in lastProp) {
		--       if (
		--         lastProp.hasOwnProperty(styleName) &&
		--         (!nextProp || !nextProp.hasOwnProperty(styleName))
		--       ) {
		--         if (!styleUpdates) {
		--           styleUpdates = {};
		--         }
		--         styleUpdates[styleName] = '';
		--       }
		--     }
		--     // Update styles that changed since `lastProp`.
		--     for (styleName in nextProp) {
		--       if (
		--         nextProp.hasOwnProperty(styleName) &&
		--         lastProp[styleName] !== nextProp[styleName]
		--       ) {
		--         if (!styleUpdates) {
		--           styleUpdates = {};
		--         }
		--         styleUpdates[styleName] = nextProp[styleName];
		--       }
		--     }
		--   } else {
		--     // Relies on `updateStylesByID` not mutating `styleUpdates`.
		--     if (!styleUpdates) {
		--       if (!updatePayload) {
		--         updatePayload = [];
		--       }
		--       updatePayload.push(propKey, styleUpdates);
		--     }
		--     styleUpdates = nextProp;
		--   }
		-- } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
		--   const nextHtml = nextProp ? nextProp[HTML] : undefined;
		--   const lastHtml = lastProp ? lastProp[HTML] : undefined;
		--   if (nextHtml != null) {
		--     if (lastHtml !== nextHtml) {
		--       (updatePayload = updatePayload || []).push(propKey, nextHtml);
		--     }
		--   } else {
		--     // TODO: It might be too late to clear this if we have children
		--     // inserted already.
		--   }
		-- } else if (propKey === CHILDREN) {
		--   if (typeof nextProp === 'string' || typeof nextProp === 'number') {
		--     (updatePayload = updatePayload || []).push(propKey, '' + nextProp);
		--   }
		-- } else if (
		--   propKey === SUPPRESS_CONTENT_EDITABLE_WARNING ||
		--   propKey === SUPPRESS_HYDRATION_WARNING
		-- ) {
		--   // Noop
		-- } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
		--   if (nextProp != null) {
		--     // We eagerly listen to this even though we haven't committed yet.
		--     if (__DEV__ && typeof nextProp !== 'function') {
		--       warnForInvalidEventListener(propKey, nextProp);
		--     }
		--     if (!enableEagerRootListeners) {
		--       ensureListeningTo(rootContainerElement, propKey, domElement);
		--     } else if (propKey === 'onScroll') {
		--       listenToNonDelegatedEvent('scroll', domElement);
		--     }
		--   }
		--   if (!updatePayload && lastProp !== nextProp) {
		--     // This is a special case. If any listener updates we need to ensure
		--     // that the "current" props pointer gets updated so we need a commit
		--     // to update this element.
		--     updatePayload = [];
		--   }
		-- } else if (
		--   typeof nextProp === 'object' &&
		--   nextProp !== null &&
		--   nextProp.$$typeof === REACT_OPAQUE_ID_TYPE
		-- ) {
		--   // If we encounter useOpaqueReference's opaque object, this means we are hydrating.
		--   // In this case, call the opaque object's toString function which generates a new client
		--   // ID so client and server IDs match and throws to rerender.
		--   nextProp.toString();
		-- } else {
		-- For any other property we always add it to the queue and then we
		-- filter it out using the allowed property list during the commit.
		-- performance: prealloc table size 2 for these 2 items at least
		-- performance TODO: don't create a table here, return multiple values!
		updatePayload = updatePayload or table.create(2)
		table.insert(updatePayload, propKey)
		table.insert(updatePayload, nextProp)
		-- }
	end
	-- if (styleUpdates) {
	--   if (__DEV__) {
	--     validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
	--   }
	--   (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
	-- }
	return updatePayload
end
exports.diffProperties = diffProperties
exports.updateProperties = RobloxComponentProps.updateProperties
exports.cleanupHostComponent = RobloxComponentProps.cleanupHostComponent

return exports
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006330</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4A6B0F0E59E445BFB0610199D877E0B9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactRobloxComponentTree</string>
									<string name="ScriptGuid">{5F8F0EFB-361E-417C-A834-92E76F2CA55F}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMComponentTree.js
-- upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/src/ReactNativeComponentTree.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent.Parent

local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type HostInstance = ReactRobloxHostTypes.HostInstance
type TextInstance = ReactRobloxHostTypes.TextInstance
type SuspenseInstance = ReactRobloxHostTypes.SuspenseInstance
type Container = ReactRobloxHostTypes.Container
type Props = ReactRobloxHostTypes.Props

local ReactInternalTypes = require(Packages.ReactReconciler)
type Fiber = ReactInternalTypes.Fiber
local Shared = require(Packages.Shared)
type ReactScopeInstance = Shared.ReactScopeInstance
-- local type {
--   ReactDOMEventHandle,
--   ReactDOMEventHandleListener,
-- } = require(Packages.../shared/ReactDOMTypes'
-- local type {
--   Container,
--   TextInstance,
--   Instance,
--   SuspenseInstance,
--   Props,
-- } = require(Packages../ReactDOMHostConfig'

local ReactWorkTags
local HostComponent
local HostText
local HostRoot
local SuspenseComponent

local getParentSuspenseInstance
local invariant = Shared.invariant
-- local {enableScopeAPI} = require(Packages.shared/ReactFeatureFlags'

local exports: { [any]: any } = {}

-- deviation: Use internal maps, since we can't set properties on Containers
-- (which are Instances). We might consider using the Attributes feature for
-- this when it releases
local containerToRoot: { [Container]: Fiber } = {}
local instanceToFiber: { [HostInstance | SuspenseInstance | ReactScopeInstance]: Fiber } = {}
local instanceToProps: { [HostInstance | SuspenseInstance]: Props } = {}

local randomKey = string.sub(tostring(math.random()), 3)
local internalInstanceKey = "__reactFiber$" .. randomKey
local internalContainerInstanceKey = "__reactContainer$" .. randomKey
-- local internalPropsKey = "__reactProps$" .. randomKey
-- local internalEventHandlersKey = '__reactEvents$' + randomKey
-- local internalEventHandlerListenersKey = '__reactListeners$' + randomKey
-- local internalEventHandlesSetKey = '__reactHandles$' + randomKey

exports.precacheFiberNode = function(hostInst: Fiber, node: HostInstance | SuspenseInstance | ReactScopeInstance)
	instanceToFiber[node] = hostInst
end

exports.uncacheFiberNode = function(node: HostInstance | SuspenseInstance | ReactScopeInstance)
	instanceToFiber[node] = nil
	instanceToProps[node] = nil
end

exports.markContainerAsRoot = function(hostRoot: Fiber, node: Container)
	-- deviation: Use our module-level map
	containerToRoot[node] = hostRoot
	-- node[internalContianerInstanceKey] = hostRoot
end

exports.unmarkContainerAsRoot = function(node: Container)
	-- deviation: Use our module-level map
	containerToRoot[node] = nil
	-- node[internalContainerInstanceKey] = nil
end

exports.isContainerMarkedAsRoot = function(node: Container): boolean
	-- deviation: Use our module-level map
	return not not containerToRoot[node]
	-- return not not node[internalContainerInstanceKey]
end

-- Given a Roblox node, return the closest HostComponent or HostText fiber ancestor.
-- If the target node is part of a hydrated or not yet rendered subtree, then
-- this may also return a SuspenseComponent or HostRoot to indicate that.
-- Conceptually the HostRoot fiber is a child of the Container node. So if you
-- pass the Container node as the targetNode, you will not actually get the
-- HostRoot back. To get to the HostRoot, you need to pass a child of it.
-- The same thing applies to Suspense boundaries.
-- TODO: This function is untested and may not work!
exports.getClosestInstanceFromNode = function(targetNode: Instance): Fiber?
	-- deviation: Use internal maps since we can't set properties on Containers
	local targetInst = instanceToFiber[targetNode]
	if targetInst then
		-- Don't return HostRoot or SuspenseComponent here.
		return targetInst
	end
	-- If the direct event target isn't a React owned DOM node, we need to look
	-- to see if one of its parents is a React owned DOM node.
	local parentNode = targetNode.Parent
	while parentNode do
		-- We'll check if this is a container root that could include
		-- React nodes in the future. We need to check this first because
		-- if we're a child of a dehydrated container, we need to first
		-- find that inner container before moving on to finding the parent
		-- instance. Note that we don't check this field on  the targetNode
		-- itself because the fibers are conceptually between the container
		-- node and the first child. It isn't surrounding the container node.
		-- If it's not a container, we check if it's an instance.
		targetInst = instanceToFiber[parentNode]
		if targetInst then
			-- Since this wasn't the direct target of the event, we might have
			-- stepped past dehydrated DOM nodes to get here. However they could
			-- also have been non-React nodes. We need to answer which one.
			-- If we the instance doesn't have any children, then there can't be
			-- a nested suspense boundary within it. So we can use this as a fast
			-- bailout. Most of the time, when people add non-React children to
			-- the tree, it is using a ref to a child-less DOM node.
			-- Normally we'd only need to check one of the fibers because if it
			-- has ever gone from having children to deleting them or vice versa
			-- it would have deleted the dehydrated boundary nested inside already.
			-- However, since the HostRoot starts out with an alternate it might
			-- have one on the alternate so we need to check in case this was a
			-- root.
			local alternate = targetInst.alternate
			if targetInst.child ~= nil or (alternate ~= nil and alternate.child ~= nil) then
				-- deviation: lazy initialize to work around circular dependency
				if getParentSuspenseInstance == nil then
					getParentSuspenseInstance = (require(script.Parent.ReactRobloxHostConfig) :: any).getParentSuspenseInstance
				end

				-- Next we need to figure out if the node that skipped past is
				-- nested within a dehydrated boundary and if so, which one.
				local suspenseInstance = getParentSuspenseInstance(targetNode)
				while suspenseInstance ~= nil do
					-- We found a suspense instance. That means that we haven't
					-- hydrated it yet. Even though we leave the comments in the
					-- DOM after hydrating, and there are boundaries in the DOM
					-- that could already be hydrated, we wouldn't have found them
					-- through this pass since if the target is hydrated it would
					-- have had an internalInstanceKey on it.
					-- Let's get the fiber associated with the SuspenseComponent
					-- as the deepest instance.
					local targetSuspenseInst = instanceToFiber[suspenseInstance]
					if targetSuspenseInst then
						return targetSuspenseInst
					end
					-- If we don't find a Fiber on the comment, it might be because
					-- we haven't gotten to hydrate it yet. There might still be a
					-- parent boundary that hasn't above this one so we need to find
					-- the outer most that is known.
					suspenseInstance = getParentSuspenseInstance(suspenseInstance)
					-- If we don't find one, then that should mean that the parent
					-- host component also hasn't hydrated yet. We can return it
					-- below since it will bail out on the isMounted check later.
				end
			end
			return targetInst
		end
		targetNode = parentNode
		parentNode = targetNode.Parent
	end
	return nil
end

--[[*
 * Given a Roblox node, return the Roblox Component
 * instance, or nil if the node was not rendered by this React.
 ]]
exports.getInstanceFromNode = function(node): Fiber?
	-- deviation: lazy initialize to avoid circular dependency
	if ReactWorkTags == nil then
		local ReactReconciler = require(script.Parent.Parent["ReactReconciler.roblox"]) :: any
		ReactWorkTags = ReactReconciler.ReactWorkTags

		HostComponent = ReactWorkTags.HostComponent
		HostText = ReactWorkTags.HostComponent
		HostRoot = ReactWorkTags.HostComponent
		SuspenseComponent = ReactWorkTags.HostComponent
	end

	local inst = (node :: any)[internalInstanceKey] or (node :: any)[internalContainerInstanceKey]
	if inst then
		if
			inst.tag == HostComponent
			or inst.tag == HostText
			or inst.tag == SuspenseComponent
			or inst.tag == HostRoot
		then
			return inst
		else
			return nil
		end
	end
	return nil
end

--[[*
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 ]]
exports.getNodeFromInstance = function(inst: Fiber): Instance | TextInstance
	if inst.tag == HostComponent or inst.tag == HostText then
		-- In Fiber this, is just the state node right now. We assume it will be
		-- a host component or host text.
		return inst.stateNode
	end

	-- Without this first invariant, passing a non-DOM-component triggers the next
	-- invariant for a missing parent, which is super confusing.
	invariant(false, "getNodeFromInstance: Invalid argument.")
	-- deviation: Luau analysis doesn't understand that invariant(false,...) is always-throw
	error("getNodeFromInstance: Invalid argument.")
end

exports.getFiberCurrentPropsFromNode = function(node: Instance | TextInstance | SuspenseInstance): Props
	return instanceToProps[node]
end

exports.updateFiberProps = function(node: Instance | SuspenseInstance, props: Props)
	instanceToProps[node] = props
end

-- exports.getEventListenerSet(node: EventTarget): Set<string> {
--   local elementListenerSet = (node: any)[internalEventHandlersKey]
--   if elementListenerSet == undefined)
--     elementListenerSet = (node: any)[internalEventHandlersKey] = new Set()
--   end
--   return elementListenerSet
-- end

-- exports.getFiberFromScopeInstance(
--   scope: ReactScopeInstance,
-- ): nil | Fiber {
--   if enableScopeAPI)
--     return (scope: any)[internalInstanceKey] or nil
--   end
--   return nil
-- end

-- exports.setEventHandlerListeners(
--   scope: EventTarget | ReactScopeInstance,
--   listeners: Set<ReactDOMEventHandleListener>,
-- ): void {
--   (scope: any)[internalEventHandlerListenersKey] = listeners
-- end

-- exports.getEventHandlerListeners(
--   scope: EventTarget | ReactScopeInstance,
-- ): nil | Set<ReactDOMEventHandleListener> {
--   return (scope: any)[internalEventHandlerListenersKey] or nil
-- end

-- exports.addEventHandleToTarget(
--   target: EventTarget | ReactScopeInstance,
--   eventHandle: ReactDOMEventHandle,
-- ): void {
--   local eventHandles = (target: any)[internalEventHandlesSetKey]
--   if eventHandles == undefined)
--     eventHandles = (target: any)[internalEventHandlesSetKey] = new Set()
--   end
--   eventHandles.add(eventHandle)
-- end

-- exports.doesTargetHaveEventHandle(
--   target: EventTarget | ReactScopeInstance,
--   eventHandle: ReactDOMEventHandle,
-- ): boolean {
--   local eventHandles = (target: any)[internalEventHandlesSetKey]
--   if eventHandles == undefined)
--     return false
--   end
--   return eventHandles.has(eventHandle)
-- end

return exports
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006331</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX461B469B8E7D47AF8E1DA775E34F2EAC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactRobloxHostConfig</string>
									<string name="ScriptGuid">{1141BD8C-21CD-44CF-98AE-A66DFD6806DE}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMHostConfig.js
-- upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/src/ReactNativeHostConfig.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
-- FIXME (roblox): remove this when our unimplemented
local function unimplemented(message: string)
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
	print("UNIMPLEMENTED ERROR: " .. tostring(message))
	error("FIXME (roblox): " .. message .. " is unimplemented", 2)
end

local CollectionService = game:GetService("CollectionService")
local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local inspect = LuauPolyfill.util.inspect
local console = require(Packages.Shared).console
local Object = LuauPolyfill.Object
local setTimeout = LuauPolyfill.setTimeout
local clearTimeout = LuauPolyfill.clearTimeout

-- local type {DOMEventName} = require(Packages.../events/DOMEventNames'
-- local type {Fiber, FiberRoot} = require(Packages.react-reconciler/src/ReactInternalTypes'
-- local type {
--   BoundingRect,
--   IntersectionObserverOptions,
--   ObserveVisibleRectsCallback,
-- } = require(Packages.react-reconciler/src/ReactTestSelectors'
local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type RootType = ReactRobloxHostTypes.RootType
type Container = ReactRobloxHostTypes.Container
type HostInstance = ReactRobloxHostTypes.HostInstance
type SuspenseInstance = ReactRobloxHostTypes.SuspenseInstance
type TextInstance = ReactRobloxHostTypes.TextInstance
type Props = ReactRobloxHostTypes.Props
type Type = ReactRobloxHostTypes.Type
type HostContext = ReactRobloxHostTypes.HostContext

-- local type {ReactScopeInstance} = require(Packages.shared/ReactTypes'
-- local type {ReactDOMFundamentalComponentInstance} = require(Packages.../shared/ReactDOMTypes'

local ReactRobloxComponentTree = require(script.Parent.ReactRobloxComponentTree)
local precacheFiberNode = ReactRobloxComponentTree.precacheFiberNode
local uncacheFiberNode = ReactRobloxComponentTree.uncacheFiberNode
local updateFiberProps = ReactRobloxComponentTree.updateFiberProps
-- local getClosestInstanceFromNode = ReactRobloxComponentTree.getClosestInstanceFromNode
-- local getFiberFromScopeInstance = ReactRobloxComponentTree.getFiberFromScopeInstance
-- local getInstanceFromNodeDOMTree = ReactRobloxComponentTree.getInstanceFromNode
-- local isContainerMarkedAsRoot = ReactRobloxComponentTree.isContainerMarkedAsRoot

-- local {hasRole} = require(Packages../DOMAccessibilityRoles'
local ReactRobloxComponent = require(script.Parent.ReactRobloxComponent)
-- local createElement = ReactRobloxComponent.createElement
-- local createTextNode = ReactRobloxComponent.createTextNode
local setInitialProperties = ReactRobloxComponent.setInitialProperties
local diffProperties = ReactRobloxComponent.diffProperties
local updateProperties = ReactRobloxComponent.updateProperties
local cleanupHostComponent = ReactRobloxComponent.cleanupHostComponent
-- local diffHydratedProperties = ReactRobloxComponent.diffHydratedProperties
-- local diffHydratedText = ReactRobloxComponent.diffHydratedText
-- local trapClickOnNonInteractiveElement = ReactRobloxComponent.trapClickOnNonInteractiveElement
-- local warnForUnmatchedText = ReactRobloxComponent.warnForUnmatchedText
-- local warnForDeletedHydratableElement = ReactRobloxComponent.warnForDeletedHydratableElement
-- local warnForDeletedHydratableText = ReactRobloxComponent.warnForDeletedHydratableText
-- local warnForInsertedHydratedElement = ReactRobloxComponent.warnForInsertedHydratedElement
-- local warnForInsertedHydratedText = ReactRobloxComponent.warnForInsertedHydratedText
-- local {getSelectionInformation, restoreSelection} = require(Packages../ReactInputSelection'
-- local setTextContent = require(Packages../setTextContent'
-- local {validateDOMNesting, updatedAncestorInfo} = require(Packages../validateDOMNesting'
-- local {
--   isEnabled as ReactBrowserEventEmitterIsEnabled,
--   setEnabled as ReactBrowserEventEmitterSetEnabled,
-- } = require(Packages.../events/ReactDOMEventListener'
-- local {getChildNamespace} = require(Packages.../shared/DOMNamespaces'
-- local {
--   ELEMENT_NODE,
--   TEXT_NODE,
--   COMMENT_NODE,
--   DOCUMENT_NODE,
--   DOCUMENT_FRAGMENT_NODE,
-- } = require(Packages.../shared/HTMLNodeType'
-- local dangerousStyleValue = require(Packages.../shared/dangerousStyleValue'

-- local {REACT_OPAQUE_ID_TYPE} = require(Packages.shared/ReactSymbols'
-- local {retryIfBlockedOn} = require(Packages.../events/ReactDOMEventReplaying'

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
-- local enableSuspenseServerRenderer = ReactFeatureFlags.enableSuspenseServerRenderer
-- local enableFundamentalAPI = ReactFeatureFlags.enableFundamentalAPI
local enableCreateEventHandleAPI = ReactFeatureFlags.enableCreateEventHandleAPI
-- local enableScopeAPI = ReactFeatureFlags.enableScopeAPI
-- local enableEagerRootListeners = ReactFeatureFlags.enableEagerRootListeners

-- local {HostComponent, HostText} = require(Packages.react-reconciler/src/ReactWorkTags'
-- local {
--   listenToReactEvent,
--   listenToAllSupportedEvents,
-- } = require(Packages.../events/DOMPluginEventSystem'

type Array<T> = { [number]: T }
type Object = { [any]: any }

-- deviation: Moved to ReactRobloxHostTypes
-- export type Type = string;
-- export type Props = {
--   autoFocus: boolean?,
--   children: any,
--   disabled: boolean?,
--   hidden: boolean?,
--   suppressHydrationWarning: boolean?,
--   dangerouslySetInnerHTML: any,
--   style: { display: string, [any]: any }?,
--   bottom: number?,
--   left: number?,
--   right: number?,
--   top: number?,
--   -- ...
--   [any]: any,
-- };
-- export type EventTargetChildElement = {
--   type: string,
--   props: nil | {
--     style?: {
--       position?: string,
--       zIndex?: number,
--       bottom?: string,
--       left?: string,
--       right?: string,
--       top?: string,
--       ...
--     },
--     ...
--   },
--   ...
-- end

-- deviation: Moved to ReactRobloxHostTypes
-- export type SuspenseInstance = Comment & {_reactRetry?: () => void, ...}
-- export type HydratableInstance = Instance | TextInstance | SuspenseInstance

-- deviation: Moved to ReactRobloxHostTypes
-- export type PublicInstance = Element | Text
-- type HostContextDev = {
--   namespace: string,
--   ancestorInfo: any,
--   -- ...
--   [any]: any,
-- }
-- type HostContextProd = string
-- export type HostContext = HostContextDev | HostContextProd

-- export type UpdatePayload = Array<mixed>
-- FIXME: cannot create type equal to void
-- export type ChildSet = void; -- Unused
-- export type TimeoutHandle = TimeoutID
-- export type NoTimeout = -1
-- export type RendererInspectionConfig = $ReadOnly<{or}>

-- export opaque type OpaqueIDType =
--   | string
--   | {
--       toString: () => string | void,
--       valueOf: () => string | void,
--     end

-- type SelectionInformation = {|
--   focusedElem: nil | HTMLElement,
--   selectionRange: mixed,
-- |}

-- local SUPPRESS_HYDRATION_WARNING
-- if __DEV__)
--   SUPPRESS_HYDRATION_WARNING = 'suppressHydrationWarning'
-- end

-- local SUSPENSE_START_DATA = '$'
-- local SUSPENSE_END_DATA = '/$'
-- local SUSPENSE_PENDING_START_DATA = '$?'
-- local SUSPENSE_FALLBACK_START_DATA = '$!'

-- local STYLE = 'style'

-- local eventsEnabled: boolean? = nil
-- local selectionInformation: nil | SelectionInformation = nil

-- function shouldAutoFocusHostComponent(type: string, props: Props): boolean {
--   switch (type)
--     case 'button':
--     case 'input':
--     case 'select':
--     case 'textarea':
--       return !!props.autoFocus
--   end
--   return false
-- end

-- deviation: Use GetDescendants rather than recursion
local function recursivelyUncacheFiberNode(node: HostInstance)
	-- ROBLOX https://jira.rbx.com/browse/LUAFDN-713: Tables are somehow ending up
	-- in this function that expects Instances. In that case, we won't be able to
	-- iterate through its descendants.
	if typeof(node :: any) ~= "Instance" then
		return
	end

	uncacheFiberNode(node)

	for _, child in node:GetDescendants() do
		uncacheFiberNode(child)
	end
end

local exports: { [any]: any } = {}
Object.assign(exports, require(Packages.Shared).ReactFiberHostConfig.WithNoPersistence)

exports.getRootHostContext = function(rootContainerInstance: Container): HostContext
	-- deviation: This is a lot of HTML-DOM specific logic; I'm not clear on
	-- whether there'll be an equivalent of `namespaceURI` for our use cases, but
	-- we may want to provide other kinds of context for host objects.

	-- For now, as a guess, we'll return the kind of instance we're attached to
	return rootContainerInstance.ClassName

	-- local type
	-- local namespace
	-- local nodeType = rootContainerInstance.nodeType
	-- switch (nodeType)
	--   case DOCUMENT_NODE:
	--   case DOCUMENT_FRAGMENT_NODE: {
	--     type = nodeType == DOCUMENT_NODE ? '#document' : '#fragment'
	--     local root = (rootContainerInstance: any).documentElement
	--     namespace = root ? root.namespaceURI : getChildNamespace(null, '')
	--     break
	--   end
	--   default: {
	--     local container: any =
	--       nodeType == COMMENT_NODE
	--         ? rootContainerInstance.parentNode
	--         : rootContainerInstance
	--     local ownNamespace = container.namespaceURI or nil
	--     type = container.tagName
	--     namespace = getChildNamespace(ownNamespace, type)
	--     break
	--   end
	-- end
	-- if _G.__DEV__ then
	--   local validatedTag = type.toLowerCase()
	--   local ancestorInfo = updatedAncestorInfo(null, validatedTag)
	--   return {namespace, ancestorInfo}
	-- end
	-- return namespace
end

exports.getChildHostContext = function(
	parentHostContext: HostContext,
	type: string,
	rootContainerInstance: Container
): HostContext
	-- deviation: unclear on the purpose here just yet, might be fine to
	-- just return parent's hostContext for now
	return parentHostContext
	-- if _G.__DEV__ then
	--   local parentHostContextDev = ((parentHostContext: any): HostContextDev)
	--   local namespace = getChildNamespace(parentHostContextDev.namespace, type)
	--   local ancestorInfo = updatedAncestorInfo(
	--     parentHostContextDev.ancestorInfo,
	--     type,
	--   )
	--   return {namespace, ancestorInfo}
	-- end
	-- local parentNamespace = ((parentHostContext: any): HostContextProd)
	-- return getChildNamespace(parentNamespace, type)
end

exports.getPublicInstance = function(instance: Instance): any
	return instance
end

exports.prepareForCommit = function(containerInfo: Container): Object?
	-- eventsEnabled = ReactBrowserEventEmitterIsEnabled()
	-- selectionInformation = getSelectionInformation()
	local activeInstance = nil
	if enableCreateEventHandleAPI then
		unimplemented("enableCreateEventHandleAPI")
		--   local focusedElem = selectionInformation.focusedElem
		--   if focusedElem ~= nil then
		--     activeInstance = getClosestInstanceFromNode(focusedElem)
		--   end
	end
	-- ReactBrowserEventEmitterSetEnabled(false)
	return activeInstance
end

exports.beforeActiveInstanceBlur = function()
	if enableCreateEventHandleAPI then
		unimplemented("enableCreateEventHandleAPI")
		-- ReactBrowserEventEmitterSetEnabled(true)
		-- dispatchBeforeDetachedBlur((selectionInformation: any).focusedElem)
		-- ReactBrowserEventEmitterSetEnabled(false)
	end
end

exports.afterActiveInstanceBlur = function()
	if enableCreateEventHandleAPI then
		unimplemented("enableCreateEventHandleAPI")
		-- ReactBrowserEventEmitterSetEnabled(true)
		-- dispatchAfterDetachedBlur((selectionInformation: any).focusedElem)
		-- ReactBrowserEventEmitterSetEnabled(false)
	end
end

exports.resetAfterCommit = function(containerInfo: Container)
	-- warn("Skip unimplemented: resetAfterCommit")
	-- restoreSelection(selectionInformation)
	-- ReactBrowserEventEmitterSetEnabled(eventsEnabled)
	-- eventsEnabled = nil
	-- selectionInformation = nil
end

exports.createInstance = function(
	type_: string,
	props: Props,
	rootContainerInstance: Container,
	hostContext: HostContext,
	internalInstanceHandle: Object
): HostInstance
	-- local hostKey = virtualNode.hostKey

	local domElement = Instance.new(type_)
	-- deviation: compatibility with old Roact where instances have their name
	-- set to the key value
	if internalInstanceHandle.key then
		domElement.Name = internalInstanceHandle.key
	else
		local currentHandle = internalInstanceHandle.return_
		while currentHandle do
			if currentHandle.key then
				domElement.Name = currentHandle.key
				break
			end
			currentHandle = currentHandle.return_
		end
	end

	precacheFiberNode(internalInstanceHandle, domElement)
	updateFiberProps(domElement, props)

	-- TODO: Support refs (does that actually happen here, or later?)
	-- applyRef(element.props[Ref], instance)

	-- Will have to be managed outside of createInstance
	-- if virtualNode.eventManager ~= nil then
	--   virtualNode.eventManager:resume()
	-- end

	return domElement

	-- return Instance.new("Frame")
	-- local parentNamespace: string
	-- if __DEV__)
	--   -- TODO: take namespace into account when validating.
	--   local hostContextDev = ((hostContext: any): HostContextDev)
	--   validateDOMNesting(type, nil, hostContextDev.ancestorInfo)
	--   if
	--     typeof props.children == 'string' or
	--     typeof props.children == 'number'
	--   )
	--     local string = '' + props.children
	--     local ownAncestorInfo = updatedAncestorInfo(
	--       hostContextDev.ancestorInfo,
	--       type,
	--     )
	--     validateDOMNesting(null, string, ownAncestorInfo)
	--   end
	--   parentNamespace = hostContextDev.namespace
	-- } else {
	--   parentNamespace = ((hostContext: any): HostContextProd)
	-- end
	-- local domElement: Instance = createElement(
	--   type,
	--   props,
	--   rootContainerInstance,
	--   parentNamespace,
	-- )
end

exports.appendInitialChild = function(parentInstance: Instance, child: Instance)
	-- deviation: Establish hierarchy with Parent property
	child.Parent = parentInstance
end

exports.finalizeInitialChildren = function(
	domElement: HostInstance,
	type_: string,
	props: Props,
	rootContainerInstance: Container,
	hostContext: HostContext
): boolean
	setInitialProperties(domElement, type_, props, rootContainerInstance)
	return false
	-- return shouldAutoFocusHostComponent(type_, props)
end

local function prepareUpdate(
	domElement: Instance,
	type_: string,
	oldProps: Props,
	newProps: Props,
	rootContainerInstance: Container,
	hostContext: HostContext
): nil | Array<any>
	-- if _G.__DEV__ then
	--   local hostContextDev = ((hostContext: any): HostContextDev)
	--   if
	--     typeof newProps.children ~= typeof oldProps.children and
	--     (typeof newProps.children == 'string' or
	--       typeof newProps.children == 'number')
	--   )
	--     local string = '' + newProps.children
	--     local ownAncestorInfo = updatedAncestorInfo(
	--       hostContextDev.ancestorInfo,
	--       type,
	--     )
	--     validateDOMNesting(null, string, ownAncestorInfo)
	--   end
	-- end
	return diffProperties(domElement, type_, oldProps, newProps, rootContainerInstance)
end
exports.prepareUpdate = prepareUpdate

exports.shouldSetTextContent = function(_type: string, _props: Props): boolean
	-- deviation: Ignore TextInstance logic, which isn't applicable to Roblox
	return false
	--   return (
	--     type == 'textarea' or
	--     type == 'option' or
	--     type == 'noscript' or
	--     typeof props.children == 'string' or
	--     typeof props.children == 'number' or
	--     (typeof props.dangerouslySetInnerHTML == 'table’' and
	--       props.dangerouslySetInnerHTML ~= nil and
	--       props.dangerouslySetInnerHTML.__html ~= nil)
	--   )
end

-- deviation: Text nodes aren't supported in Roblox renderer, so error so that tests fail immediately
exports.createTextInstance = function(
	text: string,
	rootContainerInstance: Container,
	hostContext: HostContext,
	internalInstanceHandle: Object
): any
	unimplemented("createTextInstance")
	return nil
end

exports.isPrimaryRenderer = true
exports.warnsIfNotActing = true
-- This initialization code may run even on server environments
-- if a component just imports ReactDOM (e.g. for findDOMNode).
-- Some environments might not have setTimeout or clearTimeout.
-- deviation: We're only dealing with client right now, so these always populate
exports.scheduleTimeout = setTimeout
exports.cancelTimeout = clearTimeout
exports.noTimeout = -1

-- -------------------
--     Mutation
-- -------------------

exports.supportsMutation = true

exports.commitMount = function(domElement: Instance, type: string, newProps: Props, internalInstanceHandle: Object)
	unimplemented("commitMount")
	-- -- Despite the naming that might imply otherwise, this method only
	-- -- fires if there is an `Update` effect scheduled during mounting.
	-- -- This happens if `finalizeInitialChildren` returns `true` (which it
	-- -- does to implement the `autoFocus` attribute on the client). But
	-- -- there are also other cases when this might happen (such as patching
	-- -- up text content during hydration mismatch). So we'll check this again.
	-- if shouldAutoFocusHostComponent(type, newProps))
	--   ((domElement: any):
	--     | HTMLButtonElement
	--     | HTMLInputElement
	--     | HTMLSelectElement
	--     | HTMLTextAreaElement).focus()
	-- end
end

exports.commitUpdate = function(
	domElement: Instance,
	updatePayload: Array<any>,
	type_: string,
	oldProps: Props,
	newProps: Props,
	internalInstanceHandle: Object
)
	-- Update the props handle so that we know which props are the ones with
	-- with current event handlers.
	updateFiberProps(domElement, newProps)
	-- Apply the diff to the DOM node.
	updateProperties(domElement, updatePayload, oldProps)
end

-- deviation: Ignore TextInstance logic, which isn't applicable to Roblox
-- exports.resetTextContent(domElement: Instance): void {
--   setTextContent(domElement, '')
-- end

-- deviation: Ignore TextInstance logic, which isn't applicable to Roblox
-- exports.commitTextUpdate(
--   textInstance: TextInstance,
--   oldText: string,
--   newText: string,
-- ): void {
--   textInstance.nodeValue = newText
-- end

local function checkTags(instance: Instance)
	if typeof(instance :: any) ~= "Instance" then
		console.warn("Could not check tags on non-instance %s.", inspect(instance))
		return
	end
	if not instance:IsDescendantOf(game) then
		if #CollectionService:GetTags(instance) > 0 then
			console.warn(
				'Tags applied to orphaned %s "%s" cannot be accessed via'
					.. " CollectionService:GetTagged. If you're relying on tag"
					.. " behavior in a unit test, consider mounting your test "
					.. "root into the DataModel.",
				instance.ClassName,
				instance.Name
			)
		end
	end
end

exports.appendChild = function(parentInstance: Instance, child: Instance)
	-- deviation: Roblox's DOM is based on child->parent references
	child.Parent = parentInstance
	-- parentInstance.appendChild(child)
	if _G.__DEV__ then
		checkTags(child)
	end
end

exports.appendChildToContainer = function(container: Container, child: Instance)
	-- TODO: Some of this logic may come back; for now, keep it simple
	local parentNode = container
	exports.appendChild(parentNode, child)

	-- if container.nodeType == COMMENT_NODE)
	--   parentNode = (container.parentNode: any)
	--   parentNode.insertBefore(child, container)
	-- } else {
	--   parentNode = container
	--   parentNode.appendChild(child)
	-- end
	-- -- This container might be used for a portal.
	-- -- If something inside a portal is clicked, that click should bubble
	-- -- through the React tree. However, on Mobile Safari the click would
	-- -- never bubble through the *DOM* tree unless an ancestor with onclick
	-- -- event exists. So we wouldn't see it and dispatch it.
	-- -- This is why we ensure that non React root containers have inline onclick
	-- -- defined.
	-- -- https://github.com/facebook/react/issues/11918
	-- local reactRootContainer = container._reactRootContainer
	-- if
	--   reactRootContainer == nil and parentNode.onclick == nil
	-- then
	--   -- TODO: This cast may not be sound for SVG, MathML or custom elements.
	--   trapClickOnNonInteractiveElement(((parentNode: any): HTMLElement))
	-- end
end

exports.insertBefore = function(parentInstance: Instance, child: Instance, _beforeChild: Instance)
	-- deviation: Roblox's DOM is based on child->parent references
	child.Parent = parentInstance
	-- parentInstance.insertBefore(child, beforeChild)
	if _G.__DEV__ then
		checkTags(child)
	end
end

exports.insertInContainerBefore = function(container: Container, child: Instance, beforeChild: Instance)
	-- deviation: use our container definition
	local parentNode = container
	exports.insertBefore(parentNode, child, beforeChild)
	-- if container.nodeType == COMMENT_NODE)
	--   (container.parentNode: any).insertBefore(child, beforeChild)
	-- } else {
	--   container.insertBefore(child, beforeChild)
	-- end
end

-- function createEvent(type: DOMEventName, bubbles: boolean): Event {
--   local event = document.createEvent('Event')
--   event.initEvent(((type: any): string), bubbles, false)
--   return event
-- end

-- function dispatchBeforeDetachedBlur(target: HTMLElement): void {
--   if enableCreateEventHandleAPI)
--     local event = createEvent('beforeblur', true)
--     -- Dispatch "beforeblur" directly on the target,
--     -- so it gets picked up by the event system and
--     -- can propagate through the React internal tree.
--     target.dispatchEvent(event)
--   end
-- end

-- function dispatchAfterDetachedBlur(target: HTMLElement): void {
--   if enableCreateEventHandleAPI)
--     local event = createEvent('afterblur', false)
--     -- So we know what was detached, make the relatedTarget the
--     -- detached target on the "afterblur" event.
--     (event: any).relatedTarget = target
--     -- Dispatch the event on the document.
--     document.dispatchEvent(event)
--   end
-- end

exports.removeChild = function(_parentInstance: Instance, child: Instance)
	recursivelyUncacheFiberNode(child)
	-- deviation: The roblox renderer tracks bindings and event managers
	-- for instances, so make sure we clean those up when we remove the instance
	cleanupHostComponent(child)
	-- deviation: Roblox's DOM is based on child->parent references
	child.Parent = nil
	-- parentInstance.removeChild(child)
	-- deviation: Guard against misuse by locking parent and forcing external cleanup via Destroy
	child:Destroy()
end

exports.removeChildFromContainer = function(_container: Container, child: Instance)
	-- deviation: Containers don't have special behavior and comment nodes
	-- have no datamodel equivalent, so just forward to the removeChild logic
	exports.removeChild(_container, child)
	-- if container.nodeType == COMMENT_NODE)
	--   (container.parentNode: any).removeChild(child)
	-- } else {
	--   container.removeChild(child)
	-- end
end

exports.clearSuspenseBoundary = function(parentInstance: Instance, suspenseInstance: SuspenseInstance)
	-- FIXME: this is a major thing we need to fix for Suspense to work as a feature
	unimplemented("clearSuspenseBoundary")
	--   local node = suspenseInstance
	--   -- Delete all nodes within this suspense boundary.
	--   -- There might be nested nodes so we need to keep track of how
	--   -- deep we are and only break out when we're back on top.
	--   local depth = 0
	--   do {
	--     local nextNode = node.nextSibling
	--     parentInstance.removeChild(node)
	--     if nextNode and nextNode.nodeType == COMMENT_NODE)
	--       local data = ((nextNode: any).data: string)
	--       if data == SUSPENSE_END_DATA)
	--         if depth == 0)
	--           parentInstance.removeChild(nextNode)
	--           -- Retry if any event replaying was blocked on this.
	--           retryIfBlockedOn(suspenseInstance)
	--           return
	--         } else {
	--           depth--
	--         end
	--       } else if
	--         data == SUSPENSE_START_DATA or
	--         data == SUSPENSE_PENDING_START_DATA or
	--         data == SUSPENSE_FALLBACK_START_DATA
	--       )
	--         depth++
	--       end
	--     end
	--     node = nextNode
	--   } while (node)
	--   -- TODO: Warn, we didn't find the end comment boundary.
	--   -- Retry if any event replaying was blocked on this.
	--   retryIfBlockedOn(suspenseInstance)
end

exports.clearSuspenseBoundaryFromContainer = function(container: Container, suspenseInstance: SuspenseInstance)
	-- FIXME: this is a major thing we need to fix for Suspense to work as a feature
	unimplemented("clearSuspenseBoundaryFromContainer")
	--   if container.nodeType == COMMENT_NODE)
	--     clearSuspenseBoundary((container.parentNode: any), suspenseInstance)
	--   } else if container.nodeType == ELEMENT_NODE)
	--     clearSuspenseBoundary((container: any), suspenseInstance)
	--   } else {
	--     -- Document nodes should never contain suspense boundaries.
	--   end
	--   -- Retry if any event replaying was blocked on this.
	--   retryIfBlockedOn(container)
end

exports.hideInstance = function(instance: Instance)
	unimplemented("hideInstance")
	-- -- TODO: Does this work for all element types? What about MathML? Should we
	-- -- pass host context to this method?
	-- instance = ((instance: any): HTMLElement)
	-- local style = instance.style
	-- if typeof style.setProperty == 'function')
	--   style.setProperty('display', 'none', 'important')
	-- } else {
	--   style.display = 'none'
	-- end
end

-- deviation: error on TextInstance logic, which isn't applicable to Roblox
exports.hideTextInstance = function(textInstance: TextInstance): ()
	unimplemented("hideTextInstance")
	--   textInstance.nodeValue = ''
end

exports.unhideInstance = function(instance: Instance, props: Props)
	unimplemented("unhideInstance")
	-- instance = ((instance: any): HTMLElement)
	-- local styleProp = props[STYLE]
	-- local display =
	--   styleProp ~= undefined and
	--   styleProp ~= nil and
	--   styleProp.hasOwnProperty('display')
	--     ? styleProp.display
	--     : nil
	-- instance.style.display = dangerousStyleValue('display', display)
end

-- deviation: error on TextInstance logic, which isn't applicable to Roblox
exports.unhideTextInstance = function(textInstance: TextInstance, text: string): ()
	unimplemented("unhideTextInstance")
	--   textInstance.nodeValue = text
end

exports.clearContainer = function(container: Container)
	-- deviation: with Roblox, we can simply enumerate and remove the children
	local parentInstance = container
	for _, child in parentInstance:GetChildren() do
		exports.removeChild(parentInstance, child)
	end
	-- if container.nodeType == ELEMENT_NODE)
	--   ((container: any): Element).textContent = ''
	-- } else if container.nodeType == DOCUMENT_NODE)
	--   local body = ((container: any): Document).body
	--   if body ~= nil)
	--     body.textContent = ''
	--   end
	-- end
end

-- -- -------------------
-- --     Hydration
-- -- -------------------

-- export local supportsHydration = true

-- exports.canHydrateInstance(
--   instance: HydratableInstance,
--   type: string,
--   props: Props,
-- ): nil | Instance {
--   if
--     instance.nodeType ~= ELEMENT_NODE or
--     type.toLowerCase() ~= instance.nodeName.toLowerCase()
--   )
--     return nil
--   end
--   -- This has now been refined to an element node.
--   return ((instance: any): Instance)
-- end

-- exports.canHydrateTextInstance(
--   instance: HydratableInstance,
--   text: string,
-- ): nil | TextInstance {
--   if text == '' or instance.nodeType ~= TEXT_NODE)
--     -- Empty strings are not parsed by HTML so there won't be a correct match here.
--     return nil
--   end
--   -- This has now been refined to a text node.
--   return ((instance: any): TextInstance)
-- end

-- exports.canHydrateSuspenseInstance(
--   instance: HydratableInstance,
-- ): nil | SuspenseInstance {
--   if instance.nodeType ~= COMMENT_NODE)
--     -- Empty strings are not parsed by HTML so there won't be a correct match here.
--     return nil
--   end
--   -- This has now been refined to a suspense node.
--   return ((instance: any): SuspenseInstance)
-- end

-- exports.isSuspenseInstanceFallback(instance: SuspenseInstance)
--   return instance.data == SUSPENSE_FALLBACK_START_DATA
-- end

-- exports.registerSuspenseInstanceRetry(
--   instance: SuspenseInstance,
--   callback: () => void,
-- )
--   instance._reactRetry = callback
-- end

-- function getNextHydratable(node)
--   -- Skip non-hydratable nodes.
--   for (; node ~= nil; node = node.nextSibling)
--     local nodeType = node.nodeType
--     if nodeType == ELEMENT_NODE or nodeType == TEXT_NODE)
--       break
--     end
--     if enableSuspenseServerRenderer)
--       if nodeType == COMMENT_NODE)
--         local nodeData = (node: any).data
--         if
--           nodeData == SUSPENSE_START_DATA or
--           nodeData == SUSPENSE_FALLBACK_START_DATA or
--           nodeData == SUSPENSE_PENDING_START_DATA
--         )
--           break
--         end
--       end
--     end
--   end
--   return (node: any)
-- end

-- exports.getNextHydratableSibling(
--   instance: HydratableInstance,
-- ): nil | HydratableInstance {
--   return getNextHydratable(instance.nextSibling)
-- end

-- exports.getFirstHydratableChild(
--   parentInstance: Container | Instance,
-- ): nil | HydratableInstance {
--   return getNextHydratable(parentInstance.firstChild)
-- end

-- exports.hydrateInstance(
--   instance: Instance,
--   type: string,
--   props: Props,
--   rootContainerInstance: Container,
--   hostContext: HostContext,
--   internalInstanceHandle: Object,
-- ): nil | Array<mixed> {
--   precacheFiberNode(internalInstanceHandle, instance)
--   -- TODO: Possibly defer this until the commit phase where all the events
--   -- get attached.
--   updateFiberProps(instance, props)
--   local parentNamespace: string
--   if __DEV__)
--     local hostContextDev = ((hostContext: any): HostContextDev)
--     parentNamespace = hostContextDev.namespace
--   } else {
--     parentNamespace = ((hostContext: any): HostContextProd)
--   end
--   return diffHydratedProperties(
--     instance,
--     type,
--     props,
--     parentNamespace,
--     rootContainerInstance,
--   )
-- end

-- exports.hydrateTextInstance(
--   textInstance: TextInstance,
--   text: string,
--   internalInstanceHandle: Object,
-- ): boolean {
--   precacheFiberNode(internalInstanceHandle, textInstance)
--   return diffHydratedText(textInstance, text)
-- end

-- exports.hydrateSuspenseInstance(
--   suspenseInstance: SuspenseInstance,
--   internalInstanceHandle: Object,
-- )
--   precacheFiberNode(internalInstanceHandle, suspenseInstance)
-- end

-- exports.getNextHydratableInstanceAfterSuspenseInstance(
--   suspenseInstance: SuspenseInstance,
-- ): nil | HydratableInstance {
--   local node = suspenseInstance.nextSibling
--   -- Skip past all nodes within this suspense boundary.
--   -- There might be nested nodes so we need to keep track of how
--   -- deep we are and only break out when we're back on top.
--   local depth = 0
--   while (node)
--     if node.nodeType == COMMENT_NODE)
--       local data = ((node: any).data: string)
--       if data == SUSPENSE_END_DATA)
--         if depth == 0)
--           return getNextHydratableSibling((node: any))
--         } else {
--           depth--
--         end
--       } else if
--         data == SUSPENSE_START_DATA or
--         data == SUSPENSE_FALLBACK_START_DATA or
--         data == SUSPENSE_PENDING_START_DATA
--       )
--         depth++
--       end
--     end
--     node = node.nextSibling
--   end
--   -- TODO: Warn, we didn't find the end comment boundary.
--   return nil
-- end

-- -- Returns the SuspenseInstance if this node is a direct child of a
-- -- SuspenseInstance. I.e. if its previous sibling is a Comment with
-- -- SUSPENSE_x_START_DATA. Otherwise, nil.
-- exports.getParentSuspenseInstance(
--   targetInstance: Node,
-- ): nil | SuspenseInstance {
--   local node = targetInstance.previousSibling
--   -- Skip past all nodes within this suspense boundary.
--   -- There might be nested nodes so we need to keep track of how
--   -- deep we are and only break out when we're back on top.
--   local depth = 0
--   while (node)
--     if node.nodeType == COMMENT_NODE)
--       local data = ((node: any).data: string)
--       if
--         data == SUSPENSE_START_DATA or
--         data == SUSPENSE_FALLBACK_START_DATA or
--         data == SUSPENSE_PENDING_START_DATA
--       )
--         if depth == 0)
--           return ((node: any): SuspenseInstance)
--         } else {
--           depth--
--         end
--       } else if data == SUSPENSE_END_DATA)
--         depth++
--       end
--     end
--     node = node.previousSibling
--   end
--   return nil
-- end

-- exports.commitHydratedContainer(container: Container): void {
--   -- Retry if any event replaying was blocked on this.
--   retryIfBlockedOn(container)
-- end

-- exports.commitHydratedSuspenseInstance(
--   suspenseInstance: SuspenseInstance,
-- ): void {
--   -- Retry if any event replaying was blocked on this.
--   retryIfBlockedOn(suspenseInstance)
-- end

-- exports.didNotMatchHydratedContainerTextInstance(
--   parentContainer: Container,
--   textInstance: TextInstance,
--   text: string,
-- )
--   if __DEV__)
--     warnForUnmatchedText(textInstance, text)
--   end
-- end

-- exports.didNotMatchHydratedTextInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   textInstance: TextInstance,
--   text: string,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     warnForUnmatchedText(textInstance, text)
--   end
-- end

-- exports.didNotHydrateContainerInstance(
--   parentContainer: Container,
--   instance: HydratableInstance,
-- )
--   if __DEV__)
--     if instance.nodeType == ELEMENT_NODE)
--       warnForDeletedHydratableElement(parentContainer, (instance: any))
--     } else if instance.nodeType == COMMENT_NODE)
--       -- TODO: warnForDeletedHydratableSuspenseBoundary
--     } else {
--       warnForDeletedHydratableText(parentContainer, (instance: any))
--     end
--   end
-- end

-- exports.didNotHydrateInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   instance: HydratableInstance,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     if instance.nodeType == ELEMENT_NODE)
--       warnForDeletedHydratableElement(parentInstance, (instance: any))
--     } else if instance.nodeType == COMMENT_NODE)
--       -- TODO: warnForDeletedHydratableSuspenseBoundary
--     } else {
--       warnForDeletedHydratableText(parentInstance, (instance: any))
--     end
--   end
-- end

-- exports.didNotFindHydratableContainerInstance(
--   parentContainer: Container,
--   type: string,
--   props: Props,
-- )
--   if __DEV__)
--     warnForInsertedHydratedElement(parentContainer, type, props)
--   end
-- end

-- exports.didNotFindHydratableContainerTextInstance(
--   parentContainer: Container,
--   text: string,
-- )
--   if __DEV__)
--     warnForInsertedHydratedText(parentContainer, text)
--   end
-- end

-- exports.didNotFindHydratableContainerSuspenseInstance(
--   parentContainer: Container,
-- )
--   if __DEV__)
--     -- TODO: warnForInsertedHydratedSuspense(parentContainer)
--   end
-- end

-- exports.didNotFindHydratableInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   type: string,
--   props: Props,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     warnForInsertedHydratedElement(parentInstance, type, props)
--   end
-- end

-- exports.didNotFindHydratableTextInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
--   text: string,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     warnForInsertedHydratedText(parentInstance, text)
--   end
-- end

-- exports.didNotFindHydratableSuspenseInstance(
--   parentType: string,
--   parentProps: Props,
--   parentInstance: Instance,
-- )
--   if __DEV__ and parentProps[SUPPRESS_HYDRATION_WARNING] ~= true)
--     -- TODO: warnForInsertedHydratedSuspense(parentInstance)
--   end
-- end

-- exports.getFundamentalComponentInstance(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): Instance {
--   if enableFundamentalAPI)
--     local {currentFiber, impl, props, state} = fundamentalInstance
--     local instance = impl.getInstance(null, props, state)
--     precacheFiberNode(currentFiber, instance)
--     return instance
--   end
--   -- Because of the flag above, this gets around the Flow error
--   return (null: any)
-- end

-- exports.mountFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): void {
--   if enableFundamentalAPI)
--     local {impl, instance, props, state} = fundamentalInstance
--     local onMount = impl.onMount
--     if onMount ~= undefined)
--       onMount(null, instance, props, state)
--     end
--   end
-- end

-- exports.shouldUpdateFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): boolean {
--   if enableFundamentalAPI)
--     local {impl, prevProps, props, state} = fundamentalInstance
--     local shouldUpdate = impl.shouldUpdate
--     if shouldUpdate ~= undefined)
--       return shouldUpdate(null, prevProps, props, state)
--     end
--   end
--   return true
-- end

-- exports.updateFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): void {
--   if enableFundamentalAPI)
--     local {impl, instance, prevProps, props, state} = fundamentalInstance
--     local onUpdate = impl.onUpdate
--     if onUpdate ~= undefined)
--       onUpdate(null, instance, prevProps, props, state)
--     end
--   end
-- end

-- exports.unmountFundamentalComponent(
--   fundamentalInstance: ReactDOMFundamentalComponentInstance,
-- ): void {
--   if enableFundamentalAPI)
--     local {impl, instance, props, state} = fundamentalInstance
--     local onUnmount = impl.onUnmount
--     if onUnmount ~= undefined)
--       onUnmount(null, instance, props, state)
--     end
--   end
-- end

-- exports.getInstanceFromNode(node: HTMLElement): nil | Object {
--   return getClosestInstanceFromNode(node) or nil
-- end

-- local clientId: number = 0
-- exports.makeClientId(): OpaqueIDType {
--   return 'r:' + (clientId++).toString(36)
-- end

-- exports.makeClientIdInDEV(warnOnAccessInDEV: () => void): OpaqueIDType {
--   local id = 'r:' + (clientId++).toString(36)
--   return {
--     toString()
--       warnOnAccessInDEV()
--       return id
--     },
--     valueOf()
--       warnOnAccessInDEV()
--       return id
--     },
--   end
-- end

-- exports.isOpaqueHydratingObject(value: mixed): boolean {
--   return (
--     value ~= nil and
--     typeof value == 'table’' and
--     value.$$typeof == REACT_OPAQUE_ID_TYPE
--   )
-- end

-- exports.makeOpaqueHydratingObject(
--   attemptToReadValue: () => void,
-- ): OpaqueIDType {
--   return {
--     $$typeof: REACT_OPAQUE_ID_TYPE,
--     toString: attemptToReadValue,
--     valueOf: attemptToReadValue,
--   end
-- end

exports.preparePortalMount = function(portalInstance: Instance): ()
	-- TODO: Revisit this logic and see if any of it applies
	-- if enableEagerRootListeners then
	--   listenToAllSupportedEvents(portalInstance)
	-- else
	--   listenToReactEvent('onMouseEnter', portalInstance)
	-- end
end

-- exports.prepareScopeUpdate(
--   scopeInstance: ReactScopeInstance,
--   internalInstanceHandle: Object,
-- ): void {
--   if enableScopeAPI)
--     precacheFiberNode(internalInstanceHandle, scopeInstance)
--   end
-- end

-- exports.getInstanceFromScope(
--   scopeInstance: ReactScopeInstance,
-- ): nil | Object {
--   if enableScopeAPI)
--     return getFiberFromScopeInstance(scopeInstance)
--   end
--   return nil
-- end

-- export local supportsTestSelectors = true

-- exports.findFiberRoot(node: Instance): nil | FiberRoot {
--   local stack = [node]
--   local index = 0
--   while (index < stack.length)
--     local current = stack[index++]
--     if isContainerMarkedAsRoot(current))
--       return ((getInstanceFromNodeDOMTree(current): any): FiberRoot)
--     end
--     stack.push(...current.children)
--   end
--   return nil
-- end

-- exports.getBoundingRect(node: Instance): BoundingRect {
--   local rect = node.getBoundingClientRect()
--   return {
--     x: rect.left,
--     y: rect.top,
--     width: rect.width,
--     height: rect.height,
--   end
-- end

-- exports.matchAccessibilityRole(node: Instance, role: string): boolean {
--   if hasRole(node, role))
--     return true
--   end

--   return false
-- end

-- exports.getTextContent(fiber: Fiber): string | nil {
--   switch (fiber.tag)
--     case HostComponent:
--       local textContent = ''
--       local childNodes = fiber.stateNode.childNodes
--       for (local i = 0; i < childNodes.length; i++)
--         local childNode = childNodes[i]
--         if childNode.nodeType == Node.TEXT_NODE)
--           textContent += childNode.textContent
--         end
--       end
--       return textContent
--     case HostText:
--       return fiber.stateNode.textContent
--   end

--   return nil
-- end

-- exports.isHiddenSubtree(fiber: Fiber): boolean {
--   return fiber.tag == HostComponent and fiber.memoizedProps.hidden == true
-- end

-- exports.setFocusIfFocusable(node: Instance): boolean {
--   -- The logic for determining if an element is focusable is kind of complex,
--   -- and since we want to actually change focus anyway- we can just skip it.
--   -- Instead we'll just listen for a "focus" event to verify that focus was set.
--   --
--   -- We could compare the node to document.activeElement after focus,
--   -- but this would not handle the case where application code managed focus to automatically blur.
--   local didFocus = false
--   local handleFocus = () => {
--     didFocus = true
--   end

--   local element = ((node: any): HTMLElement)
--   try {
--     element.addEventListener('focus', handleFocus)
--     (element.focus or HTMLElement.prototype.focus).call(element)
--   } finally {
--     element.removeEventListener('focus', handleFocus)
--   end

--   return didFocus
-- end

-- type RectRatio = {
--   ratio: number,
--   rect: BoundingRect,
-- end

-- exports.setupIntersectionObserver(
--   targets: Array<Instance>,
--   callback: ObserveVisibleRectsCallback,
--   options?: IntersectionObserverOptions,
-- ): {|
--   disconnect: () => void,
--   observe: (instance: Instance) => void,
--   unobserve: (instance: Instance) => void,
-- |} {
--   local rectRatioCache: Map<Instance, RectRatio> = new Map()
--   targets.forEach(target => {
--     rectRatioCache.set(target, {
--       rect: getBoundingRect(target),
--       ratio: 0,
--     })
--   })

--   local handleIntersection = (entries: Array<IntersectionObserverEntry>) => {
--     entries.forEach(entry => {
--       local {boundingClientRect, intersectionRatio, target} = entry
--       rectRatioCache.set(target, {
--         rect: {
--           x: boundingClientRect.left,
--           y: boundingClientRect.top,
--           width: boundingClientRect.width,
--           height: boundingClientRect.height,
--         },
--         ratio: intersectionRatio,
--       })
--     })

--     callback(Array.from(rectRatioCache.values()))
--   end

--   local observer = new IntersectionObserver(handleIntersection, options)
--   targets.forEach(target => {
--     observer.observe((target: any))
--   })

--   return {
--     disconnect: () => observer.disconnect(),
--     observe: target => {
--       rectRatioCache.set(target, {
--         rect: getBoundingRect(target),
--         ratio: 0,
--       })
--       observer.observe((target: any))
--     },
--     unobserve: target => {
--       rectRatioCache.delete(target)
--       observer.unobserve((target: any))
--     },
--   end
-- end

return exports
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006332</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXB5BDC85675E0448082DAEB5A6F0B661B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactRobloxHostTypes.roblox</string>
									<string name="ScriptGuid">{00D6D0F4-EC4F-47C9-B9D1-65FBD5ED63CD}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMHostConfig.js
-- upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/react-native-renderer/src/ReactNativeHostConfig.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]
local Packages = script.Parent.Parent.Parent

local ReactReconciler = require(Packages.ReactReconciler)
type FiberRoot = ReactReconciler.FiberRoot

local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type ReactNodeList = ReactTypes.ReactNodeList

type Array<T> = { [number]: T }

-- deviation: Containers should also be instances; at some point, we may
-- restrict which _kinds_ of instances, but that's not necessary right now
export type Container = Instance
-- export type Container =
--   | (Element & {_reactRootContainer?: RootType, ...})
--   | (Document & {_reactRootContainer?: RootType, ...})

-- deviation: We can't export this as `Instance`; luau gets upset!
export type HostInstance = Instance

export type TextInstance = Instance

-- TODO: Revisit this type for suspense
-- export type SuspenseInstance = Comment & {_reactRetry?: () => void, ...}
export type SuspenseInstance = any

export type Type = string
export type Props = {
	autoFocus: boolean?,
	children: any,
	disabled: boolean?,
	hidden: boolean?,
	suppressHydrationWarning: boolean?,
	dangerouslySetInnerHTML: any,
	style: { display: string, [any]: any }?,
	bottom: number?,
	left: number?,
	right: number?,
	top: number?,
	-- ...
	[any]: any,
}

-- TODO: Revisit this type for hydration
-- export type HydratableInstance = Instance | TextInstance | SuspenseInstance
export type HydratableInstance = Instance | SuspenseInstance

-- TODO: Revisit this to make sure it makes sense
-- export type PublicInstance = Element | Text
export type PublicInstance = HostInstance

-- TODO: See if these actually make sense
type HostContextDev = {
	namespace: string,
	ancestorInfo: any,
	-- ...
	[any]: any,
}
type HostContextProd = string
export type HostContext = HostContextDev | HostContextProd

export type RootType = {
	render: (self: RootType, children: ReactNodeList) -> (),
	unmount: (self: RootType) -> (),
	_internalRoot: any,
	-- _internalRoot: FiberRoot,
	-- ...
	[any]: any,
}

export type RootOptions = {
	hydrate: boolean?,
	hydrationOptions: {
		onHydrated: (suspenseNode: any) -> ()?,
		onDeleted: (suspenseNode: any) -> ()?,
		mutableSources: Array<MutableSource<any>>?,
		-- ...
		[any]: any,
	}?,
	-- ...
	[any]: any,
}

return {}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006333</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX5566C965A3CA4C65AC299858C0FB8628">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ReactRobloxRoot</string>
									<string name="ScriptGuid">{17E671B6-A70C-4573-9100-C8AA2321DE8B}</string>
									<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/8e5adfbd7e605bda9c5e96c10e015b3dc0df688e/packages/react-dom/src/client/ReactDOMRoot.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local Packages = script.Parent.Parent.Parent

local ReactRobloxHostTypes = require(script.Parent["ReactRobloxHostTypes.roblox"])
type Container = ReactRobloxHostTypes.Container
type RootType = ReactRobloxHostTypes.RootType
type RootOptions = ReactRobloxHostTypes.RootOptions

local ReconcilerTypes = require(Packages.ReactReconciler)
type RootTag = ReconcilerTypes.RootTag
local ReactTypes = require(Packages.Shared)
type MutableSource<T> = ReactTypes.MutableSource<T>
type ReactNodeList = ReactTypes.ReactNodeList
local ReactInternalTypes = require(Packages.ReactReconciler)
type FiberRoot = ReactInternalTypes.FiberRoot

type Array<T> = { [number]: T }

local ReactRobloxComponentTree = require(script.Parent.ReactRobloxComponentTree)
-- local isContainerMarkedAsRoot = ReactRobloxComponentTree.isContainerMarkedAsRoot
local markContainerAsRoot = ReactRobloxComponentTree.markContainerAsRoot
local unmarkContainerAsRoot = ReactRobloxComponentTree.unmarkContainerAsRoot
-- local listenToAllSupportedEvents = require(script.Parent.Parent.events.DOMPluginEventSystem).listenToAllSupportedEvents
-- local eagerlyTrapReplayableEvents = require(script.Parent.Parent.events.ReactDOMEventReplaying).eagerlyTrapReplayableEvents
-- local HTMLNodeType = require(script.Parent.Parent.shared.HTMLNodeType)
-- local ELEMENT_NODE = HTMLNodeType.ELEMENT_NODE
-- local COMMENT_NODE = HTMLNodeType.COMMENT_NODE
-- local DOCUMENT_NODE = HTMLNodeType.DOCUMENT_NODE
-- local DOCUMENT_FRAGMENT_NODE = HTMLNodeType.DOCUMENT_FRAGMENT_NODE
-- local ensureListeningTo = require(Packages.ReactDOMComponent).ensureListeningTo

-- deviation: Use the config-injecting entry point for the reconciler
local ReactFiberReconciler = require(script.Parent.Parent["ReactReconciler.roblox"])
local createContainer = ReactFiberReconciler.createContainer
local updateContainer = ReactFiberReconciler.updateContainer
-- local findHostInstanceWithNoPortals = ReactFiberReconciler.findHostInstanceWithNoPortals
-- local registerMutableSourceForHydration = ReactFiberReconciler.registerMutableSourceForHydration
local invariant = require(Packages.Shared).invariant
local enableEagerRootListeners = require(Packages.Shared).ReactFeatureFlags.enableEagerRootListeners

local BlockingRoot = ReactFiberReconciler.ReactRootTags.BlockingRoot
local ConcurrentRoot = ReactFiberReconciler.ReactRootTags.ConcurrentRoot
local LegacyRoot = ReactFiberReconciler.ReactRootTags.LegacyRoot

local createRootImpl

local ReactRobloxRoot = {}
ReactRobloxRoot.__index = ReactRobloxRoot

function ReactRobloxRoot.new(container: Container, options: RootOptions?): RootType
	local root: RootType = (setmetatable({}, ReactRobloxRoot) :: any) :: RootType
	root._internalRoot = createRootImpl(container, ConcurrentRoot, options)

	return root
end

local function createBlockingRoot(container: Container, tag: RootTag, options: RootOptions?): RootType
	-- deviation: We can just share the logic here via metatables
	local root: RootType = (setmetatable({}, ReactRobloxRoot) :: any) :: RootType
	root._internalRoot = createRootImpl(container, tag, options)

	return root
end

function ReactRobloxRoot:render(children: ReactNodeList)
	local root = self._internalRoot
	-- if _G.__DEV__ then
	--   if typeof (arguments[1] == 'function')
	--     console.error(
	--       'render(...): does not support the second callback argument. ' +
	--         'To execute a side effect after rendering, declare it in a component body with useEffect().',
	--     )
	--   end
	--   local container = root.containerInfo

	--   if container.nodeType ~= COMMENT_NODE)
	--     local hostInstance = findHostInstanceWithNoPortals(root.current)
	--     if hostInstance)
	--       if hostInstance.parentNode ~= container)
	--         console.error(
	--           'render(...): It looks like the React-rendered content of the ' +
	--             'root container was removed without using React. This is not ' +
	--             'supported and will cause errors. Instead, call ' +
	--             "root.unmount() to empty a root's container.",
	--         )
	--       end
	--     end
	--   end
	-- end
	updateContainer(children, root, nil)
end

function ReactRobloxRoot:unmount()
	-- if _G.__DEV__ then
	--   if typeof arguments[0] == 'function')
	--     console.error(
	--       'unmount(...): does not support a callback argument. ' +
	--         'To execute a side effect after rendering, declare it in a component body with useEffect().',
	--     )
	--   end
	-- end
	local root = self._internalRoot
	local container = root.containerInfo
	updateContainer(nil, root, nil, function()
		unmarkContainerAsRoot(container)
	end)
end

-- TODO: add Options type
-- createRootImpl = function(
--   container: Container,
--   tag: RootTag,
--   options: RootOptions
-- )
createRootImpl = function(container: Container, tag: RootTag, options: any)
	-- Tag is either LegacyRoot or Concurrent Root
	local hydrate = options ~= nil and options.hydrate == true
	local hydrationCallbacks = if options ~= nil then options.hydrationOptions else nil
	local mutableSources = (
		options ~= nil
		and options.hydrationOptions ~= nil
		and options.hydrationOptions.mutableSources
	) or nil
	local root = createContainer(container, tag, hydrate, hydrationCallbacks)
	markContainerAsRoot(root.current, container)
	-- local containerNodeType = container.nodeType

	if enableEagerRootListeners then
		--   local rootContainerElement =
		--     container.nodeType == COMMENT_NODE and container.parentNode or container
		--   listenToAllSupportedEvents(rootContainerElement)
		-- } else {
		--   if hydrate and tag ~= LegacyRoot)
		--     local doc =
		--       containerNodeType == DOCUMENT_NODE
		--         ? container
		--         : container.ownerDocument
		--     -- We need to cast this because Flow doesn't work
		--     -- with the hoisted containerNodeType. If we inline
		--     -- it, then Flow doesn't complain. We intentionally
		--     -- hoist it to reduce code-size.
		--     eagerlyTrapReplayableEvents(container, ((doc: any): Document))
		--   } else if
		--     containerNodeType ~= DOCUMENT_FRAGMENT_NODE and
		--     containerNodeType ~= DOCUMENT_NODE
		--   )
		--     ensureListeningTo(container, 'onMouseEnter')
		--   end
	end

	if mutableSources then
		-- for (local i = 0; i < mutableSources.length; i++)
		--   local mutableSource = mutableSources[i]
		--   registerMutableSourceForHydration(root, mutableSource)
		-- end
	end

	return root
end

local exports = {}

local function isValidContainer(node: any): boolean
	-- TODO: This behavior will deviate, for now just check that it's an
	-- instance, which should be good enough
	return typeof(node) == "Instance"
	-- return not not (
	--   node and
	--   (node.nodeType == ELEMENT_NODE or
	--     node.nodeType == DOCUMENT_NODE or
	--     node.nodeType == DOCUMENT_FRAGMENT_NODE or
	--     (node.nodeType == COMMENT_NODE and
	--       node.nodeValue == ' react-mount-point-unstable '))
	-- )
end

exports.isValidContainer = isValidContainer

-- deviation: Create `Container` from instance
exports.createRoot = function(container: Container, options: RootOptions?): RootType
	invariant(
		isValidContainer(container),
		-- deviation: Use roblox engine terminology
		"createRoot(...): Target container is not a Roblox Instance."
	)
	warnIfReactDOMContainerInDEV(container)
	return ReactRobloxRoot.new(container, options)
end

exports.createBlockingRoot = function(container: Container, options: RootOptions?): RootType
	invariant(
		isValidContainer(container),
		-- deviation: Use roblox engine terminology
		"createRoot(...): Target container is not a Roblox Instance."
	)
	warnIfReactDOMContainerInDEV(container)
	return createBlockingRoot(container, BlockingRoot, options)
end

exports.createLegacyRoot = function(container: Container, options: RootOptions?): RootType
	return createBlockingRoot(container, LegacyRoot, options)
end

function warnIfReactDOMContainerInDEV(container)
	if _G.__DEV__ then
		-- TODO: This behavior will deviate; should we validate that the
		-- container is not a PlayerGui of any sort?

		-- if
		--   container.nodeType == ELEMENT_NODE and
		--   container.tagName and
		--   container.tagName.toUpperCase() == 'BODY'
		-- then
		--   console.error(
		--     'createRoot(): Creating roots directly with document.body is ' ..
		--       'discouraged, since its children are often manipulated by third-party ' ..
		--       'scripts and browser extensions. This may lead to subtle ' ..
		--       'reconciliation issues. Try using a container element created ' ..
		--       'for your app.'
		--   )
		-- end
		-- if isContainerMarkedAsRoot(container) then
		--   if container._reactRootContainer then
		--     console.error(
		--       'You are calling ReactDOM.createRoot() on a container that was previously ' ..
		--         'passed to ReactDOM.render(). This is not supported.'
		--     )
		--   else
		--     console.error(
		--       'You are calling ReactDOM.createRoot() on a container that ' ..
		--         'has already been passed to createRoot() before. Instead, call ' ..
		--         'root.render() on the existing root instead if you want to update it.'
		--     )
		--   end
		-- end
	end
end

return exports
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006334</UniqueId>
								</Properties>
							</Item>
							<Item class="Folder" referent="RBX35F715A845E9418294E78C0CDE70C6AD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">roblox</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006335</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX8F5445A8702346D58782B493E99DBC0A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">RobloxComponentProps</string>
										<string name="ScriptGuid">{BA566649-6DD7-4D58-95C6-FDBD238100EC}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the MIT License (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     https://opensource.org/licenses/MIT
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]
local __DEV__ = _G.__DEV__ :: boolean
local CollectionService = game:GetService("CollectionService")
local Packages = script.Parent.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
local Object = LuauPolyfill.Object
local Set = LuauPolyfill.Set
local String = LuauPolyfill.String
local inspect = LuauPolyfill.util.inspect

local console = require(Packages.Shared).console

local React = require(Packages.React)
local ReactSymbols = require(Packages.Shared).ReactSymbols
local SingleEventManager = require(script.Parent.SingleEventManager)
type EventManager = SingleEventManager.EventManager
local Type = require(Packages.Shared).Type
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local ReactRobloxHostTypes = require(script.Parent.Parent["ReactRobloxHostTypes.roblox"])
type HostInstance = ReactRobloxHostTypes.HostInstance
local Tag = require(Packages.React).Tag

-- deviation: Essentially a placeholder for dom-specific logic, taking the place
-- of ReactDOMComponent. Most of the logic will differ pretty dramatically

type Array<T> = { [number]: T }
type Object = { [any]: any }

-- deviation: Can't assign attributes to Roblox instances, so we use maps to
-- store associated data for host instance features like binding and event
-- management
-- FIXME: Stronger typing for EventManager

local instanceToEventManager: { [HostInstance]: EventManager } = {}
local instanceToBindings: { [HostInstance]: { [string]: any } } = {}

local applyPropsError = [[
Error applying initial props to Roblox Instance '%s' (%s):
  %s
]]

local updatePropsError = [[
Error updating props on Roblox Instance '%s' (%s):
  %s
]]

local updateBindingError = [[
Error updating binding or ref assigned to key %s of '%s' (%s).

Updated value:
  %s

Error:
  %s

%s
]]

local function identity(...)
	return ...
end

local function setRobloxInstanceProperty(hostInstance, key, newValue): ()
	if newValue == nil then
		local hostClass = hostInstance.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostInstance[key] = newValue
end

local function removeBinding(hostInstance, key)
	local bindings = instanceToBindings[hostInstance]
	if bindings ~= nil then
		local disconnect = bindings[key]
		disconnect()
		bindings[key] = nil
	end
end

local function attachBinding(hostInstance, key, newBinding): ()
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(setRobloxInstanceProperty, identity, hostInstance, key, newValue)

		if not success then
			local source = newBinding._source or "<enable DEV mode for stack>"
			local fullMessage = string.format(
				updateBindingError,
				key,
				hostInstance.Name,
				hostInstance.ClassName,
				tostring(newValue),
				errorMessage,
				source
			)
			console.error(fullMessage)
			-- FIXME: Until console.error can be instrumented to send telemetry, we
			-- need to keep the hard error here
			error(fullMessage, 0)
		end
	end

	if instanceToBindings[hostInstance] == nil then
		instanceToBindings[hostInstance] = {}
	end

	instanceToBindings[hostInstance][key] = React.__subscribeToBinding(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function applyTags(hostInstance: Instance, oldTags: string?, newTags: string?)
	if __DEV__ then
		if newTags ~= nil and typeof(newTags) ~= "string" then
			console.error(
				"Type provided for ReactRoblox.Tag is invalid - tags should be "
					.. "specified as a single string, with individual tags delimited "
					.. "by spaces. Instead received:\n%s",
				inspect(newTags)
			)
			return
		end
	end

	local oldTagSet = Set.new(String.split(oldTags or "", " "))
	local newTagSet = Set.new(String.split(newTags or "", " "))

	for _, tag in oldTagSet do
		if not newTagSet:has(tag) then
			CollectionService:RemoveTag(hostInstance, tag)
		end
	end
	for _, tag in newTagSet do
		if not oldTagSet:has(tag) then
			CollectionService:AddTag(hostInstance, tag)
		end
	end
end

local function removeAllTags(hostInstance: Instance)
	for _, tag in CollectionService:GetTags(hostInstance) do
		CollectionService:RemoveTag(hostInstance, tag)
	end
end

local function applyProp(hostInstance: Instance, key, newValue, oldValue): ()
	-- performance: gets checked in applyProps so we can assume the key is valid
	-- if key == "ref" or key == "children" then
	--   return
	-- end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		local eventManager = instanceToEventManager[hostInstance]
		if eventManager == nil then
			eventManager = (SingleEventManager.new(hostInstance) :: any) :: EventManager
			instanceToEventManager[hostInstance] = eventManager
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			eventManager:connectPropertyChange(eventName, newValue)
		else
			eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	-- Handle bindings
	local newIsBinding = typeof(newValue) == "table" and newValue["$$typeof"] == ReactSymbols.REACT_BINDING_TYPE
	local oldIsBinding = oldValue ~= nil
		and typeof(oldValue) == "table"
		and oldValue["$$typeof"] == ReactSymbols.REACT_BINDING_TYPE
	if oldIsBinding then
		removeBinding(hostInstance, key)
	end

	if newIsBinding then
		attachBinding(hostInstance, key, newValue)
	elseif key == Tag then
		applyTags(hostInstance, oldValue, newValue)
	else
		setRobloxInstanceProperty(hostInstance, key, newValue)
	end
end

local function applyProps(hostInstance: Instance, props: Object): ()
	for propKey, value in props do
		-- performance: avoid the function call by inlining check here
		if propKey == "ref" or propKey == "children" then
			continue
		end

		applyProp(hostInstance, propKey, value)
	end
end

local function setInitialProperties(
	domElement: HostInstance,
	_tag: string,
	rawProps: Object,
	_rootContainerElement: HostInstance
): ()
	-- deviation: Use Roact's prop application logic
	local success, errorMessage = xpcall(applyProps, identity, domElement, rawProps)
	-- deviation: Roblox renderer doesn't currently track where instances
	-- were created the way that legacy Roact did, but DEV mode should include
	-- component stack traces as a separate warning
	if not success then
		local fullMessage = string.format(applyPropsError, domElement.Name, domElement.ClassName, errorMessage)
		console.error(fullMessage)
		-- FIXME: Until console.error can be instrumented to send telemetry, we need
		-- to keep the hard error here
		error(fullMessage, 0)
	end

	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement]:resume()
	end
end

local function safelyApplyProperties(domElement: HostInstance, updatePayload: Array<any>, lastProps: Object): ()
	local updatePayloadCount = #updatePayload
	for i = 1, updatePayloadCount, 2 do
		local propKey = updatePayload[i]
		local value = updatePayload[i + 1]
		if value == Object.None then
			value = nil
		end
		-- performance: avoid the function call by inlining check here
		if propKey ~= "ref" and propKey ~= "children" then
			applyProp(domElement, propKey, value, lastProps[propKey])
		end
	end
end

local function updateProperties(domElement: HostInstance, updatePayload: Array<any>, lastProps: Object): ()
	-- deviation: Use Roact's prop application logic
	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement]:suspend()
	end

	local success, errorMessage = xpcall(safelyApplyProperties, identity, domElement, updatePayload, lastProps)

	if not success then
		-- deviation: Roblox renderer doesn't currently track where instances
		-- were created the way that legacy Roact did, but DEV mode should include
		-- component stack traces as a separate warning
		local fullMessage = string.format(updatePropsError, domElement.Name, domElement.ClassName, errorMessage)
		console.error(fullMessage)
		-- FIXME: Until console.error can be instrumented to send telemetry, we need
		-- to keep the hard error here
		error(fullMessage, 0)
	end

	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement]:resume()
	end
end

-- deviation: Clear out references to components when they unmount so we
-- avoid leaking memory when they're removed
local function cleanupHostComponent(domElement: HostInstance)
	if instanceToEventManager[domElement] ~= nil then
		instanceToEventManager[domElement] = nil
	end
	if instanceToBindings[domElement] ~= nil then
		instanceToBindings[domElement] = nil
	end

	-- ROBLOX https://jira.rbx.com/browse/LUAFDN-718: Tables are somehow ending up
	-- in this function that expects Instances. In that case, we won't be able to
	-- iterate through its descendants.
	if typeof(domElement :: any) ~= "Instance" then
		return
	end

	removeAllTags(domElement)
	for _, descElement in domElement:GetDescendants() do
		if instanceToEventManager[descElement] ~= nil then
			instanceToEventManager[descElement] = nil
		end
		if instanceToBindings[descElement] ~= nil then
			instanceToBindings[descElement] = nil
		end
		removeAllTags(domElement)
	end
end

return {
	setInitialProperties = setInitialProperties,
	updateProperties = updateProperties,
	cleanupHostComponent = cleanupHostComponent,

	-- deviation: expose maps to test for Instance cleanups
	_instanceToEventManager = instanceToEventManager,
	_instanceToBindings = instanceToBindings,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006336</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX72EA755C34F34C6E9FD46E777A5C2252">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">SingleEventManager</string>
										<string name="ScriptGuid">{01F07FAD-B384-4A1E-A89C-4D2F2328D69C}</string>
										<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/Roblox/roact/blob/b2ba9cf4c219c2654e6572219a68d0bf1b541418/src/SingleEventManager.lua
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

--[[
	A manager for a single host virtual node's connected events.
]]

local Packages = script.Parent.Parent.Parent.Parent

local console = require(Packages.Shared).console
type Function = (...any) -> ...any

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

export type EventManager = {
	connectPropertyChange: (self: any, eventName: string, newValue: any) -> (),
	connectEvent: (self: any, eventName: string, newValue: any) -> (),
	resume: (self: any) -> (),
	suspend: (self: any) -> (),
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance: Instance): EventManager
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return (self :: any) :: EventManager
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(self._instance.GetPropertyChangedSignal, self._instance, key)

	if not success then
		error(string.format("Cannot get changed signal on property %q: %s", tostring(key), event), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	for _, eventInvocation in self._suspendedEventQueue do
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result =
				coroutine.resume(listenerCo, self._instance, unpack(eventInvocation, 3, 2 + argumentCount))

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				console.warn("%s", result)
			end
		end
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	table.clear(self._suspendedEventQueue)
end

return SingleEventManager
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006337</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX9D726B2455AE420DAFD13081E8E82700">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">getDefaultInstanceProperty</string>
										<string name="ScriptGuid">{23F5FEC4-094D-440F-A12C-843F957CBCDD}</string>
										<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/Roblox/roact/blob/b2ba9cf4c219c2654e6572219a68d0bf1b541418/src/getDefaultInstanceProperty.lua
--[[
	* Copyright (c) Roblox Corporation. All rights reserved.
	* Licensed under the Apache License, Version 2.0 (the "License");
	* you may not use this file except in compliance with the License.
	* You may obtain a copy of the License at
	*
	*     http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing, software
	* distributed under the License is distributed on an "AS IS" BASIS,
	* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	* See the License for the specific language governing permissions and
	* limitations under the License.
]]

--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Packages = script.Parent.Parent.Parent.Parent
local Symbol = require(Packages.Shared).Symbol

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function tryPropertyName(instance, propertyName)
	return instance[propertyName]
end

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(tryPropertyName, created, propertyName)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">3a589e3654c30573064751ed00006338</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX543618DA4CAA4CC2A5DE90EF74813955">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Scheduler</string>
							<string name="ScriptGuid">{33645C2D-4C4F-4ADE-9F48-AC1E381A8A6B}</string>
							<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/efd8f6442d1aa7c4566fe812cba03e7e83aaccc3/packages/scheduler/index.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local initializeScheduler = require(script.Scheduler)

local function onlyInTestError(functionName: string)
	return function()
		error(functionName .. " is only available in tests, not in production")
	end
end

local Scheduler = initializeScheduler(nil --[[ no host config, use default ]])
local Tracing = require(script.Tracing)
local TracingSubscriptions = require(script.TracingSubscriptions)
-- deviation export Tracing type from the package exports to avoid direct file access
export type Interaction = Tracing.Interaction

-- Enables `act` to use mock scheduling logic when running tests. Since there
-- are numerous testing scenarios in which we call `require` on the Roact
-- library _before_ we bootstrap tests, we expose an additional global to toggle
-- this explicilty
if _G.__ROACT_17_MOCK_SCHEDULER__ then
	return require(script.unstable_mock)
end

local exports = {
	unstable_ImmediatePriority = Scheduler.unstable_ImmediatePriority,
	unstable_UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,
	unstable_NormalPriority = Scheduler.unstable_NormalPriority,
	unstable_IdlePriority = Scheduler.unstable_IdlePriority,
	unstable_LowPriority = Scheduler.unstable_LowPriority,
	unstable_runWithPriority = Scheduler.unstable_runWithPriority,
	unstable_next = Scheduler.unstable_next,
	unstable_scheduleCallback = Scheduler.unstable_scheduleCallback,
	unstable_cancelCallback = Scheduler.unstable_cancelCallback,
	unstable_wrapCallback = Scheduler.unstable_wrapCallback,
	unstable_getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,
	unstable_shouldYield = Scheduler.unstable_shouldYield,
	unstable_requestPaint = Scheduler.unstable_requestPaint,
	unstable_continueExecution = Scheduler.unstable_continueExecution,
	unstable_pauseExecution = Scheduler.unstable_pauseExecution,
	unstable_getFirstCallbackNode = Scheduler.unstable_getFirstCallbackNode,
	unstable_now = Scheduler.unstable_now,
	unstable_forceFrameRate = Scheduler.unstable_forceFrameRate,
	unstable_flushAllWithoutAsserting = onlyInTestError("unstable_flushAllWithoutAsserting") :: any,
	unstable_flushAll = onlyInTestError("unstable_flushAll"),
	unstable_flushNumberOfYields = onlyInTestError("unstable_flushNumberOfYields"),
	unstable_clearYields = onlyInTestError("unstable_clearYields") :: any,
	unstable_flushUntilNextPaint = onlyInTestError("unstable_clearYields"),
	unstable_advanceTime = onlyInTestError("unstable_advanceTime"),
	unstable_flushExpired = onlyInTestError("unstable_flushExpired"),
	unstable_yieldValue = onlyInTestError("unstable_yieldValue"),

	tracing = {
		unstable_wrap = onlyInTestError("unstable_wrap"),
		__interactionsRef = {},
		__subscriberRef = {},
	},
}

-- FIXME Luau: need to fix CLI-56768 to remove any cast
for k, v in Tracing :: any do
	exports.tracing[k] = v
end
for k, v in TracingSubscriptions :: any do
	exports.tracing[k] = v
end

return exports
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed0000635c</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX646A6CF622804FAF944F79F5F54B9961">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Scheduler</string>
								<string name="ScriptGuid">{768FB48E-01D8-47BB-A7E0-CAC6595788A0}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/Scheduler.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
]]

-- deviation: return an initializer function instead of the module itself
-- for easier dependency injection with unstable_mock
return function(hostConfig)
	local Packages = script.Parent.Parent
	local describeError = require(Packages.Shared).describeError

	local SchedulerFeatureFlags = require(script.Parent.SchedulerFeatureFlags)
	local enableSchedulerDebugging = SchedulerFeatureFlags.enableSchedulerDebugging
	local enableProfiling = SchedulerFeatureFlags.enableProfiling

	local SchedulerHostConfig = hostConfig or require(script.Parent.SchedulerHostConfig)
	local requestHostCallback = SchedulerHostConfig.requestHostCallback
	local requestHostTimeout = SchedulerHostConfig.requestHostTimeout
	local cancelHostTimeout = SchedulerHostConfig.cancelHostTimeout
	local shouldYieldToHost = SchedulerHostConfig.shouldYieldToHost
	local getCurrentTime = SchedulerHostConfig.getCurrentTime
	local forceFrameRate = SchedulerHostConfig.forceFrameRate
	local requestPaint = SchedulerHostConfig.requestPaint

	-- deviation? inline the MinHeap to see if the module-level visibility lets Luau optimize better
	-- local SchedulerMinHeap = require(script.Parent.SchedulerMinHeap)
	-- local push = SchedulerMinHeap.push
	-- local peek = SchedulerMinHeap.peek
	-- local pop = SchedulerMinHeap.pop
	type Heap = { [number]: Node? }
	type Node = {
		id: number,
		sortIndex: number,
	}

	-- deviation: This file contains several workarounds for Luau analysis issues by using the `::` operator
	local compare, siftUp, siftDown

	local push = function(heap: Heap, node: Node): ()
		local index = #heap + 1
		heap[index] = node

		siftUp(heap, node, index)
	end

	local peek = function(heap: Heap): Node?
		return heap[1]
	end

	local pop = function(heap: Heap): Node?
		local first = heap[1]
		if first ~= nil then
			local last = heap[#heap]
			heap[#heap] = nil

			if last :: Node ~= first :: Node then
				heap[1] = last
				siftDown(heap, last :: Node, 1)
			end
			return first
		else
			return nil
		end
	end

	siftUp = function(heap: Heap, node: Node, index: number): ()
		while true do
			local parentIndex = math.floor(index / 2)
			local parent = heap[parentIndex]
			if parent ~= nil and compare(parent :: Node, node :: Node) > 0 then
				-- The parent is larger. Swap positions.
				heap[parentIndex] = node
				heap[index] = parent
				index = parentIndex
			else
				-- The parent is smaller. Exit.
				return
			end
		end
	end

	siftDown = function(heap: Heap, node: Node, index: number): ()
		local length = #heap
		while index < length do
			local leftIndex = index * 2
			local left = heap[leftIndex]
			local rightIndex = leftIndex + 1
			local right = heap[rightIndex]

			-- If the left or right node is smaller, swap with the smaller of those.
			if left ~= nil and compare(left :: Node, node) < 0 then
				if right ~= nil and compare(right :: Node, left :: Node) < 0 then
					heap[index] = right
					heap[rightIndex] = node
					index = rightIndex
				else
					heap[index] = left
					heap[leftIndex] = node
					index = leftIndex
				end
			elseif right ~= nil and compare(right :: Node, node :: Node) < 0 then
				heap[index] = right
				heap[rightIndex] = node
				index = rightIndex
			else
				-- Neither child is smaller. Exit.
				return
			end
		end
	end

	compare = function(a: Node, b: Node): number
		-- Compare sort index first, then task id.
		local diff = a.sortIndex - b.sortIndex

		if diff == 0 then
			return a.id - b.id
		end

		return diff
	end

	-- TODO: Use symbols?
	local SchedulerPriorities = require(script.Parent.SchedulerPriorities)
	local ImmediatePriority = SchedulerPriorities.ImmediatePriority
	local UserBlockingPriority = SchedulerPriorities.UserBlockingPriority
	local NormalPriority = SchedulerPriorities.NormalPriority
	local LowPriority = SchedulerPriorities.LowPriority
	local IdlePriority = SchedulerPriorities.IdlePriority

	local SchedulerProfiling = require(script.Parent.SchedulerProfiling)
	local markTaskRun = SchedulerProfiling.markTaskRun
	local markTaskYield = SchedulerProfiling.markTaskYield
	local markTaskCompleted = SchedulerProfiling.markTaskCompleted
	local markTaskCanceled = SchedulerProfiling.markTaskCanceled
	local markTaskErrored = SchedulerProfiling.markTaskErrored
	local markSchedulerSuspended = SchedulerProfiling.markSchedulerSuspended
	local markSchedulerUnsuspended = SchedulerProfiling.markSchedulerUnsuspended
	local markTaskStart = SchedulerProfiling.markTaskStart
	local stopLoggingProfilingEvents = SchedulerProfiling.stopLoggingProfilingEvents
	local startLoggingProfilingEvents = SchedulerProfiling.startLoggingProfilingEvents

	-- Max 31 bit integer. The max integer size in V8 for 32-bit systems.
	-- Math.pow(2, 30) - 1
	-- 0b111111111111111111111111111111
	local maxSigned31BitInt = 1073741823

	-- Times out immediately
	local IMMEDIATE_PRIORITY_TIMEOUT = -1
	-- Eventually times out
	local USER_BLOCKING_PRIORITY_TIMEOUT = 250
	local NORMAL_PRIORITY_TIMEOUT = 5000
	local LOW_PRIORITY_TIMEOUT = 10000
	-- Never times out
	local IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt

	-- Tasks are stored on a min heap
	local taskQueue = {}
	local timerQueue = {}

	-- Incrementing id counter. Used to maintain insertion order.
	local taskIdCounter = 1

	-- Pausing the scheduler is useful for debugging.
	local isSchedulerPaused = false

	local currentTask = nil
	local currentPriorityLevel = NormalPriority

	-- This is set while performing work, to prevent re-entrancy.
	local isPerformingWork = false

	local isHostCallbackScheduled = false
	local isHostTimeoutScheduled = false

	-- deviation: Preemptively declare these functions so that Lua understands them
	local handleTimeout, flushWork, workLoop

	local function advanceTimers(currentTime)
		-- Check for tasks that are no longer delayed and add them to the queue.
		local timer = peek(timerQueue)

		while timer ~= nil do
			if timer.callback == nil then
				-- Timer was cancelled, remove from queue
				pop(timerQueue)
			elseif timer.startTime <= currentTime then
				-- Timer fired. Transfer to the task queue.
				pop(timerQueue)
				timer.sortIndex = timer.expirationTime
				push(taskQueue, timer)
				if enableProfiling then
					markTaskStart(timer, currentTime)
					timer.isQueued = true
				end
			else
				-- Remaining timers are pending.
				return
			end

			timer = peek(timerQueue)
		end
	end

	handleTimeout = function(currentTime)
		isHostTimeoutScheduled = false
		advanceTimers(currentTime)

		if not isHostCallbackScheduled then
			if peek(taskQueue) ~= nil then
				isHostCallbackScheduled = true
				requestHostCallback(flushWork)
			else
				local firstTimer = peek(timerQueue)
				if firstTimer ~= nil then
					requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
				end
			end
		end
	end

	flushWork = function(hasTimeRemaining, initialTime)
		if enableProfiling then
			markSchedulerUnsuspended(initialTime)
		end

		-- We'll need a host callback the next time work is scheduled.
		isHostCallbackScheduled = false
		if isHostTimeoutScheduled then
			-- We scheduled a timeout but it's no longer needed. Cancel it.
			isHostTimeoutScheduled = false
			cancelHostTimeout()
		end

		isPerformingWork = true
		local previousPriorityLevel = currentPriorityLevel

		-- deviation: YOLO flag for disabling pcall
		local ok, result
		if not _G.__YOLO__ then
			-- performance: don't nest try/catch here, Lua can do better, and it eliminated an anon function creation
			if enableProfiling then
				ok, result = xpcall(workLoop, describeError, hasTimeRemaining, initialTime)

				if not ok then
					if currentTask ~= nil then
						local currentTime = getCurrentTime()
						markTaskErrored(currentTask, currentTime)
						currentTask.isQueued = false
					end
				end
			else
				-- No catch in prod code path.
				ok = true
				result = workLoop(hasTimeRemaining, initialTime)
			end
		else
			ok = true
			result = workLoop(hasTimeRemaining, initialTime)
		end

		-- NOTE: finally
		currentTask = nil
		currentPriorityLevel = previousPriorityLevel
		isPerformingWork = false
		if enableProfiling then
			local currentTime = getCurrentTime()
			markSchedulerSuspended(currentTime)
		end

		if not ok then
			error(result)
		end

		return result
	end

	workLoop = function(hasTimeRemaining, initialTime)
		local currentTime = initialTime
		advanceTimers(currentTime)
		currentTask = peek(taskQueue)
		while currentTask ~= nil and not (enableSchedulerDebugging and isSchedulerPaused) do
			if currentTask.expirationTime > currentTime and (not hasTimeRemaining or shouldYieldToHost()) then
				-- This currentTask hasn't expired, and we've reached the deadline.
				break
			end

			local callback = currentTask.callback
			if typeof(callback) == "function" then
				currentTask.callback = nil
				currentPriorityLevel = currentTask.priorityLevel
				local didUserCallbackTimeout = currentTask.expirationTime <= currentTime
				markTaskRun(currentTask, currentTime)
				local continuationCallback = callback(didUserCallbackTimeout)
				currentTime = getCurrentTime()
				if typeof(continuationCallback) == "function" then
					currentTask.callback = continuationCallback
					markTaskYield(currentTask, currentTime)
				else
					if enableProfiling then
						markTaskCompleted(currentTask, currentTime)
						currentTask.isQueued = false
					end

					if currentTask == peek(taskQueue) then
						pop(taskQueue)
					end
				end
				advanceTimers(currentTime)
			else
				pop(taskQueue)
			end

			currentTask = peek(taskQueue)
		end

		-- Return whether there's additional work
		if currentTask ~= nil then
			return true
		else
			local firstTimer = peek(timerQueue)
			if firstTimer ~= nil then
				requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime)
			end

			return false
		end
	end

	local function unstable_runWithPriority(priorityLevel, eventHandler)
		if
			priorityLevel == ImmediatePriority
			or priorityLevel == UserBlockingPriority
			or priorityLevel == NormalPriority
			or priorityLevel == LowPriority
			or priorityLevel == IdlePriority
		then
			-- Leave priority alone if assigned
		else
			priorityLevel = NormalPriority
		end

		local previousPriorityLevel = currentPriorityLevel
		currentPriorityLevel = priorityLevel

		-- deviation: YOLO flag for disabling pcall
		local ok, result
		if not _G.__YOLO__ then
			ok, result = xpcall(eventHandler, describeError)
		else
			ok = true
			result = eventHandler()
		end

		-- NOTE: finally
		currentPriorityLevel = previousPriorityLevel

		if not ok then
			error(result)
		end

		return result
	end

	local function unstable_next(eventHandler)
		local priorityLevel
		if
			currentPriorityLevel == ImmediatePriority
			or currentPriorityLevel == UserBlockingPriority
			or currentPriorityLevel == NormalPriority
		then
			-- Shift down to normal priority
			priorityLevel = NormalPriority
		else
			-- Anything lower than normal priority should remain at the current level.
			priorityLevel = currentPriorityLevel
		end

		local previousPriorityLevel = currentPriorityLevel
		currentPriorityLevel = priorityLevel

		-- deviation: YOLO flag for disabling pcall
		local ok, result
		if not _G.__YOLO__ then
			ok, result = xpcall(eventHandler, describeError)
		else
			ok = true
			result = eventHandler()
		end

		-- NOTE: finally
		currentPriorityLevel = previousPriorityLevel

		if not ok then
			error(result)
		end

		return result
	end

	local function unstable_wrapCallback(callback)
		local parentPriorityLevel = currentPriorityLevel

		return function(...)
			-- This is a fork of runWithPriority, inlined for performance.
			local previousPriorityLevel = currentPriorityLevel
			currentPriorityLevel = parentPriorityLevel

			-- deviation: YOLO flag for disabling pcall
			local ok, result
			if not _G.__YOLO__ then
				ok, result = xpcall(callback, describeError, ...)
			else
				ok = true
				result = callback(...)
			end

			-- NOTE: finally
			currentPriorityLevel = previousPriorityLevel

			if not ok then
				error(result)
			end

			return result
		end
	end

	local function unstable_scheduleCallback(priorityLevel, callback, options)
		local currentTime = getCurrentTime()

		local startTime

		if typeof(options) == "table" then
			local delay_ = options.delay
			if typeof(delay_) == "number" and delay_ > 0 then
				startTime = currentTime + delay_
			else
				startTime = currentTime
			end
		else
			startTime = currentTime
		end

		local timeout
		if priorityLevel == ImmediatePriority then
			timeout = IMMEDIATE_PRIORITY_TIMEOUT
		elseif priorityLevel == UserBlockingPriority then
			timeout = USER_BLOCKING_PRIORITY_TIMEOUT
		elseif priorityLevel == IdlePriority then
			timeout = IDLE_PRIORITY_TIMEOUT
		elseif priorityLevel == LowPriority then
			timeout = LOW_PRIORITY_TIMEOUT
		else
			timeout = NORMAL_PRIORITY_TIMEOUT
		end

		local expirationTime = startTime + timeout

		local newTask = {
			id = taskIdCounter,
			callback = callback,
			priorityLevel = priorityLevel,
			startTime = startTime,
			expirationTime = expirationTime,
			sortIndex = -1,
		}
		taskIdCounter += 1

		if enableProfiling then
			newTask.isQueued = false
		end

		if startTime > currentTime then
			-- This is a delayed task.
			newTask.sortIndex = startTime
			push(timerQueue, newTask)
			-- TODO(align): VALIDATE conversion from `peek(taskQueue) === null && newTask === peek(timerQueue)`
			if #taskQueue == 0 and newTask == peek(timerQueue) then
				-- All tasks are delayed, and this is the task with the earliest delay.
				if isHostTimeoutScheduled then
					-- Cancel an existing timeout.
					cancelHostTimeout()
				else
					isHostTimeoutScheduled = true
				end
				-- Schedule a timeout.
				requestHostTimeout(handleTimeout, startTime - currentTime)
			end
		else
			newTask.sortIndex = expirationTime
			push(taskQueue, newTask)
			if enableProfiling then
				markTaskStart(newTask, currentTime)
				newTask.isQueued = true
			end

			-- Schedule a host callback, if needed. If we're already performing work,
			-- wait until the next time we yield.
			if not isHostCallbackScheduled and not isPerformingWork then
				isHostCallbackScheduled = true
				requestHostCallback(flushWork)
			end
		end

		return newTask
	end

	local function unstable_pauseExecution()
		isSchedulerPaused = true
	end

	local function unstable_continueExecution()
		isSchedulerPaused = false
		if not isHostCallbackScheduled and not isPerformingWork then
			isHostCallbackScheduled = true
			requestHostCallback(flushWork)
		end
	end

	local function unstable_getFirstCallbackNode()
		return peek(taskQueue)
	end

	local function unstable_cancelCallback(task)
		if enableProfiling then
			if task.isQueued then
				local currentTime = getCurrentTime()
				markTaskCanceled(task, currentTime)
				task.isQueued = false
			end
		end

		-- Null out the callback to indicate the task has been canceled. (Can't
		-- remove from the queue because you can't remove arbitrary nodes from an
		-- array based heap, only the first one.)
		task.callback = nil
	end

	local function unstable_getCurrentPriorityLevel()
		return currentPriorityLevel
	end

	local unstable_requestPaint = requestPaint

	return {
		unstable_ImmediatePriority = ImmediatePriority,
		unstable_UserBlockingPriority = UserBlockingPriority,
		unstable_NormalPriority = NormalPriority,
		unstable_IdlePriority = IdlePriority,
		unstable_LowPriority = LowPriority,
		unstable_runWithPriority = unstable_runWithPriority,
		unstable_next = unstable_next,
		unstable_scheduleCallback = unstable_scheduleCallback,
		unstable_cancelCallback = unstable_cancelCallback,
		unstable_wrapCallback = unstable_wrapCallback,
		unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel,
		unstable_shouldYield = shouldYieldToHost,
		unstable_requestPaint = unstable_requestPaint,
		unstable_continueExecution = unstable_continueExecution,
		unstable_pauseExecution = unstable_pauseExecution,
		unstable_getFirstCallbackNode = unstable_getFirstCallbackNode,
		unstable_now = getCurrentTime,
		unstable_forceFrameRate = forceFrameRate,
		-- TODO: use if-expressions when all clients are on 503+
		unstable_Profiling = (function()
			if enableProfiling then
				return {
					startLoggingProfilingEvents = startLoggingProfilingEvents,
					stopLoggingProfilingEvents = stopLoggingProfilingEvents,
				}
			end
			return nil
		end)(),
	}
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000635d</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX04897155A0DD49E8A9D6680256BE7987">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulerFeatureFlags</string>
								<string name="ScriptGuid">{E2834214-E3EB-4F8D-9019-6DF5923A4A9B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/SchedulerFeatureFlags.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
]]

return {
	enableSchedulerDebugging = false,
	enableIsInputPending = false,
	enableProfiling = _G.__PROFILE__,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000635e</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX8E859164076B4DF1A7C576D032A0746D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulerHostConfig</string>
								<string name="ScriptGuid">{79E55E8A-4F75-475F-B5BB-95F7DF184984}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/00748c53e183952696157088a858352cc77b0010/packages/scheduler/src/SchedulerHostConfig.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

-- deviation: In React, this module throws an error and is expected to be
-- replaced via a bundler. In our case, we mock it explicitly when we need to
-- mock it, and return the "default" here
return require(script.Parent.forks["SchedulerHostConfig.default"])
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed0000635f</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX378CBF75A44747C697A85479C99ECAB1">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulerMinHeap</string>
								<string name="ScriptGuid">{2523A56F-B3A2-4C1F-AD9C-83DECF1F20EA}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/e706721490e50d0bd6af2cd933dbf857fd8b61ed/packages/scheduler/src/SchedulerMinHeap.js
--!strict
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

type Heap = { [number]: Node? }
type Node = {
	id: number,
	sortIndex: number,
}

local exports = {}
-- deviation: This file contains several workarounds for Luau analysis issues by using the `::` operator
local compare, siftUp, siftDown

exports.push = function(heap: Heap, node: Node): ()
	local index = #heap + 1
	heap[index] = node

	siftUp(heap, node, index)
end

exports.peek = function(heap: Heap): Node?
	return heap[1]
end

exports.pop = function(heap: Heap): Node?
	local first = heap[1]
	if first ~= nil then
		local last = heap[#heap]
		heap[#heap] = nil

		if last :: Node ~= first :: Node then
			heap[1] = last
			siftDown(heap, last :: Node, 1)
		end
		return first
	else
		return nil
	end
end

siftUp = function(heap: Heap, node: Node, index: number): ()
	while true do
		local parentIndex = math.floor(index / 2)
		local parent = heap[parentIndex]
		if parent ~= nil and compare(parent :: Node, node :: Node) > 0 then
			-- The parent is larger. Swap positions.
			heap[parentIndex] = node
			heap[index] = parent
			index = parentIndex
		else
			-- The parent is smaller. Exit.
			return
		end
	end
end

siftDown = function(heap: Heap, node: Node, index: number): ()
	local length = #heap
	while index < length do
		local leftIndex = index * 2
		local left = heap[leftIndex]
		local rightIndex = leftIndex + 1
		local right = heap[rightIndex]

		-- If the left or right node is smaller, swap with the smaller of those.
		if left ~= nil and compare(left :: Node, node) < 0 then
			if right ~= nil and compare(right :: Node, left :: Node) < 0 then
				heap[index] = right
				heap[rightIndex] = node
				index = rightIndex
			else
				heap[index] = left
				heap[leftIndex] = node
				index = leftIndex
			end
		elseif right ~= nil and compare(right :: Node, node :: Node) < 0 then
			heap[index] = right
			heap[rightIndex] = node
			index = rightIndex
		else
			-- Neither child is smaller. Exit.
			return
		end
	end
end

compare = function(a: Node, b: Node): number
	-- Compare sort index first, then task id.
	local diff = a.sortIndex - b.sortIndex

	if diff == 0 then
		return a.id - b.id
	end

	return diff
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006360</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX2895F767B2B34E65AB04BC42BB55E318">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulerPriorities</string>
								<string name="ScriptGuid">{99E69C63-9ADC-48AA-AAB3-3B78A3545B27}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/00748c53e183952696157088a858352cc77b0010/packages/scheduler/src/SchedulerHostConfig.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

export type PriorityLevel = number

-- TODO: Use symbols?
return {
	NoPriority = 0,
	ImmediatePriority = 1,
	UserBlockingPriority = 2,
	NormalPriority = 3,
	LowPriority = 4,
	IdlePriority = 5,
}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006361</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB677256D86D44BFAAA82B3C2ABF18D92">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">SchedulerProfiling</string>
								<string name="ScriptGuid">{F010F1A4-BE9B-4608-B2EC-B85E34582AE6}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream https://github.com/facebook/react/blob/8af27aeedbc6b00bc2ef49729fc84f116c70a27c/packages/scheduler/src/SchedulerProfiling.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
]]
-- NOTE: this file is synced against a post-17.0.1 version that doesn't use SharedArrayBuffer
local Packages = script.Parent.Parent
-- NOTE: use patched console from shared
local console = require(Packages.Shared).console
local exports = {}

local SchedulerPriorities = require(script.Parent.SchedulerPriorities)
type PriorityLevel = SchedulerPriorities.PriorityLevel

local ScheduleFeatureFlags = require(script.Parent.SchedulerFeatureFlags)
local enableProfiling = ScheduleFeatureFlags.enableProfiling

local runIdCounter: number = 0
local mainThreadIdCounter: number = 0

-- Bytes per element is 4
local INITIAL_EVENT_LOG_SIZE = 131072
local MAX_EVENT_LOG_SIZE = 524288 -- Equivalent to 2 megabytes

local eventLogSize = 0
local eventLogBuffer = nil
local eventLog = nil
local eventLogIndex = 1

local TaskStartEvent = 1
local TaskCompleteEvent = 2
local TaskErrorEvent = 3
local TaskCancelEvent = 4
local TaskRunEvent = 5
local TaskYieldEvent = 6
local SchedulerSuspendEvent = 7
local SchedulerResumeEvent = 8

local function logEvent(entries)
	if eventLog ~= nil then
		-- deviation: upstream uses a packed array for performance. we do something simpler for now
		eventLogIndex += #entries
		if eventLogIndex + 1 > eventLogSize then
			eventLogSize *= 2
			if eventLogSize > MAX_EVENT_LOG_SIZE then
				-- Using console['error'] to evade Babel and ESLint
				console["error"](
					"Scheduler Profiling: Event log exceeded maximum size. Don't "
						.. "forget to call `stopLoggingProfilingEvents()`."
				)
				exports.stopLoggingProfilingEvents()
				return
			end
			local newEventLog = {}
			table.insert(newEventLog, eventLog)
			eventLogBuffer = newEventLog
			eventLog = newEventLog
		end
		table.insert(eventLog, entries)
	end
end

exports.startLoggingProfilingEvents = function()
	eventLogSize = INITIAL_EVENT_LOG_SIZE
	eventLogBuffer = {}
	eventLog = eventLogBuffer
	eventLogIndex = 1
end

exports.stopLoggingProfilingEvents = function()
	local buffer = eventLogBuffer
	eventLogSize = 0
	-- FIXME Luau: needs local inference? Type 'nil' could not be converted into '{|  |}'
	eventLogBuffer = nil :: any
	eventLog = nil :: any
	eventLogIndex = 1
	return buffer
end

exports.markTaskStart = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			-- performance.now returns a float, representing milliseconds. When the
			-- event is logged, it's coerced to an int. Convert to microseconds to
			-- maintain extra degrees of precision.
			logEvent({ TaskStartEvent, ms * 1000, task.id, task.priorityLevel })
		end
	end
end

exports.markTaskCompleted = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			-- performance.now returns a float, representing milliseconds. When the
			-- event is logged, it's coerced to an int. Convert to microseconds to
			-- maintain extra degrees of precision.
			logEvent({ TaskCompleteEvent, ms * 1000, task.id })
		end
	end
end

exports.markTaskCanceled = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ TaskCancelEvent, ms * 1000, task.id })
		end
	end
end

exports.markTaskErrored = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ TaskErrorEvent, ms * 1000, task.id })
		end
	end
end

exports.markTaskRun = function(task, ms: number)
	if enableProfiling then
		runIdCounter += 1

		if eventLog ~= nil then
			logEvent({ TaskRunEvent, ms * 1000, task.id, runIdCounter })
		end
	end
end

exports.markTaskYield = function(task, ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ TaskYieldEvent, ms * 1000, task.id, runIdCounter })
		end
	end
end

exports.markSchedulerSuspended = function(ms: number)
	if enableProfiling then
		mainThreadIdCounter += 1

		if eventLog ~= nil then
			logEvent({ SchedulerSuspendEvent, ms * 1000, mainThreadIdCounter })
		end
	end
end

exports.markSchedulerUnsuspended = function(ms: number)
	if enableProfiling then
		if eventLog ~= nil then
			logEvent({ SchedulerResumeEvent, ms * 1000, mainThreadIdCounter })
		end
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006362</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0C69549B53104E7091D072B04FEAFF2F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Tracing</string>
								<string name="ScriptGuid">{70C95AE4-A1BF-4E7E-8F97-4B5046A3F45B}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
-- upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/Tracing.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */

type Function = (any) -> any
local Packages = script.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Set<T> = LuauPolyfill.Set<T>
local Set = LuauPolyfill.Set
local exports = {}

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags
local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing

export type Interaction = {
	__count: number,
	id: number,
	name: string,
	timestamp: number,
}

export type Subscriber = {
	-- A new interaction has been created via the trace() method.
	onInteractionTraced: (Interaction) -> (),

	-- All scheduled async work for an interaction has finished.
	onInteractionScheduledWorkCompleted: (Interaction) -> (),

	-- New async work has been scheduled for a set of interactions.
	-- When this work is later run, onWorkStarted/onWorkStopped will be called.
	-- A batch of async/yieldy work may be scheduled multiple times before completing.
	-- In that case, onWorkScheduled may be called more than once before onWorkStopped.
	-- Work is scheduled by a "thread" which is identified by a unique ID.
	onWorkScheduled: (Set<Interaction>, number) -> (),

	-- A batch of scheduled work has been canceled.
	-- Work is done by a "thread" which is identified by a unique ID.
	onWorkCanceled: (Set<Interaction>, number) -> (),

	-- A batch of work has started for a set of interactions.
	-- When this work is complete, onWorkStopped will be called.
	-- Work is not always completed synchronously yielding may occur in between.
	-- A batch of async/yieldy work may also be re-started before completing.
	-- In that case, onWorkStarted may be called more than once before onWorkStopped.
	-- Work is done by a "thread" which is identified by a unique ID.
	onWorkStarted: (Set<Interaction>, number) -> (),

	-- A batch of work has completed for a set of interactions.
	-- Work is done by a "thread" which is identified by a unique ID.
	onWorkStopped: (Set<Interaction>, number) -> (),
	-- ...
}

export type InteractionsRef = { current: Set<Interaction> }

export type SubscriberRef = { current: Subscriber | nil }

local DEFAULT_THREAD_ID = 0

-- Counters used to generate unique IDs.
local interactionIDCounter: number = 0
local threadIDCounter: number = 0

-- Set of currently traced interactions.
-- Interactions "stack"–
-- Meaning that newly traced interactions are appended to the previously active set.
-- When an interaction goes out of scope, the previous set (if any) is restored.
local interactionsRef: InteractionsRef

-- Listener(s) to notify when interactions begin and end.
local subscriberRef: SubscriberRef

if enableSchedulerTracing then
	interactionsRef = {
		current = Set.new(),
	}
	subscriberRef = {
		current = nil,
	}
end

exports.__interactionsRef = interactionsRef
exports.__subscriberRef = subscriberRef

exports.unstable_clear = function(callback: Function)
	if not enableSchedulerTracing then
		return callback()
	end

	local prevInteractions = interactionsRef.current
	interactionsRef.current = Set.new()

	-- try
	local ok, result = pcall(callback)
	-- finally
	interactionsRef.current = prevInteractions

	if not ok then
		error(result)
	end

	return result
end

exports.unstable_getCurrent = function(): Set<Interaction> | nil
	if not enableSchedulerTracing then
		return nil
	else
		return interactionsRef.current
	end
end

exports.unstable_getThreadID = function(): number
	threadIDCounter += 1
	return threadIDCounter
end

exports.unstable_trace = function(name: string, timestamp: number, callback: Function, threadID_: number?): any
	-- NOTE: default argument value
	local threadID = if threadID_ ~= nil then threadID_ else DEFAULT_THREAD_ID

	if not enableSchedulerTracing then
		return callback()
	end

	local interaction: Interaction = {
		__count = 1,
		id = interactionIDCounter,
		name = name,
		timestamp = timestamp,
	}
	interactionIDCounter += 1

	local prevInteractions = interactionsRef.current

	-- Traced interactions should stack/accumulate.
	-- To do that, clone the current interactions.
	-- The previous set will be restored upon completion.
	local interactions = Set.new(prevInteractions)
	interactions:add(interaction)
	interactionsRef.current = interactions

	local subscriber = subscriberRef.current
	local returnValue

	-- try
	local ok, result = pcall(function()
		if subscriber ~= nil then
			subscriber.onInteractionTraced(interaction)
		end
	end)
	-- finally
	-- try 2
	local ok2, result2 = pcall(function()
		if subscriber ~= nil then
			subscriber.onWorkStarted(interactions, threadID)
		end
	end)

	-- finally 2
	-- try 3
	local ok3, result3 = pcall(function()
		returnValue = callback()
	end)
	-- finally 3
	interactionsRef.current = prevInteractions
	-- try 4
	local ok4, result4 = pcall(function()
		if subscriber ~= nil then
			subscriber.onWorkStopped(interactions, threadID)
		end
	end)
	-- finally 4
	interaction.__count -= 1

	-- If no async work was scheduled for this interaction,
	-- Notify subscribers that it's completed.
	if subscriber ~= nil and interaction.__count == 0 then
		subscriber.onInteractionScheduledWorkCompleted(interaction)
	end

	if not ok4 then
		error(result4)
	end

	if not ok3 then
		error(result3)
	end

	if not ok2 then
		error(result2)
	end

	if not ok then
		error(result)
	end

	return returnValue
end

exports.unstable_wrap = function(
	callback: Function,
	threadID: number
): any -- ROLBOX deviation: any, since __call doesn't map to Function
	-- NOTE: default argument value
	if threadID == nil then
		threadID = DEFAULT_THREAD_ID
	end

	if not enableSchedulerTracing then
		return callback
	end

	local wrappedInteractions = interactionsRef.current

	local subscriber = subscriberRef.current
	if subscriber ~= nil then
		subscriber.onWorkScheduled(wrappedInteractions, threadID)
	end

	-- Update the pending async work count for the current interactions.
	-- Update after calling subscribers in case of error.
	for _, interaction in wrappedInteractions do
		interaction.__count += 1
	end

	local hasRun = false

	local function _wrapped(self, ...)
		local prevInteractions = interactionsRef.current
		interactionsRef.current = wrappedInteractions

		subscriber = subscriberRef.current

		-- try
		local ok, result = pcall(function(...)
			local returnValue

			-- try 2
			local ok2, result2 = pcall(function()
				if subscriber ~= nil then
					subscriber.onWorkStarted(wrappedInteractions, threadID)
				end
			end)
			-- finally 2
			-- try 3
			local ok3, result3 = pcall(function(...)
				returnValue = callback(...)
			end, ...)
			-- finally 3
			interactionsRef.current = prevInteractions

			if subscriber ~= nil then
				subscriber.onWorkStopped(wrappedInteractions, threadID)
			end

			if not ok3 then
				error(result3)
			end

			if not ok2 then
				error(result2)
			end

			return returnValue
		end, ...)

		-- finally {
		if not hasRun then
			-- We only expect a wrapped function to be executed once,
			-- But in the event that it's executed more than once–
			-- Only decrement the outstanding interaction counts once.
			hasRun = true

			-- Update pending async counts for all wrapped interactions.
			-- If this was the last scheduled async work for any of them,
			-- Mark them as completed.
			for _, interaction in wrappedInteractions do
				interaction.__count -= 1

				if subscriber ~= nil and interaction.__count == 0 then
					subscriber.onInteractionScheduledWorkCompleted(interaction)
				end
			end
		end

		if not ok then
			error(result)
		end

		return result
	end

	local _cancel = function()
		subscriber = subscriberRef.current

		local ok, result = pcall(function()
			if subscriber ~= nil then
				subscriber.onWorkCanceled(wrappedInteractions, threadID)
			end
		end)
		-- finally
		-- Update pending async counts for all wrapped interactions.
		-- If this was the last scheduled async work for any of them,
		-- Mark them as completed.
		for _, interaction in wrappedInteractions do
			interaction.__count -= 1

			if subscriber ~= nil and interaction.__count == 0 then
				subscriber.onInteractionScheduledWorkCompleted(interaction)
			end
		end

		if not ok then
			error(result)
		end
	end

	local wrapped = {}
	setmetatable(wrapped, {
		__call = _wrapped,
	})
	wrapped.cancel = _cancel

	return wrapped
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006363</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0523F99356C2481FAD674B020494C955">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TracingSubscriptions</string>
								<string name="ScriptGuid">{F53EB808-BF28-4B83-AFBA-88A9E8DC4FF2}</string>
								<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/9abc2785cb070148d64fae81e523246b90b92016/packages/scheduler/src/TracingSubscriptions.js
-- /**
--  * Copyright (c) Facebook, Inc. and its affiliates.
--  *
--  * This source code is licensed under the MIT license found in the
--  * LICENSE file in the root directory of this source tree.
--  *
--  * @flow
--  */
type Set<T> = { [T]: boolean? }
type Array<T> = { [number]: T }
local exports = {}
local Packages = script.Parent.Parent
local Object = require(Packages.LuauPolyfill).Object

local Tracing = require(script.Parent.Tracing)
type Interaction = Tracing.Interaction
type Subscriber = Tracing.Subscriber

local ReactFeatureFlags = require(Packages.Shared).ReactFeatureFlags

local enableSchedulerTracing = ReactFeatureFlags.enableSchedulerTracing
local __subscriberRef = Tracing.__subscriberRef

local subscribers: Set<Subscriber> = {}
if enableSchedulerTracing then
	subscribers = {}
end

exports.unstable_subscribe = function(subscriber: Subscriber): ()
	if enableSchedulerTracing then
		subscribers[subscriber] = true

		if #Object.keys(subscribers) == 1 then
			__subscriberRef.current = {
				onInteractionScheduledWorkCompleted = onInteractionScheduledWorkCompleted,
				onInteractionTraced = onInteractionTraced,
				onWorkCanceled = onWorkCanceled,
				onWorkScheduled = onWorkScheduled,
				onWorkStarted = onWorkStarted,
				onWorkStopped = onWorkStopped,
			}
		end
	end
end

exports.unstable_unsubscribe = function(subscriber: Subscriber): ()
	if enableSchedulerTracing then
		subscribers[subscriber] = nil

		if #Object.keys(subscribers) == 0 then
			__subscriberRef.current = nil
		end
	end
end

function onInteractionTraced(interaction: Interaction): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- try
		local ok, result = pcall(subscriber.onInteractionTraced, interaction)
		-- catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onInteractionScheduledWorkCompleted(interaction: Interaction): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- try
		local ok, result = pcall(subscriber.onInteractionScheduledWorkCompleted, interaction)
		-- catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkScheduled(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- try
		local ok, result = pcall(subscriber.onWorkScheduled, interactions, threadID)
		-- catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkStarted(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- try
		local ok, result = pcall(subscriber.onWorkStarted, interactions, threadID)
		-- catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkStopped(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- try
		local ok, result = pcall(subscriber.onWorkStopped, interactions, threadID)
		-- catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

function onWorkCanceled(interactions: Set<Interaction>, threadID: number): ()
	local didCatchError = false
	local caughtError = nil

	for subscriber, _ in subscribers do
		-- try
		local ok, result = pcall(subscriber.onWorkCanceled, interactions, threadID)
		-- catch
		if not ok then
			local error_ = result
			if not didCatchError then
				didCatchError = true
				caughtError = error_
			end
		end
	end

	if didCatchError then
		error(caughtError)
	end
end

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006364</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX10491263B8124D8EA2286DCAD1E0702C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">forks</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006365</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXBAECDE13BEAC4041BFCFAF7A8919DCAE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SchedulerHostConfig.default</string>
									<string name="ScriptGuid">{BF084689-1E1A-41FC-A465-704587CA2FCF}</string>
									<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/5474a83e258b497584bed9df95de1d554bc53f89/packages/scheduler/src/forks/SchedulerHostConfig.default.js
--!strict
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
]]

local Packages = script.Parent.Parent.Parent
local LuauPolyfill = require(Packages.LuauPolyfill)
type Error = LuauPolyfill.Error
local Object = LuauPolyfill.Object
local Shared = require(Packages.Shared)
local console = Shared.console
local errorToString = Shared.errorToString
local describeError = Shared.describeError

-- deviation: getCurrentTime will always map to `tick` in Luau
local getCurrentTime = function()
	-- Return a result in milliseconds
	return os.clock() * 1000
end

-- deviation: This module in React exports a different implementation if
-- it detects certain APIs from the DOM interface. We instead attempt to
-- approximate that behavior so that we can access features like dividing work
-- according to frame time

-- Capture local references to native APIs, in case a polyfill overrides them.
local setTimeout = LuauPolyfill.setTimeout
local clearTimeout = LuauPolyfill.clearTimeout

local isMessageLoopRunning = false
local scheduledHostCallback: ((boolean, number) -> boolean) | nil = nil
local taskTimeoutID = Object.None

-- Scheduler periodically yields in case there is other work on the main
-- thread, like user events. By default, it yields multiple times per frame.
-- It does not attempt to align with frame boundaries, since most tasks don't
-- need to be frame aligned; for those that do, use requestAnimationFrame.
local yieldInterval = 15
local deadline = 0

-- deviation: Removed some logic around browser functionality that's not
-- present in the roblox engine
local function shouldYieldToHost()
	return getCurrentTime() >= deadline
end

-- Since we yield every frame regardless, `requestPaint` has no effect.
local function requestPaint() end

local function forceFrameRate(fps)
	if fps < 0 or fps > 125 then
		console.warn(
			"forceFrameRate takes a positive int between 0 and 125, "
				.. "forcing frame rates higher than 125 fps is not supported"
		)
		return
	end
	if fps > 0 then
		yieldInterval = math.floor(1000 / fps)
	else
		-- reset the framerate
		yieldInterval = 5
	end
end

local function performWorkUntilDeadline()
	if scheduledHostCallback ~= nil then
		local currentTime = getCurrentTime()
		-- Yield after `yieldInterval` ms, regardless of where we are in the vsync
		-- cycle. This means there's always time remaining at the beginning of
		-- the message event.
		deadline = currentTime + yieldInterval
		local hasTimeRemaining = true

		local ok, result
		local function doWork()
			local hasMoreWork = (scheduledHostCallback :: any)(hasTimeRemaining, currentTime)
			if not hasMoreWork then
				isMessageLoopRunning = false
				scheduledHostCallback = nil
			else
				-- If there's more work, schedule the next message event at the end
				-- of the preceding one.

				-- deviation: Use task api instead of message channel;
				-- depending on whether or not we still have time to perform
				-- more work, either yield and defer till later this frame, or
				-- delay work till next frame

				-- FIXME: What's the proper combination of task.defer and
				-- task.delay that makes this optimal?
				task.delay(0, performWorkUntilDeadline)
			end
			return nil
		end
		if not _G.__YOLO__ then
			ok, result = xpcall(doWork, describeError)
		else
			result = doWork()
			ok = true
		end

		if not ok then
			-- If a scheduler task throws, exit the current coroutine so the
			-- error can be observed.
			task.delay(0, performWorkUntilDeadline)

			-- FIXME: the top-level Luau VM handler doesn't deal with
			-- non-string errors, so massage it until VM support lands
			error(errorToString(result :: any))
		end
	else
		isMessageLoopRunning = false
	end
end

local function requestHostCallback(callback)
	scheduledHostCallback = callback
	if not isMessageLoopRunning then
		isMessageLoopRunning = true

		task.delay(0, performWorkUntilDeadline)
	end
end

local function cancelHostCallback()
	scheduledHostCallback = nil
end

local function requestHostTimeout(callback, ms)
	taskTimeoutID = setTimeout(function()
		callback(getCurrentTime())
	end, ms)
end

local function cancelHostTimeout()
	clearTimeout(taskTimeoutID)
	taskTimeoutID = Object.None
end

return {
	requestHostCallback = requestHostCallback,
	cancelHostCallback = cancelHostCallback,
	requestHostTimeout = requestHostTimeout,
	cancelHostTimeout = cancelHostTimeout,
	shouldYieldToHost = shouldYieldToHost,
	requestPaint = requestPaint,
	getCurrentTime = getCurrentTime,
	forceFrameRate = forceFrameRate,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006366</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXE6AC9D65D9354E0BAFF3D22E14B67472">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SchedulerHostConfig.mock</string>
									<string name="ScriptGuid">{5C19BA31-9613-4948-A404-A7BA4AA7CE2B}</string>
									<ProtectedString name="Source"><![CDATA[-- upstream: https://github.com/facebook/react/blob/5474a83e258b497584bed9df95de1d554bc53f89/packages/scheduler/src/forks/SchedulerHostConfig.mock.js
--[[*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*
* @flow
]]

local exports = {}

local currentTime: number = 0
local scheduledCallback: ((boolean, number) -> ()) | nil = nil
local scheduledTimeout: ((number) -> ()) | nil = nil
local timeoutTime: number = -1
local yieldedValues: { [number]: any } | nil = nil
local expectedNumberOfYields: number = -1
local didStop: boolean = false
local isFlushing: boolean = false
local needsPaint: boolean = false
local shouldYieldForPaint: boolean = false
local Packages = script.Parent.Parent.Parent
local console = require(Packages.Shared).console
local ConsolePatchingDev = require(Packages.Shared).ConsolePatchingDev
local disabledLog = ConsolePatchingDev.disabledLog

exports.requestHostCallback = function(callback: (boolean) -> ())
	scheduledCallback = callback
end

exports.cancelHostCallback = function()
	scheduledCallback = nil
end

exports.requestHostTimeout = function(callback: (number) -> (), ms: number)
	scheduledTimeout = callback
	timeoutTime = currentTime + ms
end

exports.cancelHostTimeout = function()
	scheduledTimeout = nil
	timeoutTime = -1
end

exports.shouldYieldToHost = function(): boolean
	-- deviation: widening type to workaround Luau shortcomings
	-- https://jira.rbx.com/browse/CLI-35978
	local values: any = yieldedValues
	if
		(expectedNumberOfYields ~= -1 and values ~= nil and #values >= expectedNumberOfYields)
		or (shouldYieldForPaint and needsPaint)
	then
		-- We yielded at least as many values as expected. Stop flushing.
		didStop = true
		return true
	end

	return false
end

exports.getCurrentTime = function(): number
	return currentTime
end

exports.forceFrameRate = function()
	-- No-op
end

exports.reset = function()
	if isFlushing then
		error("Cannot reset while already flushing work.")
	end

	currentTime = 0
	scheduledCallback = nil
	scheduledTimeout = nil
	timeoutTime = -1
	yieldedValues = nil
	expectedNumberOfYields = -1
	didStop = false
	isFlushing = false
	needsPaint = false
end

-- Should only be used via an assertion helper that inspects the yielded values.
exports.unstable_flushNumberOfYields = function(count: number)
	if isFlushing then
		error("Already flushing work.")
	end

	if scheduledCallback ~= nil then
		local cb = scheduledCallback
		expectedNumberOfYields = count
		isFlushing = true

		local ok, result = pcall(function()
			local hasMoreWork = true
			repeat
				hasMoreWork = cb(true, currentTime)
			until not hasMoreWork or didStop

			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		expectedNumberOfYields = -1
		didStop = false
		isFlushing = false

		if not ok then
			error(result)
		end
	end
end

exports.unstable_flushUntilNextPaint = function()
	if isFlushing then
		error("Already flushing work.")
	end

	if scheduledCallback ~= nil then
		local cb = scheduledCallback
		shouldYieldForPaint = true
		needsPaint = false
		isFlushing = true
		-- try
		local ok, result = pcall(function()
			local hasMoreWork = true
			repeat
				hasMoreWork = cb(true, currentTime)
			until not hasMoreWork or didStop

			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		-- finally
		shouldYieldForPaint = false
		didStop = false
		isFlushing = false

		if not ok then
			error(result)
		end
	end
end

exports.unstable_flushExpired = function()
	if isFlushing then
		error("Already flushing work.")
	end
	if scheduledCallback ~= nil then
		isFlushing = true
		local ok, result = pcall(function()
			-- deviation: widening type to workaround Luau shortcomings
			-- https://jira.rbx.com/browse/CLI-35978
			local callback: any = scheduledCallback
			local hasMoreWork = callback(false, currentTime)
			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		isFlushing = false

		if not ok then
			error(result)
		end
	end
end

exports.unstable_flushAllWithoutAsserting = function(): boolean
	-- Returns false if no work was flushed.
	if isFlushing then
		error("Already flushing work.")
	end
	if scheduledCallback ~= nil then
		local cb = scheduledCallback
		isFlushing = true
		local ok, result = pcall(function()
			local hasMoreWork = true
			repeat
				hasMoreWork = cb(true, currentTime)
			until not hasMoreWork

			if not hasMoreWork then
				scheduledCallback = nil
			end
		end)

		isFlushing = false

		if not ok then
			error(result)
		end

		return true
	else
		return false
	end
end

exports.unstable_clearYields = function(): { [number]: any }
	if yieldedValues == nil then
		return {}
	end
	local values = yieldedValues
	yieldedValues = nil
	return values
end

exports.unstable_flushAll = function()
	if yieldedValues ~= nil then
		error("Log is not empty. Assert on the log of yielded values before " .. "flushing additional work.")
	end
	exports.unstable_flushAllWithoutAsserting()
	if yieldedValues ~= nil then
		error(
			"While flushing work, something yielded a value. Use an "
				.. "assertion helper to assert on the log of yielded values, e.g. "
				.. "expect(Scheduler).toFlushAndYield([...])"
		)
	end
end

exports.unstable_yieldValue = function(value: any)
	-- eslint-disable-next-line react-internal/no-production-logging
	if console.log == disabledLog then
		-- If console.log has been patched, we assume we're in render
		-- replaying and we ignore any values yielding in the second pass.
		return
	end
	if yieldedValues == nil then
		yieldedValues = { value }
	else
		-- deviation: widening type to workaround Luau shortcomings
		-- https://jira.rbx.com/browse/CLI-35978
		local values: any = yieldedValues
		table.insert(values, value)
	end
end

exports.unstable_advanceTime = function(ms: number)
	-- eslint-disable-next-line react-internal/no-production-logging
	if console.log == disabledLog then
		-- If console.log has been patched, we assume we're in render
		-- replaying and we ignore any time advancing in the second pass.
		return
	end
	currentTime += ms

	if scheduledTimeout ~= nil and timeoutTime <= currentTime then
		-- deviation: widening type to workaround Luau shortcomings
		-- https://jira.rbx.com/browse/CLI-35978
		local timeout: any = scheduledTimeout
		timeout(currentTime)
		timeoutTime = -1
		scheduledTimeout = nil
	end
end

exports.requestPaint = function()
	needsPaint = true
end

return exports
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">3a589e3654c30573064751ed00006367</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXA585ADCAA65F4E69A938BA79A3178F24">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">unstable_mock</string>
								<string name="ScriptGuid">{8DA778B5-110C-42B4-B636-C6B9F97213C9}</string>
								<ProtectedString name="Source"><![CDATA[--!strict
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*]]
local Tracing = require(script.Parent.Tracing)
local TracingSubscriptions = require(script.Parent.TracingSubscriptions)
-- deviation: export Tracing type from the package exports to avoid direct file access
export type Interaction = Tracing.Interaction

local initializeScheduler = require(script.Parent.Scheduler)
local HostConfig = require(script.Parent.forks["SchedulerHostConfig.mock"])

local Scheduler = initializeScheduler(HostConfig)

local exports = {}
exports.tracing = {}
-- FIXME Luau: need to fix CLI-56768 to remove any casts
for key, value in Scheduler :: any do
	exports[key] = value
end
for key, value in Tracing :: any do
	exports.tracing[key] = value
end
for key, value in TracingSubscriptions :: any do
	exports.tracing[key] = value
end

exports.unstable_flushAllWithoutAsserting = HostConfig.unstable_flushAllWithoutAsserting
exports.unstable_flushNumberOfYields = HostConfig.unstable_flushNumberOfYields
exports.unstable_flushExpired = HostConfig.unstable_flushExpired
exports.unstable_clearYields = HostConfig.unstable_clearYields
exports.unstable_flushUntilNextPaint = HostConfig.unstable_flushUntilNextPaint
exports.unstable_flushAll = HostConfig.unstable_flushAll
exports.unstable_yieldValue = HostConfig.unstable_yieldValue
exports.unstable_advanceTime = HostConfig.unstable_advanceTime
exports.unstable_Profiling = Scheduler.unstable_Profiling

return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006368</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX610103EAC2144349A3E6BFCB7B6455E7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">RoactTS</string>
							<string name="ScriptGuid">{F8767E81-7E09-4739-BA2A-A15A2C48B229}</string>
							<ProtectedString name="Source"><![CDATA[local Packages = script.Parent :: any

local React = require(Packages.React)
local RoactCompat = require(Packages.RoactCompat)

local exports = table.clone(React)

for key, value in RoactCompat do
	exports[key] = value
end

return exports
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">3a589e3654c30573064751ed00006380</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBX2332E3B1615944FA9DCE207D93E42A41">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">types</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">3a589e3654c30573064751ed00006381</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXAEC1D87994B94F3089706E2578D0C7D0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">matter-hooks</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ab6</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXFE8CDE6F152C4133A77D0D486D3CF1D0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{E248C2C2-3969-4B79-954A-EC28F32DB0FF}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = _G[script]
local exports = {}
TS.import(script, script, "package", "Matter")
for _k, _v in TS.import(script, script, "package", "matter-hooks") or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ab7</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBX199AA5B76C164219B8C8831848126306">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">package</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ab8</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX1EA19CB5C5174BBCA4513A9145AA745E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Matter</string>
										<string name="ScriptGuid">{E3E4A5C4-D026-4EBC-B2F0-BB3DD9690E2A}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = _G[script]
local exports = {}
for _k, _v in TS.import(script, TS.getModule(script, "@rbxts", "matter").lib) or {} do
	exports[_k] = _v
end
return exports
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ab9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX68E0C4B848314D3ABC4C20D82B02AA2C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">matter-hooks</string>
										<string name="ScriptGuid">{730DBC7A-8F30-487A-91A6-61C783A31EF3}</string>
										<ProtectedString name="Source"><![CDATA[local useAsync = require(script.useAsync)
local useChange = require(script.useChange)
local useContextAction = require(script.useContextAction)
local useMap = require(script.useMap)
local useMemo = require(script.useMemo)
local useReducer = require(script.useReducer)
local useStream = require(script.useStream)

--[=[
	@class Hooks
]=]

return {
	useAsync = useAsync,
	useChange = useChange,
	useContextAction = useContextAction,
	useMap = useMap,
	useMemo = useMemo,
	useReducer = useReducer,
	useStream = useStream,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006aba</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBXF3F6C7D9E9624880AE21DAAFF508DD07">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Queue</string>
											<string name="ScriptGuid">{89739FA8-5EAC-4C9F-90C6-1BB2071B26C3}</string>
											<ProtectedString name="Source"><![CDATA[local Queue = {}
Queue.__index = Queue

function Queue.new()
	local self = setmetatable({}, Queue)
	return self
end

function Queue:push<T>(value: T)
	local node = {
		value = value,
	}

	if self.front == nil then
		self.front = node
		self.back = node
		return
	end

	self.back.next = node
	self.back = node
end

function Queue:shift(): unknown
	local node = self.front
	if node == nil then
		return nil
	end

	self.front = node.next
	if self.back == node then
		self.back = nil
	end

	return node.value
end

return Queue
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006abb</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXEC7F29973607410983DF1C57727262ED">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">diffTables</string>
											<string name="ScriptGuid">{7C38E0DC-1FB9-4065-BB34-3AB835A2BD2F}</string>
											<ProtectedString name="Source"><![CDATA[local function diffTables(left: { unknown }?, right: { unknown }?): boolean
	if left and right then
		if left == right then
			return false
		end

		local size = 0

		for index, value in left do
			if value ~= right[index] then
				return true
			end
			size += 1
		end

		for _ in right do
			size -= 1
		end

		if size ~= 0 then
			return true
		end

		return false
	end

	return true
end

return diffTables
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006abc</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX4F9A6C859EF24D5FA2FF98C9A0201ED8">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useAsync</string>
											<string name="ScriptGuid">{A2F33658-FB1E-4176-B463-6FE5390234A5}</string>
											<ProtectedString name="Source"><![CDATA[local Package = script.Parent
local Matter = require(Package.Parent.Matter)
local diffTables = require(Package.diffTables)

--[=[
	Indicates that an async action has succeeded and holds a value.

	```lua
	local result = ready.result

	if result.success then
		processValue(result.value)
	end
	```

	.success true
	.value T

	@within Hooks
	@interface AsyncSuccess
]=]
export type AsyncSuccess<T> = {
	success: true,
	value: T,
}

--[=[
	Indicates that an async action has failed and holds an error.

	```lua
	local result = ready.result

	if not result.success then
		processError(result.error)
	end
	```

	.success false
	.error E

	@within Hooks
	@interface AsyncError
]=]
export type AsyncError<E> = {
	success: false,
	error: E,
}

--[=[
	Indicates whether an async action succeeded or failed.

	The `success` field always exists. A value of `true` indicates that the
	operation succeeded and is an [AsyncSuccess] containing the value from the
	async action. A value of `false` indicates that the operation failed and is an
	[AsyncError] containing an error from the async action.

	```lua
	local result = ready.result

	if result.success then
		-- The action was successful and we have a value.
	else
		-- The action failed and we have an error.
	end
	```

	@within Hooks
	@type AsyncResult AsyncSuccess<T> | AsyncError<E>
]=]
export type AsyncResult<T, E> = AsyncSuccess<T> | AsyncError<E>

--[=[
	Indicates that an async action has completed and the result is ready.

	```lua
	local ready = useAsync(...)

	if ready.completed then
		processResult(ready.result)
	end
	```

	.completed true
	.result AsyncResult<T, string>

	@within Hooks
	@interface AsyncComplete
]=]
export type AsyncComplete<T> = {
	completed: true,
	result: AsyncResult<T, string>,
}

--[=[
	Indicates that an async action has not yet completed.

	.completed false

	@within Hooks
	@interface AsyncIncomplete
]=]
export type AsyncIncomplete = {
	completed: false,
}

--[=[
	Indicates whether an async action has completed.

	The `completed` field always exists. A value of `true` indicates that the
	action is completed and is an [AsyncComplete] containing an [AsyncResult]. A
	value of `false` indicates the action has not yet completed and is an
	[AsyncIncomplete] that does not yet have a result.

	```lua
	local ready = useAsync(...)

	if ready.completed then
		-- The action has completed and we can use the result.
	else
		-- We're still waiting for the action to complete.
	end
	```

	@within Hooks
	@type AsyncReady AsyncComplete<T> | AsyncIncomplete
]=]
export type AsyncReady<T> = AsyncComplete<T> | AsyncIncomplete

local function cleanup(storage)
	if storage.thread then
		task.cancel(storage.thread)
	end
	storage.ready = {
		completed = false,
	}
end

--[=[
	Used to store the result of an asynchronous action.

	This is commonly used to perform tasks that take a long time to complete and
	only need to be done occasionally. The result of the operation is memoized so
	you can retrieve the same value repeatedly after the action has been run.

	The action is only performed when the dependencies change. This can be used
	for values that need to be updated in response to something else.

	:::caution
	If no dependency array is provided, new values will be recalculated every
	time. For actions that only need to run once ever, an empty array can be
	provided.
	:::

	Returns an [AsyncReady] that indicates completion. This type in turn provides
	an [AsyncResult] that indicates whether the operation succeeded or failed.

	If the hook is no longer called, or if the dependencies change before an
	action is completed, any in progress action is canceled early.

	```lua
	local ready = useAsync(function(): number
		return asyncOperation(dependency)
	end, { dependency })

	if ready.completed then
		if ready.result.success then
			updateWithAsyncValue(ready.result.value)
		else
			cancelBehavior()
		end
	end
	```

	@within Hooks

	@return AsyncReady<T> -- The completion status
]=]
local function useAsync<T>(
	callback: () -> T,
	dependencies: { unknown },
	discriminator: unknown?
): AsyncReady<T>
	local storage = Matter.useHookState(discriminator, cleanup)

	if diffTables(dependencies, storage.dependencies) then
		cleanup(storage)
		storage.dependencies = dependencies

		storage.thread = task.defer(function()
			local success, resultOrError = pcall(callback)

			storage.ready = {
				completed = true,
				result = {
					success = success,
					value = if success then resultOrError else nil,
					error = if success then nil else resultOrError,
				},
			}
		end)
	end

	return storage.ready
end

return useAsync
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006abd</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX11B36FE91A714BB9A406096EB195DE84">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useChange</string>
											<string name="ScriptGuid">{8090200B-F978-4212-AC32-27E11519A2F1}</string>
											<ProtectedString name="Source"><![CDATA[local Package = script.Parent
local Matter = require(Package.Parent.Matter)
local diffTables = require(Package.diffTables)

--[=[
	Activates when the provided dependencies change.

	:::caution
	If no dependency array is provided, this returns true always. For actions that
	only need to run once ever, an empty array can be provided.
	:::

	```lua
	if useChange({ dependency }) then
		dependingOperation(dependency)
	end
	```

	@within Hooks

	@return boolean -- True if the dependencies have changed, false otherwise
]=]
local function useChange(dependencies: { unknown }, discriminator: unknown?): boolean
	local storage = Matter.useHookState(discriminator)
	local previous = storage.dependencies
	storage.dependencies = dependencies
	return diffTables(dependencies, previous)
end

return useChange
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006abe</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXD8BAF344C91441269D96D99BE36C0F5B">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useContextAction</string>
											<string name="ScriptGuid">{199AEE9E-08A0-4F23-8E1A-78EF64FB4B1C}</string>
											<ProtectedString name="Source"><![CDATA[local Package = script.Parent
local ContextActionService = game:GetService("ContextActionService")
local Matter = require(Package.Parent.Matter)

--[=[
	.createButton boolean? -- Whether the context action creates a button
	.inputTypes { Enum.Keycode | Enum.UserInputType }? -- An array of inputs for the context action

	@within Hooks
	@interface ContextActionOptions
]=]
export type ContextActionOptions = {
	createButton: boolean?,
	inputTypes: { Enum.KeyCode | Enum.UserInputType }?,
}

type NormalizedOptions = {
	createButton: boolean,
	inputTypes: { Enum.KeyCode | Enum.UserInputType },
}

local function normalizeOptions(options: ContextActionOptions?): NormalizedOptions
	return {
		createButton = if options and options.createButton ~= nil
			then options.createButton
			else false,
		inputTypes = if options and options.inputTypes then options.inputTypes else {},
	}
end

local function cleanup(storage)
	ContextActionService:UnbindAction(storage.actionName)
end

--[=[
	Registers asynchronous context actions within systems.

	The callback is run as a context action normally would be and can sink inputs
	as it normally would by returning a [ContextActionResult]. The callback can be
	updated dynamically as the hook is called.

	:::info
	It's important to keep in mind that the callback doesn't run within your
	system, but as a normal context action.

	Assuming that it runs during your system can lead to subtle bugs.
	:::

	The action name and callback parameters are the same as are used in a normal
	context action. The optional properties encapsulate additional context action
	parameters.

	:::warning
	Only one context action can be registered for each action name.

	It's important to discriminate your action name with each call of this hook,
	such as when calling it in a loop.
	:::

	```lua
	useContextAction(
		"systemAction",
		function(actionName: string, inputState: Enum.UserInputState, inputObject: InputObject)
			if inputState == Enum.UserInputState.Begin then
				updatePosition(actionName, inputObject.Position)
			end
		end,
		{
			inputTypes = {
				Enum.UserInputType.MouseButton1,
				Enum.UserInputType.Touch,
			},
		}
	)
	```

	@within Hooks
]=]
local function useContextAction(
	actionName: string,
	callback: (
		string,
		Enum.UserInputState,
		InputObject
	) -> Enum.ContextActionResult?,
	options: ContextActionOptions
)
	local storage = Matter.useHookState(actionName, cleanup)

	if not storage.actionName then
		local options = normalizeOptions(options)
		storage.actionName = actionName

		ContextActionService:BindAction(actionName, function(...)
			return storage.callback(...)
		end, options.createButton, unpack(options.inputTypes))
	end

	storage.callback = callback
end

return useContextAction
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006abf</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXBC27EEEC655D46E78017C0BF96DB4B6D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useMap</string>
											<string name="ScriptGuid">{23518DB0-2379-4280-A3F3-C60376A4578D}</string>
											<ProtectedString name="Source"><![CDATA[local Package = script.Parent
local Matter = require(Package.Parent.Matter)

--[=[
	Used to store and retrieve values in a map based on a given key.

	This hook can be used to create a map of values that can be accessed and
	updated from within a system. The map is initialized with a default value that
	is used when a key is accessed for the first time.

	:::tip
	While this hook is useful in certain situations it may not be appropriate for
	every situation. Often a variable or table can serve the same purpose.
	:::

	:::caution
	Using non-unique keys may result in unexpected behavior or errors.
	:::

	```lua
	for id in world:query(Component) do
		local name = useMap(id, "Unknown")
		displayName(name.value)
	end
	```

	The `value` field can be updated directly when updating the key in the map.

	```lua
	for id in world:query(Component) do
		local rendered = useMap(id, false)
		if condition then
			rendered.value = true
		elseif otherCondition then
			rendered.value = false
		end
	end
	```

	@within Hooks

	@return { value: T } -- The associated value
]=]
local function useMap<T>(key: unknown, defaultValue: T): { value: T }
	local storage = Matter.useHookState(key)
	if not storage.value then
		storage.value = {
			value = defaultValue,
		}
	end
	return storage.value
end

return useMap
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ac0</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBXB12FF1D053604E3A8FF913EADA701F2B">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useMemo</string>
											<string name="ScriptGuid">{A5705C47-FB42-4EDA-A5C5-A66A18C6D578}</string>
											<ProtectedString name="Source"><![CDATA[local Package = script.Parent
local Matter = require(Package.Parent.Matter)
local diffTables = require(Package.diffTables)

--[=[
	Used to store memoized values that update when dependencies change.

	This is commonly used to perform tasks that are expensive and only need to be
	updated occasionally. The result of the operation will be memoized so you can
	retrieve the same values repeatedly after the action has been run.

	The values are only recalculated when the dependencies change. This can be
	used for values that need to be updated in response to something else.

	:::caution
	If no dependency array is provided, new values will be recalculated every
	time. For actions that only need to run once ever, an empty array can be
	provided.
	:::

	```lua
	local result = useMemo(function(): number
		return expensiveOperation(dependency)
	end, { dependency })
	```

	@within Hooks

	@return T... -- The memoized values
]=]
local function useMemo<T...>(
	callback: () -> T...,
	dependencies: { unknown },
	discriminator: unknown?
): T...
	local storage = Matter.useHookState(discriminator)

	if storage.value == nil or diffTables(dependencies, storage.dependencies) then
		storage.dependencies = dependencies
		storage.value = { callback() }
	end

	-- Luau claims this is a type error. We have specific knowledge that the only
	-- thing ever stored in `storage.value` is a table that captures the return
	-- value of a function that returns `T...`. We also know that it is always
	-- stored at least once before reaching this point.
	return unpack(storage.value)
end

return useMemo
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ac1</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX00619AA9040E4023A75F1E848A4431D4">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useReducer</string>
											<string name="ScriptGuid">{96ADAF48-373F-4606-B1E6-70847AFBC612}</string>
											<ProtectedString name="Source"><![CDATA[local Package = script.Parent
local Matter = require(Package.Parent.Matter)
local diffTables = require(Package.diffTables)

--[=[
	Used to store a stateful value that is updated by a reducer function.

	If you're familiar with Redux/Rodux you'll be familiar with the concept of
	reducers for state management already.

	Every time the dispatch is called, the reducer function is called to provide
	the updated state. It passes an action with information the reducer uses while
	updating the state.

	:::tip
	Its common to use the field `type` of the action to indicate what sort of
	action is being dispatched. Any remaining fields are open to be extended and
	used when calculating the new state.
	:::

	The reducer creates a new state based on the current state and the action
	passed by the reducer. The state is immutable and shouldn't be changed
	directly.

	:::caution
	Nothing is preventing your reducer from mutating state or causing side
	effects. If you do, things may not act as you expect.
	:::

	```lua
	type State = {
		value: number,
	}

	type Action = {
		type: "increase" | "decrease",
	}

	local state, dispatch = useReducer(function(state: State, action: Action): State
		if action.type == "increase" then
			return {
				value = state.value + 1,
			}
		elseif action.type == "decrease" then
			return {
				value = state.value - 1,
			}
		end

		return state
	end, {
		value = 0,
	})

	if state.value > 10 then
		highValueAction()
	end

	if increaseCondition then
		dispatch("increase")
	elseif decreaseCondition then
		dispatch("decrease")
	end
	```

	@within Hooks

	@return S -- The current state
	@return (action: A) -> () -- The dispatch function
]=]
local function useReducer<S, A>(
	reducer: (state: S, action: A) -> S,
	initialState: S,
	discriminator: unknown?
): (S, (action: A) -> ())
	local storage = Matter.useHookState(discriminator)

	if storage.state == nil then
		storage.state = initialState
	end

	local dependencies = { storage.state }

	-- We want to be able to use this dispatch function as a dependency for other
	-- hooks. Memoizing it this way based on state changes allows us to do that
	-- without it updating dependencies every frame.
	if diffTables(dependencies, storage.dependencies) then
		storage.dependencies = dependencies

		storage.dispatch = function(action: A)
			storage.state = reducer(storage.state, action)
		end
	end

	return storage.state, storage.dispatch
end

return useReducer
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ac2</UniqueId>
										</Properties>
									</Item>
									<Item class="ModuleScript" referent="RBX84675633EC9D45D89A116AD2327D43D1">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">useStream</string>
											<string name="ScriptGuid">{30B3BC08-DFF0-4076-BCB5-373FE71BE7F7}</string>
											<ProtectedString name="Source"><![CDATA[local Workspace = game:GetService("Workspace")
local Package = script.Parent
local Matter = require(Package.Parent.Matter)
local Queue = require(Package.Queue)

--[=[
	.descendants boolean? -- Whether to collect events about descendants
	.attribute string? -- The attribute to use

	@within Hooks
	@interface StreamOptions
]=]
export type StreamOptions = {
	descendants: boolean?,
	attribute: string?,
}

--[=[
	An event for an instance that has streamed in.

	.adding true
	.removing false
	.descendant boolean
	.instance Instance

	@within Hooks
	@interface StreamInEvent
]=]
export type StreamInEvent = {
	adding: true,
	removing: false,
	descendant: boolean,
	instance: Instance,
}

--[=[
	An event for an instance that has streamed out.

	.adding false
	.removing true
	.descendant boolean
	.instance Instance

	@within Hooks
	@interface StreamOutEvent
]=]
export type StreamOutEvent = {
	adding: false,
	removing: true,
	descendant: boolean,
	instance: Instance,
}

--[=[
	An event for an instance that has streamed in or out. The `adding` and
	`removing` fields indicate whether the instance is streaming in or out.

	@within Hooks
	@type StreamEvent StreamInEvent | StreamOutEvent
]=]
export type StreamEvent = StreamInEvent | StreamOutEvent

local function streamInEvent(instance: Instance, descendant: boolean?): StreamInEvent
	return {
		adding = true,
		removing = false,
		descendant = if descendant ~= nil then descendant else false,
		instance = instance,
	}
end

local function streamOutEvent(instance: Instance, descendant: boolean?): StreamOutEvent
	return {
		adding = false,
		removing = true,
		descendant = if descendant ~= nil then descendant else false,
		instance = instance,
	}
end

type NormalizedOptions = {
	descendants: boolean,
	attribute: string,
}

local function normalizeOptions(options: StreamOptions?): NormalizedOptions
	return {
		descendants = if options and options.descendants ~= nil then options.descendants else false,
		attribute = if options and options.attribute then options.attribute else "serverEntityId",
	}
end

local function cleanup(storage)
	storage.addedConnection:Disconnect()
	storage.removingConnection:Disconnect()
	for _, connections in storage.trackedInstances do
		connections.addedConnection:Disconnect()
		connections.removingConnection:Disconnect()
	end
end

--[=[
	Collects instance streaming events for a streaming ID attribute.

	Allows iteration over collected events for the instances tagged with an ID
	using an attribute. It can optionally collect events for the descendants of
	that instance as they stream in and out.

	Each streaming event is returned in the order it happened.

	```lua
	for _, streamEvent in useStream(entityId) do
		if streamEvent.adding then
			processStreamedIn(streamEvent.instance)
		else
			processStreamedOut(streamEvent.instance)
		end
	end
	```

	If the hook is no longer called, all events will be cleaned up automatically.

	:::caution
	The events are stored in a queue that must be processed. If events are left in
	the queue they will remain for next frame, arriving late.

	To avoid this, all events should be processed each frame.

	```lua
	for _, streamEvent in useStream(entityId) do
		if processEvent(streamEvent) then
			break -- Uh oh! This can miss events!
		end
	end
	```
	:::

	The ID can be anything you use to identify instances streamed from the server,
	but is typically a server entity ID. The default attribute this hook uses to
	discover instances by this ID is `serverEntityId`, but can be optionally
	configured.

	```lua
	for _, streamEvent in
		useStream(entityId, {
			attribute = "StreamingId",
		})
	do
		processStream(streamEvent)
	end
	```

	If the instance being streamed has descendants that stream in at different
	times, you may want to listen for them. This can be configured as well.

	```lua
	for _, streamEvent in
		useStream(entityId, {
			descendants = true,
		})
	do
		processStream(streamEvent)
	end
	```

	@within Hooks

	@return () -> (number, StreamEvent)?  -- The event iterator
]=]
local function useStream(id: unknown, options: StreamOptions?): () -> (number?, StreamEvent)
	local storage = Matter.useHookState(id, cleanup)

	if not storage.queue then
		local options = normalizeOptions(options)
		storage.queue = Queue.new()
		storage.trackedInstances = {}

		storage.addedConnection = Workspace.DescendantAdded:Connect(function(instance: Instance)
			if instance:GetAttribute(options.attribute) ~= id then
				return
			end

			storage.queue:push(streamInEvent(instance))

			if not options.descendants then
				return
			end
			if storage.trackedInstances[instance] then
				return
			end

			storage.trackedInstances[instance] = {
				addedConnection = instance.DescendantAdded:Connect(function(instance: Instance)
					storage.queue:push(streamInEvent(instance, true))
				end),

				removingConnection = instance.DescendantRemoving:Connect(function(instance: Instance)
					storage.queue:push(streamOutEvent(instance, true))
				end),
			}

			for _, descendant in instance:GetDescendants() do
				storage.queue:push(streamInEvent(descendant, true))
			end
		end)

		storage.removingConnection = Workspace.DescendantRemoving:Connect(function(instance: Instance)
			if instance:GetAttribute(options.attribute) ~= id then
				return
			end

			storage.queue:push(streamOutEvent(instance))

			if not options.descendants then
				return
			end

			for _, descendant in instance:GetDescendants() do
				storage.queue:push(streamOutEvent(descendant, true))
			end

			local connections = storage.trackedInstances[instance]
			if not connections then
				return
			end

			connections.addedConnection:Disconnect()
			connections.removingConnection:Disconnect()
		end)
	end

	local index = 0
	return function(): (number?, StreamEvent)
		index += 1

		local value = storage.queue:shift()

		if value then
			return index, value
		end
		return nil, (nil :: unknown) :: StreamEvent
	end
end

return useStream
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00006ac3</UniqueId>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX7AC3EC9CAC5C4F94A4477B964FD4F0D8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">net</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007087</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX66CA20DA29BE44BF8157176C0C3FBA46">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">out</string>
								<string name="ScriptGuid">{26792810-0B16-497F-BAE8-02A2398841D3}</string>
								<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local NetServerContext = TS.import(script, script, "server")
local NetClientContext = TS.import(script, script, "client")
local NetDefinitions = TS.import(script, script, "definitions").default
local NetMiddleware = TS.import(script, script, "middleware").NetMiddleware
--[[
	*
	* Networking Library for Roblox
	* @version 3.0
]]
local Net = {}
do
	local _container = Net
	--[[
		*
		* Legacy client API for Net
		* @deprecated
	]]
	local Client = NetClientContext
	_container.Client = Client
	--[[
		*
		* Legacy server API for Net
		* @deprecated
	]]
	local Server = NetServerContext
	_container.Server = Server
	--[[
		*
		* The definitions API for Net
	]]
	local Definitions = NetDefinitions
	_container.Definitions = Definitions
	--[[
		*
		* Utility types for Net
	]]
	local DIST = "TS"
	_container.DIST = DIST
	--[[
		*
		* The version of RbxNet
	]]
	local VERSION = "3.0.9"
	_container.VERSION = VERSION
	--[[
		*
		* Built-in middlewares
	]]
	local Middleware = NetMiddleware
	_container.Middleware = Middleware
	--[[
		*
		* Middleware function type for Net
	]]
	--[[
		*
		* Short-hand for `Net.Definitions.Create`
		* @see {@link Definitions.Create}
	]]
	local function CreateDefinitions(declarations, configuration)
		return Definitions.Create(declarations, configuration)
	end
	_container.CreateDefinitions = CreateDefinitions
end
local _ = nil
local _1 = nil
return Net
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007088</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXF3A1D30AECCD41AAA100ADCE0A484AA1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">client</string>
									<string name="ScriptGuid">{AA1063E4-8419-42AF-835A-4226B8FD20C9}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ClientAsyncFunction").default
local Event = TS.import(script, script, "ClientEvent").default
local Function = TS.import(script, script, "ClientFunction").default
return {
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007089</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXBBFC4DA53DC9428E93184C443D486EF4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ClientAsyncFunction</string>
										<string name="ScriptGuid">{8C804C42-7A09-4369-A71D-1BBD05AEEC52}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
--[[
	*
	* An event that behaves like a function
	* @rbxts client
]]
local ClientAsyncFunction
do
	ClientAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ClientAsyncFunction"
		end,
	})
	ClientAsyncFunction.__index = ClientAsyncFunction
	function ClientAsyncFunction.new(...)
		local self = setmetatable({}, ClientAsyncFunction)
		return self:constructor(...) or self
	end
	function ClientAsyncFunction:constructor(name, configuration)
		self.name = name
		self.configuration = configuration
		self.timeout = 60
		self.listeners = {}
		self.instance = getRemoteOrThrow("AsyncRemoteFunction", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot create a Net.ClientAsyncFunction on the Server!")
	end
	function ClientAsyncFunction:Wait(name, configuration)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("AsyncRemoteFunction", name, 60))
			resolve(ClientAsyncFunction.new(name, configuration))
		end))
	end
	function ClientAsyncFunction:SetCallTimeout(timeout)
		local _arg0 = timeout > 0
		assert(_arg0, "timeout must be a positive number")
		self.timeout = timeout
	end
	function ClientAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ClientAsyncFunction:SetCallback(callback)
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		self.connector = self.instance.OnClientEvent:Connect(TS.async(function(...)
			local args = { ... }
			if microprofile then
				debug.profilebegin("Net: " .. remoteId)
			end
			local _binding = args
			local eventId = _binding[1]
			local data = _binding[2]
			if type(eventId) == "string" and type(data) == "table" then
				local result = callback(unpack(data))
				if TS.Promise.is(result) then
					local _arg0 = function(promiseResult)
						self.instance:FireServer(eventId, promiseResult)
					end
					result:andThen(_arg0):catch(function(err)
						warn("[rbx-net] Failed to send response to server: " .. err)
					end)
				else
					self.instance:FireServer(eventId, result)
				end
			else
				warn("Recieved message without eventId")
			end
		end))
	end
	ClientAsyncFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			error("Attempted to call AsyncFunction '" .. (self.name .. "' - which has no user defined callback"))
		end
		local id = HttpService:GenerateGUID(false)
		local _fn = self.instance
		local _object = {}
		for _k, _v in pairs(args) do
			_object[_k] = _v
		end
		_fn:FireServer(id, _object)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			local connection
			connection = self.instance.OnClientEvent:Connect(function(...)
				local recvArgs = { ... }
				local _binding = recvArgs
				local eventId = _binding[1]
				local data = _binding[2]
				if type(eventId) == "string" then
					if eventId == id then
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _listeners = self.listeners
			local _arg1 = {
				connection = connection,
				timeout = self.timeout,
			}
			_listeners[id] = _arg1
			local warned = false
			local elapsedTime = 0
			repeat
				do
					elapsedTime += (RunService.Heartbeat:Wait())
					if elapsedTime >= 20 and not warned then
						warned = true
						warn("[rbx-net] CallServerAsync(...) - still waiting for result from remote '" .. (self.name .. "'"))
						print(debug.traceback("", 3))
					end
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			self.listeners[id] = nil
			if tick() >= startTime and connection.Connected then
				connection:Disconnect()
				reject("Request to server timed out after " .. tostring(self.timeout) .. " seconds")
			end
		end)
	end)
end
return {
	default = ClientAsyncFunction,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000708a</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXAB76B9DC16DA4CD2891A77DE7F2B342C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ClientEvent</string>
										<string name="ScriptGuid">{56BA6BB4-1A7D-48B1-B51E-1D05CB09384B}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
--[[
	*
	* Interface for client listening events
]]
--[[
	*
	* Interface for client sender events
]]
local ClientEvent
do
	ClientEvent = setmetatable({}, {
		__tostring = function()
			return "ClientEvent"
		end,
	})
	ClientEvent.__index = ClientEvent
	function ClientEvent.new(...)
		local self = setmetatable({}, ClientEvent)
		return self:constructor(...) or self
	end
	function ClientEvent:constructor(name, configuration)
		self.configuration = configuration
		self.instance = getRemoteOrThrow("RemoteEvent", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot fetch NetClientEvent on the server!")
	end
	function ClientEvent:GetInstance()
		return self.instance
	end
	function ClientEvent:Wait(name, configuration)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteEvent", name, 60))
			resolve(ClientEvent.new(name, configuration))
		end))
	end
	function ClientEvent:SendToServer(...)
		local args = { ... }
		self.instance:FireServer(unpack(args))
	end
	function ClientEvent:Connect(callback)
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		if microprofile then
			return self.instance.OnClientEvent:Connect(function(...)
				local args = { ... }
				debug.profilebegin("Net: " .. remoteId)
				callback(unpack(args))
			end)
		else
			return self.instance.OnClientEvent:Connect(callback)
		end
	end
end
local default = ClientEvent
return {
	default = default,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000708b</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2546335A9F32412D826BB3FA1B19724B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ClientFunction</string>
										<string name="ScriptGuid">{B99C5A37-4211-40C7-8B9C-461CA6E24FF3}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getRemoteOrThrow = _internal.getRemoteOrThrow
local IS_SERVER = _internal.IS_SERVER
local waitForRemote = _internal.waitForRemote
local CollectionService = game:GetService("CollectionService")
local ClientFunction
do
	ClientFunction = setmetatable({}, {
		__tostring = function()
			return "ClientFunction"
		end,
	})
	ClientFunction.__index = ClientFunction
	function ClientFunction.new(...)
		local self = setmetatable({}, ClientFunction)
		return self:constructor(...) or self
	end
	function ClientFunction:constructor(name, configuration)
		self.name = name
		self.configuration = configuration
		self.instance = getRemoteOrThrow("RemoteFunction", name)
		local _arg0 = not IS_SERVER
		assert(_arg0, "Cannot create a Net.ClientFunction on the Server!")
	end
	function ClientFunction:Wait(name, configuration)
		return TS.Promise.defer(TS.async(function(resolve)
			TS.await(waitForRemote("RemoteFunction", name, 60))
			resolve(ClientFunction.new(name, configuration))
		end))
	end
	function ClientFunction:CallServer(...)
		local args = { ... }
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			error("Attempted to call Function '" .. (self.name .. "' - which has no user defined callback"))
		end
		return self.instance:InvokeServer(unpack(args))
	end
	ClientFunction.CallServerAsync = TS.async(function(self, ...)
		local args = { ... }
		return TS.Promise.defer(function(resolve)
			local result = self.instance:InvokeServer(unpack(args))
			resolve(result)
		end)
	end)
end
return {
	default = ClientFunction,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000708c</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX65D174A348C74A568DCC4F4C6E0ABFD1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">definitions</string>
									<string name="ScriptGuid">{7385A2B4-D457-4AA0-9B5F-7F821D4731F4}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- eslint-disable @typescript-eslint/no-explicit-any
local DeclarationTypeCheck = TS.import(script, script, "Types").DeclarationTypeCheck
local ServerDefinitionBuilder = TS.import(script, script, "ServerDefinitionBuilder").ServerDefinitionBuilder
local ClientDefinitionBuilder = TS.import(script, script, "ClientDefinitionBuilder").ClientDefinitionBuilder
local NamespaceBuilder = TS.import(script, script, "NamespaceBuilder").NamespaceBuilder
local NetDefinitions = {}
do
	local _container = NetDefinitions
	--[[
		*
		* Validates the specified declarations to ensure they're valid before usage
		* @param declarations The declarations
	]]
	local function validateDeclarations(declarations)
		for _, declaration in pairs(declarations) do
			local _arg0 = DeclarationTypeCheck.check(declaration.Type)
			local _errorMessage = DeclarationTypeCheck.errorMessage
			assert(_arg0, _errorMessage)
		end
	end
	--[[
		*
		* Creates definitions for Remote instances that can be used on both the client and server.
		* @description https://docs.vorlias.com/rbx-net/docs/3.0/definitions#definitions-oh-my
		* @param declarations
	]]
	local function Create(declarations, configuration)
		if configuration == nil then
			configuration = {}
		end
		validateDeclarations(declarations)
		local _arg0 = {
			Server = ServerDefinitionBuilder.new(declarations, configuration),
			Client = ClientDefinitionBuilder.new(declarations, configuration),
		}
		return _arg0
	end
	_container.Create = Create
	--[[
		*
		* Defines a namespace of remote definitions, which can be retrieved via `GetNamespace(namespaceId)`
		*
		* E.g.
		* ```ts
		* const Remotes = Net.Definitions.Create({
		* 		ExampleGroup: Net.Definitions.Namespace({
		* 			ExampleGroupRemote: Net.Definitions.ServerToClientEvent<[message: string]>(),
		* 		}),
		* });
		* const ExampleGroupRemote = Remotes.Server.GetNamespace("ExampleGroup").Create("ExampleGroupRemote");
		* ```
		*
		* This is useful for categorizing remotes by feature.
	]]
	local function Namespace(declarations, configuration)
		return {
			Type = "Namespace",
			Definitions = NamespaceBuilder.new(declarations, configuration),
		}
	end
	_container.Namespace = Namespace
	--[[
		*
		* Defines a function in which strictly the client can call the server asynchronously
		*
		* `Client` [`Calls`] -> `Server` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Server` [`Responds to Call`] -> `Client` [`Recieves Response`]
	]]
	local function ServerAsyncFunction(mw)
		return {
			Type = "AsyncFunction",
			ServerMiddleware = mw,
		}
	end
	_container.ServerAsyncFunction = ServerAsyncFunction
	--[[
		*
		* @version 3.0
		*
		* **_Note_: This uses {@link MessagingService}, and thus is subject to those quotas/limits.**
		*
		* **_Note_: Unlike other definitions in Net, this is only available on the server.**
		*
		* Defines an event in which allows broadcasting messages between servers in the experience.
		*
		* `Source Server` [`Broadcasts`] -> `Other Servers` [`Recieves Broadcast`]
		*
		* or at a target {@link DataModel.JobId JobId}
		*
		* `Source Server [`Broadcasts`] -> `Target Server` [`Recieves Broadcast`]
		*
	]]
	local function ExperienceBroadcastEvent()
		return {
			Type = "Messaging",
		}
	end
	_container.ExperienceBroadcastEvent = ExperienceBroadcastEvent
	--[[
		*
		* @version 3.0
		*
		* **_Note_: This uses {@link MessagingService}, and thus is subject to those quotas/limits.**
		*
		* Defines an event that allows a server to broadcast to all or specified _clients_ in the experience.
		*
		* `Source Server` [`Broadcasts`] -> `Other Servers` [`Recieves Broadcast`] -> `Client` [`Recieves Forwarded Broadcast`]
		*
		* @hidden Experimental API
		* @deprecated Not yet official API, could be changed or removed.
		* @internal
	]]
	local function EXPERIMENTAL_ExperienceReplicatedEvent()
		return {
			Type = "ExperienceEvent",
		}
	end
	_container.EXPERIMENTAL_ExperienceReplicatedEvent = EXPERIMENTAL_ExperienceReplicatedEvent
	--[[
		*
		* Defines a function in which strictly the server can call the client asynchronously
		*
		* `Server` [`Calls`] -> `Client` [`Recieves Call`]
		* ... (asynchronously) ...
		* `Client` [`Responds to Call`] -> `Server` [`Recieves Response`]
	]]
	local function ClientAsyncFunction()
		return {
			Type = "AsyncFunction",
		}
	end
	_container.ClientAsyncFunction = ClientAsyncFunction
	--[[
		*
		* Defines a regular function in which strictly the client can call the server synchronously
		*
		* (Synchronous) `Client` [`Calls`, `Recieves Response`] <- (yields for response) -> `Server` [`Recieves Call`, `Responds`]
	]]
	local function ServerFunction(mw)
		return {
			Type = "Function",
			ServerMiddleware = mw,
		}
	end
	_container.ServerFunction = ServerFunction
	--[[
		*
		* Defines an event in which strictly the server fires an event that is recieved by clients
		*
		* `Server` [`Sends`] => `Client(s)` [`Recieves`]
		*
		* On the client, this will give an event that can use `Connect`.
		*
		* On the server, this will give an event that can use `SendToPlayer`, `SendToAllPlayers`, `SendToAllPlayersExcept`
		*
	]]
	local function ServerToClientEvent()
		return {
			ServerMiddleware = {},
			Type = "Event",
		}
	end
	_container.ServerToClientEvent = ServerToClientEvent
	--[[
		*
		* Defines an event in which strictly clients fire an event that's recieved by the server
		*
		* `Client(s)` [`Sends`] => `Server` [`Recieves`]
		*
		* On the client, this will give an event that can use `SendToServer`.
		*
		* On the server, this will give an event that can use `Connect`.
		*
		* @param mw The middleware of this event.
	]]
	local function ClientToServerEvent(mw)
		return {
			Type = "Event",
			ServerMiddleware = mw,
		}
	end
	_container.ClientToServerEvent = ClientToServerEvent
	--[[
		*
		* Defines a remote event that can be fired both from the client and server
		*
		* This should only be required in rare use cases where `ClientToServerEvent` or `ServerToClientEvent` is not sufficient.
		*
		* Check to see if {@link ServerAsyncFunction} is more sufficient for your use case.
	]]
	local function BidirectionalEvent()
		return {
			Type = "Event",
			ServerMiddleware = {},
		}
	end
	_container.BidirectionalEvent = BidirectionalEvent
end
local default = NetDefinitions
return {
	default = default,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000708d</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXBD1A2ABC709B4AF09CAD6D7508A983FB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ClientDefinitionBuilder</string>
										<string name="ScriptGuid">{AD14F2EC-A4F3-43DC-BCD3-1986A97F9978}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ClientAsyncFunction = TS.import(script, script.Parent.Parent, "client", "ClientAsyncFunction").default
local ClientEvent = TS.import(script, script.Parent.Parent, "client", "ClientEvent").default
local ClientFunction = TS.import(script, script.Parent.Parent, "client", "ClientFunction").default
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _internal.getGlobalRemote
local NAMESPACE_ROOT = _internal.NAMESPACE_ROOT
local NAMESPACE_SEPARATOR = _internal.NAMESPACE_SEPARATOR
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local shouldYield = setmetatable({}, {
	__mode = "k",
})
local ClientDefinitionBuilder
do
	ClientDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ClientDefinitionBuilder"
		end,
	})
	ClientDefinitionBuilder.__index = ClientDefinitionBuilder
	function ClientDefinitionBuilder.new(...)
		local self = setmetatable({}, ClientDefinitionBuilder)
		return self:constructor(...) or self
	end
	function ClientDefinitionBuilder:constructor(declarations, configuration, namespace)
		if namespace == nil then
			namespace = NAMESPACE_ROOT
		end
		self.configuration = configuration
		self.namespace = namespace
		local _self = self
		declarationMap[_self] = declarations
		local _exp = self
		local _result = configuration
		if _result ~= nil then
			_result = _result.ClientGetShouldYield
		end
		local _condition = _result
		if _condition == nil then
			_condition = true
		end
		shouldYield[_exp] = _condition
	end
	function ClientDefinitionBuilder:toString()
		return "[" .. ("ClientDefinitionBuilder" .. "]")
	end
	function ClientDefinitionBuilder:Get(remoteId)
		local _self = self
		if shouldYield[_self] then
			return self:WaitFor(remoteId):expect()
		else
			return self:GetOrThrow(remoteId)
		end
	end
	function ClientDefinitionBuilder:GetNamespace(namespaceId)
		local _self = self
		local group = declarationMap[_self][namespaceId]
		local _arg1 = "Group " .. (namespaceId .. (" does not exist under namespace " .. self.namespace))
		assert(group, _arg1)
		local _arg0 = group.Type == "Namespace"
		assert(_arg0)
		local _fn = group.Definitions
		local _exp = group.Definitions:_CombineConfigurations(self.configuration or {})
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, namespaceId }, _nAMESPACE_SEPARATOR)
		else
			_result = namespaceId
		end
		return _fn:_BuildClientDefinition(_exp, _result)
	end
	function ClientDefinitionBuilder:GetOrThrow(remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = (table.concat({ self.namespace, remoteId }, _nAMESPACE_SEPARATOR))
		else
			_result = remoteId
		end
		remoteId = _result
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		local _ = nil
		local _1 = nil
		local config = self.configuration or {}
		if item.Type == "Function" then
			return ClientFunction.new(remoteId, config)
		elseif item.Type == "Event" then
			return ClientEvent.new(remoteId, config)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction.new(remoteId, config)
		elseif item.Type == "ExperienceEvent" then
			return ClientEvent.new(getGlobalRemote(remoteId), config)
		end
		error("Type '" .. (item.Type .. "' is not a valid client remote object type"))
	end
	ClientDefinitionBuilder.WaitFor = TS.async(function(self, remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = (table.concat({ self.namespace, remoteId }, _nAMESPACE_SEPARATOR))
		else
			_result = remoteId
		end
		remoteId = _result
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		local _ = nil
		local _1 = nil
		local config = self.configuration or {}
		if item.Type == "Function" then
			return ClientFunction:Wait(remoteId, config)
		elseif item.Type == "Event" then
			return ClientEvent:Wait(remoteId, config)
		elseif item.Type == "AsyncFunction" then
			return ClientAsyncFunction:Wait(remoteId, config)
		elseif item.Type == "ExperienceEvent" then
			return ClientEvent:Wait(getGlobalRemote(remoteId), config)
		end
		error("Type '" .. (item.Type .. "' is not a valid client remote object type"))
	end)
	ClientDefinitionBuilder.OnEvent = TS.async(function(self, name, fn)
		local result = (TS.await(self:WaitFor(name)))
		return result:Connect(fn)
	end)
	ClientDefinitionBuilder.OnFunction = TS.async(function(self, name, fn)
		local result = (TS.await(self:WaitFor(name)))
		result:SetCallback(fn)
	end)
	function ClientDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ClientDefinitionBuilder = ClientDefinitionBuilder,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000708e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0C05FCB1163E42929F8355E32513F342">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">NamespaceBuilder</string>
										<string name="ScriptGuid">{CAE2484B-B131-413E-9CEC-C3AC584F16B3}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ClientDefinitionBuilder = TS.import(script, script.Parent, "ClientDefinitionBuilder").ClientDefinitionBuilder
local ServerDefinitionBuilder = TS.import(script, script.Parent, "ServerDefinitionBuilder").ServerDefinitionBuilder
local RunService = game:GetService("RunService")
-- Isolate the definitions since we don't need to access them anywhere else.
local declarationMap = setmetatable({}, {
	__mode = "k",
})
--[[
	*
	* A namespace builder. Internally used to construct definition builders
]]
local NamespaceBuilder
do
	NamespaceBuilder = setmetatable({}, {
		__tostring = function()
			return "NamespaceBuilder"
		end,
	})
	NamespaceBuilder.__index = NamespaceBuilder
	function NamespaceBuilder.new(...)
		local self = setmetatable({}, NamespaceBuilder)
		return self:constructor(...) or self
	end
	function NamespaceBuilder:constructor(declarations, config)
		self.config = config
		local _self = self
		declarationMap[_self] = declarations
		local _ = declarations
	end
	function NamespaceBuilder:_CombineConfigurations(parentConfig)
		local _object = {}
		for _k, _v in pairs(parentConfig) do
			_object[_k] = _v
		end
		local _spread = self.config
		if type(_spread) == "table" then
			for _k, _v in pairs(_spread) do
				_object[_k] = _v
			end
		end
		local newConfig = _object
		return newConfig
	end
	function NamespaceBuilder:_BuildServerDefinition(configuration, namespace)
		local _arg0 = RunService:IsServer()
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _self = self
		return ServerDefinitionBuilder.new(declarationMap[_self], configuration, namespace)
	end
	function NamespaceBuilder:_BuildClientDefinition(configuration, namespace)
		local _arg0 = RunService:IsClient()
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _self = self
		return ClientDefinitionBuilder.new(declarationMap[_self], configuration, namespace)
	end
end
return {
	NamespaceBuilder = NamespaceBuilder,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000708f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE2AD3D0BB8B94FCF93E607060099DA40">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ServerDefinitionBuilder</string>
										<string name="ScriptGuid">{715A9F2D-F25D-4BE0-878D-522E4811FAE7}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ServerAsyncFunction = TS.import(script, script.Parent.Parent, "server", "ServerAsyncFunction").default
local ServerEvent = TS.import(script, script.Parent.Parent, "server", "ServerEvent").default
local ServerFunction = TS.import(script, script.Parent.Parent, "server", "ServerFunction").default
local _internal = TS.import(script, script.Parent.Parent, "internal")
local NAMESPACE_ROOT = _internal.NAMESPACE_ROOT
local NAMESPACE_SEPARATOR = _internal.NAMESPACE_SEPARATOR
local ExperienceBroadcastEvent = TS.import(script, script.Parent.Parent, "messaging", "ExperienceBroadcastEvent").default
local ServerMessagingEvent = TS.import(script, script.Parent.Parent, "server", "ServerMessagingEvent").default
local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
-- Tidy up all the types here.
-- Keep the declarations fully isolated
local declarationMap = setmetatable({}, {
	__mode = "k",
})
local remoteEventCache = {}
local remoteAsyncFunctionCache = {}
local remoteFunctionCache = {}
local messagingEventCache = {}
local messagingServerEventCache = {}
local ServerDefinitionBuilder
do
	ServerDefinitionBuilder = setmetatable({}, {
		__tostring = function()
			return "ServerDefinitionBuilder"
		end,
	})
	ServerDefinitionBuilder.__index = ServerDefinitionBuilder
	function ServerDefinitionBuilder.new(...)
		local self = setmetatable({}, ServerDefinitionBuilder)
		return self:constructor(...) or self
	end
	function ServerDefinitionBuilder:constructor(declarations, config, namespace)
		if namespace == nil then
			namespace = NAMESPACE_ROOT
		end
		self.config = config
		self.namespace = namespace
		local _binding = config
		local AutoGenerateServerRemotes = _binding.ServerAutoGenerateRemotes
		if AutoGenerateServerRemotes == nil then
			AutoGenerateServerRemotes = true
		end
		local GlobalMiddleware = _binding.ServerGlobalMiddleware
		local _self = self
		declarationMap[_self] = declarations
		local _ = declarations
		-- We only run remote creation on the server
		if RunService:IsServer() and AutoGenerateServerRemotes then
			self:_InitServer()
		end
		self.globalMiddleware = GlobalMiddleware
	end
	function ServerDefinitionBuilder:_CreateOrGetInstance(id, declaration)
		local _arg0 = RunService:IsServer()
		assert(_arg0, "Can only create server instances on the server")
		--[[
			*
			* This is used to generate or fetch the specified remote from a declaration
			*
			* The generated remote id is based off the current namespace.
		]]
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, id }, _nAMESPACE_SEPARATOR)
		else
			_result = id
		end
		local namespacedId = _result
		local config = self.config
		if declaration.Type == "Function" then
			local func
			if remoteFunctionCache[namespacedId] ~= nil then
				return remoteFunctionCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					func = ServerFunction.new(namespacedId, declaration.ServerMiddleware, config)
				else
					func = ServerFunction.new(namespacedId, nil, config)
				end
				CollectionService:AddTag(func:GetInstance(), "NetDefinitionManaged")
				local _func = func
				remoteFunctionCache[namespacedId] = _func
				local _result_1 = self.globalMiddleware
				if _result_1 ~= nil then
					local _arg0_1 = function(mw)
						return func:_use(mw)
					end
					for _k, _v in ipairs(_result_1) do
						_arg0_1(_v, _k - 1, _result_1)
					end
				end
				return func
			end
		elseif declaration.Type == "AsyncFunction" then
			local asyncFunction
			-- This should make certain use cases cheaper
			if remoteAsyncFunctionCache[namespacedId] ~= nil then
				return remoteAsyncFunctionCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					asyncFunction = ServerAsyncFunction.new(namespacedId, declaration.ServerMiddleware, config)
				else
					asyncFunction = ServerAsyncFunction.new(namespacedId, nil, config)
				end
				CollectionService:AddTag(asyncFunction:GetInstance(), "NetDefinitionManaged")
				local _asyncFunction = asyncFunction
				remoteAsyncFunctionCache[namespacedId] = _asyncFunction
			end
			local _result_1 = self.globalMiddleware
			if _result_1 ~= nil then
				local _arg0_1 = function(mw)
					return asyncFunction:_use(mw)
				end
				for _k, _v in ipairs(_result_1) do
					_arg0_1(_v, _k - 1, _result_1)
				end
			end
			return asyncFunction
		elseif declaration.Type == "Event" then
			local event
			-- This should make certain use cases cheaper
			if remoteEventCache[namespacedId] ~= nil then
				return remoteEventCache[namespacedId]
			else
				if declaration.ServerMiddleware then
					event = ServerEvent.new(namespacedId, declaration.ServerMiddleware, config)
				else
					event = ServerEvent.new(namespacedId, nil, config)
				end
				CollectionService:AddTag(event:GetInstance(), "NetDefinitionManaged")
				local _event = event
				remoteEventCache[namespacedId] = _event
			end
			local _result_1 = self.globalMiddleware
			if _result_1 ~= nil then
				local _arg0_1 = function(mw)
					return event:_use(mw)
				end
				for _k, _v in ipairs(_result_1) do
					_arg0_1(_v, _k - 1, _result_1)
				end
			end
			return event
		elseif declaration.Type == "Messaging" then
			local event
			if messagingEventCache[namespacedId] ~= nil then
				return messagingEventCache[namespacedId]
			else
				event = ExperienceBroadcastEvent.new(namespacedId)
				local _event = event
				messagingEventCache[namespacedId] = _event
			end
			return event
		elseif declaration.Type == "ExperienceEvent" then
			local event
			if messagingServerEventCache[namespacedId] ~= nil then
				return messagingServerEventCache[namespacedId]
			else
				event = ServerMessagingEvent.new(namespacedId, config)
				local _event = event
				messagingServerEventCache[namespacedId] = _event
			end
			return event
		else
			error("Unhandled type")
		end
	end
	function ServerDefinitionBuilder:_InitServer()
		--[[
			*
			* Used to generate all the remotes on the server-side straight away.
			*
			* So long as the remote declaration file is imported, and it's the server this _should_ run.
			*
			* This will fix https://github.com/roblox-aurora/rbx-net/issues/57, which is a long standing race-condition issue
			* I, as well as many other users have run into from time to time.
		]]
		local _ = nil
		local _1 = nil
		local _self = self
		local declarations = declarationMap[_self]
		for id, declaration in pairs(declarations) do
			local _exp = declaration.Type
			repeat
				local _fallthrough = false
				if _exp == "Event" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "AsyncFunction" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "Function" then
					_fallthrough = true
				end
				if _fallthrough or _exp == "Messaging" then
					self:_CreateOrGetInstance(id, declaration)
					break
				end
				if _exp == "Namespace" then
					self:GetNamespace(id)
					break
				end
			until true
		end
	end
	function ServerDefinitionBuilder:toString()
		return "[" .. ("ServerDefinitionBuilder" .. "]")
	end
	function ServerDefinitionBuilder:OnEvent(name, fn)
		local result = self:Get(name)
		return result:Connect(fn)
	end
	function ServerDefinitionBuilder:GetNamespace(namespaceId)
		local _self = self
		local group = declarationMap[_self][namespaceId]
		local _arg1 = "Group " .. (namespaceId .. (" does not exist under namespace " .. self.namespace))
		assert(group, _arg1)
		local _arg0 = group.Type == "Namespace"
		assert(_arg0)
		local _ = nil
		local _1 = nil
		local _fn = group.Definitions
		local _exp = group.Definitions:_CombineConfigurations(self.config)
		local _result
		if self.namespace ~= NAMESPACE_ROOT then
			-- ▼ ReadonlyArray.join ▼
			local _nAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR
			if _nAMESPACE_SEPARATOR == nil then
				_nAMESPACE_SEPARATOR = ", "
			end
			-- ▲ ReadonlyArray.join ▲
			_result = table.concat({ self.namespace, namespaceId }, _nAMESPACE_SEPARATOR)
		else
			_result = namespaceId
		end
		return _fn:_BuildServerDefinition(_exp, _result)
	end
	function ServerDefinitionBuilder:Get(remoteId)
		local _self = self
		local item = declarationMap[_self][remoteId]
		local _arg0 = item and item.Type
		local _arg1 = "'" .. (remoteId .. "' is not defined in this definition.")
		assert(_arg0, _arg1)
		if item.Type == "Function" or (item.Type == "AsyncFunction" or (item.Type == "Event" or item.Type == "Messaging")) then
			if remoteAsyncFunctionCache[remoteId] ~= nil then
				local _ = nil
				local _1 = nil
				return remoteAsyncFunctionCache[remoteId]
			else
				return self:_CreateOrGetInstance(remoteId, item)
			end
		else
			error("Invalid type for " .. remoteId)
		end
	end
	function ServerDefinitionBuilder:Create(remoteId)
		return self:Get(remoteId)
	end
	function ServerDefinitionBuilder:OnFunction(name, fn)
		local result = self:Get(name)
		result:SetCallback(fn)
	end
	function ServerDefinitionBuilder:__tostring()
		return self:toString()
	end
end
return {
	ServerDefinitionBuilder = ServerDefinitionBuilder,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007090</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX425A1205AF294E7EABAEE33AEAF41615">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">Types</string>
										<string name="ScriptGuid">{ED0796CD-35AB-47F0-B928-8CE0BDFD9AE1}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
--[[
	*
	* Types
	*
	* I will admit, this is a lot of type spaghetti. It makes the definitions work good though. :D
]]
local oneOf = TS.import(script, script.Parent.Parent, "internal", "validator").oneOf
--[[
	*
	* The DefinitionBuilders type
]]
--[[
	*
	* @deprecated
]]
--[[
	*
	* A declaration for an async client function
]]
--[[
	*
	* A declaration for an async server function
]]
-- * @deprecated
--[[
	*
	* A declaration for a client -> server event
]]
--[[
	*
	* A declaration for a server -> client event
]]
--[[
	*
	* A declaration for a server -> server event
]]
--[[
	*
	* A declaration for a server -> server event, that replicates to clients
]]
--[[
	*
	* A declaration for a Bidirectional event
]]
--[[
	*
	* A declaration group
]]
-- //////////////////////////////
-- * Inference Magic
-- /////////////////////////////
--[[
	*
	* This infers the client remote type based on the given value
]]
--[[
	*
	* This infers the server remote type based on the given value
]]
-- ///////////////////////////////////////
-- * Results
-- ///////////////////////////////////////
local DeclarationTypeCheck = oneOf("Event", "Function", "AsyncFunction", "Namespace", "Messaging", "ExperienceEvent")
return {
	DeclarationTypeCheck = DeclarationTypeCheck,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007091</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX811F18C4B5C14340B8D731B07BC65CB4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">internal</string>
									<string name="ScriptGuid">{0C0F101E-179B-439D-96E2-3A036DC8CA95}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local HttpService = game:GetService("HttpService")
local runService = game:GetService("RunService")
local collectionService = game:GetService("CollectionService")
-- * @internal
local NAMESPACE_SEPARATOR = "/"
-- * @internal
local NAMESPACE_ROOT = "@"
-- * @internal
local IS_SERVER = not runService:IsRunning() or runService:IsServer()
-- * @internal
local IS_CLIENT = runService:IsRunning() and runService:IsClient()
local IS_RUNNING = runService:IsRunning()
-- * @internal
local MAX_CLIENT_WAITFORCHILD_TIMEOUT = 10
-- * @internal
local function getGlobalRemote(name)
	return ":\\" .. name
end
-- * @internal
local function isLuaTable(value)
	return type(value) == "table"
end
-- * @internal
local NetMiddlewareEvent
do
	NetMiddlewareEvent = setmetatable({}, {
		__tostring = function()
			return "NetMiddlewareEvent"
		end,
	})
	NetMiddlewareEvent.__index = NetMiddlewareEvent
	function NetMiddlewareEvent.new(...)
		local self = setmetatable({}, NetMiddlewareEvent)
		return self:constructor(...) or self
	end
	function NetMiddlewareEvent:constructor(netInstance)
		self.netInstance = netInstance
	end
	function NetMiddlewareEvent:GetInstance()
		return self.netInstance:GetInstance()
	end
end
local REMOTES_FOLDER_NAME = "_NetManaged"
-- * @internal
-- * @internal
local ServerTickFunctions = {}
-- * @internal
local function findOrCreateFolder(parent, name)
	local folder = parent:FindFirstChild(name)
	if folder then
		return folder
	else
		folder = Instance.new("Folder", parent)
		folder.Name = name
		return folder
	end
end
-- const dist = $env<"TS" | "Luau" | "TestTS">("TYPE", "TS");
local location = script.Parent
local _ = nil
local _1 = nil
local remoteFolder = findOrCreateFolder(location, REMOTES_FOLDER_NAME)
--[[
	*
	* Errors with variables formatted in a message
	* @param message The message
	* @param vars variables to pass to the error message
]]
local function errorft(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _arg1 = function(token)
		local _condition = vars[token]
		if _condition == nil then
			_condition = token
		end
		return _condition
	end
	message = string.gsub(message, "{([%w_][%w%d_]*)}", _arg1)
	error(message, 2)
end
local traceSet = {}
local function warnOnce(message)
	local trace = debug.traceback()
	if traceSet[trace] ~= nil then
		return nil
	end
	traceSet[trace] = true
	warn("[rbx-net] " .. message)
end
local function format(message, vars)
	-- eslint-disable-next-line @typescript-eslint/ban-ts-comment
	-- @ts-ignore
	local _arg1 = function(token)
		local _condition = vars[token]
		if _condition == nil then
			_condition = token
		end
		return _condition
	end
	message = string.gsub(message, "{([%w_][%w%d_]*)}", _arg1)
	return message
end
-- * @internal
local findRemote, getTagFromRemoteType
local function waitForRemote(remoteType, name, timeout)
	return TS.Promise.defer(function(resolve, reject)
		-- First, check if remote already exists
		local result = findRemote(remoteType, name)
		if result then
			resolve(result)
			return nil
		end
		-- If not, wait for remote
		local searchStart = os.clock()
		local remote = remoteFolder:WaitForChild(name, timeout)
		local remoteTypeTag = getTagFromRemoteType(remoteType)
		if remote and table.find(collectionService:GetTags(remote), remoteTypeTag) ~= nil then
			resolve(remote)
			return nil
		end
		-- If result is not correct remote type, poll until correct remote is added
		local elapsed = os.clock() - searchStart
		while elapsed < timeout do
			elapsed += (runService.Heartbeat:Wait())
			result = findRemote(remoteType, name)
			if result then
				resolve(result)
				return nil
			end
		end
		reject("Timed out while waiting for " .. (remoteType .. (" '" .. (name .. ("' after " .. (tostring(elapsed) .. " seconds."))))))
	end)
end
-- * @internal
function findRemote(remoteType, name)
	local tag = getTagFromRemoteType(remoteType)
	local _exp = collectionService:GetTagged(tag)
	local _arg0 = function(f)
		return f.Name == name
	end
	-- ▼ ReadonlyArray.find ▼
	local _result
	for _i, _v in ipairs(_exp) do
		if _arg0(_v, _i - 1, _exp) == true then
			_result = _v
			break
		end
	end
	-- ▲ ReadonlyArray.find ▲
	return _result
end
-- * @internal
function getTagFromRemoteType(remoteType)
	repeat
		if remoteType == "AsyncRemoteFunction" then
			return "NetManagedAsyncFunction"
		end
		if remoteType == "RemoteEvent" then
			return "NetManagedEvent"
		end
		if remoteType == "RemoteFunction" then
			return "NetManagedLegacyFunction"
		end
	until true
	error("Invalid Remote Access")
end
-- * @internal
local function getRemoteOrThrow(remoteType, name)
	local existing = findRemote(remoteType, name)
	if existing then
		return existing
	else
		error("Could not find Remote of type " .. (remoteType .. (' called "' .. (name .. '"'))))
	end
end
-- * @internal
local function findOrCreateRemote(remoteType, name, onCreate)
	local existing = findRemote(remoteType, name)
	if existing then
		if collectionService:HasTag(existing, "NetDefinitionManaged") then
			warnOnce("Fetching " .. (remoteType .. (" '" .. (name .. "', which is a DefinitionsManaged instance from a non-definitions context. This is considered unsafe."))))
		end
		return existing
	else
		if not IS_SERVER then
			error("Creation of Events or Functions must be done on server!")
		end
		local remote
		if remoteType == "RemoteEvent" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedEvent")
		elseif remoteType == "AsyncRemoteFunction" then
			remote = Instance.new("RemoteEvent")
			collectionService:AddTag(remote, "NetManagedAsyncFunction")
		elseif remoteType == "RemoteFunction" then
			remote = Instance.new("RemoteFunction")
			collectionService:AddTag(remote, "NetManagedLegacyFunction")
		else
			error("Invalid Remote Type: " .. remoteType)
		end
		remote.Name = name
		remote.Parent = remoteFolder
		local _2 = nil
		local _3 = nil
		local _result = onCreate
		if _result ~= nil then
			_result(remote)
		end
		return remote
	end
end
-- * @internal
local function checkArguments(types, args)
	if args == nil then
		warn("[net-types] Argument length is zero")
		return false
	end
	do
		local i = 0
		local _shouldIncrement = false
		while true do
			if _shouldIncrement then
				i += 1
			else
				_shouldIncrement = true
			end
			if not (i < #types) then
				break
			end
			local typeCheck = types[i + 1]
			local value = args[i + 1]
			if not typeCheck(value) then
				warn("[net-types] Argument at index " .. (tostring(i) .. " was invalid type."))
				return false
			end
		end
	end
	return true
end
if IS_SERVER then
	game:GetService("RunService").Stepped:Connect(function(time, step)
		for _2, f in ipairs(ServerTickFunctions) do
			f()
		end
	end)
end
return {
	getGlobalRemote = getGlobalRemote,
	isLuaTable = isLuaTable,
	findOrCreateFolder = findOrCreateFolder,
	errorft = errorft,
	warnOnce = warnOnce,
	format = format,
	waitForRemote = waitForRemote,
	findRemote = findRemote,
	getTagFromRemoteType = getTagFromRemoteType,
	getRemoteOrThrow = getRemoteOrThrow,
	findOrCreateRemote = findOrCreateRemote,
	checkArguments = checkArguments,
	NAMESPACE_SEPARATOR = NAMESPACE_SEPARATOR,
	NAMESPACE_ROOT = NAMESPACE_ROOT,
	IS_SERVER = IS_SERVER,
	IS_CLIENT = IS_CLIENT,
	IS_RUNNING = IS_RUNNING,
	MAX_CLIENT_WAITFORCHILD_TIMEOUT = MAX_CLIENT_WAITFORCHILD_TIMEOUT,
	NetMiddlewareEvent = NetMiddlewareEvent,
	ServerTickFunctions = ServerTickFunctions,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007092</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX913F1C3CD46146D2A26E933C179FF722">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">tables</string>
										<string name="ScriptGuid">{7FCD5CEA-719B-4C7B-BD15-F9AF269F4C7E}</string>
										<ProtectedString name="Source"><![CDATA[local function isMixed(t)
	assert(type(t) == "table")
	local mixed = false
	local _idxType

	for index, value in next, t do
		if _idxType and _idxType ~= type(index) then
			return true
		end

		_idxType = type(index)
		if type(value) == "table" then
			mixed = mixed and isMixed(value) and not (not getmetatable(value))
		end
	end

	return mixed
end

return {
	mixed = isMixed
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007093</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX31FF0E30971B4392A56E8002153AE28A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">validator</string>
										<string name="ScriptGuid">{EF9125DC-E1FE-447C-913B-61B36EA029A7}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local isMixed = TS.import(script, script.Parent, "tables").isMixed
local Workspace = game:GetService("Workspace")
local ServerStorage = game:GetService("ServerStorage")
local ServerScriptService = game:GetService("ServerScriptService")
-- * @internal
local isSerializable
local function validateArguments(...)
	local args = { ... }
	for index, value in ipairs(args) do
		if not isSerializable.check(value) then
			error(string.format(isSerializable.errorMessage, index), 2)
		end
		if typeof(value) == "Instance" then
			if value:IsDescendantOf(ServerStorage) or value:IsDescendantOf(ServerScriptService) then
				error("[rbx-net] Instance at argument #" .. (tostring(index) .. " is inside a server-only container and cannot be sent via remotes."))
			end
			if not value:IsDescendantOf(game) then
				error("[rbx-net] Instance at argument #" .. (tostring(index) .. " is not a valid descendant of game, and wont replicate"))
			end
		end
	end
end
-- * @internal
isSerializable = {
	errorMessage = "Argument #%d is not serializable. - see http://docs.vorlias.com/rbx-net/docs/2.0/serialization",
	check = function(value)
		-- Can't allow functions or threads
		if type(value) == "function" or type(value) == "thread" then
			return false
		end
		-- Can't allow metatabled objects
		if type(value) == "table" and getmetatable(value) ~= nil then
			return false
		end
		-- Ensure not a mixed table type
		if type(value) == "table" then
			return not isMixed(value)
		end
		return true
	end,
}
-- * @internal
local function oneOf(...)
	local values = { ... }
	return {
		errorMessage = "Expected one of: " .. table.concat(values, ", "),
		check = function(value)
			if not (type(value) == "string") then
				return false
			end
			for _, cmpValue in ipairs(values) do
				if value == cmpValue then
					return true
				end
			end
			return false
		end,
	}
end
return {
	validateArguments = validateArguments,
	oneOf = oneOf,
	isSerializable = isSerializable,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007094</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX58FFA558F48E4E43B11AE0B213273720">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">messaging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007095</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX381BF97C56B94B26B8F4C4FEA2F57CF7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ExperienceBroadcastEvent</string>
										<string name="ScriptGuid">{FB72C79C-B6D7-43D4-AC12-2DBB1FB3F6D5}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local isLuaTable = _internal.isLuaTable
local ServerTickFunctions = _internal.ServerTickFunctions
-- const MessagingService = game.GetService("MessagingService");
local MessagingService = TS.import(script, script.Parent, "MessagingService")
local Players = game:GetService("Players")
local IS_STUDIO = game:GetService("RunService"):IsStudio()
--[[
	*
	* Checks if a value matches that of a subscription message
	* @param value The value
]]
local function isSubscriptionMessage(value)
	if isLuaTable(value) then
		local hasData = value.Data ~= nil
		return hasData
	else
		return false
	end
end
local function isJobTargetMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.jobId ~= nil
		end
	end
	return false
end
local globalMessageQueue = {}
local lastQueueTick = 0
local globalEventMessageCounter = 0
local globalSubscriptionCounter = 0
local ExperienceBroadcastEvent
local function processMessageQueue()
	if tick() >= lastQueueTick + 60 then
		globalEventMessageCounter = 0
		globalSubscriptionCounter = 0
		lastQueueTick = tick()
		while #globalMessageQueue > 0 do
			-- ▼ Array.pop ▼
			local _length = #globalMessageQueue
			local _result = globalMessageQueue[_length]
			globalMessageQueue[_length] = nil
			-- ▲ Array.pop ▲
			local message = _result
			MessagingService:PublishAsync(message.Name, message.Data)
			globalEventMessageCounter += 1
		end
		if globalEventMessageCounter >= ExperienceBroadcastEvent:GetMessageLimit() then
			warn("[rbx-net] Too many messages are being sent, any further messages will be queued!")
		end
	end
end
--[[
	*
	* Message Size: 1kB
	* MessagesPerMin: 150 + 60 * NUMPLAYERS
	* MessagesPerTopicMin: 30M
	* MessagesPerUniversePerMin: 30M
	* SubsPerServer: 5 + 2 * numPlayers
	* SubsPerUniverse: 10K
]]
--[[
	*
	* An event that works across all servers
	* @see https://developer.roblox.com/api-reference/class/MessagingService for limits, etc.
]]
do
	ExperienceBroadcastEvent = setmetatable({}, {
		__tostring = function()
			return "ExperienceBroadcastEvent"
		end,
	})
	ExperienceBroadcastEvent.__index = ExperienceBroadcastEvent
	function ExperienceBroadcastEvent.new(...)
		local self = setmetatable({}, ExperienceBroadcastEvent)
		return self:constructor(...) or self
	end
	function ExperienceBroadcastEvent:constructor(name)
		self.name = name
	end
	function ExperienceBroadcastEvent:GetMessageLimit()
		return 150 + 60 * #Players:GetPlayers()
	end
	function ExperienceBroadcastEvent:GetSubscriptionLimit()
		return 5 + 2 * #Players:GetPlayers()
	end
	function ExperienceBroadcastEvent:sendToAllServersOrQueue(data)
		local limit = ExperienceBroadcastEvent:GetMessageLimit()
		if globalEventMessageCounter >= limit then
			warn("[rbx-net] Exceeded message limit of " .. (tostring(limit) .. ", adding to queue..."))
			local _arg0 = {
				Name = self.name,
				Data = data,
			}
			table.insert(globalMessageQueue, _arg0)
		else
			globalEventMessageCounter += 1
			-- Since this yields
			MessagingService:PublishAsync(self.name, data)
		end
	end
	function ExperienceBroadcastEvent:SendToServer(serverJobId, sendData)
		self:sendToAllServersOrQueue({
			jobId = serverJobId,
			message = sendData,
		})
	end
	function ExperienceBroadcastEvent:SendToAllServers(sendData)
		self:sendToAllServersOrQueue(sendData)
	end
	function ExperienceBroadcastEvent:Connect(handler)
		local limit = ExperienceBroadcastEvent:GetSubscriptionLimit()
		if globalSubscriptionCounter >= limit then
			error("[rbx-net] Exceeded Subscription limit of " .. (tostring(limit) .. "!"))
		end
		globalSubscriptionCounter += 1
		return MessagingService:SubscribeAsync(self.name, function(message)
			local recieved = message
			local _binding = recieved
			local Sent = _binding.Sent
			if isJobTargetMessage(recieved) then
				local _binding_1 = recieved
				local Data = _binding_1.Data
				if game.JobId == Data.JobId then
					handler(Data.InnerData, Sent)
				end
			else
				handler(recieved.Data, Sent)
			end
		end)
	end
end
table.insert(ServerTickFunctions, processMessageQueue)
return {
	isSubscriptionMessage = isSubscriptionMessage,
	default = ExperienceBroadcastEvent,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007096</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF16E95C31DEB4330BF517D35DF69CD8A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MessagingService</string>
										<string name="ScriptGuid">{4318665C-B36B-4219-86B2-4582CC534657}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local MessagingService = game:GetService("MessagingService")

local MockMessagingService = {}
local topics = {}

function MockMessagingService:PublishAsync(topicName, message)
	local topic = topics[topicName]
	if topic then
		topic:Fire(
			{
				Sent = tick(),
				Data = message
			}
		)
	end
end

function MockMessagingService:SubscribeAsync(topicName, callback)
	local topic = topics[topicName]
	if not topic then
		topic = Instance.new("BindableEvent")
		topic.Parent = script
		topic.Name = topicName
		topics[topicName] = topic
	end

	return topic.Event:Connect(callback)
end

local service
if RunService:IsStudio() then
    service = MockMessagingService
else
    service = MessagingService
end


return service]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007097</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX9B1CD38EDF834DCFBF85FF69819D76B8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">middleware</string>
									<string name="ScriptGuid">{182D58C2-50BF-419A-911B-8F625E37153A}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local createLoggerMiddleware = TS.import(script, script, "LoggerMiddleware")
local createRateLimiter = TS.import(script, script, "RateLimitMiddleware").default
local NetTypeCheckingMiddleware = TS.import(script, script, "TypeCheckMiddleware")
local NetMiddleware = {}
do
	local _container = NetMiddleware
	local RateLimit = createRateLimiter
	_container.RateLimit = RateLimit
	local Logging = createLoggerMiddleware
	_container.Logging = Logging
	-- * The type checking middleware
	local TypeChecking = NetTypeCheckingMiddleware
	_container.TypeChecking = TypeChecking
	--[[
		*
		* Creates a global read-only middleware for use in `Net.Definitions` global middleware.
	]]
	local function Global(middleware)
		local _arg0 = function(processNext, event)
			return function(sender, ...)
				local args = { ... }
				middleware(event:GetInstance().Name, args, sender)
				return processNext(sender, unpack(args))
			end
		end
		return _arg0
	end
	_container.Global = Global
end
local createTypeChecker = NetTypeCheckingMiddleware
return {
	NetMiddleware = NetMiddleware,
	createRateLimiter = createRateLimiter,
	createTypeChecker = createTypeChecker,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007098</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX568D3CA6BE4744289C567D3EA400E9A1">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">LoggerMiddleware</string>
										<string name="ScriptGuid">{ADA0D56C-0901-4203-8746-C1C4A234CD1D}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio()

local function defaultLogger(name, args)
    if IS_STUDIO then
        local str = {};
        for _, arg in ipairs(args) do
            table.insert(str, HttpService:JSONEncode(arg))
        end
        print("[rbx-net] Called", name, "with arguments", "[ " .. table.concat(str, ", ") .. " ]")
    end
end

return function(options)
    options = options or {}
    local logger = options.Logger or defaultLogger

    return function (next, event)
        local name = options.Name or event:GetInstance().Name
        return function(player, ...)
            logger(name, {...})
            return next(player, ...)
        end
    end
end]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb00007099</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXABEC438819D341A796805106761EEF71">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">RateLimitMiddleware</string>
										<string name="ScriptGuid">{2B4320BA-5216-4DB8-9EA3-ABE76CBE64CD}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local format = _internal.format
local IS_SERVER = _internal.IS_SERVER
local ServerTickFunctions = _internal.ServerTickFunctions
local throttler = TS.import(script, script, "throttle")
local throttles = {}
local function rateLimitWarningHandler(rateLimitError)
	warn("[rbx-net]", rateLimitError.Message)
end
local THROTTLE_RESET_TIMER = 60
--[[
	*
	* Creates a throttle middleware for this event
	*
	* Will limit the amount of requests a player can make to this event
	*
	* _NOTE: Must be used before **other** middlewares as it's not a type altering middleware_
	* @param maxRequestsPerMinute The maximum requests per minute
]]
local function createRateLimiter(options)
	local maxRequestsPerMinute = options.MaxRequestsPerMinute
	local errorHandler = options.ErrorHandler or rateLimitWarningHandler
	local _condition = options.ThrottleMessage
	if _condition == nil then
		_condition = "Request limit exceeded ({limit}) by {player} via {remote}"
	end
	local throttleMessage = _condition
	return function(processNext, event)
		local instance = event:GetInstance()
		local throttle = throttles[event]
		if throttle == nil then
			throttle = throttler:Get(instance:GetFullName())
		end
		return function(player, ...)
			local args = { ... }
			local count = throttle:Get(player)
			if count >= maxRequestsPerMinute then
				local _result = errorHandler
				if _result ~= nil then
					_result({
						Message = format(throttleMessage, {
							player = player.UserId,
							remote = instance.Name,
							limit = maxRequestsPerMinute,
						}),
						MaxRequestsPerMinute = maxRequestsPerMinute,
						RemoteId = instance.Name,
						UserId = player.UserId,
					})
				end
			else
				throttle:Increment(player)
				return processNext(player, unpack(args))
			end
		end
	end
end
if IS_SERVER then
	local lastTick = 0
	local _arg0 = function()
		if tick() > lastTick + THROTTLE_RESET_TIMER then
			lastTick = tick()
			throttler:Clear()
		end
	end
	table.insert(ServerTickFunctions, _arg0)
end
local default = createRateLimiter
return {
	rateLimitWarningHandler = rateLimitWarningHandler,
	default = default,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000709a</UniqueId>
									</Properties>
									<Item class="ModuleScript" referent="RBXB51BD8C1273B4E6490D784956A7626BC">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
											<bool name="DefinesCapabilities">false</bool>
											<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">throttle</string>
											<string name="ScriptGuid">{657245D1-9EF5-46BE-A054-DA4662495123}</string>
											<ProtectedString name="Source"><![CDATA[local Throttle = {
	counters = {}
}
local RequestCounter = {}
RequestCounter.__index = RequestCounter

function RequestCounter.new()
	local self = {
		counter = {}
	}

	return setmetatable(self, RequestCounter)
end

function RequestCounter:Get(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]
	return playerQueue or 0
end

function RequestCounter:Increment(player)
	local counter = self.counter
	local playerQueue = counter[player.UserId]

	if not counter[player.UserId] then
		counter[player.UserId] = 1
	else
		counter[player.UserId] = playerQueue + 1
	end
end

function RequestCounter:__tostring()
	return "RequestCounter"
end

function RequestCounter:ClearAll()
	self.counter = {}
end

function Throttle:Get(name)
	local existing = self.counters[name]
	if (existing) then
		return existing
	else
		local newCounter = RequestCounter.new()
		self.counters[name] = newCounter
		return newCounter
	end
end

function Throttle:Clear()
	for _, counter in pairs(self.counters) do
		counter:ClearAll()
	end
end

return Throttle
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000709b</UniqueId>
										</Properties>
									</Item>
								</Item>
								<Item class="ModuleScript" referent="RBXAF90990B694D40559DC3DC01C1EBF7D5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">TypeCheckMiddleware</string>
										<string name="ScriptGuid">{F29FA21E-20E8-472F-ADC8-C16CCDEAEE5D}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")
local IS_STUDIO = RunService:IsStudio();

local function defaultErrorHandler(event, args, index)
    local name = event:GetInstance().Name
    if IS_STUDIO then
        warn("[TypeCheckMiddleware] Call to " .. name .. " failed")
        warn("\tRecieved: " .. HttpService:JSONEncode(args))
        warn("\tInvalid argument at index " .. tostring(index))
    end
end

local MiddlewareGlobal = {}
MiddlewareGlobal.__index = MiddlewareGlobal
MiddlewareGlobal.defaultErrorHandler = defaultErrorHandler

local function typeCheckMiddleware(...)
    local checks = {...}
    local MiddlewareInstance = {}
    MiddlewareInstance.__index = MiddlewareInstance;

    function MiddlewareInstance:next(next, event)
        local errorHandler = self.errorHandler or MiddlewareGlobal.defaultErrorHandler
        --  what's returned as callbackFn
        return function(player, ...)
            local args = {...}
            for index, check in ipairs(checks) do
                if not check(args[index]) then
                    pcall(errorHandler, event, args, index)
                    return false
                end
            end

            -- Invoke the next middleware OR the callback (if none left)
            return next(player, ...)
        end
    end

    function MiddlewareInstance.__tostring()
        return "TypeCheckMiddleware"
    end

    function MiddlewareInstance:WithErrorHandler(fn)
        self.errorHandler = fn
        return self
    end

    function MiddlewareInstance:__call(...)
        return self:next(...)
    end
    
    return setmetatable({}, MiddlewareInstance)
    -- ^ The middleware
end

function MiddlewareGlobal.__call(_, ...)
    return typeCheckMiddleware(...)
end

function MiddlewareGlobal.SetDefaultErrorHandler(_, fn)
    MiddlewareGlobal.defaultErrorHandler = fn
end

return setmetatable({}, MiddlewareGlobal)]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000709c</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBXE44E39B248E54D0B8023B98178285C88">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">server</string>
									<string name="ScriptGuid">{D96B8322-ADDD-4BB8-987F-D15FDF7D12FE}</string>
									<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local AsyncFunction = TS.import(script, script, "ServerAsyncFunction").default
local Event = TS.import(script, script, "ServerEvent").default
local MessagingEvent = TS.import(script, script, "ServerMessagingEvent").default
local Function = TS.import(script, script, "ServerFunction").default
return {
	Event = Event,
	AsyncFunction = AsyncFunction,
	Function = Function,
	MessagingEvent = MessagingEvent,
}
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000709d</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX9F40A69244ED4DB98EF777E923D6A895">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">CreateServerListener</string>
										<string name="ScriptGuid">{1B1D00FE-EFDE-4676-BD87-81560CD8A7AA}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local ServerEventV2 = TS.import(script, script.Parent, "ServerEvent").default
local function isMiddlewareArgument(args)
	local _condition = #args > 1
	if _condition then
		local _arg0 = args[1]
		_condition = type(_arg0) == "table"
	end
	return _condition
end
--[[
	*
	* Creates a server listening event
]]
local function createServerListener(id, ...)
	local args = { ... }
	local event
	if isMiddlewareArgument(args) then
		local _binding = args
		local middleware = _binding[1]
		local connect = _binding[2]
		event = ServerEventV2.new(id, middleware, {})
		return event:Connect(connect)
	else
		local _binding = args
		local connect = _binding[1]
		event = ServerEventV2.new(id, nil, {})
		return event:Connect(connect)
	end
end
return {
	default = createServerListener,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000709e</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX6E26655CAB304ADE98BAACBDC35E8DEB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MiddlewareEvent</string>
										<string name="ScriptGuid">{060A8949-08A7-4157-BAF7-6AFCEB0FBA20}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
-- * @internal
local MiddlewareEvent
do
	MiddlewareEvent = {}
	function MiddlewareEvent:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareEvent:_use(middleware)
		local _exp = (self.middlewares)
		table.insert(_exp, middleware)
	end
	function MiddlewareEvent:_processMiddleware(callback)
		local _binding = self
		local middlewares = _binding.middlewares
		local _exitType, _returns = TS.try(function()
			local _arg0 = type(middlewares) == "table"
			local _arg1 = "The middleware argument should be an array of middlewares not a " .. typeof(middlewares)
			assert(_arg0, _arg1)
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
local default = MiddlewareEvent
return {
	default = default,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb0000709f</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX772427C6208B478B95B3C3F5FD4219C4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MiddlewareFunction</string>
										<string name="ScriptGuid">{6216A092-3B13-4033-8DC3-A1F3C4A6D715}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local MiddlewareFunction
do
	MiddlewareFunction = {}
	function MiddlewareFunction:constructor(middlewares)
		if middlewares == nil then
			middlewares = {}
		end
		self.middlewares = middlewares
	end
	function MiddlewareFunction:_use(middleware)
		local _exp = (self.middlewares)
		table.insert(_exp, middleware)
	end
	function MiddlewareFunction:_processMiddleware(callback)
		local _binding = self
		local middlewares = _binding.middlewares
		local _exitType, _returns = TS.try(function()
			if #middlewares > 0 then
				local callbackFn = callback
				-- Run through each middleware
				for _, middleware in ipairs(middlewares) do
					callbackFn = middleware(callbackFn, self)
				end
				return TS.TRY_RETURN, { callbackFn }
			else
				return TS.TRY_RETURN, { callback }
			end
		end, function(e)
			warn("[rbx-net] " .. tostring(e))
		end)
		if _exitType then
			return unpack(_returns)
		end
	end
end
local default = MiddlewareFunction
return {
	default = default,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070a0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX449F3BB89C4E41C48AEA8C1C31B57BB0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">NetServerScriptSignal</string>
										<string name="ScriptGuid">{561A3128-A782-45A1-AD36-8703CA0A7F79}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
--[[
	*
	* A wrapper around a RBXScriptSignal for remotes, that always has a listener set.
]]
local NetServerScriptSignal
do
	NetServerScriptSignal = setmetatable({}, {
		__tostring = function()
			return "NetServerScriptSignal"
		end,
	})
	NetServerScriptSignal.__index = NetServerScriptSignal
	function NetServerScriptSignal.new(...)
		local self = setmetatable({}, NetServerScriptSignal)
		return self:constructor(...) or self
	end
	function NetServerScriptSignal:constructor(signalInstance, instance)
		self.signalInstance = signalInstance
		self.instance = instance
		self.connections = {}
		self.connectionRefs = setmetatable({}, {
			__mode = "k",
		})
		self.defaultConnectionDelegate = (function(player, ...)
			local args = { ... }
		end)
		self.defaultConnection = signalInstance:Connect(self.defaultConnectionDelegate)
		local sig
		sig = self.instance.AncestryChanged:Connect(function(child, parent)
			if child == instance and parent == nil then
				self:DisconnectAll()
				sig:Disconnect()
			end
		end)
	end
	function NetServerScriptSignal:Connect(callback)
		if self.defaultConnection then
			self.defaultConnection:Disconnect()
			self.defaultConnection = nil
		end
		local connection = self.signalInstance:Connect(callback)
		local _connections = self.connections
		table.insert(_connections, connection)
		local ref
		local _arg0 = {
			NetSignal = self,
			RBXSignal = connection,
			Connected = connection.Connected,
			Disconnect = function(self)
				local _connections_1 = self.NetSignal.connections
				local _arg0_1 = function(f)
					return f == ref
				end
				-- ▼ ReadonlyArray.findIndex ▼
				local _result = -1
				for _i, _v in ipairs(_connections_1) do
					if _arg0_1(_v, _i - 1, _connections_1) == true then
						_result = _i - 1
						break
					end
				end
				-- ▲ ReadonlyArray.findIndex ▲
				local idx = _result
				if idx ~= -1 then
					self.NetSignal:DisconnectAt(idx)
					self.Connected = false
				end
			end,
		}
		ref = _arg0
		self.connectionRefs[ref] = true
		return ref
	end
	function NetServerScriptSignal:Wait()
		return self.signalInstance:Wait()
	end
	function NetServerScriptSignal:WaitAsync()
		return TS.Promise.defer(function(resolve)
			local result = { self.signalInstance:Wait() }
			resolve(result)
		end)
	end
	function NetServerScriptSignal:GetCount()
		return #self.connections
	end
	function NetServerScriptSignal:DisconnectAt(index)
		local connection = self.connections[index + 1]
		if connection then
			connection:Disconnect()
			table.remove(self.connections, index + 1)
		end
		if #self.connections == 0 then
			self.defaultConnection = self.signalInstance:Connect(self.defaultConnectionDelegate)
		end
	end
	function NetServerScriptSignal:DisconnectAll()
		for _, connection in ipairs(self.connections) do
			connection:Disconnect()
		end
		table.clear(self.connections)
		for ref in pairs(self.connectionRefs) do
			ref.Connected = false
		end
		table.clear(self.connectionRefs)
		self.defaultConnection = self.signalInstance:Connect(self.defaultConnectionDelegate)
	end
end
return {
	NetServerScriptSignal = NetServerScriptSignal,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070a1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX8DD137AB25484E60859E3207B3821DEB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ServerAsyncFunction</string>
										<string name="ScriptGuid">{5B8465A0-9D24-4579-BCD2-81808CEFAA40}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_CLIENT = _internal.IS_CLIENT
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local CollectionService = game:GetService("CollectionService")
local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")
local function isEventArgs(value)
	if #value < 2 then
		return false
	end
	local _binding = value
	local eventId = _binding[1]
	local data = _binding[2]
	return type(eventId) == "string" and type(data) == "table"
end
--[[
	*
	* An asynchronous function for two way communication between the client and server
]]
local ServerAsyncFunction
do
	local super = MiddlewareEvent
	ServerAsyncFunction = setmetatable({}, {
		__tostring = function()
			return "ServerAsyncFunction"
		end,
		__index = super,
	})
	ServerAsyncFunction.__index = ServerAsyncFunction
	function ServerAsyncFunction.new(...)
		local self = setmetatable({}, ServerAsyncFunction)
		return self:constructor(...) or self
	end
	function ServerAsyncFunction:constructor(name, middlewares, configuration)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.configuration = configuration
		self.timeout = 10
		self.listeners = {}
		self.instance = findOrCreateRemote("AsyncRemoteFunction", name, function(instance)
			-- Default connection
			self.defaultHook = instance.OnServerEvent:Connect(ServerAsyncFunction.DefaultEventHook)
			CollectionService:AddTag(instance, "NetDefaultListener")
		end)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a NetServerAsyncFunction on the client!")
	end
	function ServerAsyncFunction:GetInstance()
		return self.instance
	end
	function ServerAsyncFunction:SetCallTimeout(timeout)
		local _arg0 = timeout > 0
		assert(_arg0, "timeout must be a positive number")
		self.timeout = timeout
		return self
	end
	function ServerAsyncFunction:GetCallTimeout()
		return self.timeout
	end
	function ServerAsyncFunction:SetCallback(callback)
		if self.defaultHook ~= nil then
			self.defaultHook:Disconnect()
			self.defaultHook = nil
			CollectionService:RemoveTag(self.instance, "NetDefaultListener")
		end
		if self.connector then
			self.connector:Disconnect()
			self.connector = nil
		end
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		self.connector = self.instance.OnServerEvent:Connect(TS.async(function(player, ...)
			local args = { ... }
			if microprofile then
				debug.profilebegin("Net: " .. remoteId)
			end
			if isEventArgs(args) then
				local _binding = args
				local eventId = _binding[1]
				local data = _binding[2]
				local _result = self:_processMiddleware(callback)
				if _result ~= nil then
					_result = _result(player, unpack(data))
				end
				local result = _result
				if TS.Promise.is(result) then
					local _arg0 = function(promiseResult)
						self.instance:FireClient(player, eventId, promiseResult)
					end
					result:andThen(_arg0):catch(function(err)
						warn("[rbx-net] Failed to send response to client: " .. err)
					end)
				else
					self.instance:FireClient(player, eventId, result)
				end
			else
				warn("[rbx-net-async] Recieved message without eventId")
			end
		end))
	end
	ServerAsyncFunction.CallPlayerAsync = TS.async(function(self, player, ...)
		local args = { ... }
		local id = HttpService:GenerateGUID(false)
		local _fn = self.instance
		local _object = {}
		for _k, _v in pairs(args) do
			_object[_k] = _v
		end
		_fn:FireClient(player, id, _object)
		return TS.Promise.new(function(resolve, reject)
			local startTime = tick()
			local connection
			connection = self.instance.OnServerEvent:Connect(function(fromPlayer, ...)
				local recvArgs = { ... }
				local _binding = recvArgs
				local eventId = _binding[1]
				local data = _binding[2]
				if type(eventId) == "string" and data ~= nil then
					if player == player and eventId == id then
						connection:Disconnect()
						resolve(data)
					end
				end
			end)
			local _listeners = self.listeners
			local _arg1 = {
				connection = connection,
				timeout = self.timeout,
			}
			_listeners[id] = _arg1
			repeat
				do
					RunService.Stepped:Wait()
				end
			until not (connection.Connected and tick() < startTime + self.timeout)
			self.listeners[id] = nil
			if tick() >= startTime and connection.Connected then
				connection:Disconnect()
				reject("Request to client timed out")
			end
		end)
	end)
	ServerAsyncFunction.DefaultEventHook = function(player, ...)
		local args = { ... }
	end
end
local default = ServerAsyncFunction
return {
	default = default,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070a2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA422B17A1EC543F6945FF5A1EBE1E32E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ServerEvent</string>
										<string name="ScriptGuid">{0B2E9863-C597-430E-A962-19DF49A6FA1A}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_CLIENT = _internal.IS_CLIENT
local IS_RUNNING = _internal.IS_RUNNING
local MiddlewareEvent = TS.import(script, script.Parent, "MiddlewareEvent").default
local NetServerScriptSignal = TS.import(script, script.Parent, "NetServerScriptSignal").NetServerScriptSignal
--[[
	*
	* Interface for server listening events
]]
--[[
	*
	* Interface for server sender events
]]
local ServerEvent
do
	local super = MiddlewareEvent
	ServerEvent = setmetatable({}, {
		__tostring = function()
			return "ServerEvent"
		end,
		__index = super,
	})
	ServerEvent.__index = ServerEvent
	function ServerEvent.new(...)
		local self = setmetatable({}, ServerEvent)
		return self:constructor(...) or self
	end
	function ServerEvent:constructor(name, middlewares, configuration)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.configuration = configuration
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a NetServerEvent on the client!")
		self.instance = findOrCreateRemote("RemoteEvent", name)
		self.connection = NetServerScriptSignal.new(self.instance.OnServerEvent, self.instance)
	end
	function ServerEvent:GetInstance()
		return self.instance
	end
	function ServerEvent:Connect(callback)
		local remoteId = self.instance.Name
		local microprofile = self.configuration.MicroprofileCallbacks
		return self.connection:Connect(function(player, ...)
			local args = { ... }
			if microprofile then
				debug.profilebegin("Net: " .. remoteId)
			end
			local _result = self:_processMiddleware(callback)
			if _result ~= nil then
				_result(player, unpack(args))
			end
		end)
	end
	function ServerEvent:SendToAllPlayers(...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireAllClients(unpack(args))
	end
	function ServerEvent:SendToAllPlayersExcept(blacklist, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		local Players = game:GetService("Players")
		if typeof(blacklist) == "Instance" then
			local _exp = Players:GetPlayers()
			local _arg0 = function(p)
				return p ~= blacklist
			end
			-- ▼ ReadonlyArray.filter ▼
			local _newValue = {}
			local _length = 0
			for _k, _v in ipairs(_exp) do
				if _arg0(_v, _k - 1, _exp) == true then
					_length += 1
					_newValue[_length] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local otherPlayers = _newValue
			for _, player in ipairs(otherPlayers) do
				self.instance:FireClient(player, unpack(args))
			end
		elseif type(blacklist) == "table" then
			for _, player in ipairs(Players:GetPlayers()) do
				if (table.find(blacklist, player) or 0) - 1 == -1 then
					self.instance:FireClient(player, unpack(args))
				end
			end
		end
	end
	function ServerEvent:SendToPlayer(player, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		self.instance:FireClient(player, unpack(args))
	end
	function ServerEvent:SendToPlayers(players, ...)
		local args = { ... }
		if not IS_RUNNING then
			return nil
		end
		for _, player in ipairs(players) do
			self:SendToPlayer(player, unpack(args))
		end
	end
end
return {
	default = ServerEvent,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070a3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX73D03E3C472742C799D8782DD7745F1E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ServerFunction</string>
										<string name="ScriptGuid">{174EE3CA-31EB-4A43-BBE1-CC8241C00D0C}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _internal = TS.import(script, script.Parent.Parent, "internal")
local findOrCreateRemote = _internal.findOrCreateRemote
local IS_SERVER = _internal.IS_SERVER
local MiddlewareFunction = TS.import(script, script.Parent, "MiddlewareFunction").default
local CollectionService = game:GetService("CollectionService")
local ServerFunction
do
	local super = MiddlewareFunction
	ServerFunction = setmetatable({}, {
		__tostring = function()
			return "ServerFunction"
		end,
		__index = super,
	})
	ServerFunction.__index = ServerFunction
	function ServerFunction.new(...)
		local self = setmetatable({}, ServerFunction)
		return self:constructor(...) or self
	end
	function ServerFunction:constructor(name, middlewares, configuration)
		if middlewares == nil then
			middlewares = {}
		end
		super.constructor(self, middlewares)
		self.configuration = configuration
		self.instance = findOrCreateRemote("RemoteFunction", name, function(instance)
			-- Default listener
			instance.OnServerInvoke = ServerFunction.DefaultFunctionHook
			CollectionService:AddTag(instance, "NetDefaultListener")
		end)
		assert(IS_SERVER, "Cannot create a Net.ServerFunction on the Client!")
	end
	function ServerFunction:GetInstance()
		return self.instance
	end
	function ServerFunction:SetCallback(callback)
		if CollectionService:HasTag(self.instance, "NetDefaultListener") then
			CollectionService:RemoveTag(self.instance, "NetDefaultListener")
		end
		self.instance.OnServerInvoke = function(player, ...)
			local args = { ... }
			local _result = self:_processMiddleware(callback)
			if _result ~= nil then
				_result = _result(player, unpack(args))
			end
			local result = _result
			if TS.Promise.is(result) then
				warn("[rbx-net] WARNING: Promises should be used with an AsyncFunction!")
				local success, value = result:await()
				if success then
					return value
				else
					error(value)
				end
			end
			return result
		end
	end
	ServerFunction.DefaultFunctionHook = function()
		-- TODO: 2.2 make usable for analytics?
		-- Although, unlike `Event`, this will need to be part of `SetCallback`'s stuff.
		return nil
	end
end
return {
	default = ServerFunction,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070a4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDA3EA1B5D6594EFE8C442E3F2E3D72C5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ServerMessagingEvent</string>
										<string name="ScriptGuid">{D24FD94D-E289-4674-AC38-1D32DA381E81}</string>
										<ProtectedString name="Source"><![CDATA[-- Compiled with roblox-ts v1.3.3
local TS = _G[script]
local _ExperienceBroadcastEvent = TS.import(script, script.Parent.Parent, "messaging", "ExperienceBroadcastEvent")
local ExperienceBroadcastEvent = _ExperienceBroadcastEvent.default
local isSubscriptionMessage = _ExperienceBroadcastEvent.isSubscriptionMessage
local _internal = TS.import(script, script.Parent.Parent, "internal")
local getGlobalRemote = _internal.getGlobalRemote
local IS_CLIENT = _internal.IS_CLIENT
local isLuaTable = _internal.isLuaTable
local ServerEvent = TS.import(script, script.Parent, "ServerEvent").default
local Players = game:GetService("Players")
local function isTargetedSubscriptionMessage(value)
	if isSubscriptionMessage(value) then
		if isLuaTable(value.Data) then
			return value.Data.InnerData ~= nil
		end
	end
	return false
end
--[[
	*
	* Similar to a ServerEvent, but works across all servers.
]]
local ServerMessagingEvent
do
	ServerMessagingEvent = setmetatable({}, {
		__tostring = function()
			return "ServerMessagingEvent"
		end,
	})
	ServerMessagingEvent.__index = ServerMessagingEvent
	function ServerMessagingEvent.new(...)
		local self = setmetatable({}, ServerMessagingEvent)
		return self:constructor(...) or self
	end
	function ServerMessagingEvent:constructor(name, config)
		self.instance = ServerEvent.new(getGlobalRemote(name), nil, config)
		self.event = ExperienceBroadcastEvent.new(name)
		local _arg0 = not IS_CLIENT
		assert(_arg0, "Cannot create a Net.GlobalServerEvent on the Client!")
		self.eventHandler = self.event:Connect(function(message)
			if isTargetedSubscriptionMessage(message) then
				self:recievedMessage(message.Data)
			else
				warn("[rbx-net] Recieved malformed message for ServerGameEvent: " .. name)
			end
		end)
	end
	function ServerMessagingEvent:getPlayersMatchingId(matching)
		if type(matching) == "number" then
			return Players:GetPlayerByUserId(matching)
		else
			local players = {}
			for _, id in ipairs(matching) do
				local player = Players:GetPlayerByUserId(id)
				if player then
					table.insert(players, player)
				end
			end
			return players
		end
	end
	function ServerMessagingEvent:recievedMessage(message)
		if message.TargetIds then
			local players = self:getPlayersMatchingId(message.TargetIds)
			if players then
				self.instance:SendToPlayers(players, unpack(message.InnerData))
			end
		elseif message.TargetId ~= nil then
			local player = self:getPlayersMatchingId(message.TargetId)
			if player then
				self.instance:SendToPlayer(player, unpack(message.InnerData))
			end
		else
			self.instance:SendToAllPlayers(unpack(message.InnerData))
		end
	end
	function ServerMessagingEvent:Connect(serverListener)
		return self.event:Connect(function(data, sent)
			serverListener(data, sent)
		end)
	end
	function ServerMessagingEvent:SendToAllServers(...)
		local args = { ... }
		self.event:SendToAllServers({
			InnerData = args,
		})
	end
	function ServerMessagingEvent:SendToServer(jobId, ...)
		local args = { ... }
		self.event:SendToServer(jobId, {
			InnerData = args,
		})
	end
	function ServerMessagingEvent:SendToUserId(userId, ...)
		local args = { ... }
		local player = Players:GetPlayerByUserId(userId)
		-- If the player exists in this instance, just send it straight to them.
		if player then
			self.instance:SendToPlayer(player, unpack(args))
		else
			self.event:SendToAllServers({
				InnerData = args,
				TargetId = userId,
			})
		end
	end
	function ServerMessagingEvent:SendToUserIds(userIds, ...)
		local args = { ... }
		-- Check to see if any of these users are in this server first, and handle accordingly.
		for _, targetId in ipairs(userIds) do
			local player = Players:GetPlayerByUserId(targetId)
			if player then
				self.instance:SendToPlayer(player, unpack(args))
				table.remove(userIds, targetId + 1)
			end
		end
		if #userIds > 0 then
			self.event:SendToAllServers({
				InnerData = args,
				TargetIds = userIds,
			})
		end
	end
end
return {
	default = ServerMessagingEvent,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">6e1c5c92d2c1cbdf064807cb000070a5</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXBDAFE7EF760D4168ADC7A643532F8407">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">bytenet</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">728dc1e802cb68f50651539a000062c7</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX174C3CA076C7444EABBEACD87019E200">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">src</string>
								<string name="ScriptGuid">{B94E52D5-85AB-45DB-8E5F-CE965D27CA40}</string>
								<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local clientProcess = require(script.process.client)
local array = require(script.dataTypes.array)
local bool = require(script.dataTypes.bool)
local buff = require(script.dataTypes.buff)
local cframe = require(script.dataTypes.cframe)
local float32 = require(script.dataTypes.float32)
local float64 = require(script.dataTypes.float64)
local inst = require(script.dataTypes.inst)
local int16 = require(script.dataTypes.int16)
local int32 = require(script.dataTypes.int32)
local int8 = require(script.dataTypes.int8)
local map = require(script.dataTypes.map)
local nothing = require(script.dataTypes.nothing)
local optional = require(script.dataTypes.optional)
local string = require(script.dataTypes.string)
local struct = require(script.dataTypes.struct)
local uint16 = require(script.dataTypes.uint16)
local uint32 = require(script.dataTypes.uint32)
local uint8 = require(script.dataTypes.uint8)
local unknown = require(script.dataTypes.unknown)
local vec2 = require(script.dataTypes.vec2)
local vec3 = require(script.dataTypes.vec3)
local namespace = require(script.namespaces.namespace)
local definePacket = require(script.packets.definePacket)
local serverProcess = require(script.process.server)
local values = require(script.replicated.values)
local types = require(script.types)

values.start()

if RunService:IsServer() then
	serverProcess.start()
else
	clientProcess.start()
end

return (
	table.freeze({
		definePacket = definePacket,
		defineNamespace = namespace,

		array = array,
		bool = bool(),
		optional = optional,
		uint8 = uint8(),
		uint16 = uint16(),
		uint32 = uint32(),
		int8 = int8(),
		int16 = int16(),
		int32 = int32(),
		float32 = float32(),
		float64 = float64(),
		cframe = cframe(),
		string = string(),
		vec2 = vec2(),
		vec3 = vec3(),
		buff = buff(),
		struct = struct,
		map = map,
		inst = inst(),
		unknown = unknown(),
		nothing = nothing(),
	}) :: any
) :: types.ByteNet
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">1d49987330d0c4970652dfb200006106</UniqueId>
							</Properties>
							<Item class="Folder" referent="RBXB003985AA5F24AAF8EE3CD4E506E2D4E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">dataTypes</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060be</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXD065E48176F84631A80E4970BB9CEADC">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">array</string>
										<string name="ScriptGuid">{EFF9AA3F-238A-4A38-A383-2BDBC989276D}</string>
										<ProtectedString name="Source"><![CDATA[--!optimize 2
local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writeu16 = bufferWriter.writeu16

--[[
	Create a new array with the given dataTypeInterface
]]
return function<T>(valueType: types.dataTypeInterface<T>): types.dataTypeInterface<{ [number]: T }>
	local valueWrite = valueType.write
	local valueRead = valueType.read
	

	return {
		read = function(b: buffer, cursor: number)
			local arrayLength = buffer.readu16(b, cursor)
			local arrayCursor = cursor + 2

			local array = table.create(arrayLength)

			for i = 1, arrayLength do
				local item, length = valueRead(b, arrayCursor)
				array[i] = item

				arrayCursor += length
			end

			return array, arrayCursor - cursor
		end,
		write = function(value: any)
			local length = #value
			writeu16(length)

			-- numeric iteration is about 2x faster than generic iteration
			for i = 1, length do
				valueWrite(value[i])
			end
		end,
	}
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060bf</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE472917AA0954BA3962409AB72CCE7BB">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">bool</string>
										<string name="ScriptGuid">{48DA6588-72F1-4A56-BE71-610096CDC0C9}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local boolean = {
	--[[
		1 = true
		0 = false
		
		Write and read based off a uint8
	]]
	read = function(b: buffer, cursor: number)
		return buffer.readu8(b, cursor) == 1, 1
	end,

	length = 1,

	write = bufferWriter.writebool,
}

return function(): types.dataTypeInterface<boolean>
	return boolean
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX523A1EE7F15D4DA7B95883E42BB8C318">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">buff</string>
										<string name="ScriptGuid">{BECA8660-3FA2-493B-ABF9-4F029C933BE5}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writeu16 = bufferWriter.writeu16
local writecopy = bufferWriter.writecopy
local dyn_alloc = bufferWriter.dyn_alloc

local buff = {
	read = function(b: buffer, cursor: number)
		local length = buffer.readu16(b, cursor)
		local freshBuffer = buffer.create(length)

		-- copy the data from the main buffer to the new buffer with an offset of 2 because of length
		buffer.copy(freshBuffer, 0, b, cursor + 2, length)

		return freshBuffer, length + 2
	end,
	write = function(data: buffer)
		local length = buffer.len(data)
		writeu16(length)

		dyn_alloc(length)

		-- write the length of the buffer, then the buffer itself
		writecopy(data)
	end,
}

return function(): types.dataTypeInterface<buffer>
	return buff
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX93827D85385D404BBDC181892ADC6E4C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">cframe</string>
										<string name="ScriptGuid">{53AB6D64-7BF0-48C2-AF0E-D5F64CC0DF08}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writef32NoAlloc = bufferWriter.writef32NoAlloc
local alloc = bufferWriter.alloc

-- thanks jack :p
local cframe = {
	read = function(b: buffer, cursor: number)
		local x = buffer.readf32(b, cursor)
		local y = buffer.readf32(b, cursor + 4)
		local z = buffer.readf32(b, cursor + 8)
		local rx = buffer.readf32(b, cursor + 12)
		local ry = buffer.readf32(b, cursor + 16)
		local rz = buffer.readf32(b, cursor + 20)

		-- Re-construct the CFrame from the axis-angle representation
		local axis = Vector3.new(rx, ry, rz)
		local angle = axis.Magnitude

		return CFrame.fromAxisAngle(axis, angle) + Vector3.new(x, y, z), 24
	end,
	write = function(value: CFrame)
		-- Convert the CFrame to an axis-angle representation
		local x, y, z = value.X, value.Y, value.Z

		local axis, angle = value:ToAxisAngle()
		local rx, ry, rz = axis.X, axis.Y, axis.Z
		axis = axis * angle

		-- Math done, write it now
		alloc(24)
		writef32NoAlloc(x)
		writef32NoAlloc(y)
		writef32NoAlloc(z)
		writef32NoAlloc(rx)
		writef32NoAlloc(ry)
		writef32NoAlloc(rz)
	end,
}

return function(): types.dataTypeInterface<CFrame>
	return cframe
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXF62D9F623AD6422E8472D6FBD6D95CB0">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">float32</string>
										<string name="ScriptGuid">{A2EAB9C3-A6DE-47F5-9D19-5BEAC82BD3F2}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local f32 = bufferWriter.writef32

local float32 = {
	write = f32,

	read = function(b: buffer, cursor: number)
		return buffer.readf32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return float32
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c3</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0A0AEE58F5DC4197820E44221CA7A048">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">float64</string>
										<string name="ScriptGuid">{96011B16-203C-4006-A385-DE80DF6F9EE4}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writef64 = bufferWriter.writef64

local float64 = {
	write = writef64,

	read = function(b: buffer, cursor: number)
		return buffer.readf64(b, cursor), 8
	end,
}

return function(): types.dataTypeInterface<number>
	return float64
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c4</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX348E38C27BE1439FA5F38496B1C0F72F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">inst</string>
										<string name="ScriptGuid">{60824391-EC19-4A4D-AA58-7D47C922B8ED}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local readRefs = require(script.Parent.Parent.process.readRefs)
local types = require(script.Parent.Parent.types)

local writeReference = bufferWriter.writeReference
local alloc = bufferWriter.alloc

return function(): types.dataTypeInterface<Instance?>
	return {
		write = function(value)
			alloc(1)
			writeReference(value)
		end,

		read = function(b: buffer, cursor: number)
			local refs = readRefs.get()

			if not refs then
				return nil, 1
			end

			local ref = refs[buffer.readu8(b, cursor)]

			if typeof(ref) == "Instance" then
				return ref, 1
			else
				return nil, 1
			end
		end,
	}
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c5</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXCB6E84D97B3646F89F9DE436DB7BA425">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">int16</string>
										<string name="ScriptGuid">{32CDB17C-4399-4859-A1A3-0831BD29B5C1}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writei16 = bufferWriter.writei16

local int16 = {
	write = writei16,

	read = function(b: buffer, cursor: number)
		return buffer.readi16(b, cursor), 2
	end,
}

return function(): types.dataTypeInterface<number>
	return int16
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c6</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXDFC598884BF2480C848CB94B82B1A61E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">int32</string>
										<string name="ScriptGuid">{6E7C8D4D-1AAE-4314-903A-0572AE178441}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writei32 = bufferWriter.writei32

local int32 = {
	write = writei32,

	read = function(b: buffer, cursor: number)
		return buffer.readi32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return int32
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c7</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE33F0A89DFE042B5AF63194A829B2B98">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">int8</string>
										<string name="ScriptGuid">{635645CA-F5DD-4313-B0C1-593A4791BA4B}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writei8 = bufferWriter.writei8

local int8 = {
	write = writei8,

	read = function(b: buffer, cursor: number)
		return buffer.readi8(b, cursor), 1
	end,
}

return function(): types.dataTypeInterface<number>
	return int8
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0DA0E06B90AE43E59E5157112E56BA2C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">map</string>
										<string name="ScriptGuid">{0A5CC428-B4DC-40E5-AE54-1524F67AEDFD}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writeu16 = bufferWriter.writeu16

-- thanks jack :p
return function(
	keyType: types.dataTypeInterface<any>,
	valueType: types.dataTypeInterface<any>
): types.dataTypeInterface<{ [any]: any }>
	-- Cache these functions to avoid the overhead of the index
	local keyWrite = keyType.write
	local valueWrite = valueType.write

	return {
		read = function(b: buffer, cursor: number)
			local map = {}
			local mapCursor = cursor

			-- Read map length
			local mapLength = buffer.readu16(b, mapCursor)
			mapCursor += 2

			for _ = 1, mapLength do
				-- read key/value pairs and add them to the map
				local key, keyLength = keyType.read(b, mapCursor)
				mapCursor += keyLength

				local value, valueLength = valueType.read(b, mapCursor)
				mapCursor += valueLength

				map[key] = value
			end

			-- Return the map, alongside length, because mapCursor - cursor = size
			return map, mapCursor - cursor
		end,
		write = function(map: any)
			local count = 0
			for _ in map do
				count += 1
			end

			-- Write length
			writeu16(count)

			for k, v in map do
				-- Write key/value pairs
				keyWrite(k)
				valueWrite(v)
			end
		end,
	}
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060c9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2EF4065FD04E473381B258AFF8D21D00">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">nothing</string>
										<string name="ScriptGuid">{8D378F4B-1200-414A-85BE-8897578DD8D6}</string>
										<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)

local nothing = {
	write = function() end,

	read = function()
		return nil, 0
	end,
}

return function(): types.dataTypeInterface<nil>
	return nothing
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060ca</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0B2133A4A82B481BADB5DBF081B76A74">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">optional</string>
										<string name="ScriptGuid">{C01E061B-B170-4681-A8A5-5EB67E5FFCFE}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writebool = bufferWriter.writebool

return function<T>(valueType: types.dataTypeInterface<T>): types.dataTypeInterface<T?>
	local valueRead = valueType.read
	local valueWrite = valueType.write

	return {
		--[[
			first byte is a boolean, if it's true, the next bytes are the value of valueType
			if it's false, its length of 1 cuz only 1 boolean
		]]

		read = function(b: buffer, cursor: number)
			if buffer.readu8(b, cursor) == 0 then
				-- doesn't exist
				return nil, 1
			else
				-- exists, read the value
				local item, length = valueRead(b, cursor + 1)
				return item, length + 1
			end
		end,

		write = function(value: any)
			local exists = value ~= nil

			writebool(exists)

			if exists then
				valueWrite(value)
			end
		end,
	}
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060cb</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3F8D53AD6D15497EBDDDA7C6C7B23D40">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">string</string>
										<string name="ScriptGuid">{E2E02C31-6A5A-49DD-9DAE-28BC380EBC5C}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writeu16 = bufferWriter.writeu16
local writestring = bufferWriter.writestring

local dyn_alloc = bufferWriter.dyn_alloc

local str = {
	-- 2 bytes for the length, then the string

	read = function(b: buffer, cursor: number)
		local length = buffer.readu16(b, cursor)

		return buffer.readstring(b, cursor + 2, length), length + 2
	end,
	write = function(data: string)
		local length = string.len(data)
		writeu16(length)

		dyn_alloc(length)
		writestring(data)
	end,
}

return function(): types.dataTypeInterface<string>
	return str
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060cc</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXFCA37108454D4CD6B1963B4EDA0A3D4E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">struct</string>
										<string name="ScriptGuid">{30F04D97-D64C-4AB6-98A9-F607AEEC6CC0}</string>
										<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local namespacesDependencies = require(script.Parent.Parent.namespaces.namespacesDependencies)
local values = require(script.Parent.Parent.replicated.values)
local types = require(script.Parent.Parent.types)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

type structData = {
	[string]: number,
}

return function(input: {
	[string]: types.dataTypeInterface<any>,
}): types.dataTypeInterface<{}>
	-- This is used in the reading/writing parts, and isn't used in the initialization code
	-- It's used to store the index-value pairs and the index-key pairs
	-- Index being the position of the value in the array, and the key being the key in the struct dictionary
	local indexValueTypePairs: {
		[number]: types.dataTypeInterface<any>,
	} = {}
	local indexKeyPairs: { [number]: string } = {}

	--[[
		Array should look like {
			[index (1)] = value
			[index (2)] = value
		}

		Index value type is {
			[index (1)] = int32
		}

		Index key is {
			[index (1)] = "structField"
		}
	]]

	if runContext == "server" then
		local serializedStruct = {}

		-- Convert the struct to an array
		local count = 0
		for key in input do
			count += 1
			serializedStruct[key] = count

			-- Store the index-value pairs and the index-key pairs as a shortcut for serializing n all that
			indexValueTypePairs[count] = input[key]
			indexKeyPairs[count] = key
		end

		-- replicate
		namespacesDependencies.add(serializedStruct)
	elseif runContext == "client" then
		-- There's a layer of complexity added here because we have to access the namespace data
		namespacesDependencies.add(input)

		local name = namespacesDependencies.currentName()

		local namespaceReplicator = values.access(name)
		local namespaceData = namespaceReplicator:read() :: types.namespaceData

		-- struct id is just based on the order of creation in the namespace function
		local structData = namespaceData.structs[namespacesDependencies.currentLength()]

		-- Fetch the data from the server and store it in the index-value pairs and the index-key pairs
		for key, index in structData do
			indexValueTypePairs[index] = input[key]
			indexKeyPairs[index] = key
		end
	end

	return {
		read = function(b, cursor)
			local constructed = table.clone(input)
			local structCursor = cursor

			for index, valueType in indexValueTypePairs do
				local value, length = valueType.read(b, structCursor)

				constructed[indexKeyPairs[index]] = value

				structCursor += length
			end

			return constructed, structCursor - cursor
		end,

		write = function(structValue)
			for index, valueType in indexValueTypePairs do
				valueType.write(structValue[indexKeyPairs[index]])
			end
		end,
	}
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060cd</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX223A62FFAEE343E0BE65EBF8D212AA95">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">uint16</string>
										<string name="ScriptGuid">{E38ED686-FB4C-4963-A0D5-0AB28DFC2C71}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writeu16 = bufferWriter.writeu16

local uint16 = {
	write = writeu16,

	read = function(b: buffer, cursor: number)
		return buffer.readu16(b, cursor), 2
	end,
}

return function(): types.dataTypeInterface<number>
	return uint16
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060ce</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXFD95C1867EE74D5F9D405A584A465B01">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">uint32</string>
										<string name="ScriptGuid">{1830C6DA-BA32-4344-A805-391FA0B39277}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writeu32 = bufferWriter.writeu32

local uint32 = {
	write = writeu32,

	read = function(b: buffer, cursor: number)
		return buffer.readu32(b, cursor), 4
	end,
}

return function(): types.dataTypeInterface<number>
	return uint32
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060cf</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB502157FD8D84506A3C7BF89741DAC1E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">uint8</string>
										<string name="ScriptGuid">{6B8A679F-141D-422C-A95D-CEAEDCBDE255}</string>
										<ProtectedString name="Source"><![CDATA[local types = require(script.Parent.Parent.types)
local bufferWriter = require(script.Parent.Parent.process.bufferWriter)

local writeu8 = bufferWriter.writeu8

local uint8 = {
	write = writeu8,

	read = function(b: buffer, cursor: number)
		return buffer.readu8(b, cursor), 1
	end,
}

return function(): types.dataTypeInterface<number>
	return uint8
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060d0</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX176D96BBE8DF4F58A9F2F7D63932C7D8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">unknown</string>
										<string name="ScriptGuid">{130EAC1E-9963-4725-B072-2B8FA5D14A44}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local readRefs = require(script.Parent.Parent.process.readRefs)
local types = require(script.Parent.Parent.types)

local writeReference = bufferWriter.writeReference
local alloc = bufferWriter.alloc

return function(): types.dataTypeInterface<unknown>
	return {
		write = function(value: unknown)
			alloc(1)
			writeReference(value)
		end,

		read = function(b: buffer, cursor: number)
			local refs = readRefs.get()

			if not refs then
				return nil, 1
			end

			return refs[buffer.readu8(b, cursor)], 1
		end,
	}
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060d1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXFA4608339F29450DA717902B76F21F1B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">vec2</string>
										<string name="ScriptGuid">{6B555052-EC62-48FF-8737-60475B0A8784}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writef32NoAlloc = bufferWriter.writef32NoAlloc
local alloc = bufferWriter.alloc

local vec2 = {
	--[[
		2 float32s, one for X, one for Y
	]]

	read = function(b: buffer, cursor: number)
		return Vector2.new(buffer.readf32(b, cursor), buffer.readf32(b, cursor + 4)), 8
	end,

	write = function(value: Vector2)
		alloc(8)
		writef32NoAlloc(value.X)
		writef32NoAlloc(value.Y)
	end,
}

return function(): types.dataTypeInterface<Vector2>
	return vec2
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060d2</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7EF93EF23F1C4B0FA655238760A1239E">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">vec3</string>
										<string name="ScriptGuid">{779BCAAF-9878-4F3C-BFA5-8E73DF695052}</string>
										<ProtectedString name="Source"><![CDATA[local bufferWriter = require(script.Parent.Parent.process.bufferWriter)
local types = require(script.Parent.Parent.types)

local writef32NoAlloc = bufferWriter.writef32NoAlloc
local alloc = bufferWriter.alloc

local vec3 = {
	--[[
		3 floats, 12 bytes
	]]
	read = function(b: buffer, cursor: number)
		return Vector3.new(buffer.readf32(b, cursor), buffer.readf32(b, cursor + 4), buffer.readf32(b, cursor + 8)), 12
	end,

	write = function(value: Vector3)
		alloc(12)
		writef32NoAlloc(value.X)
		writef32NoAlloc(value.Y)
		writef32NoAlloc(value.Z)
	end,
}

return function(): types.dataTypeInterface<Vector3>
	return vec3
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060d3</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX0FC7EF52A4654F769A527C9C6B848E32">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">namespaces</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060e9</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXA577060A671E48AC8DF0B098B6818846">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">namespace</string>
										<string name="ScriptGuid">{E5DC6117-4651-44B5-B1B6-AAC1E05F5309}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	The file that contains the function for handling and creating namespaces.
	Namespaces aren't really anything special, they are just an encapsulation to make it easier to manage packets and structs.
	
	Dependency management is fun!
]]

local RunService = game:GetService("RunService")

local values = require(script.Parent.Parent.replicated.values)
local types = require(script.Parent.Parent.types)
local namespacesDependencies = require(script.Parent.namespacesDependencies)
local packetIDs = require(script.Parent.packetIDs)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

local count = 0

return function(
	name: string,
	input: () -> {
		[string]: any,
	}
)
	local namespaceReplicator = values.access(name)

	namespacesDependencies.start(name)
	local packets: {
		[string]: (id: number) -> any,
	} = input()
	local structs = namespacesDependencies.empty()

	local result = {}

	if runContext == "server" then
		local constructedNamespace = {
			structs = {},
			packets = {},
		}

		for key in packets do
			count += 1
			constructedNamespace.packets[key] = count
			result[key] = packets[key](count)

			packetIDs.set(count, result[key])
		end

		for index, value in structs do
			constructedNamespace.structs[index] = value
		end

		namespaceReplicator:write(constructedNamespace)
	elseif runContext == "client" then
		-- yes, this means that packets technically don't need to be defined on the client
		-- we do it anyway for typechecking and perf shortcuts
		local namespaceData = namespaceReplicator:read() :: types.namespaceData

		for key, packet in packets do
			result[key] = packet(namespaceData.packets[key])

			packetIDs.set(namespaceData.packets[key], result[key])
		end
	end

	return result
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060ea</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXB67D66BC342742B9B5EE324A289B6531">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">namespacesDependencies</string>
										<string name="ScriptGuid">{BA34B564-B501-43BF-9C6A-53C7480EFCCC}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	Basic dependency graph for structs created within a namespace
]]

local current: { [number]: any }?
local currentName: string

local namespacesDependencies = {}

function namespacesDependencies.start(name: string)
	current = {} :: { [number]: any }
	currentName = name
end

function namespacesDependencies.add(data)
	if not current then
		return
	end

	table.insert(current, data)
end

function namespacesDependencies.currentLength()
	return if current then #current else 0
end

function namespacesDependencies.currentName()
	return currentName
end

function namespacesDependencies.empty(): { [number]: any }
	if current == nil then
		return {}
	end

	local result = current
	current = nil

	return result
end

return namespacesDependencies
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060eb</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXD8CB8DCEFC2542D497A330A813DF3E70">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">packetIDs</string>
										<string name="ScriptGuid">{B8171F36-06F2-4C39-B854-19A0AD415704}</string>
										<ProtectedString name="Source"><![CDATA[--!native

--[[
	Exists solely to get a packet instance from an ID in the reader file.
	Might be able to be done in a better way?
]]
local dict = {}

local packetIDs = {}

function packetIDs.set(id: number, packet: any)
	dict[id] = packet
end

-- Use this instead of a get function for performance.
function packetIDs.ref()
	return dict
end

return packetIDs
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060ec</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBXC55B99BC8C114F29958AD0CCCB45C017">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">packets</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f0</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX299DF80BF57A499999DAFBEF2199A8F7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">definePacket</string>
										<string name="ScriptGuid">{2601EC23-A626-4287-8CB6-2B81B677F892}</string>
										<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Exists so that the namespace can set the ID of the packet

	Packet shouldnt need to care about making its own ID
]]
local types = require(script.Parent.Parent.types)
local packet = require(script.Parent.packet)

return function(props: types.packetProps<any>)
	return function(id: number)
		return packet(props, id)
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f1</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX3D57E9A3B36441E28E3923124CA0D36F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">packet</string>
										<string name="ScriptGuid">{1C342761-52D7-458D-8F3B-B45B27B71AF8}</string>
										<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local client = require(script.Parent.Parent.process.client)
local server = require(script.Parent.Parent.process.server)

local moduleRunContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

--[[
	We use closures here instead of metatables for performance
	It's just faster to use closures than metatables
]]
return function(props: types.packetProps<types.dataTypeInterface<any>>, id: number)
	-- Basic properties: reliability type, "unique" which is used to get the packet ID, and set up listeners
	local reliabilityType = props.reliabilityType or "reliable"
	local listeners = {}

	local serverSendFunction: (player: Player, id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then server.sendPlayerReliable
		else server.sendPlayerUnreliable

	local serverSendAllFunction: (id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then server.sendAllReliable
		else server.sendAllUnreliable

	local clientSendFunction: (id: number, writer: (value: any) -> (), data: any) -> () = if reliabilityType
			== "reliable"
		then client.sendReliable
		else client.sendUnreliable

	-- shorcut to avoid indexxing
	local writer = props.value.write

	local exported = {}

	-- RunContext error checking that doesn't have performance drawbacks
	setmetatable(exported, {
		__index = function(index)
			if
				(index == "sendTo" or index == "sendToAllExcept" or index == "sendToAll")
				and moduleRunContext == "client"
			then
				error("You cannot use sendTo, sendToAllExcept, or sendToAll on the client")
			elseif index == "send" and moduleRunContext == "server" then
				error("You cannot use send on the server")
			end
		end,
	})

	-- exposed for the reader file
	exported.reader = props.value.read

	if moduleRunContext == "server" then
		function exported.sendToList(data, players: { Player })
			for _, player in players do
				serverSendFunction(player, id, writer, data)
			end
		end

		function exported.sendTo(data, player: Player)
			serverSendFunction(player, id, writer, data)
		end

		function exported.sendToAllExcept(data, except: Player)
			for _, player: Player in Players:GetPlayers() do
				if player ~= except then
					serverSendFunction(player, id, writer, data)
				end
			end
		end

		function exported.sendToAll(data)
			serverSendAllFunction(id, writer, data)
		end
	elseif moduleRunContext == "client" then
		function exported.send(data)
			clientSendFunction(id, writer, data)
		end
	end

	function exported.wait()
		-- define it up here so we can use it to disconnect
		local index: number

		local runningThread = coroutine.running()
		table.insert(listeners, function(data, player)
			task.spawn(runningThread, data, player)

			-- Disconnects the listener
			table.remove(listeners, index)
		end)

		-- we connected, time to set the index for when we need to disconnect.
		index = #listeners

		-- the listener will resume the thread
		return coroutine.yield()
	end

	function exported.listen(callback)
		table.insert(listeners, callback)
	end

	function exported.getListeners()
		return listeners
	end

	return exported
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f2</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX74D3AA58757E4DA79DAA0E8F62E68701">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">process</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f5</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBXAB383D04AA9744949D515102EAF39914">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">bufferWriter</string>
										<string name="ScriptGuid">{25B3E6F0-D49D-4048-A5CA-A7E3E56FC555}</string>
										<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2

--[[
	Collects all write operations into a queue.
	When the buffer is written, it will be written in the order of the queue.
	
	All operations take in 2 parameters: the cursor and the value.
	Knowing this we can easily attach everything in a nice table, where
	{
		[1] = writer,
		[2] = cursor,
		[3] = value
	}
	
	A lot of these functions just exist as shorthand optimizations.
]]
local types = require(script.Parent.Parent.types)

local size: number
local cursor: number
local buff: buffer
local references: { [number]: unknown }

-- There are not fastcalls for copy and create, so this is slightly faster.
local bufferCopy = buffer.copy
local bufferCreate = buffer.create

local function alloc(bytes: number)
	if not (cursor + bytes >= size) then
		return
	end

	size = math.round(size * 1.5)

	local newBuffer = bufferCreate(size)
	bufferCopy(newBuffer, 0, buff)

	buff = newBuffer
end

local function dyn_alloc(bytes: number)
	while cursor + bytes >= size do
		size = math.round(size * 1.5)
	end

	local newBuffer = buffer.create(size)
	buffer.copy(newBuffer, 0, buff)

	buff = newBuffer
end

local bufferWriter = {}

-- this will let alloc and dyn_alloc be inlined for functions in here
bufferWriter.alloc = alloc
bufferWriter.dyn_alloc = dyn_alloc

function bufferWriter.writeu8(value: number)
	alloc(1)
	buffer.writeu8(buff, cursor, value)
	cursor += 1
end

function bufferWriter.writei8(value: number)
	alloc(1)
	buffer.writei8(buff, cursor, value)
	cursor += 1
end

-- this exists solely for the unknown and instance data type. Will likely be obselete soon enough
function bufferWriter.writeReference(value: any)
	table.insert(references, value)
	local index = #references

	buffer.writeu8(buff, cursor, index)
	cursor += 1
	print(references)
end

function bufferWriter.writeu16(value: number)
	alloc(2)
	buffer.writeu16(buff, cursor, value)
	cursor += 2
end

function bufferWriter.writei16(value: number)
	alloc(2)
	buffer.writeu16(buff, cursor, value)
	cursor += 2
end

function bufferWriter.writeu32(value: number)
	alloc(4)
	buffer.writeu32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writestring(value: string)
	buffer.writestring(buff, cursor, value)
	cursor += string.len(value)
end

function bufferWriter.writei32(value: number)
	alloc(4)
	buffer.writei32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writef32NoAlloc(value: number)
	buffer.writef32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writef64NoAlloc(value: number)
	buffer.writef64(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writef32(value: number)
	alloc(4)
	buffer.writef32(buff, cursor, value)
	cursor += 4
end

function bufferWriter.writef64(value: number)
	alloc(8)
	buffer.writef64(buff, cursor, value)
	cursor += 8
end

function bufferWriter.writecopy(value)
	buffer.copy(buff, cursor, value)
	cursor += buffer.len(value)
end

function bufferWriter.writebool(val: boolean)
	alloc(1)
	buffer.writeu8(buff, cursor, if val then 1 else 0)
	cursor += 1
end

function bufferWriter.writePacket(channel: types.channelData, id, writer, data)
	size = channel.size
	cursor = channel.cursor
	references = channel.references
	buff = channel.buff

	alloc(1)
	buffer.writeu8(buff, cursor, id)
	cursor += 1

	writer(data)

	channel.size = size
	channel.cursor = cursor
	channel.references = references
	channel.buff = buff
	return channel
end

return bufferWriter
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f6</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXE44609B74978476F91A411FB1C0A4CD5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">client</string>
										<string name="ScriptGuid">{87EAFB30-B470-4507-A42D-2FDC571B9E0D}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local read = require(script.Parent.read)
local bufferWriter = require(script.Parent.bufferWriter)

local writePacket = bufferWriter.writePacket

local function onClientEvent(receivedBuffer, ref)
	read(receivedBuffer, ref)
end

-- Shared with: src/process/server.luau (Infeasible to split this into another file)
local function create()
	return {
		cursor = 0,
		size = 256,
		references = {},
		buff = buffer.create(256),
	}
end

local function dump(channel: types.channelData): (buffer, { unknown }?)
	local cursor = channel.cursor
	local dumpBuffer = buffer.create(cursor)

	buffer.copy(dumpBuffer, 0, channel.buff, 0, cursor)

	return dumpBuffer, if #channel.references > 0 then channel.references else nil
end
-- No longer shared

local reliable: types.channelData = create()
local unreliable: types.channelData = create()

local clientProcess = {}

function clientProcess.sendReliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	reliable = writePacket(reliable, id, writer, data)
end

function clientProcess.sendUnreliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	unreliable = writePacket(unreliable, id, writer, data)
end

function clientProcess.start()
	local reliableRemote = ReplicatedStorage:WaitForChild("ByteNetReliable")
	reliableRemote.OnClientEvent:Connect(onClientEvent)

	local unreliableRemote = ReplicatedStorage:WaitForChild("ByteNetUnreliable")
	unreliableRemote.OnClientEvent:Connect(onClientEvent)

	RunService.Heartbeat:Connect(function()
		-- Again, checking if there's anything in the channel before we send it.
		if reliable.cursor > 0 then
			local b, r = dump(reliable)
			reliableRemote:FireServer(b, r)

			-- effectively clears the channel
			reliable.cursor = 0
			table.clear(reliable.references)
		end

		if unreliable.cursor > 0 then
			local b, r = dump(unreliable)
			unreliableRemote:FireServer(b, r)

			unreliable.cursor = 0
			table.clear(unreliable.references)
		end
	end)
end

return clientProcess
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f7</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7DF94E99B0584A3CBAFD2D274EB731B4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">read</string>
										<string name="ScriptGuid">{3D873C6C-D64F-49D2-A565-A5AEB05ADE76}</string>
										<ProtectedString name="Source"><![CDATA[--!optimize 2
--!native
local packetIDs = require(script.Parent.Parent.namespaces.packetIDs)
local readRefs = require(script.Parent.readRefs)

local ref = packetIDs.ref()
local freeThread: thread?

local function functionPasser(fn, ...)
	local aquiredThread = freeThread
	freeThread = nil
	fn(...)
	freeThread = aquiredThread
end

local function yielder()
	while true do
		functionPasser(coroutine.yield())
	end
end

local function runListener(fn, ...)
	if freeThread == nil then
		freeThread = coroutine.create(yielder)
		coroutine.resume(freeThread :: thread)
	end

	task.spawn(freeThread :: thread, fn, ...)
end

return function(incomingBuffer: buffer, references: { [number]: unknown }?, player: Player?)
	local length = buffer.len(incomingBuffer)
	local readCursor = 0

	readRefs.set(references)

	while readCursor < length do
		local packet = ref[buffer.readu8(incomingBuffer, readCursor)]
		readCursor += 1

		local value, valueLength = packet.reader(incomingBuffer, readCursor)

		readCursor += valueLength

		for _, listener in packet.getListeners() do
			runListener(listener, value, player)
		end
	end
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f8</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBXA18EBE1980644D418FC8B4BC409FB9D7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">readRefs</string>
										<string name="ScriptGuid">{A4B98F8D-5477-4BED-950C-D77CA60A43F6}</string>
										<ProtectedString name="Source"><![CDATA[--!native
local current

local readRefs = {}

function readRefs.set(refTable)
	current = refTable
end

function readRefs.get()
	return current
end

return readRefs
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060f9</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX7117CC1517C94C23951B137389260CC2">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">server</string>
										<string name="ScriptGuid">{36E97C2D-C552-4DEC-A3B6-085A79FE8A13}</string>
										<ProtectedString name="Source"><![CDATA[--!native
--!optimize 2
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local types = require(script.Parent.Parent.types)
local read = require(script.Parent.read)
local bufferWriter = require(script.Parent.bufferWriter)

local writePacket = bufferWriter.writePacket

-- All channelData is set to nil upon being sent which is why these are all optionals
local perPlayerReliable: { [Player]: types.channelData } = {}
local perPlayerUnreliable: { [Player]: types.channelData } = {}

-- Shared with: src/process/client.luau (Infeasible to split this into another file)
local function create()
	return {
		cursor = 0,
		size = 256,
		references = {},
		buff = buffer.create(256),
	}
end

local function dump(channel: types.channelData): (buffer, { unknown }?)
	local cursor = channel.cursor
	local dumpBuffer = buffer.create(cursor)

	buffer.copy(dumpBuffer, 0, channel.buff, 0, cursor)

	return dumpBuffer, if #channel.references > 0 then channel.references else nil
end
-- No longer shared

local globalReliable: types.channelData = create()
local globalUnreliable: types.channelData = create()

-- TODO handle invalid data better
local function onServerEvent(player: Player, data, references)
	-- Only accept buffer data
	if not (typeof(data) == "buffer") then
		return
	end

	read(data, references, player)
end

local function playerAdded(player)
	if not perPlayerReliable[player] then
		perPlayerReliable[player] = create()
	end

	if not perPlayerUnreliable[player] then
		perPlayerUnreliable[player] = create()
	end
end

local serverProcess = {}

function serverProcess.sendAllReliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	globalReliable = writePacket(globalReliable, id, writer, data)
end

function serverProcess.sendAllUnreliable(id: number, writer: (value: any) -> (), data: { [string]: any })
	globalUnreliable = writePacket(globalUnreliable, id, writer, data)
end

function serverProcess.sendPlayerReliable(
	player: Player,
	id: number,
	writer: (value: any) -> (),
	data: { [string]: any }
)
	perPlayerReliable[player] = writePacket(perPlayerReliable[player], id, writer, data)
end

function serverProcess.sendPlayerUnreliable(
	player: Player,
	id: number,
	writer: (value: any) -> (),
	data: { [string]: any }
)
	perPlayerUnreliable[player] = writePacket(perPlayerUnreliable[player], id, writer, data)
end

function serverProcess.start()
	local reliableRemote = Instance.new("RemoteEvent")
	reliableRemote.Name = "ByteNetReliable"
	reliableRemote.OnServerEvent:Connect(onServerEvent)
	reliableRemote.Parent = ReplicatedStorage

	local unreliableRemote = Instance.new("UnreliableRemoteEvent")
	unreliableRemote.Name = "ByteNetUnreliable"
	unreliableRemote.OnServerEvent:Connect(onServerEvent)
	unreliableRemote.Parent = ReplicatedStorage

	for _, player in Players:GetPlayers() do
		playerAdded(player)
	end

	Players.PlayerAdded:Connect(playerAdded)

	RunService.Heartbeat:Connect(function()
		-- Check if the channel has anything before trying to send it
		if globalReliable.cursor > 0 then
			local b, r = dump(globalReliable)
			reliableRemote:FireAllClients(b, r)

			globalReliable.cursor = 0
			table.clear(globalReliable.references)
		end

		if globalUnreliable.cursor > 0 then
			local b, r = dump(globalUnreliable)
			unreliableRemote:FireAllClients(b, r)

			globalUnreliable.cursor = 0
			table.clear(globalUnreliable.references)
		end

		for _, player in Players:GetPlayers() do
			if perPlayerReliable[player].cursor > 0 then
				local b, r = dump(perPlayerReliable[player])
				reliableRemote:FireClient(player, b, r)

				perPlayerReliable[player].cursor = 0
				table.clear(perPlayerReliable[player].references)
			end

			if perPlayerUnreliable[player].cursor > 0 then
				local b, r = dump(perPlayerUnreliable[player])
				unreliableRemote:FireClient(player, b, r)

				perPlayerUnreliable[player].cursor = 0
				table.clear(perPlayerUnreliable[player].references)
			end
		end
	end)
end

return serverProcess
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb2000060fa</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="Folder" referent="RBX2C152DD23B1646BEAFE29F27C7DFFC32">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<string name="Name">replicated</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">1d49987330d0c4970652dfb200006101</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX9E58B3508ADB4CEDB9BA5C2021C7F40B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">replicatedValue</string>
										<string name="ScriptGuid">{2D218CA4-25CE-4EC9-856F-892060204585}</string>
										<ProtectedString name="Source"><![CDATA[local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"

local replicatedValuePrototype = {}
local replicatedValueMetatable = { __index = replicatedValuePrototype }
export type replicatedValueType = typeof(setmetatable(
	{} :: {
		_luauData: {},
		_value: StringValue,
	},
	replicatedValueMetatable
))

function replicatedValuePrototype.write(self: replicatedValueType, value: {})
	assert(runContext == "server", "cannot write to replicatdvalue on client")

	self._luauData = value

	-- self._value.Value :(
	self._value.Value = HttpService:JSONEncode(value)
end

function replicatedValuePrototype.read(self: replicatedValueType)
	return self._luauData
end

return function(valueObject: StringValue): replicatedValueType
	local self = setmetatable({}, replicatedValueMetatable)

	self._luauData = {}
	self._value = valueObject

	-- important note: We freeze the table on the client to ensure that it never is modified
	-- We initialize _luauData as an empty table because on the server, we don't need to freeze it.
	if runContext == "client" then
		self._luauData = table.freeze(HttpService:JSONDecode(valueObject.Value))

		valueObject.Changed:Connect(function(value: string)
			if not value then
				return
			end

			self._luauData = table.freeze(HttpService:JSONDecode(value))
		end)
	end

	return self
end
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb200006102</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2982D06076F54096BCA3B4A39E262B25">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">values</string>
										<string name="ScriptGuid">{92F41D07-08E0-4553-BBF2-4125A04122DF}</string>
										<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local replicatedValue = require(script.Parent.replicatedValue)

local runContext: "server" | "client" = if RunService:IsServer() then "server" else "client"
local valueFolder: Folder
local valueDictionary: {
	[string]: replicatedValue.replicatedValueType,
} = {}

local values = {}

function values.start()
	if runContext == "server" then
		local storage = Instance.new("Folder")
		storage.Name = "BytenetStorage"
		storage.Parent = ReplicatedStorage

		valueFolder = storage
	elseif runContext == "client" then
		valueFolder = ReplicatedStorage:WaitForChild("BytenetStorage")
	end
end

function values.access(name: string): replicatedValue.replicatedValueType
	-- caching
	if valueDictionary[name] then
		return valueDictionary[name]
	end

	if runContext == "client" then
		local potentialValueInstance = valueFolder:FindFirstChild(name)
		if potentialValueInstance and potentialValueInstance:IsA("StringValue") then
			-- set up the value and return it
			local value = replicatedValue(potentialValueInstance)

			valueDictionary[name] = value

			return value
		end
	elseif runContext == "server" then
		-- create the value and return it
		local newValueInstance = Instance.new("StringValue")
		newValueInstance.Name = name
		newValueInstance.Parent = valueFolder

		local value = replicatedValue(newValueInstance)

		valueDictionary[name] = value

		return value
	end

	return valueDictionary[name]
end

return values
]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">1d49987330d0c4970652dfb200006103</UniqueId>
									</Properties>
								</Item>
							</Item>
							<Item class="ModuleScript" referent="RBX85CD57B6ECEF442787F57429C466D6F2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">types</string>
									<string name="ScriptGuid">{B2D19995-A79C-4F4A-91FF-980CC95187CA}</string>
									<ProtectedString name="Source"><![CDATA[export type namespaceData = {
	packets: {
		[string]: any,
	},
	structs: {
		[number]: {
			[string]: any,
		},
	},
}

-- Externally used for defining packets
export type packetProps<T> = {
	value: T,
	reliabilityType: ("reliable" | "unreliable")?,
	callbackBehavior: {
		spawnThread: boolean,
		allowMultiple: boolean,
	}?,
}

-- Used internally for
export type channelData = {
	cursor: number,
	size: number,
	references: { unknown },
	buff: buffer,
}

-- Used internally for serializing and deserializing all data types
export type dataTypeInterface<T> = {
	write: (value: T) -> (),
	read: (b: buffer, cursor: number) -> (T, number),
	length: number?,
}

-- Somewhat public facing: used as return result in definePacket
type Packet<T> = {
	sendToAll: (data: T) -> (),
	sendTo: (data: T, target: Player) -> (),
	sendToList: (data: T, targets: { Player }) -> (),
	sendToAllExcept: (data: T, exceptions: { Player }) -> (),

	wait: () -> T,
	send: (data: T, target: Player?) -> (),
	listen: (callback: (data: T, player: Player?) -> ()) -> (),
}

-- Library type
export type ByteNet = {
	definePacket: <T>(props: packetProps<T>) -> Packet<T>,
	defineNamespace: <T>(name: string, namespace: () -> T) -> T,

	struct: <T>(format: T) -> T,
	bool: boolean,
	array: <T>(value: T) -> { [number]: T },
	optional: <T>(value: T) -> T?,
	inst: Instance,
	nothing: nil,
	unknown: unknown,
	uint8: number,
	uint16: number,
	uint32: number,
	int8: number,
	int16: number,
	int32: number,
	float32: number,
	float64: number,
	string: string,
	vec3: Vector3,
	vec2: Vector2,
	buff: buffer,
	cframe: CFrame,
	map: <K, V>(key: K, value: V) -> { [K]: V },
}

return nil
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">1d49987330d0c4970652dfb200006108</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX198B088B7B4C4E2CBAED26BD54A4F24D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">mock-memory-store-service</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">7adaba999e94e082065fffa30000607d</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX5448D33FEC1648A2B6E0A7B107EB6ECC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">lib</string>
								<string name="ScriptGuid">{7B1F8551-B072-4D07-98C8-7122E64DB07B}</string>
								<ProtectedString name="Source"><![CDATA[local MockMemoryStoreServiceModule = script.MockMemoryStoreService

local shouldUseMock = false
if game.GameId == 0 then
    shouldUseMock = true
elseif game:GetService("RunService"):IsStudio() then
	local status, message = pcall(function()
		-- This will error if current instance has no Studio API access:
		game:GetService("MemoryStoreService"):GetSortedMap("__TEST")
	end)
	if not status and message:find("403", 1, true) then -- HACK
		-- Can connect to datastores, but no API access
		shouldUseMock = true
	end
end

-- Return the mock or actual service depending on environment:
if shouldUseMock then
	warn("INFO: Using MockMemoryStoreService instead of MemoryStoreService")
	return require(MockMemoryStoreServiceModule) :: MemoryStoreService
else
	return game:GetService("MemoryStoreService") :: MemoryStoreService
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">7adaba999e94e082065fffa30000607e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5C5A653F1B3D44EA86118E74CB9246E1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">MockMemoryStoreService</string>
									<string name="ScriptGuid">{1FBEA0CE-BF04-438F-B2A8-9068E5FF1485}</string>
									<ProtectedString name="Source"><![CDATA[local MockMemoryStoreSortedMap = require(script.MockMemoryStoreSortedMap)
local MockMemoryStoreQueue = require(script.MockMemoryStoreQueue)
local MockMemoryStoreQuota = require(script.MockMemoryStoreQuota)
local MockMemoryStoreUtils = require(script.MockMemoryStoreUtils)

local RunService = game:GetService("RunService")

local MockMemoryStoreService = {
    queues = {},
    sortedMaps = {}
}
MockMemoryStoreService.__index = MockMemoryStoreService

--[[
    Will retrieve a MockMemoryStoreSortedMap object under the specified name
]]
function MockMemoryStoreService:GetSortedMap(name: string)
    local sortedMap = self.sortedMaps[name];
    if sortedMap == nil then
        sortedMap = MockMemoryStoreSortedMap.new(name)
        self.sortedMaps[name] = sortedMap
    end

    return sortedMap
end

--[[
    Will retrieve a MockMemoryStoreQueue object under the specified name
]]
function MockMemoryStoreService:GetQueue(name: string, timeout: number?)
    MockMemoryStoreUtils.WarnOnce("MockMemoryStoreService queue is still in development, and may not work accurately just yet.")

    local queue = self.queues[name]
    if queue == nil then
        queue = MockMemoryStoreQueue.new(name, timeout)
        self.queues[name] = queue
    end

    return queue
end

-- Lifetime handling
local function onHeartbeat(deltaTime)
    MockMemoryStoreQuota:UpdateQuota()

    -- Need to handle expiration for each map value
    for _, map in pairs(MockMemoryStoreService.sortedMaps) do
        -- Iterate through each value to check if they're expired
        -- Then expire them
        for key, value in pairs(map.mapValues) do
            if value.expiration <= tick() then
                map:RemoveExpiringKey(key)
            end
        end
    end

    for _, queue in pairs(MockMemoryStoreService.queues) do
        queue:HandleTimeouts()
    end
end
RunService.Heartbeat:Connect(onHeartbeat)

return MockMemoryStoreService]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">7adaba999e94e082065fffa30000607f</UniqueId>
								</Properties>
								<Item class="ModuleScript" referent="RBX9A2C5DBCBBD34A60BFFBA0B09B888018">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">ArrayUtil</string>
										<string name="ScriptGuid">{1B223B70-5A07-444E-8493-71909173F5AD}</string>
										<ProtectedString name="Source"><![CDATA[local function map(arr, mapFn)
    local alloc = table.create(#arr)
    for index, value in ipairs(arr) do
        table.insert(alloc, mapFn(value, index))
    end
    return alloc
end

return {
    Map = map
}]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7adaba999e94e082065fffa300006080</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX48CD196372F84D4D8F94B1C88A02244A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MockMemoryStoreQueue</string>
										<string name="ScriptGuid">{D460DB85-C167-492F-8AC7-515E4B2F6A0A}</string>
										<ProtectedString name="Source"><![CDATA[local MockMemoryStoreQuota = require(script.Parent.MockMemoryStoreQuota)
local ArrayUtil = require(script.Parent.ArrayUtil)

local httpService = game:GetService("HttpService")

local MockMemoryStoreQueue = {}
MockMemoryStoreQueue.__index = MockMemoryStoreQueue;

type Value = {
    value: any,
    priority: number,
    expiration: number,
}

function MockMemoryStoreQueue.new(name: string, timeout: number)
    return setmetatable({
        queue = {},
        refs = {},
        invisibilityTimeout = timeout or 30
    }, MockMemoryStoreQueue)
end

function MockMemoryStoreQueue:GetRef(id)
    return self.refs[id]
end

function MockMemoryStoreQueue:ReadAsync(count: number, allOrNothing: boolean?, waitTimeout: number?)
    assert(typeof(count) == "number", "Expected count (number)")
    assert(count < 100 and count >= 0, "Expected count of 0 - 100")
    allOrNothing = if allOrNothing then allOrNothing else false
    waitTimeout = if waitTimeout then waitTimeout else -1

    assert(type(allOrNothing) == "boolean")
    assert(type(waitTimeout) == "number")

    MockMemoryStoreQuota:ProcessReadRequest()

    local time = 0
    repeat
        print("yield", time);
        time += task.wait()
    until (waitTimeout ~= -1 and time >= waitTimeout) or (not allOrNothing or #self.queue >= count)

    local queueCount = #self.queue

    local results = table.move(self.queue, queueCount + 1 - count, queueCount, 1, {})
    local refId = httpService:GenerateGUID(false)

    self.queue = table.move(self.queue, 1, #self.queue - count, 1, {})
    self.refs[refId] = {
        results = results,
        timeout = tick() + self.invisibilityTimeout
    }

    local mapped = ArrayUtil.Map(results, function(v)
        return v.value
    end)

    return mapped, refId, { time = time, queue = self.queue, refs = self.refs }
end

function MockMemoryStoreQueue:HandleTimeouts()
    -- Remove expired values in queue
    for index, value in ipairs(self.queue) do
        if value.expiration < tick() then
            table.remove(self.queue, index)
        end
    end

    -- Push any timed out values back into queue if not used
    for index, value in pairs(self.refs) do
        if value.timeout < tick() then
            self.refs[index] = nil
            for _, result in pairs(value.results) do
                self:AddAsyncInternal(result)
            end
        end
    end
end

function MockMemoryStoreQueue:RemoveAsync(ref: string)
    MockMemoryStoreQuota:ProcessWriteRequest()

    local valueRef = self.refs[ref]
    if valueRef then
        self.refs[ref] = nil
    end
end

function MockMemoryStoreQueue:AddAsyncInternal(value: Value)
    -- First index, since FIFO
    table.insert(self.queue, 1, value)

    table.sort(self.queue, function(a: Value, b: Value)
        return a.priority > b.priority
    end)
end

function MockMemoryStoreQueue:AddAsync(value: any, expirationSeconds: number, priority: number?)
    assert(typeof(expirationSeconds) == "number", "Expected 'expirationSeconds' (number) at argument #2")

    MockMemoryStoreQuota:ProcessWriteRequest()
    self:AddAsyncInternal({
        value = value,
        expiration = tick() + expirationSeconds,
        priority = priority or 3
    })
end

return MockMemoryStoreQueue]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7adaba999e94e082065fffa300006081</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX0FADC69E676C4DA3B77141C756C03B54">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MockMemoryStoreQuota</string>
										<string name="ScriptGuid">{FDEF6356-3D0F-4FDC-8C4D-1A6037D41E5A}</string>
										<ProtectedString name="Source"><![CDATA[local MockMemoryStoreQuota = {
    quota = 1000,
    lastQuotaCheckTime = 0
}

function MockMemoryStoreQuota:GetRequestBaseQuota()
    return 1000
end

function MockMemoryStoreQuota:GetRequestPlayerQuota(numPlayers)
    return 100 * (if numPlayers ~= nil then numPlayers else #game:GetService("Players"):GetPlayers())
end

function MockMemoryStoreQuota:Get()
    return self.quota
end

function MockMemoryStoreQuota:ProcessWriteRequest()
    if self.quota <= 0 then
        error("Exceeded MemoryStore quota (on write)", 2)
    end

    self.quota -= 1
end

function MockMemoryStoreQuota:ProcessReadRequest()
    if self.quota <= 0 then
        error("Exceeded MemoryStore quota (on read)", 2)
    end

    self.quota -= 1
end

function MockMemoryStoreQuota:UpdateQuota()
    -- Every 60 seconds, we're resetting teh quota.
    if self.lastQuotaCheckTime < tick() + 60 then
        self.quota = self:GetRequestBaseQuota() + self:GetRequestPlayerQuota()
        self.lastQuotaCheckTime = tick()
    end
end

return MockMemoryStoreQuota]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7adaba999e94e082065fffa300006082</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX2AF5F724C66443D7B0DB0796F088208B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MockMemoryStoreSortedMap</string>
										<string name="ScriptGuid">{EDACDA61-603B-4227-8682-24FE1B9C3F36}</string>
										<ProtectedString name="Source"><![CDATA[local MockMemoryStoreQuota = require(script.Parent.MockMemoryStoreQuota)
local MockMemoryStoreUtils = require(script.Parent.MockMemoryStoreUtils)

local MockMemoryStoreSortedMap = {}
MockMemoryStoreSortedMap.__index = MockMemoryStoreSortedMap;

function MockMemoryStoreSortedMap.new(name)
    return setmetatable({
        mapValues = {},
    }, MockMemoryStoreSortedMap)
end

function MockMemoryStoreSortedMap:GetAsync(key)
    MockMemoryStoreUtils.AssertKeyIsValid(key)
    MockMemoryStoreQuota:ProcessReadRequest()

    local value = self.mapValues[key]
    if value then
        return value.innerValue
    else
        return nil
    end
end

function MockMemoryStoreSortedMap:SetAsync(key, value, expiration)
    MockMemoryStoreUtils.AssertKeyIsValid(key)
    assert(expiration, "Expiration required")

    assert(expiration <= MockMemoryStoreUtils.MAX_EXPIRATION_SECONDS, "Exceeds max expiration time")

    local mapValue = {
        innerValue = value,
        expiration = tick() + expiration
    }

    MockMemoryStoreQuota:ProcessWriteRequest()
    local isExistingItem = self.mapValues[key] ~= nil
    self.mapValues[key] = mapValue

    return isExistingItem
end

function MockMemoryStoreSortedMap:UpdateAsync(key, transformFunction, expiration)
    assert(typeof(key) == "string", "Expects key (argument #1)")
    assert(typeof(transformFunction) == "function", "Expects transformFunction (argument #2)")
    assert(typeof(expiration) == "number", "Expects expiration (argument #3)")

    local oldValue = self:GetAsync(key)

    local newValue = transformFunction(oldValue)
    if newValue ~= nil then
        self:SetAsync(key, newValue, expiration)
        return newValue
    else
        return nil
    end
end

function MockMemoryStoreSortedMap:RemoveAsync(key)
    MockMemoryStoreQuota:ProcessWriteRequest()

    self.mapValues[key] = nil
end

function MockMemoryStoreSortedMap:RemoveExpiringKey(key)
    self.mapValues[key] = nil
end

function MockMemoryStoreSortedMap:GetRangeAsync(direction, count, exclusiveLowerBound, exclusiveUpperBound)
    error("Not yet implemented", 2)
end

return MockMemoryStoreSortedMap]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7adaba999e94e082065fffa300006083</UniqueId>
									</Properties>
								</Item>
								<Item class="ModuleScript" referent="RBX5DDCBD9E6546495A999B6402A2EC2F5B">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
										<bool name="DefinesCapabilities">false</bool>
										<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">MockMemoryStoreUtils</string>
										<string name="ScriptGuid">{6D287BD2-5916-4761-AB9B-B3385FFEFB19}</string>
										<ProtectedString name="Source"><![CDATA[local MockMemoryStoreUtils = {}

local MAX_KEY_LENGTH = 128

function MockMemoryStoreUtils.AssertKeyIsValid(key: string)
    assert(type(key) == "string", "Expects string got " .. typeof(key))

    if #key >= MAX_KEY_LENGTH then
        error("Key '" .. tostring(key) .. "' exceeds maximum length of " .. MAX_KEY_LENGTH, 3)
    end
end

local onceUsedLocations = {}
function MockMemoryStoreUtils.WarnOnce(message: string)
    local trace = debug.traceback()

    if onceUsedLocations[trace] then
        return
    end

    onceUsedLocations[trace] = true;
    warn(message)
end

MockMemoryStoreUtils.MAX_EXPIRATION_SECONDS = 2_592_000

return MockMemoryStoreUtils]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UniqueId name="UniqueId">7adaba999e94e082065fffa300006084</UniqueId>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX3B09E0861C4A47CF8759C0D5AE3F7917">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000000348</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX60119E8C4BFF4811A00B7BAACBC828CB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca100000034a</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBXC7E40214C7D94A35B327A31FBCF4106E">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005b4</UniqueId>
		</Properties>
	</Item>
	<Item class="Teams" referent="RBXFD89FCDAE3D241D5B23317846AA52A0D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teams</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1813ceff5c688db10644960300003504</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBXE01A3073AAE3457C9300906FA7AC509D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000419e</UniqueId>
		</Properties>
	</Item>
	<Item class="ProximityPromptService" referent="RBX0B42956F070149A4955A58E108F14734">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1813ceff5c688db10644960300003508</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBXE9CF6347FF764625996BD69403C149EB">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LodDataService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000005b7</UniqueId>
		</Properties>
	</Item>
	<Item class="VoiceChatService" referent="RBXC0BDC55B4653455AA3DFBAB0F2FDB62E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableDefaultVoice">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VoiceChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">1813ceff5c688db106449603000034fe</UniqueId>
			<token name="UseAudioApi">1</token>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX1A6E192C1E064D11BF8B86B69B590ED2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">true</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad064098390000036c</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBXFA92E4083D1D4C439726E913A679A5DE">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad0640983900003f78</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX358CF04A4FFA45CBA1161594EF0047ED">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">5fa9a08a53fcc5ad06409839000041a4</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX522404CA5F3440379136CD1A78CDBB24">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">63cc3685df3b4f00065eca1000004265</UniqueId>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBXB16F53C856A540AFBC61E3C2950F7708">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">7adaba999e94e082065fffa300004236</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>